var ZV=Object.defineProperty;var YV=(e,t,n)=>t in e?ZV(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n;var Ra=(e,t,n)=>YV(e,typeof t!="symbol"?t+"":t,n);function JV(e,t){for(var n=0;n<t.length;n++){const r=t[n];if(typeof r!="string"&&!Array.isArray(r)){for(const a in r)if(a!=="default"&&!(a in e)){const s=Object.getOwnPropertyDescriptor(r,a);s&&Object.defineProperty(e,a,s.get?s:{enumerable:!0,get:()=>r[a]})}}}return Object.freeze(Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}))}(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const a of document.querySelectorAll('link[rel="modulepreload"]'))r(a);new MutationObserver(a=>{for(const s of a)if(s.type==="childList")for(const i of s.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&r(i)}).observe(document,{childList:!0,subtree:!0});function n(a){const s={};return a.integrity&&(s.integrity=a.integrity),a.referrerPolicy&&(s.referrerPolicy=a.referrerPolicy),a.crossOrigin==="use-credentials"?s.credentials="include":a.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function r(a){if(a.ep)return;a.ep=!0;const s=n(a);fetch(a.href,s)}})();function QV(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var mM={exports:{}},$x={},gM={exports:{}},Je={};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Nm=Symbol.for("react.element"),ej=Symbol.for("react.portal"),tj=Symbol.for("react.fragment"),nj=Symbol.for("react.strict_mode"),rj=Symbol.for("react.profiler"),aj=Symbol.for("react.provider"),sj=Symbol.for("react.context"),ij=Symbol.for("react.forward_ref"),oj=Symbol.for("react.suspense"),lj=Symbol.for("react.memo"),uj=Symbol.for("react.lazy"),fT=Symbol.iterator;function cj(e){return e===null||typeof e!="object"?null:(e=fT&&e[fT]||e["@@iterator"],typeof e=="function"?e:null)}var yM={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},xM=Object.assign,bM={};function ld(e,t,n){this.props=e,this.context=t,this.refs=bM,this.updater=n||yM}ld.prototype.isReactComponent={};ld.prototype.setState=function(e,t){if(typeof e!="object"&&typeof e!="function"&&e!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,t,"setState")};ld.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")};function vM(){}vM.prototype=ld.prototype;function v2(e,t,n){this.props=e,this.context=t,this.refs=bM,this.updater=n||yM}var w2=v2.prototype=new vM;w2.constructor=v2;xM(w2,ld.prototype);w2.isPureReactComponent=!0;var mT=Array.isArray,wM=Object.prototype.hasOwnProperty,k2={current:null},kM={key:!0,ref:!0,__self:!0,__source:!0};function SM(e,t,n){var r,a={},s=null,i=null;if(t!=null)for(r in t.ref!==void 0&&(i=t.ref),t.key!==void 0&&(s=""+t.key),t)wM.call(t,r)&&!kM.hasOwnProperty(r)&&(a[r]=t[r]);var o=arguments.length-2;if(o===1)a.children=n;else if(1<o){for(var l=Array(o),c=0;c<o;c++)l[c]=arguments[c+2];a.children=l}if(e&&e.defaultProps)for(r in o=e.defaultProps,o)a[r]===void 0&&(a[r]=o[r]);return{$$typeof:Nm,type:e,key:s,ref:i,props:a,_owner:k2.current}}function hj(e,t){return{$$typeof:Nm,type:e.type,key:t,ref:e.ref,props:e.props,_owner:e._owner}}function S2(e){return typeof e=="object"&&e!==null&&e.$$typeof===Nm}function dj(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,function(n){return t[n]})}var gT=/\/+/g;function Rv(e,t){return typeof e=="object"&&e!==null&&e.key!=null?dj(""+e.key):t.toString(36)}function e0(e,t,n,r,a){var s=typeof e;(s==="undefined"||s==="boolean")&&(e=null);var i=!1;if(e===null)i=!0;else switch(s){case"string":case"number":i=!0;break;case"object":switch(e.$$typeof){case Nm:case ej:i=!0}}if(i)return i=e,a=a(i),e=r===""?"."+Rv(i,0):r,mT(a)?(n="",e!=null&&(n=e.replace(gT,"$&/")+"/"),e0(a,t,n,"",function(c){return c})):a!=null&&(S2(a)&&(a=hj(a,n+(!a.key||i&&i.key===a.key?"":(""+a.key).replace(gT,"$&/")+"/")+e)),t.push(a)),1;if(i=0,r=r===""?".":r+":",mT(e))for(var o=0;o<e.length;o++){s=e[o];var l=r+Rv(s,o);i+=e0(s,t,n,l,a)}else if(l=cj(e),typeof l=="function")for(e=l.call(e),o=0;!(s=e.next()).done;)s=s.value,l=r+Rv(s,o++),i+=e0(s,t,n,l,a);else if(s==="object")throw t=String(e),Error("Objects are not valid as a React child (found: "+(t==="[object Object]"?"object with keys {"+Object.keys(e).join(", ")+"}":t)+"). If you meant to render a collection of children, use an array instead.");return i}function ty(e,t,n){if(e==null)return e;var r=[],a=0;return e0(e,r,"","",function(s){return t.call(n,s,a++)}),r}function pj(e){if(e._status===-1){var t=e._result;t=t(),t.then(function(n){(e._status===0||e._status===-1)&&(e._status=1,e._result=n)},function(n){(e._status===0||e._status===-1)&&(e._status=2,e._result=n)}),e._status===-1&&(e._status=0,e._result=t)}if(e._status===1)return e._result.default;throw e._result}var Ir={current:null},t0={transition:null},fj={ReactCurrentDispatcher:Ir,ReactCurrentBatchConfig:t0,ReactCurrentOwner:k2};function IM(){throw Error("act(...) is not supported in production builds of React.")}Je.Children={map:ty,forEach:function(e,t,n){ty(e,function(){t.apply(this,arguments)},n)},count:function(e){var t=0;return ty(e,function(){t++}),t},toArray:function(e){return ty(e,function(t){return t})||[]},only:function(e){if(!S2(e))throw Error("React.Children.only expected to receive a single React element child.");return e}};Je.Component=ld;Je.Fragment=tj;Je.Profiler=rj;Je.PureComponent=v2;Je.StrictMode=nj;Je.Suspense=oj;Je.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=fj;Je.act=IM;Je.cloneElement=function(e,t,n){if(e==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+e+".");var r=xM({},e.props),a=e.key,s=e.ref,i=e._owner;if(t!=null){if(t.ref!==void 0&&(s=t.ref,i=k2.current),t.key!==void 0&&(a=""+t.key),e.type&&e.type.defaultProps)var o=e.type.defaultProps;for(l in t)wM.call(t,l)&&!kM.hasOwnProperty(l)&&(r[l]=t[l]===void 0&&o!==void 0?o[l]:t[l])}var l=arguments.length-2;if(l===1)r.children=n;else if(1<l){o=Array(l);for(var c=0;c<l;c++)o[c]=arguments[c+2];r.children=o}return{$$typeof:Nm,type:e.type,key:a,ref:s,props:r,_owner:i}};Je.createContext=function(e){return e={$$typeof:sj,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},e.Provider={$$typeof:aj,_context:e},e.Consumer=e};Je.createElement=SM;Je.createFactory=function(e){var t=SM.bind(null,e);return t.type=e,t};Je.createRef=function(){return{current:null}};Je.forwardRef=function(e){return{$$typeof:ij,render:e}};Je.isValidElement=S2;Je.lazy=function(e){return{$$typeof:uj,_payload:{_status:-1,_result:e},_init:pj}};Je.memo=function(e,t){return{$$typeof:lj,type:e,compare:t===void 0?null:t}};Je.startTransition=function(e){var t=t0.transition;t0.transition={};try{e()}finally{t0.transition=t}};Je.unstable_act=IM;Je.useCallback=function(e,t){return Ir.current.useCallback(e,t)};Je.useContext=function(e){return Ir.current.useContext(e)};Je.useDebugValue=function(){};Je.useDeferredValue=function(e){return Ir.current.useDeferredValue(e)};Je.useEffect=function(e,t){return Ir.current.useEffect(e,t)};Je.useId=function(){return Ir.current.useId()};Je.useImperativeHandle=function(e,t,n){return Ir.current.useImperativeHandle(e,t,n)};Je.useInsertionEffect=function(e,t){return Ir.current.useInsertionEffect(e,t)};Je.useLayoutEffect=function(e,t){return Ir.current.useLayoutEffect(e,t)};Je.useMemo=function(e,t){return Ir.current.useMemo(e,t)};Je.useReducer=function(e,t,n){return Ir.current.useReducer(e,t,n)};Je.useRef=function(e){return Ir.current.useRef(e)};Je.useState=function(e){return Ir.current.useState(e)};Je.useSyncExternalStore=function(e,t,n){return Ir.current.useSyncExternalStore(e,t,n)};Je.useTransition=function(){return Ir.current.useTransition()};Je.version="18.3.1";gM.exports=Je;var ee=gM.exports;const NM=QV(ee),mj=JV({__proto__:null,default:NM},[ee]);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var gj=ee,yj=Symbol.for("react.element"),xj=Symbol.for("react.fragment"),bj=Object.prototype.hasOwnProperty,vj=gj.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,wj={key:!0,ref:!0,__self:!0,__source:!0};function _M(e,t,n){var r,a={},s=null,i=null;n!==void 0&&(s=""+n),t.key!==void 0&&(s=""+t.key),t.ref!==void 0&&(i=t.ref);for(r in t)bj.call(t,r)&&!wj.hasOwnProperty(r)&&(a[r]=t[r]);if(e&&e.defaultProps)for(r in t=e.defaultProps,t)a[r]===void 0&&(a[r]=t[r]);return{$$typeof:yj,type:e,key:s,ref:i,props:a,_owner:vj.current}}$x.Fragment=xj;$x.jsx=_M;$x.jsxs=_M;mM.exports=$x;var N=mM.exports,CM={exports:{}},pa={},TM={exports:{}},EM={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function(e){function t(z,K){var Z=z.length;z.push(K);e:for(;0<Z;){var J=Z-1>>>1,Q=z[J];if(0<a(Q,K))z[J]=K,z[Z]=Q,Z=J;else break e}}function n(z){return z.length===0?null:z[0]}function r(z){if(z.length===0)return null;var K=z[0],Z=z.pop();if(Z!==K){z[0]=Z;e:for(var J=0,Q=z.length,ne=Q>>>1;J<ne;){var oe=2*(J+1)-1,ue=z[oe],ve=oe+1,we=z[ve];if(0>a(ue,Z))ve<Q&&0>a(we,ue)?(z[J]=we,z[ve]=Z,J=ve):(z[J]=ue,z[oe]=Z,J=oe);else if(ve<Q&&0>a(we,Z))z[J]=we,z[ve]=Z,J=ve;else break e}}return K}function a(z,K){var Z=z.sortIndex-K.sortIndex;return Z!==0?Z:z.id-K.id}if(typeof performance=="object"&&typeof performance.now=="function"){var s=performance;e.unstable_now=function(){return s.now()}}else{var i=Date,o=i.now();e.unstable_now=function(){return i.now()-o}}var l=[],c=[],u=1,h=null,d=3,p=!1,f=!1,m=!1,y=typeof setTimeout=="function"?setTimeout:null,g=typeof clearTimeout=="function"?clearTimeout:null,x=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function b(z){for(var K=n(c);K!==null;){if(K.callback===null)r(c);else if(K.startTime<=z)r(c),K.sortIndex=K.expirationTime,t(l,K);else break;K=n(c)}}function v(z){if(m=!1,b(z),!f)if(n(l)!==null)f=!0,q(w);else{var K=n(c);K!==null&&H(v,K.startTime-z)}}function w(z,K){f=!1,m&&(m=!1,g(T),T=-1),p=!0;var Z=d;try{for(b(K),h=n(l);h!==null&&(!(h.expirationTime>K)||z&&!F());){var J=h.callback;if(typeof J=="function"){h.callback=null,d=h.priorityLevel;var Q=J(h.expirationTime<=K);K=e.unstable_now(),typeof Q=="function"?h.callback=Q:h===n(l)&&r(l),b(K)}else r(l);h=n(l)}if(h!==null)var ne=!0;else{var oe=n(c);oe!==null&&H(v,oe.startTime-K),ne=!1}return ne}finally{h=null,d=Z,p=!1}}var I=!1,_=null,T=-1,A=5,M=-1;function F(){return!(e.unstable_now()-M<A)}function C(){if(_!==null){var z=e.unstable_now();M=z;var K=!0;try{K=_(!0,z)}finally{K?D():(I=!1,_=null)}}else I=!1}var D;if(typeof x=="function")D=function(){x(C)};else if(typeof MessageChannel<"u"){var L=new MessageChannel,O=L.port2;L.port1.onmessage=C,D=function(){O.postMessage(null)}}else D=function(){y(C,0)};function q(z){_=z,I||(I=!0,D())}function H(z,K){T=y(function(){z(e.unstable_now())},K)}e.unstable_IdlePriority=5,e.unstable_ImmediatePriority=1,e.unstable_LowPriority=4,e.unstable_NormalPriority=3,e.unstable_Profiling=null,e.unstable_UserBlockingPriority=2,e.unstable_cancelCallback=function(z){z.callback=null},e.unstable_continueExecution=function(){f||p||(f=!0,q(w))},e.unstable_forceFrameRate=function(z){0>z||125<z?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):A=0<z?Math.floor(1e3/z):5},e.unstable_getCurrentPriorityLevel=function(){return d},e.unstable_getFirstCallbackNode=function(){return n(l)},e.unstable_next=function(z){switch(d){case 1:case 2:case 3:var K=3;break;default:K=d}var Z=d;d=K;try{return z()}finally{d=Z}},e.unstable_pauseExecution=function(){},e.unstable_requestPaint=function(){},e.unstable_runWithPriority=function(z,K){switch(z){case 1:case 2:case 3:case 4:case 5:break;default:z=3}var Z=d;d=z;try{return K()}finally{d=Z}},e.unstable_scheduleCallback=function(z,K,Z){var J=e.unstable_now();switch(typeof Z=="object"&&Z!==null?(Z=Z.delay,Z=typeof Z=="number"&&0<Z?J+Z:J):Z=J,z){case 1:var Q=-1;break;case 2:Q=250;break;case 5:Q=1073741823;break;case 4:Q=1e4;break;default:Q=5e3}return Q=Z+Q,z={id:u++,callback:K,priorityLevel:z,startTime:Z,expirationTime:Q,sortIndex:-1},Z>J?(z.sortIndex=Z,t(c,z),n(l)===null&&z===n(c)&&(m?(g(T),T=-1):m=!0,H(v,Z-J))):(z.sortIndex=Q,t(l,z),f||p||(f=!0,q(w))),z},e.unstable_shouldYield=F,e.unstable_wrapCallback=function(z){var K=d;return function(){var Z=d;d=K;try{return z.apply(this,arguments)}finally{d=Z}}}})(EM);TM.exports=EM;var kj=TM.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Sj=ee,ua=kj;function ce(e){for(var t="https://reactjs.org/docs/error-decoder.html?invariant="+e,n=1;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var AM=new Set,Bf={};function ru(e,t){Oh(e,t),Oh(e+"Capture",t)}function Oh(e,t){for(Bf[e]=t,e=0;e<t.length;e++)AM.add(t[e])}var si=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),o1=Object.prototype.hasOwnProperty,Ij=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,yT={},xT={};function Nj(e){return o1.call(xT,e)?!0:o1.call(yT,e)?!1:Ij.test(e)?xT[e]=!0:(yT[e]=!0,!1)}function _j(e,t,n,r){if(n!==null&&n.type===0)return!1;switch(typeof t){case"function":case"symbol":return!0;case"boolean":return r?!1:n!==null?!n.acceptsBooleans:(e=e.toLowerCase().slice(0,5),e!=="data-"&&e!=="aria-");default:return!1}}function Cj(e,t,n,r){if(t===null||typeof t>"u"||_j(e,t,n,r))return!0;if(r)return!1;if(n!==null)switch(n.type){case 3:return!t;case 4:return t===!1;case 5:return isNaN(t);case 6:return isNaN(t)||1>t}return!1}function Nr(e,t,n,r,a,s,i){this.acceptsBooleans=t===2||t===3||t===4,this.attributeName=r,this.attributeNamespace=a,this.mustUseProperty=n,this.propertyName=e,this.type=t,this.sanitizeURL=s,this.removeEmptyString=i}var Pn={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(e){Pn[e]=new Nr(e,0,!1,e,null,!1,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(e){var t=e[0];Pn[t]=new Nr(t,1,!1,e[1],null,!1,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(e){Pn[e]=new Nr(e,2,!1,e.toLowerCase(),null,!1,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(e){Pn[e]=new Nr(e,2,!1,e,null,!1,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(e){Pn[e]=new Nr(e,3,!1,e.toLowerCase(),null,!1,!1)});["checked","multiple","muted","selected"].forEach(function(e){Pn[e]=new Nr(e,3,!0,e,null,!1,!1)});["capture","download"].forEach(function(e){Pn[e]=new Nr(e,4,!1,e,null,!1,!1)});["cols","rows","size","span"].forEach(function(e){Pn[e]=new Nr(e,6,!1,e,null,!1,!1)});["rowSpan","start"].forEach(function(e){Pn[e]=new Nr(e,5,!1,e.toLowerCase(),null,!1,!1)});var I2=/[\-:]([a-z])/g;function N2(e){return e[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(e){var t=e.replace(I2,N2);Pn[t]=new Nr(t,1,!1,e,null,!1,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(e){var t=e.replace(I2,N2);Pn[t]=new Nr(t,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)});["xml:base","xml:lang","xml:space"].forEach(function(e){var t=e.replace(I2,N2);Pn[t]=new Nr(t,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)});["tabIndex","crossOrigin"].forEach(function(e){Pn[e]=new Nr(e,1,!1,e.toLowerCase(),null,!1,!1)});Pn.xlinkHref=new Nr("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(e){Pn[e]=new Nr(e,1,!1,e.toLowerCase(),null,!0,!0)});function _2(e,t,n,r){var a=Pn.hasOwnProperty(t)?Pn[t]:null;(a!==null?a.type!==0:r||!(2<t.length)||t[0]!=="o"&&t[0]!=="O"||t[1]!=="n"&&t[1]!=="N")&&(Cj(t,n,a,r)&&(n=null),r||a===null?Nj(t)&&(n===null?e.removeAttribute(t):e.setAttribute(t,""+n)):a.mustUseProperty?e[a.propertyName]=n===null?a.type===3?!1:"":n:(t=a.attributeName,r=a.attributeNamespace,n===null?e.removeAttribute(t):(a=a.type,n=a===3||a===4&&n===!0?"":""+n,r?e.setAttributeNS(r,t,n):e.setAttribute(t,n))))}var hi=Sj.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,ny=Symbol.for("react.element"),ch=Symbol.for("react.portal"),hh=Symbol.for("react.fragment"),C2=Symbol.for("react.strict_mode"),l1=Symbol.for("react.profiler"),$M=Symbol.for("react.provider"),MM=Symbol.for("react.context"),T2=Symbol.for("react.forward_ref"),u1=Symbol.for("react.suspense"),c1=Symbol.for("react.suspense_list"),E2=Symbol.for("react.memo"),Pi=Symbol.for("react.lazy"),FM=Symbol.for("react.offscreen"),bT=Symbol.iterator;function Vp(e){return e===null||typeof e!="object"?null:(e=bT&&e[bT]||e["@@iterator"],typeof e=="function"?e:null)}var Ut=Object.assign,Dv;function lf(e){if(Dv===void 0)try{throw Error()}catch(n){var t=n.stack.trim().match(/\n( *(at )?)/);Dv=t&&t[1]||""}return`
`+Dv+e}var Ov=!1;function zv(e,t){if(!e||Ov)return"";Ov=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(t)if(t=function(){throw Error()},Object.defineProperty(t.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(t,[])}catch(c){var r=c}Reflect.construct(e,[],t)}else{try{t.call()}catch(c){r=c}e.call(t.prototype)}else{try{throw Error()}catch(c){r=c}e()}}catch(c){if(c&&r&&typeof c.stack=="string"){for(var a=c.stack.split(`
`),s=r.stack.split(`
`),i=a.length-1,o=s.length-1;1<=i&&0<=o&&a[i]!==s[o];)o--;for(;1<=i&&0<=o;i--,o--)if(a[i]!==s[o]){if(i!==1||o!==1)do if(i--,o--,0>o||a[i]!==s[o]){var l=`
`+a[i].replace(" at new "," at ");return e.displayName&&l.includes("<anonymous>")&&(l=l.replace("<anonymous>",e.displayName)),l}while(1<=i&&0<=o);break}}}finally{Ov=!1,Error.prepareStackTrace=n}return(e=e?e.displayName||e.name:"")?lf(e):""}function Tj(e){switch(e.tag){case 5:return lf(e.type);case 16:return lf("Lazy");case 13:return lf("Suspense");case 19:return lf("SuspenseList");case 0:case 2:case 15:return e=zv(e.type,!1),e;case 11:return e=zv(e.type.render,!1),e;case 1:return e=zv(e.type,!0),e;default:return""}}function h1(e){if(e==null)return null;if(typeof e=="function")return e.displayName||e.name||null;if(typeof e=="string")return e;switch(e){case hh:return"Fragment";case ch:return"Portal";case l1:return"Profiler";case C2:return"StrictMode";case u1:return"Suspense";case c1:return"SuspenseList"}if(typeof e=="object")switch(e.$$typeof){case MM:return(e.displayName||"Context")+".Consumer";case $M:return(e._context.displayName||"Context")+".Provider";case T2:var t=e.render;return e=e.displayName,e||(e=t.displayName||t.name||"",e=e!==""?"ForwardRef("+e+")":"ForwardRef"),e;case E2:return t=e.displayName||null,t!==null?t:h1(e.type)||"Memo";case Pi:t=e._payload,e=e._init;try{return h1(e(t))}catch{}}return null}function Ej(e){var t=e.type;switch(e.tag){case 24:return"Cache";case 9:return(t.displayName||"Context")+".Consumer";case 10:return(t._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return e=t.render,e=e.displayName||e.name||"",t.displayName||(e!==""?"ForwardRef("+e+")":"ForwardRef");case 7:return"Fragment";case 5:return t;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return h1(t);case 8:return t===C2?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof t=="function")return t.displayName||t.name||null;if(typeof t=="string")return t}return null}function co(e){switch(typeof e){case"boolean":case"number":case"string":case"undefined":return e;case"object":return e;default:return""}}function RM(e){var t=e.type;return(e=e.nodeName)&&e.toLowerCase()==="input"&&(t==="checkbox"||t==="radio")}function Aj(e){var t=RM(e)?"checked":"value",n=Object.getOwnPropertyDescriptor(e.constructor.prototype,t),r=""+e[t];if(!e.hasOwnProperty(t)&&typeof n<"u"&&typeof n.get=="function"&&typeof n.set=="function"){var a=n.get,s=n.set;return Object.defineProperty(e,t,{configurable:!0,get:function(){return a.call(this)},set:function(i){r=""+i,s.call(this,i)}}),Object.defineProperty(e,t,{enumerable:n.enumerable}),{getValue:function(){return r},setValue:function(i){r=""+i},stopTracking:function(){e._valueTracker=null,delete e[t]}}}}function ry(e){e._valueTracker||(e._valueTracker=Aj(e))}function DM(e){if(!e)return!1;var t=e._valueTracker;if(!t)return!0;var n=t.getValue(),r="";return e&&(r=RM(e)?e.checked?"true":"false":e.value),e=r,e!==n?(t.setValue(e),!0):!1}function I0(e){if(e=e||(typeof document<"u"?document:void 0),typeof e>"u")return null;try{return e.activeElement||e.body}catch{return e.body}}function d1(e,t){var n=t.checked;return Ut({},t,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:n??e._wrapperState.initialChecked})}function vT(e,t){var n=t.defaultValue==null?"":t.defaultValue,r=t.checked!=null?t.checked:t.defaultChecked;n=co(t.value!=null?t.value:n),e._wrapperState={initialChecked:r,initialValue:n,controlled:t.type==="checkbox"||t.type==="radio"?t.checked!=null:t.value!=null}}function OM(e,t){t=t.checked,t!=null&&_2(e,"checked",t,!1)}function p1(e,t){OM(e,t);var n=co(t.value),r=t.type;if(n!=null)r==="number"?(n===0&&e.value===""||e.value!=n)&&(e.value=""+n):e.value!==""+n&&(e.value=""+n);else if(r==="submit"||r==="reset"){e.removeAttribute("value");return}t.hasOwnProperty("value")?f1(e,t.type,n):t.hasOwnProperty("defaultValue")&&f1(e,t.type,co(t.defaultValue)),t.checked==null&&t.defaultChecked!=null&&(e.defaultChecked=!!t.defaultChecked)}function wT(e,t,n){if(t.hasOwnProperty("value")||t.hasOwnProperty("defaultValue")){var r=t.type;if(!(r!=="submit"&&r!=="reset"||t.value!==void 0&&t.value!==null))return;t=""+e._wrapperState.initialValue,n||t===e.value||(e.value=t),e.defaultValue=t}n=e.name,n!==""&&(e.name=""),e.defaultChecked=!!e._wrapperState.initialChecked,n!==""&&(e.name=n)}function f1(e,t,n){(t!=="number"||I0(e.ownerDocument)!==e)&&(n==null?e.defaultValue=""+e._wrapperState.initialValue:e.defaultValue!==""+n&&(e.defaultValue=""+n))}var uf=Array.isArray;function Sh(e,t,n,r){if(e=e.options,t){t={};for(var a=0;a<n.length;a++)t["$"+n[a]]=!0;for(n=0;n<e.length;n++)a=t.hasOwnProperty("$"+e[n].value),e[n].selected!==a&&(e[n].selected=a),a&&r&&(e[n].defaultSelected=!0)}else{for(n=""+co(n),t=null,a=0;a<e.length;a++){if(e[a].value===n){e[a].selected=!0,r&&(e[a].defaultSelected=!0);return}t!==null||e[a].disabled||(t=e[a])}t!==null&&(t.selected=!0)}}function m1(e,t){if(t.dangerouslySetInnerHTML!=null)throw Error(ce(91));return Ut({},t,{value:void 0,defaultValue:void 0,children:""+e._wrapperState.initialValue})}function kT(e,t){var n=t.value;if(n==null){if(n=t.children,t=t.defaultValue,n!=null){if(t!=null)throw Error(ce(92));if(uf(n)){if(1<n.length)throw Error(ce(93));n=n[0]}t=n}t==null&&(t=""),n=t}e._wrapperState={initialValue:co(n)}}function zM(e,t){var n=co(t.value),r=co(t.defaultValue);n!=null&&(n=""+n,n!==e.value&&(e.value=n),t.defaultValue==null&&e.defaultValue!==n&&(e.defaultValue=n)),r!=null&&(e.defaultValue=""+r)}function ST(e){var t=e.textContent;t===e._wrapperState.initialValue&&t!==""&&t!==null&&(e.value=t)}function PM(e){switch(e){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function g1(e,t){return e==null||e==="http://www.w3.org/1999/xhtml"?PM(t):e==="http://www.w3.org/2000/svg"&&t==="foreignObject"?"http://www.w3.org/1999/xhtml":e}var ay,LM=function(e){return typeof MSApp<"u"&&MSApp.execUnsafeLocalFunction?function(t,n,r,a){MSApp.execUnsafeLocalFunction(function(){return e(t,n,r,a)})}:e}(function(e,t){if(e.namespaceURI!=="http://www.w3.org/2000/svg"||"innerHTML"in e)e.innerHTML=t;else{for(ay=ay||document.createElement("div"),ay.innerHTML="<svg>"+t.valueOf().toString()+"</svg>",t=ay.firstChild;e.firstChild;)e.removeChild(e.firstChild);for(;t.firstChild;)e.appendChild(t.firstChild)}});function Wf(e,t){if(t){var n=e.firstChild;if(n&&n===e.lastChild&&n.nodeType===3){n.nodeValue=t;return}}e.textContent=t}var If={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},$j=["Webkit","ms","Moz","O"];Object.keys(If).forEach(function(e){$j.forEach(function(t){t=t+e.charAt(0).toUpperCase()+e.substring(1),If[t]=If[e]})});function BM(e,t,n){return t==null||typeof t=="boolean"||t===""?"":n||typeof t!="number"||t===0||If.hasOwnProperty(e)&&If[e]?(""+t).trim():t+"px"}function WM(e,t){e=e.style;for(var n in t)if(t.hasOwnProperty(n)){var r=n.indexOf("--")===0,a=BM(n,t[n],r);n==="float"&&(n="cssFloat"),r?e.setProperty(n,a):e[n]=a}}var Mj=Ut({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function y1(e,t){if(t){if(Mj[e]&&(t.children!=null||t.dangerouslySetInnerHTML!=null))throw Error(ce(137,e));if(t.dangerouslySetInnerHTML!=null){if(t.children!=null)throw Error(ce(60));if(typeof t.dangerouslySetInnerHTML!="object"||!("__html"in t.dangerouslySetInnerHTML))throw Error(ce(61))}if(t.style!=null&&typeof t.style!="object")throw Error(ce(62))}}function x1(e,t){if(e.indexOf("-")===-1)return typeof t.is=="string";switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var b1=null;function A2(e){return e=e.target||e.srcElement||window,e.correspondingUseElement&&(e=e.correspondingUseElement),e.nodeType===3?e.parentNode:e}var v1=null,Ih=null,Nh=null;function IT(e){if(e=Tm(e)){if(typeof v1!="function")throw Error(ce(280));var t=e.stateNode;t&&(t=Ox(t),v1(e.stateNode,e.type,t))}}function UM(e){Ih?Nh?Nh.push(e):Nh=[e]:Ih=e}function VM(){if(Ih){var e=Ih,t=Nh;if(Nh=Ih=null,IT(e),t)for(e=0;e<t.length;e++)IT(t[e])}}function jM(e,t){return e(t)}function GM(){}var Pv=!1;function HM(e,t,n){if(Pv)return e(t,n);Pv=!0;try{return jM(e,t,n)}finally{Pv=!1,(Ih!==null||Nh!==null)&&(GM(),VM())}}function Uf(e,t){var n=e.stateNode;if(n===null)return null;var r=Ox(n);if(r===null)return null;n=r[t];e:switch(t){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(r=!r.disabled)||(e=e.type,r=!(e==="button"||e==="input"||e==="select"||e==="textarea")),e=!r;break e;default:e=!1}if(e)return null;if(n&&typeof n!="function")throw Error(ce(231,t,typeof n));return n}var w1=!1;if(si)try{var jp={};Object.defineProperty(jp,"passive",{get:function(){w1=!0}}),window.addEventListener("test",jp,jp),window.removeEventListener("test",jp,jp)}catch{w1=!1}function Fj(e,t,n,r,a,s,i,o,l){var c=Array.prototype.slice.call(arguments,3);try{t.apply(n,c)}catch(u){this.onError(u)}}var Nf=!1,N0=null,_0=!1,k1=null,Rj={onError:function(e){Nf=!0,N0=e}};function Dj(e,t,n,r,a,s,i,o,l){Nf=!1,N0=null,Fj.apply(Rj,arguments)}function Oj(e,t,n,r,a,s,i,o,l){if(Dj.apply(this,arguments),Nf){if(Nf){var c=N0;Nf=!1,N0=null}else throw Error(ce(198));_0||(_0=!0,k1=c)}}function au(e){var t=e,n=e;if(e.alternate)for(;t.return;)t=t.return;else{e=t;do t=e,t.flags&4098&&(n=t.return),e=t.return;while(e)}return t.tag===3?n:null}function qM(e){if(e.tag===13){var t=e.memoizedState;if(t===null&&(e=e.alternate,e!==null&&(t=e.memoizedState)),t!==null)return t.dehydrated}return null}function NT(e){if(au(e)!==e)throw Error(ce(188))}function zj(e){var t=e.alternate;if(!t){if(t=au(e),t===null)throw Error(ce(188));return t!==e?null:e}for(var n=e,r=t;;){var a=n.return;if(a===null)break;var s=a.alternate;if(s===null){if(r=a.return,r!==null){n=r;continue}break}if(a.child===s.child){for(s=a.child;s;){if(s===n)return NT(a),e;if(s===r)return NT(a),t;s=s.sibling}throw Error(ce(188))}if(n.return!==r.return)n=a,r=s;else{for(var i=!1,o=a.child;o;){if(o===n){i=!0,n=a,r=s;break}if(o===r){i=!0,r=a,n=s;break}o=o.sibling}if(!i){for(o=s.child;o;){if(o===n){i=!0,n=s,r=a;break}if(o===r){i=!0,r=s,n=a;break}o=o.sibling}if(!i)throw Error(ce(189))}}if(n.alternate!==r)throw Error(ce(190))}if(n.tag!==3)throw Error(ce(188));return n.stateNode.current===n?e:t}function KM(e){return e=zj(e),e!==null?XM(e):null}function XM(e){if(e.tag===5||e.tag===6)return e;for(e=e.child;e!==null;){var t=XM(e);if(t!==null)return t;e=e.sibling}return null}var ZM=ua.unstable_scheduleCallback,_T=ua.unstable_cancelCallback,Pj=ua.unstable_shouldYield,Lj=ua.unstable_requestPaint,Xt=ua.unstable_now,Bj=ua.unstable_getCurrentPriorityLevel,$2=ua.unstable_ImmediatePriority,YM=ua.unstable_UserBlockingPriority,C0=ua.unstable_NormalPriority,Wj=ua.unstable_LowPriority,JM=ua.unstable_IdlePriority,Mx=null,ks=null;function Uj(e){if(ks&&typeof ks.onCommitFiberRoot=="function")try{ks.onCommitFiberRoot(Mx,e,void 0,(e.current.flags&128)===128)}catch{}}var Ka=Math.clz32?Math.clz32:Gj,Vj=Math.log,jj=Math.LN2;function Gj(e){return e>>>=0,e===0?32:31-(Vj(e)/jj|0)|0}var sy=64,iy=4194304;function cf(e){switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return e&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return e&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return e}}function T0(e,t){var n=e.pendingLanes;if(n===0)return 0;var r=0,a=e.suspendedLanes,s=e.pingedLanes,i=n&268435455;if(i!==0){var o=i&~a;o!==0?r=cf(o):(s&=i,s!==0&&(r=cf(s)))}else i=n&~a,i!==0?r=cf(i):s!==0&&(r=cf(s));if(r===0)return 0;if(t!==0&&t!==r&&!(t&a)&&(a=r&-r,s=t&-t,a>=s||a===16&&(s&4194240)!==0))return t;if(r&4&&(r|=n&16),t=e.entangledLanes,t!==0)for(e=e.entanglements,t&=r;0<t;)n=31-Ka(t),a=1<<n,r|=e[n],t&=~a;return r}function Hj(e,t){switch(e){case 1:case 2:case 4:return t+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return t+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function qj(e,t){for(var n=e.suspendedLanes,r=e.pingedLanes,a=e.expirationTimes,s=e.pendingLanes;0<s;){var i=31-Ka(s),o=1<<i,l=a[i];l===-1?(!(o&n)||o&r)&&(a[i]=Hj(o,t)):l<=t&&(e.expiredLanes|=o),s&=~o}}function S1(e){return e=e.pendingLanes&-1073741825,e!==0?e:e&1073741824?1073741824:0}function QM(){var e=sy;return sy<<=1,!(sy&4194240)&&(sy=64),e}function Lv(e){for(var t=[],n=0;31>n;n++)t.push(e);return t}function _m(e,t,n){e.pendingLanes|=t,t!==536870912&&(e.suspendedLanes=0,e.pingedLanes=0),e=e.eventTimes,t=31-Ka(t),e[t]=n}function Kj(e,t){var n=e.pendingLanes&~t;e.pendingLanes=t,e.suspendedLanes=0,e.pingedLanes=0,e.expiredLanes&=t,e.mutableReadLanes&=t,e.entangledLanes&=t,t=e.entanglements;var r=e.eventTimes;for(e=e.expirationTimes;0<n;){var a=31-Ka(n),s=1<<a;t[a]=0,r[a]=-1,e[a]=-1,n&=~s}}function M2(e,t){var n=e.entangledLanes|=t;for(e=e.entanglements;n;){var r=31-Ka(n),a=1<<r;a&t|e[r]&t&&(e[r]|=t),n&=~a}}var yt=0;function eF(e){return e&=-e,1<e?4<e?e&268435455?16:536870912:4:1}var tF,F2,nF,rF,aF,I1=!1,oy=[],Ji=null,Qi=null,eo=null,Vf=new Map,jf=new Map,Ui=[],Xj="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function CT(e,t){switch(e){case"focusin":case"focusout":Ji=null;break;case"dragenter":case"dragleave":Qi=null;break;case"mouseover":case"mouseout":eo=null;break;case"pointerover":case"pointerout":Vf.delete(t.pointerId);break;case"gotpointercapture":case"lostpointercapture":jf.delete(t.pointerId)}}function Gp(e,t,n,r,a,s){return e===null||e.nativeEvent!==s?(e={blockedOn:t,domEventName:n,eventSystemFlags:r,nativeEvent:s,targetContainers:[a]},t!==null&&(t=Tm(t),t!==null&&F2(t)),e):(e.eventSystemFlags|=r,t=e.targetContainers,a!==null&&t.indexOf(a)===-1&&t.push(a),e)}function Zj(e,t,n,r,a){switch(t){case"focusin":return Ji=Gp(Ji,e,t,n,r,a),!0;case"dragenter":return Qi=Gp(Qi,e,t,n,r,a),!0;case"mouseover":return eo=Gp(eo,e,t,n,r,a),!0;case"pointerover":var s=a.pointerId;return Vf.set(s,Gp(Vf.get(s)||null,e,t,n,r,a)),!0;case"gotpointercapture":return s=a.pointerId,jf.set(s,Gp(jf.get(s)||null,e,t,n,r,a)),!0}return!1}function sF(e){var t=xl(e.target);if(t!==null){var n=au(t);if(n!==null){if(t=n.tag,t===13){if(t=qM(n),t!==null){e.blockedOn=t,aF(e.priority,function(){nF(n)});return}}else if(t===3&&n.stateNode.current.memoizedState.isDehydrated){e.blockedOn=n.tag===3?n.stateNode.containerInfo:null;return}}}e.blockedOn=null}function n0(e){if(e.blockedOn!==null)return!1;for(var t=e.targetContainers;0<t.length;){var n=N1(e.domEventName,e.eventSystemFlags,t[0],e.nativeEvent);if(n===null){n=e.nativeEvent;var r=new n.constructor(n.type,n);b1=r,n.target.dispatchEvent(r),b1=null}else return t=Tm(n),t!==null&&F2(t),e.blockedOn=n,!1;t.shift()}return!0}function TT(e,t,n){n0(e)&&n.delete(t)}function Yj(){I1=!1,Ji!==null&&n0(Ji)&&(Ji=null),Qi!==null&&n0(Qi)&&(Qi=null),eo!==null&&n0(eo)&&(eo=null),Vf.forEach(TT),jf.forEach(TT)}function Hp(e,t){e.blockedOn===t&&(e.blockedOn=null,I1||(I1=!0,ua.unstable_scheduleCallback(ua.unstable_NormalPriority,Yj)))}function Gf(e){function t(a){return Hp(a,e)}if(0<oy.length){Hp(oy[0],e);for(var n=1;n<oy.length;n++){var r=oy[n];r.blockedOn===e&&(r.blockedOn=null)}}for(Ji!==null&&Hp(Ji,e),Qi!==null&&Hp(Qi,e),eo!==null&&Hp(eo,e),Vf.forEach(t),jf.forEach(t),n=0;n<Ui.length;n++)r=Ui[n],r.blockedOn===e&&(r.blockedOn=null);for(;0<Ui.length&&(n=Ui[0],n.blockedOn===null);)sF(n),n.blockedOn===null&&Ui.shift()}var _h=hi.ReactCurrentBatchConfig,E0=!0;function Jj(e,t,n,r){var a=yt,s=_h.transition;_h.transition=null;try{yt=1,R2(e,t,n,r)}finally{yt=a,_h.transition=s}}function Qj(e,t,n,r){var a=yt,s=_h.transition;_h.transition=null;try{yt=4,R2(e,t,n,r)}finally{yt=a,_h.transition=s}}function R2(e,t,n,r){if(E0){var a=N1(e,t,n,r);if(a===null)Xv(e,t,r,A0,n),CT(e,r);else if(Zj(a,e,t,n,r))r.stopPropagation();else if(CT(e,r),t&4&&-1<Xj.indexOf(e)){for(;a!==null;){var s=Tm(a);if(s!==null&&tF(s),s=N1(e,t,n,r),s===null&&Xv(e,t,r,A0,n),s===a)break;a=s}a!==null&&r.stopPropagation()}else Xv(e,t,r,null,n)}}var A0=null;function N1(e,t,n,r){if(A0=null,e=A2(r),e=xl(e),e!==null)if(t=au(e),t===null)e=null;else if(n=t.tag,n===13){if(e=qM(t),e!==null)return e;e=null}else if(n===3){if(t.stateNode.current.memoizedState.isDehydrated)return t.tag===3?t.stateNode.containerInfo:null;e=null}else t!==e&&(e=null);return A0=e,null}function iF(e){switch(e){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(Bj()){case $2:return 1;case YM:return 4;case C0:case Wj:return 16;case JM:return 536870912;default:return 16}default:return 16}}var Gi=null,D2=null,r0=null;function oF(){if(r0)return r0;var e,t=D2,n=t.length,r,a="value"in Gi?Gi.value:Gi.textContent,s=a.length;for(e=0;e<n&&t[e]===a[e];e++);var i=n-e;for(r=1;r<=i&&t[n-r]===a[s-r];r++);return r0=a.slice(e,1<r?1-r:void 0)}function a0(e){var t=e.keyCode;return"charCode"in e?(e=e.charCode,e===0&&t===13&&(e=13)):e=t,e===10&&(e=13),32<=e||e===13?e:0}function ly(){return!0}function ET(){return!1}function fa(e){function t(n,r,a,s,i){this._reactName=n,this._targetInst=a,this.type=r,this.nativeEvent=s,this.target=i,this.currentTarget=null;for(var o in e)e.hasOwnProperty(o)&&(n=e[o],this[o]=n?n(s):s[o]);return this.isDefaultPrevented=(s.defaultPrevented!=null?s.defaultPrevented:s.returnValue===!1)?ly:ET,this.isPropagationStopped=ET,this}return Ut(t.prototype,{preventDefault:function(){this.defaultPrevented=!0;var n=this.nativeEvent;n&&(n.preventDefault?n.preventDefault():typeof n.returnValue!="unknown"&&(n.returnValue=!1),this.isDefaultPrevented=ly)},stopPropagation:function(){var n=this.nativeEvent;n&&(n.stopPropagation?n.stopPropagation():typeof n.cancelBubble!="unknown"&&(n.cancelBubble=!0),this.isPropagationStopped=ly)},persist:function(){},isPersistent:ly}),t}var ud={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},O2=fa(ud),Cm=Ut({},ud,{view:0,detail:0}),e5=fa(Cm),Bv,Wv,qp,Fx=Ut({},Cm,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:z2,button:0,buttons:0,relatedTarget:function(e){return e.relatedTarget===void 0?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==qp&&(qp&&e.type==="mousemove"?(Bv=e.screenX-qp.screenX,Wv=e.screenY-qp.screenY):Wv=Bv=0,qp=e),Bv)},movementY:function(e){return"movementY"in e?e.movementY:Wv}}),AT=fa(Fx),t5=Ut({},Fx,{dataTransfer:0}),n5=fa(t5),r5=Ut({},Cm,{relatedTarget:0}),Uv=fa(r5),a5=Ut({},ud,{animationName:0,elapsedTime:0,pseudoElement:0}),s5=fa(a5),i5=Ut({},ud,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}}),o5=fa(i5),l5=Ut({},ud,{data:0}),$T=fa(l5),u5={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},c5={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},h5={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function d5(e){var t=this.nativeEvent;return t.getModifierState?t.getModifierState(e):(e=h5[e])?!!t[e]:!1}function z2(){return d5}var p5=Ut({},Cm,{key:function(e){if(e.key){var t=u5[e.key]||e.key;if(t!=="Unidentified")return t}return e.type==="keypress"?(e=a0(e),e===13?"Enter":String.fromCharCode(e)):e.type==="keydown"||e.type==="keyup"?c5[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:z2,charCode:function(e){return e.type==="keypress"?a0(e):0},keyCode:function(e){return e.type==="keydown"||e.type==="keyup"?e.keyCode:0},which:function(e){return e.type==="keypress"?a0(e):e.type==="keydown"||e.type==="keyup"?e.keyCode:0}}),f5=fa(p5),m5=Ut({},Fx,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),MT=fa(m5),g5=Ut({},Cm,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:z2}),y5=fa(g5),x5=Ut({},ud,{propertyName:0,elapsedTime:0,pseudoElement:0}),b5=fa(x5),v5=Ut({},Fx,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0}),w5=fa(v5),k5=[9,13,27,32],P2=si&&"CompositionEvent"in window,_f=null;si&&"documentMode"in document&&(_f=document.documentMode);var S5=si&&"TextEvent"in window&&!_f,lF=si&&(!P2||_f&&8<_f&&11>=_f),FT=" ",RT=!1;function uF(e,t){switch(e){case"keyup":return k5.indexOf(t.keyCode)!==-1;case"keydown":return t.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function cF(e){return e=e.detail,typeof e=="object"&&"data"in e?e.data:null}var dh=!1;function I5(e,t){switch(e){case"compositionend":return cF(t);case"keypress":return t.which!==32?null:(RT=!0,FT);case"textInput":return e=t.data,e===FT&&RT?null:e;default:return null}}function N5(e,t){if(dh)return e==="compositionend"||!P2&&uF(e,t)?(e=oF(),r0=D2=Gi=null,dh=!1,e):null;switch(e){case"paste":return null;case"keypress":if(!(t.ctrlKey||t.altKey||t.metaKey)||t.ctrlKey&&t.altKey){if(t.char&&1<t.char.length)return t.char;if(t.which)return String.fromCharCode(t.which)}return null;case"compositionend":return lF&&t.locale!=="ko"?null:t.data;default:return null}}var _5={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function DT(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t==="input"?!!_5[e.type]:t==="textarea"}function hF(e,t,n,r){UM(r),t=$0(t,"onChange"),0<t.length&&(n=new O2("onChange","change",null,n,r),e.push({event:n,listeners:t}))}var Cf=null,Hf=null;function C5(e){kF(e,0)}function Rx(e){var t=mh(e);if(DM(t))return e}function T5(e,t){if(e==="change")return t}var dF=!1;if(si){var Vv;if(si){var jv="oninput"in document;if(!jv){var OT=document.createElement("div");OT.setAttribute("oninput","return;"),jv=typeof OT.oninput=="function"}Vv=jv}else Vv=!1;dF=Vv&&(!document.documentMode||9<document.documentMode)}function zT(){Cf&&(Cf.detachEvent("onpropertychange",pF),Hf=Cf=null)}function pF(e){if(e.propertyName==="value"&&Rx(Hf)){var t=[];hF(t,Hf,e,A2(e)),HM(C5,t)}}function E5(e,t,n){e==="focusin"?(zT(),Cf=t,Hf=n,Cf.attachEvent("onpropertychange",pF)):e==="focusout"&&zT()}function A5(e){if(e==="selectionchange"||e==="keyup"||e==="keydown")return Rx(Hf)}function $5(e,t){if(e==="click")return Rx(t)}function M5(e,t){if(e==="input"||e==="change")return Rx(t)}function F5(e,t){return e===t&&(e!==0||1/e===1/t)||e!==e&&t!==t}var Qa=typeof Object.is=="function"?Object.is:F5;function qf(e,t){if(Qa(e,t))return!0;if(typeof e!="object"||e===null||typeof t!="object"||t===null)return!1;var n=Object.keys(e),r=Object.keys(t);if(n.length!==r.length)return!1;for(r=0;r<n.length;r++){var a=n[r];if(!o1.call(t,a)||!Qa(e[a],t[a]))return!1}return!0}function PT(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function LT(e,t){var n=PT(e);e=0;for(var r;n;){if(n.nodeType===3){if(r=e+n.textContent.length,e<=t&&r>=t)return{node:n,offset:t-e};e=r}e:{for(;n;){if(n.nextSibling){n=n.nextSibling;break e}n=n.parentNode}n=void 0}n=PT(n)}}function fF(e,t){return e&&t?e===t?!0:e&&e.nodeType===3?!1:t&&t.nodeType===3?fF(e,t.parentNode):"contains"in e?e.contains(t):e.compareDocumentPosition?!!(e.compareDocumentPosition(t)&16):!1:!1}function mF(){for(var e=window,t=I0();t instanceof e.HTMLIFrameElement;){try{var n=typeof t.contentWindow.location.href=="string"}catch{n=!1}if(n)e=t.contentWindow;else break;t=I0(e.document)}return t}function L2(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t&&(t==="input"&&(e.type==="text"||e.type==="search"||e.type==="tel"||e.type==="url"||e.type==="password")||t==="textarea"||e.contentEditable==="true")}function R5(e){var t=mF(),n=e.focusedElem,r=e.selectionRange;if(t!==n&&n&&n.ownerDocument&&fF(n.ownerDocument.documentElement,n)){if(r!==null&&L2(n)){if(t=r.start,e=r.end,e===void 0&&(e=t),"selectionStart"in n)n.selectionStart=t,n.selectionEnd=Math.min(e,n.value.length);else if(e=(t=n.ownerDocument||document)&&t.defaultView||window,e.getSelection){e=e.getSelection();var a=n.textContent.length,s=Math.min(r.start,a);r=r.end===void 0?s:Math.min(r.end,a),!e.extend&&s>r&&(a=r,r=s,s=a),a=LT(n,s);var i=LT(n,r);a&&i&&(e.rangeCount!==1||e.anchorNode!==a.node||e.anchorOffset!==a.offset||e.focusNode!==i.node||e.focusOffset!==i.offset)&&(t=t.createRange(),t.setStart(a.node,a.offset),e.removeAllRanges(),s>r?(e.addRange(t),e.extend(i.node,i.offset)):(t.setEnd(i.node,i.offset),e.addRange(t)))}}for(t=[],e=n;e=e.parentNode;)e.nodeType===1&&t.push({element:e,left:e.scrollLeft,top:e.scrollTop});for(typeof n.focus=="function"&&n.focus(),n=0;n<t.length;n++)e=t[n],e.element.scrollLeft=e.left,e.element.scrollTop=e.top}}var D5=si&&"documentMode"in document&&11>=document.documentMode,ph=null,_1=null,Tf=null,C1=!1;function BT(e,t,n){var r=n.window===n?n.document:n.nodeType===9?n:n.ownerDocument;C1||ph==null||ph!==I0(r)||(r=ph,"selectionStart"in r&&L2(r)?r={start:r.selectionStart,end:r.selectionEnd}:(r=(r.ownerDocument&&r.ownerDocument.defaultView||window).getSelection(),r={anchorNode:r.anchorNode,anchorOffset:r.anchorOffset,focusNode:r.focusNode,focusOffset:r.focusOffset}),Tf&&qf(Tf,r)||(Tf=r,r=$0(_1,"onSelect"),0<r.length&&(t=new O2("onSelect","select",null,t,n),e.push({event:t,listeners:r}),t.target=ph)))}function uy(e,t){var n={};return n[e.toLowerCase()]=t.toLowerCase(),n["Webkit"+e]="webkit"+t,n["Moz"+e]="moz"+t,n}var fh={animationend:uy("Animation","AnimationEnd"),animationiteration:uy("Animation","AnimationIteration"),animationstart:uy("Animation","AnimationStart"),transitionend:uy("Transition","TransitionEnd")},Gv={},gF={};si&&(gF=document.createElement("div").style,"AnimationEvent"in window||(delete fh.animationend.animation,delete fh.animationiteration.animation,delete fh.animationstart.animation),"TransitionEvent"in window||delete fh.transitionend.transition);function Dx(e){if(Gv[e])return Gv[e];if(!fh[e])return e;var t=fh[e],n;for(n in t)if(t.hasOwnProperty(n)&&n in gF)return Gv[e]=t[n];return e}var yF=Dx("animationend"),xF=Dx("animationiteration"),bF=Dx("animationstart"),vF=Dx("transitionend"),wF=new Map,WT="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function Ao(e,t){wF.set(e,t),ru(t,[e])}for(var Hv=0;Hv<WT.length;Hv++){var qv=WT[Hv],O5=qv.toLowerCase(),z5=qv[0].toUpperCase()+qv.slice(1);Ao(O5,"on"+z5)}Ao(yF,"onAnimationEnd");Ao(xF,"onAnimationIteration");Ao(bF,"onAnimationStart");Ao("dblclick","onDoubleClick");Ao("focusin","onFocus");Ao("focusout","onBlur");Ao(vF,"onTransitionEnd");Oh("onMouseEnter",["mouseout","mouseover"]);Oh("onMouseLeave",["mouseout","mouseover"]);Oh("onPointerEnter",["pointerout","pointerover"]);Oh("onPointerLeave",["pointerout","pointerover"]);ru("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));ru("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));ru("onBeforeInput",["compositionend","keypress","textInput","paste"]);ru("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));ru("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));ru("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var hf="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),P5=new Set("cancel close invalid load scroll toggle".split(" ").concat(hf));function UT(e,t,n){var r=e.type||"unknown-event";e.currentTarget=n,Oj(r,t,void 0,e),e.currentTarget=null}function kF(e,t){t=(t&4)!==0;for(var n=0;n<e.length;n++){var r=e[n],a=r.event;r=r.listeners;e:{var s=void 0;if(t)for(var i=r.length-1;0<=i;i--){var o=r[i],l=o.instance,c=o.currentTarget;if(o=o.listener,l!==s&&a.isPropagationStopped())break e;UT(a,o,c),s=l}else for(i=0;i<r.length;i++){if(o=r[i],l=o.instance,c=o.currentTarget,o=o.listener,l!==s&&a.isPropagationStopped())break e;UT(a,o,c),s=l}}}if(_0)throw e=k1,_0=!1,k1=null,e}function Et(e,t){var n=t[M1];n===void 0&&(n=t[M1]=new Set);var r=e+"__bubble";n.has(r)||(SF(t,e,2,!1),n.add(r))}function Kv(e,t,n){var r=0;t&&(r|=4),SF(n,e,r,t)}var cy="_reactListening"+Math.random().toString(36).slice(2);function Kf(e){if(!e[cy]){e[cy]=!0,AM.forEach(function(n){n!=="selectionchange"&&(P5.has(n)||Kv(n,!1,e),Kv(n,!0,e))});var t=e.nodeType===9?e:e.ownerDocument;t===null||t[cy]||(t[cy]=!0,Kv("selectionchange",!1,t))}}function SF(e,t,n,r){switch(iF(t)){case 1:var a=Jj;break;case 4:a=Qj;break;default:a=R2}n=a.bind(null,t,n,e),a=void 0,!w1||t!=="touchstart"&&t!=="touchmove"&&t!=="wheel"||(a=!0),r?a!==void 0?e.addEventListener(t,n,{capture:!0,passive:a}):e.addEventListener(t,n,!0):a!==void 0?e.addEventListener(t,n,{passive:a}):e.addEventListener(t,n,!1)}function Xv(e,t,n,r,a){var s=r;if(!(t&1)&&!(t&2)&&r!==null)e:for(;;){if(r===null)return;var i=r.tag;if(i===3||i===4){var o=r.stateNode.containerInfo;if(o===a||o.nodeType===8&&o.parentNode===a)break;if(i===4)for(i=r.return;i!==null;){var l=i.tag;if((l===3||l===4)&&(l=i.stateNode.containerInfo,l===a||l.nodeType===8&&l.parentNode===a))return;i=i.return}for(;o!==null;){if(i=xl(o),i===null)return;if(l=i.tag,l===5||l===6){r=s=i;continue e}o=o.parentNode}}r=r.return}HM(function(){var c=s,u=A2(n),h=[];e:{var d=wF.get(e);if(d!==void 0){var p=O2,f=e;switch(e){case"keypress":if(a0(n)===0)break e;case"keydown":case"keyup":p=f5;break;case"focusin":f="focus",p=Uv;break;case"focusout":f="blur",p=Uv;break;case"beforeblur":case"afterblur":p=Uv;break;case"click":if(n.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":p=AT;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":p=n5;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":p=y5;break;case yF:case xF:case bF:p=s5;break;case vF:p=b5;break;case"scroll":p=e5;break;case"wheel":p=w5;break;case"copy":case"cut":case"paste":p=o5;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":p=MT}var m=(t&4)!==0,y=!m&&e==="scroll",g=m?d!==null?d+"Capture":null:d;m=[];for(var x=c,b;x!==null;){b=x;var v=b.stateNode;if(b.tag===5&&v!==null&&(b=v,g!==null&&(v=Uf(x,g),v!=null&&m.push(Xf(x,v,b)))),y)break;x=x.return}0<m.length&&(d=new p(d,f,null,n,u),h.push({event:d,listeners:m}))}}if(!(t&7)){e:{if(d=e==="mouseover"||e==="pointerover",p=e==="mouseout"||e==="pointerout",d&&n!==b1&&(f=n.relatedTarget||n.fromElement)&&(xl(f)||f[ii]))break e;if((p||d)&&(d=u.window===u?u:(d=u.ownerDocument)?d.defaultView||d.parentWindow:window,p?(f=n.relatedTarget||n.toElement,p=c,f=f?xl(f):null,f!==null&&(y=au(f),f!==y||f.tag!==5&&f.tag!==6)&&(f=null)):(p=null,f=c),p!==f)){if(m=AT,v="onMouseLeave",g="onMouseEnter",x="mouse",(e==="pointerout"||e==="pointerover")&&(m=MT,v="onPointerLeave",g="onPointerEnter",x="pointer"),y=p==null?d:mh(p),b=f==null?d:mh(f),d=new m(v,x+"leave",p,n,u),d.target=y,d.relatedTarget=b,v=null,xl(u)===c&&(m=new m(g,x+"enter",f,n,u),m.target=b,m.relatedTarget=y,v=m),y=v,p&&f)t:{for(m=p,g=f,x=0,b=m;b;b=Wc(b))x++;for(b=0,v=g;v;v=Wc(v))b++;for(;0<x-b;)m=Wc(m),x--;for(;0<b-x;)g=Wc(g),b--;for(;x--;){if(m===g||g!==null&&m===g.alternate)break t;m=Wc(m),g=Wc(g)}m=null}else m=null;p!==null&&VT(h,d,p,m,!1),f!==null&&y!==null&&VT(h,y,f,m,!0)}}e:{if(d=c?mh(c):window,p=d.nodeName&&d.nodeName.toLowerCase(),p==="select"||p==="input"&&d.type==="file")var w=T5;else if(DT(d))if(dF)w=M5;else{w=A5;var I=E5}else(p=d.nodeName)&&p.toLowerCase()==="input"&&(d.type==="checkbox"||d.type==="radio")&&(w=$5);if(w&&(w=w(e,c))){hF(h,w,n,u);break e}I&&I(e,d,c),e==="focusout"&&(I=d._wrapperState)&&I.controlled&&d.type==="number"&&f1(d,"number",d.value)}switch(I=c?mh(c):window,e){case"focusin":(DT(I)||I.contentEditable==="true")&&(ph=I,_1=c,Tf=null);break;case"focusout":Tf=_1=ph=null;break;case"mousedown":C1=!0;break;case"contextmenu":case"mouseup":case"dragend":C1=!1,BT(h,n,u);break;case"selectionchange":if(D5)break;case"keydown":case"keyup":BT(h,n,u)}var _;if(P2)e:{switch(e){case"compositionstart":var T="onCompositionStart";break e;case"compositionend":T="onCompositionEnd";break e;case"compositionupdate":T="onCompositionUpdate";break e}T=void 0}else dh?uF(e,n)&&(T="onCompositionEnd"):e==="keydown"&&n.keyCode===229&&(T="onCompositionStart");T&&(lF&&n.locale!=="ko"&&(dh||T!=="onCompositionStart"?T==="onCompositionEnd"&&dh&&(_=oF()):(Gi=u,D2="value"in Gi?Gi.value:Gi.textContent,dh=!0)),I=$0(c,T),0<I.length&&(T=new $T(T,e,null,n,u),h.push({event:T,listeners:I}),_?T.data=_:(_=cF(n),_!==null&&(T.data=_)))),(_=S5?I5(e,n):N5(e,n))&&(c=$0(c,"onBeforeInput"),0<c.length&&(u=new $T("onBeforeInput","beforeinput",null,n,u),h.push({event:u,listeners:c}),u.data=_))}kF(h,t)})}function Xf(e,t,n){return{instance:e,listener:t,currentTarget:n}}function $0(e,t){for(var n=t+"Capture",r=[];e!==null;){var a=e,s=a.stateNode;a.tag===5&&s!==null&&(a=s,s=Uf(e,n),s!=null&&r.unshift(Xf(e,s,a)),s=Uf(e,t),s!=null&&r.push(Xf(e,s,a))),e=e.return}return r}function Wc(e){if(e===null)return null;do e=e.return;while(e&&e.tag!==5);return e||null}function VT(e,t,n,r,a){for(var s=t._reactName,i=[];n!==null&&n!==r;){var o=n,l=o.alternate,c=o.stateNode;if(l!==null&&l===r)break;o.tag===5&&c!==null&&(o=c,a?(l=Uf(n,s),l!=null&&i.unshift(Xf(n,l,o))):a||(l=Uf(n,s),l!=null&&i.push(Xf(n,l,o)))),n=n.return}i.length!==0&&e.push({event:t,listeners:i})}var L5=/\r\n?/g,B5=/\u0000|\uFFFD/g;function jT(e){return(typeof e=="string"?e:""+e).replace(L5,`
`).replace(B5,"")}function hy(e,t,n){if(t=jT(t),jT(e)!==t&&n)throw Error(ce(425))}function M0(){}var T1=null,E1=null;function A1(e,t){return e==="textarea"||e==="noscript"||typeof t.children=="string"||typeof t.children=="number"||typeof t.dangerouslySetInnerHTML=="object"&&t.dangerouslySetInnerHTML!==null&&t.dangerouslySetInnerHTML.__html!=null}var $1=typeof setTimeout=="function"?setTimeout:void 0,W5=typeof clearTimeout=="function"?clearTimeout:void 0,GT=typeof Promise=="function"?Promise:void 0,U5=typeof queueMicrotask=="function"?queueMicrotask:typeof GT<"u"?function(e){return GT.resolve(null).then(e).catch(V5)}:$1;function V5(e){setTimeout(function(){throw e})}function Zv(e,t){var n=t,r=0;do{var a=n.nextSibling;if(e.removeChild(n),a&&a.nodeType===8)if(n=a.data,n==="/$"){if(r===0){e.removeChild(a),Gf(t);return}r--}else n!=="$"&&n!=="$?"&&n!=="$!"||r++;n=a}while(n);Gf(t)}function to(e){for(;e!=null;e=e.nextSibling){var t=e.nodeType;if(t===1||t===3)break;if(t===8){if(t=e.data,t==="$"||t==="$!"||t==="$?")break;if(t==="/$")return null}}return e}function HT(e){e=e.previousSibling;for(var t=0;e;){if(e.nodeType===8){var n=e.data;if(n==="$"||n==="$!"||n==="$?"){if(t===0)return e;t--}else n==="/$"&&t++}e=e.previousSibling}return null}var cd=Math.random().toString(36).slice(2),xs="__reactFiber$"+cd,Zf="__reactProps$"+cd,ii="__reactContainer$"+cd,M1="__reactEvents$"+cd,j5="__reactListeners$"+cd,G5="__reactHandles$"+cd;function xl(e){var t=e[xs];if(t)return t;for(var n=e.parentNode;n;){if(t=n[ii]||n[xs]){if(n=t.alternate,t.child!==null||n!==null&&n.child!==null)for(e=HT(e);e!==null;){if(n=e[xs])return n;e=HT(e)}return t}e=n,n=e.parentNode}return null}function Tm(e){return e=e[xs]||e[ii],!e||e.tag!==5&&e.tag!==6&&e.tag!==13&&e.tag!==3?null:e}function mh(e){if(e.tag===5||e.tag===6)return e.stateNode;throw Error(ce(33))}function Ox(e){return e[Zf]||null}var F1=[],gh=-1;function $o(e){return{current:e}}function At(e){0>gh||(e.current=F1[gh],F1[gh]=null,gh--)}function Ct(e,t){gh++,F1[gh]=e.current,e.current=t}var ho={},tr=$o(ho),zr=$o(!1),Ml=ho;function zh(e,t){var n=e.type.contextTypes;if(!n)return ho;var r=e.stateNode;if(r&&r.__reactInternalMemoizedUnmaskedChildContext===t)return r.__reactInternalMemoizedMaskedChildContext;var a={},s;for(s in n)a[s]=t[s];return r&&(e=e.stateNode,e.__reactInternalMemoizedUnmaskedChildContext=t,e.__reactInternalMemoizedMaskedChildContext=a),a}function Pr(e){return e=e.childContextTypes,e!=null}function F0(){At(zr),At(tr)}function qT(e,t,n){if(tr.current!==ho)throw Error(ce(168));Ct(tr,t),Ct(zr,n)}function IF(e,t,n){var r=e.stateNode;if(t=t.childContextTypes,typeof r.getChildContext!="function")return n;r=r.getChildContext();for(var a in r)if(!(a in t))throw Error(ce(108,Ej(e)||"Unknown",a));return Ut({},n,r)}function R0(e){return e=(e=e.stateNode)&&e.__reactInternalMemoizedMergedChildContext||ho,Ml=tr.current,Ct(tr,e),Ct(zr,zr.current),!0}function KT(e,t,n){var r=e.stateNode;if(!r)throw Error(ce(169));n?(e=IF(e,t,Ml),r.__reactInternalMemoizedMergedChildContext=e,At(zr),At(tr),Ct(tr,e)):At(zr),Ct(zr,n)}var Hs=null,zx=!1,Yv=!1;function NF(e){Hs===null?Hs=[e]:Hs.push(e)}function H5(e){zx=!0,NF(e)}function Mo(){if(!Yv&&Hs!==null){Yv=!0;var e=0,t=yt;try{var n=Hs;for(yt=1;e<n.length;e++){var r=n[e];do r=r(!0);while(r!==null)}Hs=null,zx=!1}catch(a){throw Hs!==null&&(Hs=Hs.slice(e+1)),ZM($2,Mo),a}finally{yt=t,Yv=!1}}return null}var yh=[],xh=0,D0=null,O0=0,Sa=[],Ia=0,Fl=null,Ys=1,Js="";function sl(e,t){yh[xh++]=O0,yh[xh++]=D0,D0=e,O0=t}function _F(e,t,n){Sa[Ia++]=Ys,Sa[Ia++]=Js,Sa[Ia++]=Fl,Fl=e;var r=Ys;e=Js;var a=32-Ka(r)-1;r&=~(1<<a),n+=1;var s=32-Ka(t)+a;if(30<s){var i=a-a%5;s=(r&(1<<i)-1).toString(32),r>>=i,a-=i,Ys=1<<32-Ka(t)+a|n<<a|r,Js=s+e}else Ys=1<<s|n<<a|r,Js=e}function B2(e){e.return!==null&&(sl(e,1),_F(e,1,0))}function W2(e){for(;e===D0;)D0=yh[--xh],yh[xh]=null,O0=yh[--xh],yh[xh]=null;for(;e===Fl;)Fl=Sa[--Ia],Sa[Ia]=null,Js=Sa[--Ia],Sa[Ia]=null,Ys=Sa[--Ia],Sa[Ia]=null}var oa=null,ta=null,Rt=!1,Ga=null;function CF(e,t){var n=Na(5,null,null,0);n.elementType="DELETED",n.stateNode=t,n.return=e,t=e.deletions,t===null?(e.deletions=[n],e.flags|=16):t.push(n)}function XT(e,t){switch(e.tag){case 5:var n=e.type;return t=t.nodeType!==1||n.toLowerCase()!==t.nodeName.toLowerCase()?null:t,t!==null?(e.stateNode=t,oa=e,ta=to(t.firstChild),!0):!1;case 6:return t=e.pendingProps===""||t.nodeType!==3?null:t,t!==null?(e.stateNode=t,oa=e,ta=null,!0):!1;case 13:return t=t.nodeType!==8?null:t,t!==null?(n=Fl!==null?{id:Ys,overflow:Js}:null,e.memoizedState={dehydrated:t,treeContext:n,retryLane:1073741824},n=Na(18,null,null,0),n.stateNode=t,n.return=e,e.child=n,oa=e,ta=null,!0):!1;default:return!1}}function R1(e){return(e.mode&1)!==0&&(e.flags&128)===0}function D1(e){if(Rt){var t=ta;if(t){var n=t;if(!XT(e,t)){if(R1(e))throw Error(ce(418));t=to(n.nextSibling);var r=oa;t&&XT(e,t)?CF(r,n):(e.flags=e.flags&-4097|2,Rt=!1,oa=e)}}else{if(R1(e))throw Error(ce(418));e.flags=e.flags&-4097|2,Rt=!1,oa=e}}}function ZT(e){for(e=e.return;e!==null&&e.tag!==5&&e.tag!==3&&e.tag!==13;)e=e.return;oa=e}function dy(e){if(e!==oa)return!1;if(!Rt)return ZT(e),Rt=!0,!1;var t;if((t=e.tag!==3)&&!(t=e.tag!==5)&&(t=e.type,t=t!=="head"&&t!=="body"&&!A1(e.type,e.memoizedProps)),t&&(t=ta)){if(R1(e))throw TF(),Error(ce(418));for(;t;)CF(e,t),t=to(t.nextSibling)}if(ZT(e),e.tag===13){if(e=e.memoizedState,e=e!==null?e.dehydrated:null,!e)throw Error(ce(317));e:{for(e=e.nextSibling,t=0;e;){if(e.nodeType===8){var n=e.data;if(n==="/$"){if(t===0){ta=to(e.nextSibling);break e}t--}else n!=="$"&&n!=="$!"&&n!=="$?"||t++}e=e.nextSibling}ta=null}}else ta=oa?to(e.stateNode.nextSibling):null;return!0}function TF(){for(var e=ta;e;)e=to(e.nextSibling)}function Ph(){ta=oa=null,Rt=!1}function U2(e){Ga===null?Ga=[e]:Ga.push(e)}var q5=hi.ReactCurrentBatchConfig;function Kp(e,t,n){if(e=n.ref,e!==null&&typeof e!="function"&&typeof e!="object"){if(n._owner){if(n=n._owner,n){if(n.tag!==1)throw Error(ce(309));var r=n.stateNode}if(!r)throw Error(ce(147,e));var a=r,s=""+e;return t!==null&&t.ref!==null&&typeof t.ref=="function"&&t.ref._stringRef===s?t.ref:(t=function(i){var o=a.refs;i===null?delete o[s]:o[s]=i},t._stringRef=s,t)}if(typeof e!="string")throw Error(ce(284));if(!n._owner)throw Error(ce(290,e))}return e}function py(e,t){throw e=Object.prototype.toString.call(t),Error(ce(31,e==="[object Object]"?"object with keys {"+Object.keys(t).join(", ")+"}":e))}function YT(e){var t=e._init;return t(e._payload)}function EF(e){function t(g,x){if(e){var b=g.deletions;b===null?(g.deletions=[x],g.flags|=16):b.push(x)}}function n(g,x){if(!e)return null;for(;x!==null;)t(g,x),x=x.sibling;return null}function r(g,x){for(g=new Map;x!==null;)x.key!==null?g.set(x.key,x):g.set(x.index,x),x=x.sibling;return g}function a(g,x){return g=so(g,x),g.index=0,g.sibling=null,g}function s(g,x,b){return g.index=b,e?(b=g.alternate,b!==null?(b=b.index,b<x?(g.flags|=2,x):b):(g.flags|=2,x)):(g.flags|=1048576,x)}function i(g){return e&&g.alternate===null&&(g.flags|=2),g}function o(g,x,b,v){return x===null||x.tag!==6?(x=aw(b,g.mode,v),x.return=g,x):(x=a(x,b),x.return=g,x)}function l(g,x,b,v){var w=b.type;return w===hh?u(g,x,b.props.children,v,b.key):x!==null&&(x.elementType===w||typeof w=="object"&&w!==null&&w.$$typeof===Pi&&YT(w)===x.type)?(v=a(x,b.props),v.ref=Kp(g,x,b),v.return=g,v):(v=h0(b.type,b.key,b.props,null,g.mode,v),v.ref=Kp(g,x,b),v.return=g,v)}function c(g,x,b,v){return x===null||x.tag!==4||x.stateNode.containerInfo!==b.containerInfo||x.stateNode.implementation!==b.implementation?(x=sw(b,g.mode,v),x.return=g,x):(x=a(x,b.children||[]),x.return=g,x)}function u(g,x,b,v,w){return x===null||x.tag!==7?(x=Cl(b,g.mode,v,w),x.return=g,x):(x=a(x,b),x.return=g,x)}function h(g,x,b){if(typeof x=="string"&&x!==""||typeof x=="number")return x=aw(""+x,g.mode,b),x.return=g,x;if(typeof x=="object"&&x!==null){switch(x.$$typeof){case ny:return b=h0(x.type,x.key,x.props,null,g.mode,b),b.ref=Kp(g,null,x),b.return=g,b;case ch:return x=sw(x,g.mode,b),x.return=g,x;case Pi:var v=x._init;return h(g,v(x._payload),b)}if(uf(x)||Vp(x))return x=Cl(x,g.mode,b,null),x.return=g,x;py(g,x)}return null}function d(g,x,b,v){var w=x!==null?x.key:null;if(typeof b=="string"&&b!==""||typeof b=="number")return w!==null?null:o(g,x,""+b,v);if(typeof b=="object"&&b!==null){switch(b.$$typeof){case ny:return b.key===w?l(g,x,b,v):null;case ch:return b.key===w?c(g,x,b,v):null;case Pi:return w=b._init,d(g,x,w(b._payload),v)}if(uf(b)||Vp(b))return w!==null?null:u(g,x,b,v,null);py(g,b)}return null}function p(g,x,b,v,w){if(typeof v=="string"&&v!==""||typeof v=="number")return g=g.get(b)||null,o(x,g,""+v,w);if(typeof v=="object"&&v!==null){switch(v.$$typeof){case ny:return g=g.get(v.key===null?b:v.key)||null,l(x,g,v,w);case ch:return g=g.get(v.key===null?b:v.key)||null,c(x,g,v,w);case Pi:var I=v._init;return p(g,x,b,I(v._payload),w)}if(uf(v)||Vp(v))return g=g.get(b)||null,u(x,g,v,w,null);py(x,v)}return null}function f(g,x,b,v){for(var w=null,I=null,_=x,T=x=0,A=null;_!==null&&T<b.length;T++){_.index>T?(A=_,_=null):A=_.sibling;var M=d(g,_,b[T],v);if(M===null){_===null&&(_=A);break}e&&_&&M.alternate===null&&t(g,_),x=s(M,x,T),I===null?w=M:I.sibling=M,I=M,_=A}if(T===b.length)return n(g,_),Rt&&sl(g,T),w;if(_===null){for(;T<b.length;T++)_=h(g,b[T],v),_!==null&&(x=s(_,x,T),I===null?w=_:I.sibling=_,I=_);return Rt&&sl(g,T),w}for(_=r(g,_);T<b.length;T++)A=p(_,g,T,b[T],v),A!==null&&(e&&A.alternate!==null&&_.delete(A.key===null?T:A.key),x=s(A,x,T),I===null?w=A:I.sibling=A,I=A);return e&&_.forEach(function(F){return t(g,F)}),Rt&&sl(g,T),w}function m(g,x,b,v){var w=Vp(b);if(typeof w!="function")throw Error(ce(150));if(b=w.call(b),b==null)throw Error(ce(151));for(var I=w=null,_=x,T=x=0,A=null,M=b.next();_!==null&&!M.done;T++,M=b.next()){_.index>T?(A=_,_=null):A=_.sibling;var F=d(g,_,M.value,v);if(F===null){_===null&&(_=A);break}e&&_&&F.alternate===null&&t(g,_),x=s(F,x,T),I===null?w=F:I.sibling=F,I=F,_=A}if(M.done)return n(g,_),Rt&&sl(g,T),w;if(_===null){for(;!M.done;T++,M=b.next())M=h(g,M.value,v),M!==null&&(x=s(M,x,T),I===null?w=M:I.sibling=M,I=M);return Rt&&sl(g,T),w}for(_=r(g,_);!M.done;T++,M=b.next())M=p(_,g,T,M.value,v),M!==null&&(e&&M.alternate!==null&&_.delete(M.key===null?T:M.key),x=s(M,x,T),I===null?w=M:I.sibling=M,I=M);return e&&_.forEach(function(C){return t(g,C)}),Rt&&sl(g,T),w}function y(g,x,b,v){if(typeof b=="object"&&b!==null&&b.type===hh&&b.key===null&&(b=b.props.children),typeof b=="object"&&b!==null){switch(b.$$typeof){case ny:e:{for(var w=b.key,I=x;I!==null;){if(I.key===w){if(w=b.type,w===hh){if(I.tag===7){n(g,I.sibling),x=a(I,b.props.children),x.return=g,g=x;break e}}else if(I.elementType===w||typeof w=="object"&&w!==null&&w.$$typeof===Pi&&YT(w)===I.type){n(g,I.sibling),x=a(I,b.props),x.ref=Kp(g,I,b),x.return=g,g=x;break e}n(g,I);break}else t(g,I);I=I.sibling}b.type===hh?(x=Cl(b.props.children,g.mode,v,b.key),x.return=g,g=x):(v=h0(b.type,b.key,b.props,null,g.mode,v),v.ref=Kp(g,x,b),v.return=g,g=v)}return i(g);case ch:e:{for(I=b.key;x!==null;){if(x.key===I)if(x.tag===4&&x.stateNode.containerInfo===b.containerInfo&&x.stateNode.implementation===b.implementation){n(g,x.sibling),x=a(x,b.children||[]),x.return=g,g=x;break e}else{n(g,x);break}else t(g,x);x=x.sibling}x=sw(b,g.mode,v),x.return=g,g=x}return i(g);case Pi:return I=b._init,y(g,x,I(b._payload),v)}if(uf(b))return f(g,x,b,v);if(Vp(b))return m(g,x,b,v);py(g,b)}return typeof b=="string"&&b!==""||typeof b=="number"?(b=""+b,x!==null&&x.tag===6?(n(g,x.sibling),x=a(x,b),x.return=g,g=x):(n(g,x),x=aw(b,g.mode,v),x.return=g,g=x),i(g)):n(g,x)}return y}var Lh=EF(!0),AF=EF(!1),z0=$o(null),P0=null,bh=null,V2=null;function j2(){V2=bh=P0=null}function G2(e){var t=z0.current;At(z0),e._currentValue=t}function O1(e,t,n){for(;e!==null;){var r=e.alternate;if((e.childLanes&t)!==t?(e.childLanes|=t,r!==null&&(r.childLanes|=t)):r!==null&&(r.childLanes&t)!==t&&(r.childLanes|=t),e===n)break;e=e.return}}function Ch(e,t){P0=e,V2=bh=null,e=e.dependencies,e!==null&&e.firstContext!==null&&(e.lanes&t&&(Rr=!0),e.firstContext=null)}function Ta(e){var t=e._currentValue;if(V2!==e)if(e={context:e,memoizedValue:t,next:null},bh===null){if(P0===null)throw Error(ce(308));bh=e,P0.dependencies={lanes:0,firstContext:e}}else bh=bh.next=e;return t}var bl=null;function H2(e){bl===null?bl=[e]:bl.push(e)}function $F(e,t,n,r){var a=t.interleaved;return a===null?(n.next=n,H2(t)):(n.next=a.next,a.next=n),t.interleaved=n,oi(e,r)}function oi(e,t){e.lanes|=t;var n=e.alternate;for(n!==null&&(n.lanes|=t),n=e,e=e.return;e!==null;)e.childLanes|=t,n=e.alternate,n!==null&&(n.childLanes|=t),n=e,e=e.return;return n.tag===3?n.stateNode:null}var Li=!1;function q2(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function MF(e,t){e=e.updateQueue,t.updateQueue===e&&(t.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,effects:e.effects})}function Qs(e,t){return{eventTime:e,lane:t,tag:0,payload:null,callback:null,next:null}}function no(e,t,n){var r=e.updateQueue;if(r===null)return null;if(r=r.shared,it&2){var a=r.pending;return a===null?t.next=t:(t.next=a.next,a.next=t),r.pending=t,oi(e,n)}return a=r.interleaved,a===null?(t.next=t,H2(r)):(t.next=a.next,a.next=t),r.interleaved=t,oi(e,n)}function s0(e,t,n){if(t=t.updateQueue,t!==null&&(t=t.shared,(n&4194240)!==0)){var r=t.lanes;r&=e.pendingLanes,n|=r,t.lanes=n,M2(e,n)}}function JT(e,t){var n=e.updateQueue,r=e.alternate;if(r!==null&&(r=r.updateQueue,n===r)){var a=null,s=null;if(n=n.firstBaseUpdate,n!==null){do{var i={eventTime:n.eventTime,lane:n.lane,tag:n.tag,payload:n.payload,callback:n.callback,next:null};s===null?a=s=i:s=s.next=i,n=n.next}while(n!==null);s===null?a=s=t:s=s.next=t}else a=s=t;n={baseState:r.baseState,firstBaseUpdate:a,lastBaseUpdate:s,shared:r.shared,effects:r.effects},e.updateQueue=n;return}e=n.lastBaseUpdate,e===null?n.firstBaseUpdate=t:e.next=t,n.lastBaseUpdate=t}function L0(e,t,n,r){var a=e.updateQueue;Li=!1;var s=a.firstBaseUpdate,i=a.lastBaseUpdate,o=a.shared.pending;if(o!==null){a.shared.pending=null;var l=o,c=l.next;l.next=null,i===null?s=c:i.next=c,i=l;var u=e.alternate;u!==null&&(u=u.updateQueue,o=u.lastBaseUpdate,o!==i&&(o===null?u.firstBaseUpdate=c:o.next=c,u.lastBaseUpdate=l))}if(s!==null){var h=a.baseState;i=0,u=c=l=null,o=s;do{var d=o.lane,p=o.eventTime;if((r&d)===d){u!==null&&(u=u.next={eventTime:p,lane:0,tag:o.tag,payload:o.payload,callback:o.callback,next:null});e:{var f=e,m=o;switch(d=t,p=n,m.tag){case 1:if(f=m.payload,typeof f=="function"){h=f.call(p,h,d);break e}h=f;break e;case 3:f.flags=f.flags&-65537|128;case 0:if(f=m.payload,d=typeof f=="function"?f.call(p,h,d):f,d==null)break e;h=Ut({},h,d);break e;case 2:Li=!0}}o.callback!==null&&o.lane!==0&&(e.flags|=64,d=a.effects,d===null?a.effects=[o]:d.push(o))}else p={eventTime:p,lane:d,tag:o.tag,payload:o.payload,callback:o.callback,next:null},u===null?(c=u=p,l=h):u=u.next=p,i|=d;if(o=o.next,o===null){if(o=a.shared.pending,o===null)break;d=o,o=d.next,d.next=null,a.lastBaseUpdate=d,a.shared.pending=null}}while(!0);if(u===null&&(l=h),a.baseState=l,a.firstBaseUpdate=c,a.lastBaseUpdate=u,t=a.shared.interleaved,t!==null){a=t;do i|=a.lane,a=a.next;while(a!==t)}else s===null&&(a.shared.lanes=0);Dl|=i,e.lanes=i,e.memoizedState=h}}function QT(e,t,n){if(e=t.effects,t.effects=null,e!==null)for(t=0;t<e.length;t++){var r=e[t],a=r.callback;if(a!==null){if(r.callback=null,r=n,typeof a!="function")throw Error(ce(191,a));a.call(r)}}}var Em={},Ss=$o(Em),Yf=$o(Em),Jf=$o(Em);function vl(e){if(e===Em)throw Error(ce(174));return e}function K2(e,t){switch(Ct(Jf,t),Ct(Yf,e),Ct(Ss,Em),e=t.nodeType,e){case 9:case 11:t=(t=t.documentElement)?t.namespaceURI:g1(null,"");break;default:e=e===8?t.parentNode:t,t=e.namespaceURI||null,e=e.tagName,t=g1(t,e)}At(Ss),Ct(Ss,t)}function Bh(){At(Ss),At(Yf),At(Jf)}function FF(e){vl(Jf.current);var t=vl(Ss.current),n=g1(t,e.type);t!==n&&(Ct(Yf,e),Ct(Ss,n))}function X2(e){Yf.current===e&&(At(Ss),At(Yf))}var Bt=$o(0);function B0(e){for(var t=e;t!==null;){if(t.tag===13){var n=t.memoizedState;if(n!==null&&(n=n.dehydrated,n===null||n.data==="$?"||n.data==="$!"))return t}else if(t.tag===19&&t.memoizedProps.revealOrder!==void 0){if(t.flags&128)return t}else if(t.child!==null){t.child.return=t,t=t.child;continue}if(t===e)break;for(;t.sibling===null;){if(t.return===null||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}return null}var Jv=[];function Z2(){for(var e=0;e<Jv.length;e++)Jv[e]._workInProgressVersionPrimary=null;Jv.length=0}var i0=hi.ReactCurrentDispatcher,Qv=hi.ReactCurrentBatchConfig,Rl=0,Wt=null,fn=null,En=null,W0=!1,Ef=!1,Qf=0,K5=0;function jn(){throw Error(ce(321))}function Y2(e,t){if(t===null)return!1;for(var n=0;n<t.length&&n<e.length;n++)if(!Qa(e[n],t[n]))return!1;return!0}function J2(e,t,n,r,a,s){if(Rl=s,Wt=t,t.memoizedState=null,t.updateQueue=null,t.lanes=0,i0.current=e===null||e.memoizedState===null?J5:Q5,e=n(r,a),Ef){s=0;do{if(Ef=!1,Qf=0,25<=s)throw Error(ce(301));s+=1,En=fn=null,t.updateQueue=null,i0.current=e6,e=n(r,a)}while(Ef)}if(i0.current=U0,t=fn!==null&&fn.next!==null,Rl=0,En=fn=Wt=null,W0=!1,t)throw Error(ce(300));return e}function Q2(){var e=Qf!==0;return Qf=0,e}function ds(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return En===null?Wt.memoizedState=En=e:En=En.next=e,En}function Ea(){if(fn===null){var e=Wt.alternate;e=e!==null?e.memoizedState:null}else e=fn.next;var t=En===null?Wt.memoizedState:En.next;if(t!==null)En=t,fn=e;else{if(e===null)throw Error(ce(310));fn=e,e={memoizedState:fn.memoizedState,baseState:fn.baseState,baseQueue:fn.baseQueue,queue:fn.queue,next:null},En===null?Wt.memoizedState=En=e:En=En.next=e}return En}function em(e,t){return typeof t=="function"?t(e):t}function ew(e){var t=Ea(),n=t.queue;if(n===null)throw Error(ce(311));n.lastRenderedReducer=e;var r=fn,a=r.baseQueue,s=n.pending;if(s!==null){if(a!==null){var i=a.next;a.next=s.next,s.next=i}r.baseQueue=a=s,n.pending=null}if(a!==null){s=a.next,r=r.baseState;var o=i=null,l=null,c=s;do{var u=c.lane;if((Rl&u)===u)l!==null&&(l=l.next={lane:0,action:c.action,hasEagerState:c.hasEagerState,eagerState:c.eagerState,next:null}),r=c.hasEagerState?c.eagerState:e(r,c.action);else{var h={lane:u,action:c.action,hasEagerState:c.hasEagerState,eagerState:c.eagerState,next:null};l===null?(o=l=h,i=r):l=l.next=h,Wt.lanes|=u,Dl|=u}c=c.next}while(c!==null&&c!==s);l===null?i=r:l.next=o,Qa(r,t.memoizedState)||(Rr=!0),t.memoizedState=r,t.baseState=i,t.baseQueue=l,n.lastRenderedState=r}if(e=n.interleaved,e!==null){a=e;do s=a.lane,Wt.lanes|=s,Dl|=s,a=a.next;while(a!==e)}else a===null&&(n.lanes=0);return[t.memoizedState,n.dispatch]}function tw(e){var t=Ea(),n=t.queue;if(n===null)throw Error(ce(311));n.lastRenderedReducer=e;var r=n.dispatch,a=n.pending,s=t.memoizedState;if(a!==null){n.pending=null;var i=a=a.next;do s=e(s,i.action),i=i.next;while(i!==a);Qa(s,t.memoizedState)||(Rr=!0),t.memoizedState=s,t.baseQueue===null&&(t.baseState=s),n.lastRenderedState=s}return[s,r]}function RF(){}function DF(e,t){var n=Wt,r=Ea(),a=t(),s=!Qa(r.memoizedState,a);if(s&&(r.memoizedState=a,Rr=!0),r=r.queue,eS(PF.bind(null,n,r,e),[e]),r.getSnapshot!==t||s||En!==null&&En.memoizedState.tag&1){if(n.flags|=2048,tm(9,zF.bind(null,n,r,a,t),void 0,null),Fn===null)throw Error(ce(349));Rl&30||OF(n,t,a)}return a}function OF(e,t,n){e.flags|=16384,e={getSnapshot:t,value:n},t=Wt.updateQueue,t===null?(t={lastEffect:null,stores:null},Wt.updateQueue=t,t.stores=[e]):(n=t.stores,n===null?t.stores=[e]:n.push(e))}function zF(e,t,n,r){t.value=n,t.getSnapshot=r,LF(t)&&BF(e)}function PF(e,t,n){return n(function(){LF(t)&&BF(e)})}function LF(e){var t=e.getSnapshot;e=e.value;try{var n=t();return!Qa(e,n)}catch{return!0}}function BF(e){var t=oi(e,1);t!==null&&Xa(t,e,1,-1)}function eE(e){var t=ds();return typeof e=="function"&&(e=e()),t.memoizedState=t.baseState=e,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:em,lastRenderedState:e},t.queue=e,e=e.dispatch=Y5.bind(null,Wt,e),[t.memoizedState,e]}function tm(e,t,n,r){return e={tag:e,create:t,destroy:n,deps:r,next:null},t=Wt.updateQueue,t===null?(t={lastEffect:null,stores:null},Wt.updateQueue=t,t.lastEffect=e.next=e):(n=t.lastEffect,n===null?t.lastEffect=e.next=e:(r=n.next,n.next=e,e.next=r,t.lastEffect=e)),e}function WF(){return Ea().memoizedState}function o0(e,t,n,r){var a=ds();Wt.flags|=e,a.memoizedState=tm(1|t,n,void 0,r===void 0?null:r)}function Px(e,t,n,r){var a=Ea();r=r===void 0?null:r;var s=void 0;if(fn!==null){var i=fn.memoizedState;if(s=i.destroy,r!==null&&Y2(r,i.deps)){a.memoizedState=tm(t,n,s,r);return}}Wt.flags|=e,a.memoizedState=tm(1|t,n,s,r)}function tE(e,t){return o0(8390656,8,e,t)}function eS(e,t){return Px(2048,8,e,t)}function UF(e,t){return Px(4,2,e,t)}function VF(e,t){return Px(4,4,e,t)}function jF(e,t){if(typeof t=="function")return e=e(),t(e),function(){t(null)};if(t!=null)return e=e(),t.current=e,function(){t.current=null}}function GF(e,t,n){return n=n!=null?n.concat([e]):null,Px(4,4,jF.bind(null,t,e),n)}function tS(){}function HF(e,t){var n=Ea();t=t===void 0?null:t;var r=n.memoizedState;return r!==null&&t!==null&&Y2(t,r[1])?r[0]:(n.memoizedState=[e,t],e)}function qF(e,t){var n=Ea();t=t===void 0?null:t;var r=n.memoizedState;return r!==null&&t!==null&&Y2(t,r[1])?r[0]:(e=e(),n.memoizedState=[e,t],e)}function KF(e,t,n){return Rl&21?(Qa(n,t)||(n=QM(),Wt.lanes|=n,Dl|=n,e.baseState=!0),t):(e.baseState&&(e.baseState=!1,Rr=!0),e.memoizedState=n)}function X5(e,t){var n=yt;yt=n!==0&&4>n?n:4,e(!0);var r=Qv.transition;Qv.transition={};try{e(!1),t()}finally{yt=n,Qv.transition=r}}function XF(){return Ea().memoizedState}function Z5(e,t,n){var r=ao(e);if(n={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null},ZF(e))YF(t,n);else if(n=$F(e,t,n,r),n!==null){var a=yr();Xa(n,e,r,a),JF(n,t,r)}}function Y5(e,t,n){var r=ao(e),a={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null};if(ZF(e))YF(t,a);else{var s=e.alternate;if(e.lanes===0&&(s===null||s.lanes===0)&&(s=t.lastRenderedReducer,s!==null))try{var i=t.lastRenderedState,o=s(i,n);if(a.hasEagerState=!0,a.eagerState=o,Qa(o,i)){var l=t.interleaved;l===null?(a.next=a,H2(t)):(a.next=l.next,l.next=a),t.interleaved=a;return}}catch{}finally{}n=$F(e,t,a,r),n!==null&&(a=yr(),Xa(n,e,r,a),JF(n,t,r))}}function ZF(e){var t=e.alternate;return e===Wt||t!==null&&t===Wt}function YF(e,t){Ef=W0=!0;var n=e.pending;n===null?t.next=t:(t.next=n.next,n.next=t),e.pending=t}function JF(e,t,n){if(n&4194240){var r=t.lanes;r&=e.pendingLanes,n|=r,t.lanes=n,M2(e,n)}}var U0={readContext:Ta,useCallback:jn,useContext:jn,useEffect:jn,useImperativeHandle:jn,useInsertionEffect:jn,useLayoutEffect:jn,useMemo:jn,useReducer:jn,useRef:jn,useState:jn,useDebugValue:jn,useDeferredValue:jn,useTransition:jn,useMutableSource:jn,useSyncExternalStore:jn,useId:jn,unstable_isNewReconciler:!1},J5={readContext:Ta,useCallback:function(e,t){return ds().memoizedState=[e,t===void 0?null:t],e},useContext:Ta,useEffect:tE,useImperativeHandle:function(e,t,n){return n=n!=null?n.concat([e]):null,o0(4194308,4,jF.bind(null,t,e),n)},useLayoutEffect:function(e,t){return o0(4194308,4,e,t)},useInsertionEffect:function(e,t){return o0(4,2,e,t)},useMemo:function(e,t){var n=ds();return t=t===void 0?null:t,e=e(),n.memoizedState=[e,t],e},useReducer:function(e,t,n){var r=ds();return t=n!==void 0?n(t):t,r.memoizedState=r.baseState=t,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:t},r.queue=e,e=e.dispatch=Z5.bind(null,Wt,e),[r.memoizedState,e]},useRef:function(e){var t=ds();return e={current:e},t.memoizedState=e},useState:eE,useDebugValue:tS,useDeferredValue:function(e){return ds().memoizedState=e},useTransition:function(){var e=eE(!1),t=e[0];return e=X5.bind(null,e[1]),ds().memoizedState=e,[t,e]},useMutableSource:function(){},useSyncExternalStore:function(e,t,n){var r=Wt,a=ds();if(Rt){if(n===void 0)throw Error(ce(407));n=n()}else{if(n=t(),Fn===null)throw Error(ce(349));Rl&30||OF(r,t,n)}a.memoizedState=n;var s={value:n,getSnapshot:t};return a.queue=s,tE(PF.bind(null,r,s,e),[e]),r.flags|=2048,tm(9,zF.bind(null,r,s,n,t),void 0,null),n},useId:function(){var e=ds(),t=Fn.identifierPrefix;if(Rt){var n=Js,r=Ys;n=(r&~(1<<32-Ka(r)-1)).toString(32)+n,t=":"+t+"R"+n,n=Qf++,0<n&&(t+="H"+n.toString(32)),t+=":"}else n=K5++,t=":"+t+"r"+n.toString(32)+":";return e.memoizedState=t},unstable_isNewReconciler:!1},Q5={readContext:Ta,useCallback:HF,useContext:Ta,useEffect:eS,useImperativeHandle:GF,useInsertionEffect:UF,useLayoutEffect:VF,useMemo:qF,useReducer:ew,useRef:WF,useState:function(){return ew(em)},useDebugValue:tS,useDeferredValue:function(e){var t=Ea();return KF(t,fn.memoizedState,e)},useTransition:function(){var e=ew(em)[0],t=Ea().memoizedState;return[e,t]},useMutableSource:RF,useSyncExternalStore:DF,useId:XF,unstable_isNewReconciler:!1},e6={readContext:Ta,useCallback:HF,useContext:Ta,useEffect:eS,useImperativeHandle:GF,useInsertionEffect:UF,useLayoutEffect:VF,useMemo:qF,useReducer:tw,useRef:WF,useState:function(){return tw(em)},useDebugValue:tS,useDeferredValue:function(e){var t=Ea();return fn===null?t.memoizedState=e:KF(t,fn.memoizedState,e)},useTransition:function(){var e=tw(em)[0],t=Ea().memoizedState;return[e,t]},useMutableSource:RF,useSyncExternalStore:DF,useId:XF,unstable_isNewReconciler:!1};function Va(e,t){if(e&&e.defaultProps){t=Ut({},t),e=e.defaultProps;for(var n in e)t[n]===void 0&&(t[n]=e[n]);return t}return t}function z1(e,t,n,r){t=e.memoizedState,n=n(r,t),n=n==null?t:Ut({},t,n),e.memoizedState=n,e.lanes===0&&(e.updateQueue.baseState=n)}var Lx={isMounted:function(e){return(e=e._reactInternals)?au(e)===e:!1},enqueueSetState:function(e,t,n){e=e._reactInternals;var r=yr(),a=ao(e),s=Qs(r,a);s.payload=t,n!=null&&(s.callback=n),t=no(e,s,a),t!==null&&(Xa(t,e,a,r),s0(t,e,a))},enqueueReplaceState:function(e,t,n){e=e._reactInternals;var r=yr(),a=ao(e),s=Qs(r,a);s.tag=1,s.payload=t,n!=null&&(s.callback=n),t=no(e,s,a),t!==null&&(Xa(t,e,a,r),s0(t,e,a))},enqueueForceUpdate:function(e,t){e=e._reactInternals;var n=yr(),r=ao(e),a=Qs(n,r);a.tag=2,t!=null&&(a.callback=t),t=no(e,a,r),t!==null&&(Xa(t,e,r,n),s0(t,e,r))}};function nE(e,t,n,r,a,s,i){return e=e.stateNode,typeof e.shouldComponentUpdate=="function"?e.shouldComponentUpdate(r,s,i):t.prototype&&t.prototype.isPureReactComponent?!qf(n,r)||!qf(a,s):!0}function QF(e,t,n){var r=!1,a=ho,s=t.contextType;return typeof s=="object"&&s!==null?s=Ta(s):(a=Pr(t)?Ml:tr.current,r=t.contextTypes,s=(r=r!=null)?zh(e,a):ho),t=new t(n,s),e.memoizedState=t.state!==null&&t.state!==void 0?t.state:null,t.updater=Lx,e.stateNode=t,t._reactInternals=e,r&&(e=e.stateNode,e.__reactInternalMemoizedUnmaskedChildContext=a,e.__reactInternalMemoizedMaskedChildContext=s),t}function rE(e,t,n,r){e=t.state,typeof t.componentWillReceiveProps=="function"&&t.componentWillReceiveProps(n,r),typeof t.UNSAFE_componentWillReceiveProps=="function"&&t.UNSAFE_componentWillReceiveProps(n,r),t.state!==e&&Lx.enqueueReplaceState(t,t.state,null)}function P1(e,t,n,r){var a=e.stateNode;a.props=n,a.state=e.memoizedState,a.refs={},q2(e);var s=t.contextType;typeof s=="object"&&s!==null?a.context=Ta(s):(s=Pr(t)?Ml:tr.current,a.context=zh(e,s)),a.state=e.memoizedState,s=t.getDerivedStateFromProps,typeof s=="function"&&(z1(e,t,s,n),a.state=e.memoizedState),typeof t.getDerivedStateFromProps=="function"||typeof a.getSnapshotBeforeUpdate=="function"||typeof a.UNSAFE_componentWillMount!="function"&&typeof a.componentWillMount!="function"||(t=a.state,typeof a.componentWillMount=="function"&&a.componentWillMount(),typeof a.UNSAFE_componentWillMount=="function"&&a.UNSAFE_componentWillMount(),t!==a.state&&Lx.enqueueReplaceState(a,a.state,null),L0(e,n,a,r),a.state=e.memoizedState),typeof a.componentDidMount=="function"&&(e.flags|=4194308)}function Wh(e,t){try{var n="",r=t;do n+=Tj(r),r=r.return;while(r);var a=n}catch(s){a=`
Error generating stack: `+s.message+`
`+s.stack}return{value:e,source:t,stack:a,digest:null}}function nw(e,t,n){return{value:e,source:null,stack:n??null,digest:t??null}}function L1(e,t){try{console.error(t.value)}catch(n){setTimeout(function(){throw n})}}var t6=typeof WeakMap=="function"?WeakMap:Map;function eR(e,t,n){n=Qs(-1,n),n.tag=3,n.payload={element:null};var r=t.value;return n.callback=function(){j0||(j0=!0,X1=r),L1(e,t)},n}function tR(e,t,n){n=Qs(-1,n),n.tag=3;var r=e.type.getDerivedStateFromError;if(typeof r=="function"){var a=t.value;n.payload=function(){return r(a)},n.callback=function(){L1(e,t)}}var s=e.stateNode;return s!==null&&typeof s.componentDidCatch=="function"&&(n.callback=function(){L1(e,t),typeof r!="function"&&(ro===null?ro=new Set([this]):ro.add(this));var i=t.stack;this.componentDidCatch(t.value,{componentStack:i!==null?i:""})}),n}function aE(e,t,n){var r=e.pingCache;if(r===null){r=e.pingCache=new t6;var a=new Set;r.set(t,a)}else a=r.get(t),a===void 0&&(a=new Set,r.set(t,a));a.has(n)||(a.add(n),e=m6.bind(null,e,t,n),t.then(e,e))}function sE(e){do{var t;if((t=e.tag===13)&&(t=e.memoizedState,t=t!==null?t.dehydrated!==null:!0),t)return e;e=e.return}while(e!==null);return null}function iE(e,t,n,r,a){return e.mode&1?(e.flags|=65536,e.lanes=a,e):(e===t?e.flags|=65536:(e.flags|=128,n.flags|=131072,n.flags&=-52805,n.tag===1&&(n.alternate===null?n.tag=17:(t=Qs(-1,1),t.tag=2,no(n,t,1))),n.lanes|=1),e)}var n6=hi.ReactCurrentOwner,Rr=!1;function pr(e,t,n,r){t.child=e===null?AF(t,null,n,r):Lh(t,e.child,n,r)}function oE(e,t,n,r,a){n=n.render;var s=t.ref;return Ch(t,a),r=J2(e,t,n,r,s,a),n=Q2(),e!==null&&!Rr?(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~a,li(e,t,a)):(Rt&&n&&B2(t),t.flags|=1,pr(e,t,r,a),t.child)}function lE(e,t,n,r,a){if(e===null){var s=n.type;return typeof s=="function"&&!uS(s)&&s.defaultProps===void 0&&n.compare===null&&n.defaultProps===void 0?(t.tag=15,t.type=s,nR(e,t,s,r,a)):(e=h0(n.type,null,r,t,t.mode,a),e.ref=t.ref,e.return=t,t.child=e)}if(s=e.child,!(e.lanes&a)){var i=s.memoizedProps;if(n=n.compare,n=n!==null?n:qf,n(i,r)&&e.ref===t.ref)return li(e,t,a)}return t.flags|=1,e=so(s,r),e.ref=t.ref,e.return=t,t.child=e}function nR(e,t,n,r,a){if(e!==null){var s=e.memoizedProps;if(qf(s,r)&&e.ref===t.ref)if(Rr=!1,t.pendingProps=r=s,(e.lanes&a)!==0)e.flags&131072&&(Rr=!0);else return t.lanes=e.lanes,li(e,t,a)}return B1(e,t,n,r,a)}function rR(e,t,n){var r=t.pendingProps,a=r.children,s=e!==null?e.memoizedState:null;if(r.mode==="hidden")if(!(t.mode&1))t.memoizedState={baseLanes:0,cachePool:null,transitions:null},Ct(wh,ea),ea|=n;else{if(!(n&1073741824))return e=s!==null?s.baseLanes|n:n,t.lanes=t.childLanes=1073741824,t.memoizedState={baseLanes:e,cachePool:null,transitions:null},t.updateQueue=null,Ct(wh,ea),ea|=e,null;t.memoizedState={baseLanes:0,cachePool:null,transitions:null},r=s!==null?s.baseLanes:n,Ct(wh,ea),ea|=r}else s!==null?(r=s.baseLanes|n,t.memoizedState=null):r=n,Ct(wh,ea),ea|=r;return pr(e,t,a,n),t.child}function aR(e,t){var n=t.ref;(e===null&&n!==null||e!==null&&e.ref!==n)&&(t.flags|=512,t.flags|=2097152)}function B1(e,t,n,r,a){var s=Pr(n)?Ml:tr.current;return s=zh(t,s),Ch(t,a),n=J2(e,t,n,r,s,a),r=Q2(),e!==null&&!Rr?(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~a,li(e,t,a)):(Rt&&r&&B2(t),t.flags|=1,pr(e,t,n,a),t.child)}function uE(e,t,n,r,a){if(Pr(n)){var s=!0;R0(t)}else s=!1;if(Ch(t,a),t.stateNode===null)l0(e,t),QF(t,n,r),P1(t,n,r,a),r=!0;else if(e===null){var i=t.stateNode,o=t.memoizedProps;i.props=o;var l=i.context,c=n.contextType;typeof c=="object"&&c!==null?c=Ta(c):(c=Pr(n)?Ml:tr.current,c=zh(t,c));var u=n.getDerivedStateFromProps,h=typeof u=="function"||typeof i.getSnapshotBeforeUpdate=="function";h||typeof i.UNSAFE_componentWillReceiveProps!="function"&&typeof i.componentWillReceiveProps!="function"||(o!==r||l!==c)&&rE(t,i,r,c),Li=!1;var d=t.memoizedState;i.state=d,L0(t,r,i,a),l=t.memoizedState,o!==r||d!==l||zr.current||Li?(typeof u=="function"&&(z1(t,n,u,r),l=t.memoizedState),(o=Li||nE(t,n,o,r,d,l,c))?(h||typeof i.UNSAFE_componentWillMount!="function"&&typeof i.componentWillMount!="function"||(typeof i.componentWillMount=="function"&&i.componentWillMount(),typeof i.UNSAFE_componentWillMount=="function"&&i.UNSAFE_componentWillMount()),typeof i.componentDidMount=="function"&&(t.flags|=4194308)):(typeof i.componentDidMount=="function"&&(t.flags|=4194308),t.memoizedProps=r,t.memoizedState=l),i.props=r,i.state=l,i.context=c,r=o):(typeof i.componentDidMount=="function"&&(t.flags|=4194308),r=!1)}else{i=t.stateNode,MF(e,t),o=t.memoizedProps,c=t.type===t.elementType?o:Va(t.type,o),i.props=c,h=t.pendingProps,d=i.context,l=n.contextType,typeof l=="object"&&l!==null?l=Ta(l):(l=Pr(n)?Ml:tr.current,l=zh(t,l));var p=n.getDerivedStateFromProps;(u=typeof p=="function"||typeof i.getSnapshotBeforeUpdate=="function")||typeof i.UNSAFE_componentWillReceiveProps!="function"&&typeof i.componentWillReceiveProps!="function"||(o!==h||d!==l)&&rE(t,i,r,l),Li=!1,d=t.memoizedState,i.state=d,L0(t,r,i,a);var f=t.memoizedState;o!==h||d!==f||zr.current||Li?(typeof p=="function"&&(z1(t,n,p,r),f=t.memoizedState),(c=Li||nE(t,n,c,r,d,f,l)||!1)?(u||typeof i.UNSAFE_componentWillUpdate!="function"&&typeof i.componentWillUpdate!="function"||(typeof i.componentWillUpdate=="function"&&i.componentWillUpdate(r,f,l),typeof i.UNSAFE_componentWillUpdate=="function"&&i.UNSAFE_componentWillUpdate(r,f,l)),typeof i.componentDidUpdate=="function"&&(t.flags|=4),typeof i.getSnapshotBeforeUpdate=="function"&&(t.flags|=1024)):(typeof i.componentDidUpdate!="function"||o===e.memoizedProps&&d===e.memoizedState||(t.flags|=4),typeof i.getSnapshotBeforeUpdate!="function"||o===e.memoizedProps&&d===e.memoizedState||(t.flags|=1024),t.memoizedProps=r,t.memoizedState=f),i.props=r,i.state=f,i.context=l,r=c):(typeof i.componentDidUpdate!="function"||o===e.memoizedProps&&d===e.memoizedState||(t.flags|=4),typeof i.getSnapshotBeforeUpdate!="function"||o===e.memoizedProps&&d===e.memoizedState||(t.flags|=1024),r=!1)}return W1(e,t,n,r,s,a)}function W1(e,t,n,r,a,s){aR(e,t);var i=(t.flags&128)!==0;if(!r&&!i)return a&&KT(t,n,!1),li(e,t,s);r=t.stateNode,n6.current=t;var o=i&&typeof n.getDerivedStateFromError!="function"?null:r.render();return t.flags|=1,e!==null&&i?(t.child=Lh(t,e.child,null,s),t.child=Lh(t,null,o,s)):pr(e,t,o,s),t.memoizedState=r.state,a&&KT(t,n,!0),t.child}function sR(e){var t=e.stateNode;t.pendingContext?qT(e,t.pendingContext,t.pendingContext!==t.context):t.context&&qT(e,t.context,!1),K2(e,t.containerInfo)}function cE(e,t,n,r,a){return Ph(),U2(a),t.flags|=256,pr(e,t,n,r),t.child}var U1={dehydrated:null,treeContext:null,retryLane:0};function V1(e){return{baseLanes:e,cachePool:null,transitions:null}}function iR(e,t,n){var r=t.pendingProps,a=Bt.current,s=!1,i=(t.flags&128)!==0,o;if((o=i)||(o=e!==null&&e.memoizedState===null?!1:(a&2)!==0),o?(s=!0,t.flags&=-129):(e===null||e.memoizedState!==null)&&(a|=1),Ct(Bt,a&1),e===null)return D1(t),e=t.memoizedState,e!==null&&(e=e.dehydrated,e!==null)?(t.mode&1?e.data==="$!"?t.lanes=8:t.lanes=1073741824:t.lanes=1,null):(i=r.children,e=r.fallback,s?(r=t.mode,s=t.child,i={mode:"hidden",children:i},!(r&1)&&s!==null?(s.childLanes=0,s.pendingProps=i):s=Ux(i,r,0,null),e=Cl(e,r,n,null),s.return=t,e.return=t,s.sibling=e,t.child=s,t.child.memoizedState=V1(n),t.memoizedState=U1,e):nS(t,i));if(a=e.memoizedState,a!==null&&(o=a.dehydrated,o!==null))return r6(e,t,i,r,o,a,n);if(s){s=r.fallback,i=t.mode,a=e.child,o=a.sibling;var l={mode:"hidden",children:r.children};return!(i&1)&&t.child!==a?(r=t.child,r.childLanes=0,r.pendingProps=l,t.deletions=null):(r=so(a,l),r.subtreeFlags=a.subtreeFlags&14680064),o!==null?s=so(o,s):(s=Cl(s,i,n,null),s.flags|=2),s.return=t,r.return=t,r.sibling=s,t.child=r,r=s,s=t.child,i=e.child.memoizedState,i=i===null?V1(n):{baseLanes:i.baseLanes|n,cachePool:null,transitions:i.transitions},s.memoizedState=i,s.childLanes=e.childLanes&~n,t.memoizedState=U1,r}return s=e.child,e=s.sibling,r=so(s,{mode:"visible",children:r.children}),!(t.mode&1)&&(r.lanes=n),r.return=t,r.sibling=null,e!==null&&(n=t.deletions,n===null?(t.deletions=[e],t.flags|=16):n.push(e)),t.child=r,t.memoizedState=null,r}function nS(e,t){return t=Ux({mode:"visible",children:t},e.mode,0,null),t.return=e,e.child=t}function fy(e,t,n,r){return r!==null&&U2(r),Lh(t,e.child,null,n),e=nS(t,t.pendingProps.children),e.flags|=2,t.memoizedState=null,e}function r6(e,t,n,r,a,s,i){if(n)return t.flags&256?(t.flags&=-257,r=nw(Error(ce(422))),fy(e,t,i,r)):t.memoizedState!==null?(t.child=e.child,t.flags|=128,null):(s=r.fallback,a=t.mode,r=Ux({mode:"visible",children:r.children},a,0,null),s=Cl(s,a,i,null),s.flags|=2,r.return=t,s.return=t,r.sibling=s,t.child=r,t.mode&1&&Lh(t,e.child,null,i),t.child.memoizedState=V1(i),t.memoizedState=U1,s);if(!(t.mode&1))return fy(e,t,i,null);if(a.data==="$!"){if(r=a.nextSibling&&a.nextSibling.dataset,r)var o=r.dgst;return r=o,s=Error(ce(419)),r=nw(s,r,void 0),fy(e,t,i,r)}if(o=(i&e.childLanes)!==0,Rr||o){if(r=Fn,r!==null){switch(i&-i){case 4:a=2;break;case 16:a=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:a=32;break;case 536870912:a=268435456;break;default:a=0}a=a&(r.suspendedLanes|i)?0:a,a!==0&&a!==s.retryLane&&(s.retryLane=a,oi(e,a),Xa(r,e,a,-1))}return lS(),r=nw(Error(ce(421))),fy(e,t,i,r)}return a.data==="$?"?(t.flags|=128,t.child=e.child,t=g6.bind(null,e),a._reactRetry=t,null):(e=s.treeContext,ta=to(a.nextSibling),oa=t,Rt=!0,Ga=null,e!==null&&(Sa[Ia++]=Ys,Sa[Ia++]=Js,Sa[Ia++]=Fl,Ys=e.id,Js=e.overflow,Fl=t),t=nS(t,r.children),t.flags|=4096,t)}function hE(e,t,n){e.lanes|=t;var r=e.alternate;r!==null&&(r.lanes|=t),O1(e.return,t,n)}function rw(e,t,n,r,a){var s=e.memoizedState;s===null?e.memoizedState={isBackwards:t,rendering:null,renderingStartTime:0,last:r,tail:n,tailMode:a}:(s.isBackwards=t,s.rendering=null,s.renderingStartTime=0,s.last=r,s.tail=n,s.tailMode=a)}function oR(e,t,n){var r=t.pendingProps,a=r.revealOrder,s=r.tail;if(pr(e,t,r.children,n),r=Bt.current,r&2)r=r&1|2,t.flags|=128;else{if(e!==null&&e.flags&128)e:for(e=t.child;e!==null;){if(e.tag===13)e.memoizedState!==null&&hE(e,n,t);else if(e.tag===19)hE(e,n,t);else if(e.child!==null){e.child.return=e,e=e.child;continue}if(e===t)break e;for(;e.sibling===null;){if(e.return===null||e.return===t)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}r&=1}if(Ct(Bt,r),!(t.mode&1))t.memoizedState=null;else switch(a){case"forwards":for(n=t.child,a=null;n!==null;)e=n.alternate,e!==null&&B0(e)===null&&(a=n),n=n.sibling;n=a,n===null?(a=t.child,t.child=null):(a=n.sibling,n.sibling=null),rw(t,!1,a,n,s);break;case"backwards":for(n=null,a=t.child,t.child=null;a!==null;){if(e=a.alternate,e!==null&&B0(e)===null){t.child=a;break}e=a.sibling,a.sibling=n,n=a,a=e}rw(t,!0,n,null,s);break;case"together":rw(t,!1,null,null,void 0);break;default:t.memoizedState=null}return t.child}function l0(e,t){!(t.mode&1)&&e!==null&&(e.alternate=null,t.alternate=null,t.flags|=2)}function li(e,t,n){if(e!==null&&(t.dependencies=e.dependencies),Dl|=t.lanes,!(n&t.childLanes))return null;if(e!==null&&t.child!==e.child)throw Error(ce(153));if(t.child!==null){for(e=t.child,n=so(e,e.pendingProps),t.child=n,n.return=t;e.sibling!==null;)e=e.sibling,n=n.sibling=so(e,e.pendingProps),n.return=t;n.sibling=null}return t.child}function a6(e,t,n){switch(t.tag){case 3:sR(t),Ph();break;case 5:FF(t);break;case 1:Pr(t.type)&&R0(t);break;case 4:K2(t,t.stateNode.containerInfo);break;case 10:var r=t.type._context,a=t.memoizedProps.value;Ct(z0,r._currentValue),r._currentValue=a;break;case 13:if(r=t.memoizedState,r!==null)return r.dehydrated!==null?(Ct(Bt,Bt.current&1),t.flags|=128,null):n&t.child.childLanes?iR(e,t,n):(Ct(Bt,Bt.current&1),e=li(e,t,n),e!==null?e.sibling:null);Ct(Bt,Bt.current&1);break;case 19:if(r=(n&t.childLanes)!==0,e.flags&128){if(r)return oR(e,t,n);t.flags|=128}if(a=t.memoizedState,a!==null&&(a.rendering=null,a.tail=null,a.lastEffect=null),Ct(Bt,Bt.current),r)break;return null;case 22:case 23:return t.lanes=0,rR(e,t,n)}return li(e,t,n)}var lR,j1,uR,cR;lR=function(e,t){for(var n=t.child;n!==null;){if(n.tag===5||n.tag===6)e.appendChild(n.stateNode);else if(n.tag!==4&&n.child!==null){n.child.return=n,n=n.child;continue}if(n===t)break;for(;n.sibling===null;){if(n.return===null||n.return===t)return;n=n.return}n.sibling.return=n.return,n=n.sibling}};j1=function(){};uR=function(e,t,n,r){var a=e.memoizedProps;if(a!==r){e=t.stateNode,vl(Ss.current);var s=null;switch(n){case"input":a=d1(e,a),r=d1(e,r),s=[];break;case"select":a=Ut({},a,{value:void 0}),r=Ut({},r,{value:void 0}),s=[];break;case"textarea":a=m1(e,a),r=m1(e,r),s=[];break;default:typeof a.onClick!="function"&&typeof r.onClick=="function"&&(e.onclick=M0)}y1(n,r);var i;n=null;for(c in a)if(!r.hasOwnProperty(c)&&a.hasOwnProperty(c)&&a[c]!=null)if(c==="style"){var o=a[c];for(i in o)o.hasOwnProperty(i)&&(n||(n={}),n[i]="")}else c!=="dangerouslySetInnerHTML"&&c!=="children"&&c!=="suppressContentEditableWarning"&&c!=="suppressHydrationWarning"&&c!=="autoFocus"&&(Bf.hasOwnProperty(c)?s||(s=[]):(s=s||[]).push(c,null));for(c in r){var l=r[c];if(o=a!=null?a[c]:void 0,r.hasOwnProperty(c)&&l!==o&&(l!=null||o!=null))if(c==="style")if(o){for(i in o)!o.hasOwnProperty(i)||l&&l.hasOwnProperty(i)||(n||(n={}),n[i]="");for(i in l)l.hasOwnProperty(i)&&o[i]!==l[i]&&(n||(n={}),n[i]=l[i])}else n||(s||(s=[]),s.push(c,n)),n=l;else c==="dangerouslySetInnerHTML"?(l=l?l.__html:void 0,o=o?o.__html:void 0,l!=null&&o!==l&&(s=s||[]).push(c,l)):c==="children"?typeof l!="string"&&typeof l!="number"||(s=s||[]).push(c,""+l):c!=="suppressContentEditableWarning"&&c!=="suppressHydrationWarning"&&(Bf.hasOwnProperty(c)?(l!=null&&c==="onScroll"&&Et("scroll",e),s||o===l||(s=[])):(s=s||[]).push(c,l))}n&&(s=s||[]).push("style",n);var c=s;(t.updateQueue=c)&&(t.flags|=4)}};cR=function(e,t,n,r){n!==r&&(t.flags|=4)};function Xp(e,t){if(!Rt)switch(e.tailMode){case"hidden":t=e.tail;for(var n=null;t!==null;)t.alternate!==null&&(n=t),t=t.sibling;n===null?e.tail=null:n.sibling=null;break;case"collapsed":n=e.tail;for(var r=null;n!==null;)n.alternate!==null&&(r=n),n=n.sibling;r===null?t||e.tail===null?e.tail=null:e.tail.sibling=null:r.sibling=null}}function Gn(e){var t=e.alternate!==null&&e.alternate.child===e.child,n=0,r=0;if(t)for(var a=e.child;a!==null;)n|=a.lanes|a.childLanes,r|=a.subtreeFlags&14680064,r|=a.flags&14680064,a.return=e,a=a.sibling;else for(a=e.child;a!==null;)n|=a.lanes|a.childLanes,r|=a.subtreeFlags,r|=a.flags,a.return=e,a=a.sibling;return e.subtreeFlags|=r,e.childLanes=n,t}function s6(e,t,n){var r=t.pendingProps;switch(W2(t),t.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Gn(t),null;case 1:return Pr(t.type)&&F0(),Gn(t),null;case 3:return r=t.stateNode,Bh(),At(zr),At(tr),Z2(),r.pendingContext&&(r.context=r.pendingContext,r.pendingContext=null),(e===null||e.child===null)&&(dy(t)?t.flags|=4:e===null||e.memoizedState.isDehydrated&&!(t.flags&256)||(t.flags|=1024,Ga!==null&&(J1(Ga),Ga=null))),j1(e,t),Gn(t),null;case 5:X2(t);var a=vl(Jf.current);if(n=t.type,e!==null&&t.stateNode!=null)uR(e,t,n,r,a),e.ref!==t.ref&&(t.flags|=512,t.flags|=2097152);else{if(!r){if(t.stateNode===null)throw Error(ce(166));return Gn(t),null}if(e=vl(Ss.current),dy(t)){r=t.stateNode,n=t.type;var s=t.memoizedProps;switch(r[xs]=t,r[Zf]=s,e=(t.mode&1)!==0,n){case"dialog":Et("cancel",r),Et("close",r);break;case"iframe":case"object":case"embed":Et("load",r);break;case"video":case"audio":for(a=0;a<hf.length;a++)Et(hf[a],r);break;case"source":Et("error",r);break;case"img":case"image":case"link":Et("error",r),Et("load",r);break;case"details":Et("toggle",r);break;case"input":vT(r,s),Et("invalid",r);break;case"select":r._wrapperState={wasMultiple:!!s.multiple},Et("invalid",r);break;case"textarea":kT(r,s),Et("invalid",r)}y1(n,s),a=null;for(var i in s)if(s.hasOwnProperty(i)){var o=s[i];i==="children"?typeof o=="string"?r.textContent!==o&&(s.suppressHydrationWarning!==!0&&hy(r.textContent,o,e),a=["children",o]):typeof o=="number"&&r.textContent!==""+o&&(s.suppressHydrationWarning!==!0&&hy(r.textContent,o,e),a=["children",""+o]):Bf.hasOwnProperty(i)&&o!=null&&i==="onScroll"&&Et("scroll",r)}switch(n){case"input":ry(r),wT(r,s,!0);break;case"textarea":ry(r),ST(r);break;case"select":case"option":break;default:typeof s.onClick=="function"&&(r.onclick=M0)}r=a,t.updateQueue=r,r!==null&&(t.flags|=4)}else{i=a.nodeType===9?a:a.ownerDocument,e==="http://www.w3.org/1999/xhtml"&&(e=PM(n)),e==="http://www.w3.org/1999/xhtml"?n==="script"?(e=i.createElement("div"),e.innerHTML="<script><\/script>",e=e.removeChild(e.firstChild)):typeof r.is=="string"?e=i.createElement(n,{is:r.is}):(e=i.createElement(n),n==="select"&&(i=e,r.multiple?i.multiple=!0:r.size&&(i.size=r.size))):e=i.createElementNS(e,n),e[xs]=t,e[Zf]=r,lR(e,t,!1,!1),t.stateNode=e;e:{switch(i=x1(n,r),n){case"dialog":Et("cancel",e),Et("close",e),a=r;break;case"iframe":case"object":case"embed":Et("load",e),a=r;break;case"video":case"audio":for(a=0;a<hf.length;a++)Et(hf[a],e);a=r;break;case"source":Et("error",e),a=r;break;case"img":case"image":case"link":Et("error",e),Et("load",e),a=r;break;case"details":Et("toggle",e),a=r;break;case"input":vT(e,r),a=d1(e,r),Et("invalid",e);break;case"option":a=r;break;case"select":e._wrapperState={wasMultiple:!!r.multiple},a=Ut({},r,{value:void 0}),Et("invalid",e);break;case"textarea":kT(e,r),a=m1(e,r),Et("invalid",e);break;default:a=r}y1(n,a),o=a;for(s in o)if(o.hasOwnProperty(s)){var l=o[s];s==="style"?WM(e,l):s==="dangerouslySetInnerHTML"?(l=l?l.__html:void 0,l!=null&&LM(e,l)):s==="children"?typeof l=="string"?(n!=="textarea"||l!=="")&&Wf(e,l):typeof l=="number"&&Wf(e,""+l):s!=="suppressContentEditableWarning"&&s!=="suppressHydrationWarning"&&s!=="autoFocus"&&(Bf.hasOwnProperty(s)?l!=null&&s==="onScroll"&&Et("scroll",e):l!=null&&_2(e,s,l,i))}switch(n){case"input":ry(e),wT(e,r,!1);break;case"textarea":ry(e),ST(e);break;case"option":r.value!=null&&e.setAttribute("value",""+co(r.value));break;case"select":e.multiple=!!r.multiple,s=r.value,s!=null?Sh(e,!!r.multiple,s,!1):r.defaultValue!=null&&Sh(e,!!r.multiple,r.defaultValue,!0);break;default:typeof a.onClick=="function"&&(e.onclick=M0)}switch(n){case"button":case"input":case"select":case"textarea":r=!!r.autoFocus;break e;case"img":r=!0;break e;default:r=!1}}r&&(t.flags|=4)}t.ref!==null&&(t.flags|=512,t.flags|=2097152)}return Gn(t),null;case 6:if(e&&t.stateNode!=null)cR(e,t,e.memoizedProps,r);else{if(typeof r!="string"&&t.stateNode===null)throw Error(ce(166));if(n=vl(Jf.current),vl(Ss.current),dy(t)){if(r=t.stateNode,n=t.memoizedProps,r[xs]=t,(s=r.nodeValue!==n)&&(e=oa,e!==null))switch(e.tag){case 3:hy(r.nodeValue,n,(e.mode&1)!==0);break;case 5:e.memoizedProps.suppressHydrationWarning!==!0&&hy(r.nodeValue,n,(e.mode&1)!==0)}s&&(t.flags|=4)}else r=(n.nodeType===9?n:n.ownerDocument).createTextNode(r),r[xs]=t,t.stateNode=r}return Gn(t),null;case 13:if(At(Bt),r=t.memoizedState,e===null||e.memoizedState!==null&&e.memoizedState.dehydrated!==null){if(Rt&&ta!==null&&t.mode&1&&!(t.flags&128))TF(),Ph(),t.flags|=98560,s=!1;else if(s=dy(t),r!==null&&r.dehydrated!==null){if(e===null){if(!s)throw Error(ce(318));if(s=t.memoizedState,s=s!==null?s.dehydrated:null,!s)throw Error(ce(317));s[xs]=t}else Ph(),!(t.flags&128)&&(t.memoizedState=null),t.flags|=4;Gn(t),s=!1}else Ga!==null&&(J1(Ga),Ga=null),s=!0;if(!s)return t.flags&65536?t:null}return t.flags&128?(t.lanes=n,t):(r=r!==null,r!==(e!==null&&e.memoizedState!==null)&&r&&(t.child.flags|=8192,t.mode&1&&(e===null||Bt.current&1?xn===0&&(xn=3):lS())),t.updateQueue!==null&&(t.flags|=4),Gn(t),null);case 4:return Bh(),j1(e,t),e===null&&Kf(t.stateNode.containerInfo),Gn(t),null;case 10:return G2(t.type._context),Gn(t),null;case 17:return Pr(t.type)&&F0(),Gn(t),null;case 19:if(At(Bt),s=t.memoizedState,s===null)return Gn(t),null;if(r=(t.flags&128)!==0,i=s.rendering,i===null)if(r)Xp(s,!1);else{if(xn!==0||e!==null&&e.flags&128)for(e=t.child;e!==null;){if(i=B0(e),i!==null){for(t.flags|=128,Xp(s,!1),r=i.updateQueue,r!==null&&(t.updateQueue=r,t.flags|=4),t.subtreeFlags=0,r=n,n=t.child;n!==null;)s=n,e=r,s.flags&=14680066,i=s.alternate,i===null?(s.childLanes=0,s.lanes=e,s.child=null,s.subtreeFlags=0,s.memoizedProps=null,s.memoizedState=null,s.updateQueue=null,s.dependencies=null,s.stateNode=null):(s.childLanes=i.childLanes,s.lanes=i.lanes,s.child=i.child,s.subtreeFlags=0,s.deletions=null,s.memoizedProps=i.memoizedProps,s.memoizedState=i.memoizedState,s.updateQueue=i.updateQueue,s.type=i.type,e=i.dependencies,s.dependencies=e===null?null:{lanes:e.lanes,firstContext:e.firstContext}),n=n.sibling;return Ct(Bt,Bt.current&1|2),t.child}e=e.sibling}s.tail!==null&&Xt()>Uh&&(t.flags|=128,r=!0,Xp(s,!1),t.lanes=4194304)}else{if(!r)if(e=B0(i),e!==null){if(t.flags|=128,r=!0,n=e.updateQueue,n!==null&&(t.updateQueue=n,t.flags|=4),Xp(s,!0),s.tail===null&&s.tailMode==="hidden"&&!i.alternate&&!Rt)return Gn(t),null}else 2*Xt()-s.renderingStartTime>Uh&&n!==1073741824&&(t.flags|=128,r=!0,Xp(s,!1),t.lanes=4194304);s.isBackwards?(i.sibling=t.child,t.child=i):(n=s.last,n!==null?n.sibling=i:t.child=i,s.last=i)}return s.tail!==null?(t=s.tail,s.rendering=t,s.tail=t.sibling,s.renderingStartTime=Xt(),t.sibling=null,n=Bt.current,Ct(Bt,r?n&1|2:n&1),t):(Gn(t),null);case 22:case 23:return oS(),r=t.memoizedState!==null,e!==null&&e.memoizedState!==null!==r&&(t.flags|=8192),r&&t.mode&1?ea&1073741824&&(Gn(t),t.subtreeFlags&6&&(t.flags|=8192)):Gn(t),null;case 24:return null;case 25:return null}throw Error(ce(156,t.tag))}function i6(e,t){switch(W2(t),t.tag){case 1:return Pr(t.type)&&F0(),e=t.flags,e&65536?(t.flags=e&-65537|128,t):null;case 3:return Bh(),At(zr),At(tr),Z2(),e=t.flags,e&65536&&!(e&128)?(t.flags=e&-65537|128,t):null;case 5:return X2(t),null;case 13:if(At(Bt),e=t.memoizedState,e!==null&&e.dehydrated!==null){if(t.alternate===null)throw Error(ce(340));Ph()}return e=t.flags,e&65536?(t.flags=e&-65537|128,t):null;case 19:return At(Bt),null;case 4:return Bh(),null;case 10:return G2(t.type._context),null;case 22:case 23:return oS(),null;case 24:return null;default:return null}}var my=!1,Xn=!1,o6=typeof WeakSet=="function"?WeakSet:Set,Se=null;function vh(e,t){var n=e.ref;if(n!==null)if(typeof n=="function")try{n(null)}catch(r){jt(e,t,r)}else n.current=null}function G1(e,t,n){try{n()}catch(r){jt(e,t,r)}}var dE=!1;function l6(e,t){if(T1=E0,e=mF(),L2(e)){if("selectionStart"in e)var n={start:e.selectionStart,end:e.selectionEnd};else e:{n=(n=e.ownerDocument)&&n.defaultView||window;var r=n.getSelection&&n.getSelection();if(r&&r.rangeCount!==0){n=r.anchorNode;var a=r.anchorOffset,s=r.focusNode;r=r.focusOffset;try{n.nodeType,s.nodeType}catch{n=null;break e}var i=0,o=-1,l=-1,c=0,u=0,h=e,d=null;t:for(;;){for(var p;h!==n||a!==0&&h.nodeType!==3||(o=i+a),h!==s||r!==0&&h.nodeType!==3||(l=i+r),h.nodeType===3&&(i+=h.nodeValue.length),(p=h.firstChild)!==null;)d=h,h=p;for(;;){if(h===e)break t;if(d===n&&++c===a&&(o=i),d===s&&++u===r&&(l=i),(p=h.nextSibling)!==null)break;h=d,d=h.parentNode}h=p}n=o===-1||l===-1?null:{start:o,end:l}}else n=null}n=n||{start:0,end:0}}else n=null;for(E1={focusedElem:e,selectionRange:n},E0=!1,Se=t;Se!==null;)if(t=Se,e=t.child,(t.subtreeFlags&1028)!==0&&e!==null)e.return=t,Se=e;else for(;Se!==null;){t=Se;try{var f=t.alternate;if(t.flags&1024)switch(t.tag){case 0:case 11:case 15:break;case 1:if(f!==null){var m=f.memoizedProps,y=f.memoizedState,g=t.stateNode,x=g.getSnapshotBeforeUpdate(t.elementType===t.type?m:Va(t.type,m),y);g.__reactInternalSnapshotBeforeUpdate=x}break;case 3:var b=t.stateNode.containerInfo;b.nodeType===1?b.textContent="":b.nodeType===9&&b.documentElement&&b.removeChild(b.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(ce(163))}}catch(v){jt(t,t.return,v)}if(e=t.sibling,e!==null){e.return=t.return,Se=e;break}Se=t.return}return f=dE,dE=!1,f}function Af(e,t,n){var r=t.updateQueue;if(r=r!==null?r.lastEffect:null,r!==null){var a=r=r.next;do{if((a.tag&e)===e){var s=a.destroy;a.destroy=void 0,s!==void 0&&G1(t,n,s)}a=a.next}while(a!==r)}}function Bx(e,t){if(t=t.updateQueue,t=t!==null?t.lastEffect:null,t!==null){var n=t=t.next;do{if((n.tag&e)===e){var r=n.create;n.destroy=r()}n=n.next}while(n!==t)}}function H1(e){var t=e.ref;if(t!==null){var n=e.stateNode;switch(e.tag){case 5:e=n;break;default:e=n}typeof t=="function"?t(e):t.current=e}}function hR(e){var t=e.alternate;t!==null&&(e.alternate=null,hR(t)),e.child=null,e.deletions=null,e.sibling=null,e.tag===5&&(t=e.stateNode,t!==null&&(delete t[xs],delete t[Zf],delete t[M1],delete t[j5],delete t[G5])),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}function dR(e){return e.tag===5||e.tag===3||e.tag===4}function pE(e){e:for(;;){for(;e.sibling===null;){if(e.return===null||dR(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;e.tag!==5&&e.tag!==6&&e.tag!==18;){if(e.flags&2||e.child===null||e.tag===4)continue e;e.child.return=e,e=e.child}if(!(e.flags&2))return e.stateNode}}function q1(e,t,n){var r=e.tag;if(r===5||r===6)e=e.stateNode,t?n.nodeType===8?n.parentNode.insertBefore(e,t):n.insertBefore(e,t):(n.nodeType===8?(t=n.parentNode,t.insertBefore(e,n)):(t=n,t.appendChild(e)),n=n._reactRootContainer,n!=null||t.onclick!==null||(t.onclick=M0));else if(r!==4&&(e=e.child,e!==null))for(q1(e,t,n),e=e.sibling;e!==null;)q1(e,t,n),e=e.sibling}function K1(e,t,n){var r=e.tag;if(r===5||r===6)e=e.stateNode,t?n.insertBefore(e,t):n.appendChild(e);else if(r!==4&&(e=e.child,e!==null))for(K1(e,t,n),e=e.sibling;e!==null;)K1(e,t,n),e=e.sibling}var On=null,ja=!1;function Ii(e,t,n){for(n=n.child;n!==null;)pR(e,t,n),n=n.sibling}function pR(e,t,n){if(ks&&typeof ks.onCommitFiberUnmount=="function")try{ks.onCommitFiberUnmount(Mx,n)}catch{}switch(n.tag){case 5:Xn||vh(n,t);case 6:var r=On,a=ja;On=null,Ii(e,t,n),On=r,ja=a,On!==null&&(ja?(e=On,n=n.stateNode,e.nodeType===8?e.parentNode.removeChild(n):e.removeChild(n)):On.removeChild(n.stateNode));break;case 18:On!==null&&(ja?(e=On,n=n.stateNode,e.nodeType===8?Zv(e.parentNode,n):e.nodeType===1&&Zv(e,n),Gf(e)):Zv(On,n.stateNode));break;case 4:r=On,a=ja,On=n.stateNode.containerInfo,ja=!0,Ii(e,t,n),On=r,ja=a;break;case 0:case 11:case 14:case 15:if(!Xn&&(r=n.updateQueue,r!==null&&(r=r.lastEffect,r!==null))){a=r=r.next;do{var s=a,i=s.destroy;s=s.tag,i!==void 0&&(s&2||s&4)&&G1(n,t,i),a=a.next}while(a!==r)}Ii(e,t,n);break;case 1:if(!Xn&&(vh(n,t),r=n.stateNode,typeof r.componentWillUnmount=="function"))try{r.props=n.memoizedProps,r.state=n.memoizedState,r.componentWillUnmount()}catch(o){jt(n,t,o)}Ii(e,t,n);break;case 21:Ii(e,t,n);break;case 22:n.mode&1?(Xn=(r=Xn)||n.memoizedState!==null,Ii(e,t,n),Xn=r):Ii(e,t,n);break;default:Ii(e,t,n)}}function fE(e){var t=e.updateQueue;if(t!==null){e.updateQueue=null;var n=e.stateNode;n===null&&(n=e.stateNode=new o6),t.forEach(function(r){var a=y6.bind(null,e,r);n.has(r)||(n.add(r),r.then(a,a))})}}function Da(e,t){var n=t.deletions;if(n!==null)for(var r=0;r<n.length;r++){var a=n[r];try{var s=e,i=t,o=i;e:for(;o!==null;){switch(o.tag){case 5:On=o.stateNode,ja=!1;break e;case 3:On=o.stateNode.containerInfo,ja=!0;break e;case 4:On=o.stateNode.containerInfo,ja=!0;break e}o=o.return}if(On===null)throw Error(ce(160));pR(s,i,a),On=null,ja=!1;var l=a.alternate;l!==null&&(l.return=null),a.return=null}catch(c){jt(a,t,c)}}if(t.subtreeFlags&12854)for(t=t.child;t!==null;)fR(t,e),t=t.sibling}function fR(e,t){var n=e.alternate,r=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:if(Da(t,e),ls(e),r&4){try{Af(3,e,e.return),Bx(3,e)}catch(m){jt(e,e.return,m)}try{Af(5,e,e.return)}catch(m){jt(e,e.return,m)}}break;case 1:Da(t,e),ls(e),r&512&&n!==null&&vh(n,n.return);break;case 5:if(Da(t,e),ls(e),r&512&&n!==null&&vh(n,n.return),e.flags&32){var a=e.stateNode;try{Wf(a,"")}catch(m){jt(e,e.return,m)}}if(r&4&&(a=e.stateNode,a!=null)){var s=e.memoizedProps,i=n!==null?n.memoizedProps:s,o=e.type,l=e.updateQueue;if(e.updateQueue=null,l!==null)try{o==="input"&&s.type==="radio"&&s.name!=null&&OM(a,s),x1(o,i);var c=x1(o,s);for(i=0;i<l.length;i+=2){var u=l[i],h=l[i+1];u==="style"?WM(a,h):u==="dangerouslySetInnerHTML"?LM(a,h):u==="children"?Wf(a,h):_2(a,u,h,c)}switch(o){case"input":p1(a,s);break;case"textarea":zM(a,s);break;case"select":var d=a._wrapperState.wasMultiple;a._wrapperState.wasMultiple=!!s.multiple;var p=s.value;p!=null?Sh(a,!!s.multiple,p,!1):d!==!!s.multiple&&(s.defaultValue!=null?Sh(a,!!s.multiple,s.defaultValue,!0):Sh(a,!!s.multiple,s.multiple?[]:"",!1))}a[Zf]=s}catch(m){jt(e,e.return,m)}}break;case 6:if(Da(t,e),ls(e),r&4){if(e.stateNode===null)throw Error(ce(162));a=e.stateNode,s=e.memoizedProps;try{a.nodeValue=s}catch(m){jt(e,e.return,m)}}break;case 3:if(Da(t,e),ls(e),r&4&&n!==null&&n.memoizedState.isDehydrated)try{Gf(t.containerInfo)}catch(m){jt(e,e.return,m)}break;case 4:Da(t,e),ls(e);break;case 13:Da(t,e),ls(e),a=e.child,a.flags&8192&&(s=a.memoizedState!==null,a.stateNode.isHidden=s,!s||a.alternate!==null&&a.alternate.memoizedState!==null||(sS=Xt())),r&4&&fE(e);break;case 22:if(u=n!==null&&n.memoizedState!==null,e.mode&1?(Xn=(c=Xn)||u,Da(t,e),Xn=c):Da(t,e),ls(e),r&8192){if(c=e.memoizedState!==null,(e.stateNode.isHidden=c)&&!u&&e.mode&1)for(Se=e,u=e.child;u!==null;){for(h=Se=u;Se!==null;){switch(d=Se,p=d.child,d.tag){case 0:case 11:case 14:case 15:Af(4,d,d.return);break;case 1:vh(d,d.return);var f=d.stateNode;if(typeof f.componentWillUnmount=="function"){r=d,n=d.return;try{t=r,f.props=t.memoizedProps,f.state=t.memoizedState,f.componentWillUnmount()}catch(m){jt(r,n,m)}}break;case 5:vh(d,d.return);break;case 22:if(d.memoizedState!==null){gE(h);continue}}p!==null?(p.return=d,Se=p):gE(h)}u=u.sibling}e:for(u=null,h=e;;){if(h.tag===5){if(u===null){u=h;try{a=h.stateNode,c?(s=a.style,typeof s.setProperty=="function"?s.setProperty("display","none","important"):s.display="none"):(o=h.stateNode,l=h.memoizedProps.style,i=l!=null&&l.hasOwnProperty("display")?l.display:null,o.style.display=BM("display",i))}catch(m){jt(e,e.return,m)}}}else if(h.tag===6){if(u===null)try{h.stateNode.nodeValue=c?"":h.memoizedProps}catch(m){jt(e,e.return,m)}}else if((h.tag!==22&&h.tag!==23||h.memoizedState===null||h===e)&&h.child!==null){h.child.return=h,h=h.child;continue}if(h===e)break e;for(;h.sibling===null;){if(h.return===null||h.return===e)break e;u===h&&(u=null),h=h.return}u===h&&(u=null),h.sibling.return=h.return,h=h.sibling}}break;case 19:Da(t,e),ls(e),r&4&&fE(e);break;case 21:break;default:Da(t,e),ls(e)}}function ls(e){var t=e.flags;if(t&2){try{e:{for(var n=e.return;n!==null;){if(dR(n)){var r=n;break e}n=n.return}throw Error(ce(160))}switch(r.tag){case 5:var a=r.stateNode;r.flags&32&&(Wf(a,""),r.flags&=-33);var s=pE(e);K1(e,s,a);break;case 3:case 4:var i=r.stateNode.containerInfo,o=pE(e);q1(e,o,i);break;default:throw Error(ce(161))}}catch(l){jt(e,e.return,l)}e.flags&=-3}t&4096&&(e.flags&=-4097)}function u6(e,t,n){Se=e,mR(e)}function mR(e,t,n){for(var r=(e.mode&1)!==0;Se!==null;){var a=Se,s=a.child;if(a.tag===22&&r){var i=a.memoizedState!==null||my;if(!i){var o=a.alternate,l=o!==null&&o.memoizedState!==null||Xn;o=my;var c=Xn;if(my=i,(Xn=l)&&!c)for(Se=a;Se!==null;)i=Se,l=i.child,i.tag===22&&i.memoizedState!==null?yE(a):l!==null?(l.return=i,Se=l):yE(a);for(;s!==null;)Se=s,mR(s),s=s.sibling;Se=a,my=o,Xn=c}mE(e)}else a.subtreeFlags&8772&&s!==null?(s.return=a,Se=s):mE(e)}}function mE(e){for(;Se!==null;){var t=Se;if(t.flags&8772){var n=t.alternate;try{if(t.flags&8772)switch(t.tag){case 0:case 11:case 15:Xn||Bx(5,t);break;case 1:var r=t.stateNode;if(t.flags&4&&!Xn)if(n===null)r.componentDidMount();else{var a=t.elementType===t.type?n.memoizedProps:Va(t.type,n.memoizedProps);r.componentDidUpdate(a,n.memoizedState,r.__reactInternalSnapshotBeforeUpdate)}var s=t.updateQueue;s!==null&&QT(t,s,r);break;case 3:var i=t.updateQueue;if(i!==null){if(n=null,t.child!==null)switch(t.child.tag){case 5:n=t.child.stateNode;break;case 1:n=t.child.stateNode}QT(t,i,n)}break;case 5:var o=t.stateNode;if(n===null&&t.flags&4){n=o;var l=t.memoizedProps;switch(t.type){case"button":case"input":case"select":case"textarea":l.autoFocus&&n.focus();break;case"img":l.src&&(n.src=l.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(t.memoizedState===null){var c=t.alternate;if(c!==null){var u=c.memoizedState;if(u!==null){var h=u.dehydrated;h!==null&&Gf(h)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(ce(163))}Xn||t.flags&512&&H1(t)}catch(d){jt(t,t.return,d)}}if(t===e){Se=null;break}if(n=t.sibling,n!==null){n.return=t.return,Se=n;break}Se=t.return}}function gE(e){for(;Se!==null;){var t=Se;if(t===e){Se=null;break}var n=t.sibling;if(n!==null){n.return=t.return,Se=n;break}Se=t.return}}function yE(e){for(;Se!==null;){var t=Se;try{switch(t.tag){case 0:case 11:case 15:var n=t.return;try{Bx(4,t)}catch(l){jt(t,n,l)}break;case 1:var r=t.stateNode;if(typeof r.componentDidMount=="function"){var a=t.return;try{r.componentDidMount()}catch(l){jt(t,a,l)}}var s=t.return;try{H1(t)}catch(l){jt(t,s,l)}break;case 5:var i=t.return;try{H1(t)}catch(l){jt(t,i,l)}}}catch(l){jt(t,t.return,l)}if(t===e){Se=null;break}var o=t.sibling;if(o!==null){o.return=t.return,Se=o;break}Se=t.return}}var c6=Math.ceil,V0=hi.ReactCurrentDispatcher,rS=hi.ReactCurrentOwner,_a=hi.ReactCurrentBatchConfig,it=0,Fn=null,rn=null,zn=0,ea=0,wh=$o(0),xn=0,nm=null,Dl=0,Wx=0,aS=0,$f=null,Mr=null,sS=0,Uh=1/0,Gs=null,j0=!1,X1=null,ro=null,gy=!1,Hi=null,G0=0,Mf=0,Z1=null,u0=-1,c0=0;function yr(){return it&6?Xt():u0!==-1?u0:u0=Xt()}function ao(e){return e.mode&1?it&2&&zn!==0?zn&-zn:q5.transition!==null?(c0===0&&(c0=QM()),c0):(e=yt,e!==0||(e=window.event,e=e===void 0?16:iF(e.type)),e):1}function Xa(e,t,n,r){if(50<Mf)throw Mf=0,Z1=null,Error(ce(185));_m(e,n,r),(!(it&2)||e!==Fn)&&(e===Fn&&(!(it&2)&&(Wx|=n),xn===4&&Vi(e,zn)),Lr(e,r),n===1&&it===0&&!(t.mode&1)&&(Uh=Xt()+500,zx&&Mo()))}function Lr(e,t){var n=e.callbackNode;qj(e,t);var r=T0(e,e===Fn?zn:0);if(r===0)n!==null&&_T(n),e.callbackNode=null,e.callbackPriority=0;else if(t=r&-r,e.callbackPriority!==t){if(n!=null&&_T(n),t===1)e.tag===0?H5(xE.bind(null,e)):NF(xE.bind(null,e)),U5(function(){!(it&6)&&Mo()}),n=null;else{switch(eF(r)){case 1:n=$2;break;case 4:n=YM;break;case 16:n=C0;break;case 536870912:n=JM;break;default:n=C0}n=SR(n,gR.bind(null,e))}e.callbackPriority=t,e.callbackNode=n}}function gR(e,t){if(u0=-1,c0=0,it&6)throw Error(ce(327));var n=e.callbackNode;if(Th()&&e.callbackNode!==n)return null;var r=T0(e,e===Fn?zn:0);if(r===0)return null;if(r&30||r&e.expiredLanes||t)t=H0(e,r);else{t=r;var a=it;it|=2;var s=xR();(Fn!==e||zn!==t)&&(Gs=null,Uh=Xt()+500,_l(e,t));do try{p6();break}catch(o){yR(e,o)}while(!0);j2(),V0.current=s,it=a,rn!==null?t=0:(Fn=null,zn=0,t=xn)}if(t!==0){if(t===2&&(a=S1(e),a!==0&&(r=a,t=Y1(e,a))),t===1)throw n=nm,_l(e,0),Vi(e,r),Lr(e,Xt()),n;if(t===6)Vi(e,r);else{if(a=e.current.alternate,!(r&30)&&!h6(a)&&(t=H0(e,r),t===2&&(s=S1(e),s!==0&&(r=s,t=Y1(e,s))),t===1))throw n=nm,_l(e,0),Vi(e,r),Lr(e,Xt()),n;switch(e.finishedWork=a,e.finishedLanes=r,t){case 0:case 1:throw Error(ce(345));case 2:il(e,Mr,Gs);break;case 3:if(Vi(e,r),(r&130023424)===r&&(t=sS+500-Xt(),10<t)){if(T0(e,0)!==0)break;if(a=e.suspendedLanes,(a&r)!==r){yr(),e.pingedLanes|=e.suspendedLanes&a;break}e.timeoutHandle=$1(il.bind(null,e,Mr,Gs),t);break}il(e,Mr,Gs);break;case 4:if(Vi(e,r),(r&4194240)===r)break;for(t=e.eventTimes,a=-1;0<r;){var i=31-Ka(r);s=1<<i,i=t[i],i>a&&(a=i),r&=~s}if(r=a,r=Xt()-r,r=(120>r?120:480>r?480:1080>r?1080:1920>r?1920:3e3>r?3e3:4320>r?4320:1960*c6(r/1960))-r,10<r){e.timeoutHandle=$1(il.bind(null,e,Mr,Gs),r);break}il(e,Mr,Gs);break;case 5:il(e,Mr,Gs);break;default:throw Error(ce(329))}}}return Lr(e,Xt()),e.callbackNode===n?gR.bind(null,e):null}function Y1(e,t){var n=$f;return e.current.memoizedState.isDehydrated&&(_l(e,t).flags|=256),e=H0(e,t),e!==2&&(t=Mr,Mr=n,t!==null&&J1(t)),e}function J1(e){Mr===null?Mr=e:Mr.push.apply(Mr,e)}function h6(e){for(var t=e;;){if(t.flags&16384){var n=t.updateQueue;if(n!==null&&(n=n.stores,n!==null))for(var r=0;r<n.length;r++){var a=n[r],s=a.getSnapshot;a=a.value;try{if(!Qa(s(),a))return!1}catch{return!1}}}if(n=t.child,t.subtreeFlags&16384&&n!==null)n.return=t,t=n;else{if(t===e)break;for(;t.sibling===null;){if(t.return===null||t.return===e)return!0;t=t.return}t.sibling.return=t.return,t=t.sibling}}return!0}function Vi(e,t){for(t&=~aS,t&=~Wx,e.suspendedLanes|=t,e.pingedLanes&=~t,e=e.expirationTimes;0<t;){var n=31-Ka(t),r=1<<n;e[n]=-1,t&=~r}}function xE(e){if(it&6)throw Error(ce(327));Th();var t=T0(e,0);if(!(t&1))return Lr(e,Xt()),null;var n=H0(e,t);if(e.tag!==0&&n===2){var r=S1(e);r!==0&&(t=r,n=Y1(e,r))}if(n===1)throw n=nm,_l(e,0),Vi(e,t),Lr(e,Xt()),n;if(n===6)throw Error(ce(345));return e.finishedWork=e.current.alternate,e.finishedLanes=t,il(e,Mr,Gs),Lr(e,Xt()),null}function iS(e,t){var n=it;it|=1;try{return e(t)}finally{it=n,it===0&&(Uh=Xt()+500,zx&&Mo())}}function Ol(e){Hi!==null&&Hi.tag===0&&!(it&6)&&Th();var t=it;it|=1;var n=_a.transition,r=yt;try{if(_a.transition=null,yt=1,e)return e()}finally{yt=r,_a.transition=n,it=t,!(it&6)&&Mo()}}function oS(){ea=wh.current,At(wh)}function _l(e,t){e.finishedWork=null,e.finishedLanes=0;var n=e.timeoutHandle;if(n!==-1&&(e.timeoutHandle=-1,W5(n)),rn!==null)for(n=rn.return;n!==null;){var r=n;switch(W2(r),r.tag){case 1:r=r.type.childContextTypes,r!=null&&F0();break;case 3:Bh(),At(zr),At(tr),Z2();break;case 5:X2(r);break;case 4:Bh();break;case 13:At(Bt);break;case 19:At(Bt);break;case 10:G2(r.type._context);break;case 22:case 23:oS()}n=n.return}if(Fn=e,rn=e=so(e.current,null),zn=ea=t,xn=0,nm=null,aS=Wx=Dl=0,Mr=$f=null,bl!==null){for(t=0;t<bl.length;t++)if(n=bl[t],r=n.interleaved,r!==null){n.interleaved=null;var a=r.next,s=n.pending;if(s!==null){var i=s.next;s.next=a,r.next=i}n.pending=r}bl=null}return e}function yR(e,t){do{var n=rn;try{if(j2(),i0.current=U0,W0){for(var r=Wt.memoizedState;r!==null;){var a=r.queue;a!==null&&(a.pending=null),r=r.next}W0=!1}if(Rl=0,En=fn=Wt=null,Ef=!1,Qf=0,rS.current=null,n===null||n.return===null){xn=1,nm=t,rn=null;break}e:{var s=e,i=n.return,o=n,l=t;if(t=zn,o.flags|=32768,l!==null&&typeof l=="object"&&typeof l.then=="function"){var c=l,u=o,h=u.tag;if(!(u.mode&1)&&(h===0||h===11||h===15)){var d=u.alternate;d?(u.updateQueue=d.updateQueue,u.memoizedState=d.memoizedState,u.lanes=d.lanes):(u.updateQueue=null,u.memoizedState=null)}var p=sE(i);if(p!==null){p.flags&=-257,iE(p,i,o,s,t),p.mode&1&&aE(s,c,t),t=p,l=c;var f=t.updateQueue;if(f===null){var m=new Set;m.add(l),t.updateQueue=m}else f.add(l);break e}else{if(!(t&1)){aE(s,c,t),lS();break e}l=Error(ce(426))}}else if(Rt&&o.mode&1){var y=sE(i);if(y!==null){!(y.flags&65536)&&(y.flags|=256),iE(y,i,o,s,t),U2(Wh(l,o));break e}}s=l=Wh(l,o),xn!==4&&(xn=2),$f===null?$f=[s]:$f.push(s),s=i;do{switch(s.tag){case 3:s.flags|=65536,t&=-t,s.lanes|=t;var g=eR(s,l,t);JT(s,g);break e;case 1:o=l;var x=s.type,b=s.stateNode;if(!(s.flags&128)&&(typeof x.getDerivedStateFromError=="function"||b!==null&&typeof b.componentDidCatch=="function"&&(ro===null||!ro.has(b)))){s.flags|=65536,t&=-t,s.lanes|=t;var v=tR(s,o,t);JT(s,v);break e}}s=s.return}while(s!==null)}vR(n)}catch(w){t=w,rn===n&&n!==null&&(rn=n=n.return);continue}break}while(!0)}function xR(){var e=V0.current;return V0.current=U0,e===null?U0:e}function lS(){(xn===0||xn===3||xn===2)&&(xn=4),Fn===null||!(Dl&268435455)&&!(Wx&268435455)||Vi(Fn,zn)}function H0(e,t){var n=it;it|=2;var r=xR();(Fn!==e||zn!==t)&&(Gs=null,_l(e,t));do try{d6();break}catch(a){yR(e,a)}while(!0);if(j2(),it=n,V0.current=r,rn!==null)throw Error(ce(261));return Fn=null,zn=0,xn}function d6(){for(;rn!==null;)bR(rn)}function p6(){for(;rn!==null&&!Pj();)bR(rn)}function bR(e){var t=kR(e.alternate,e,ea);e.memoizedProps=e.pendingProps,t===null?vR(e):rn=t,rS.current=null}function vR(e){var t=e;do{var n=t.alternate;if(e=t.return,t.flags&32768){if(n=i6(n,t),n!==null){n.flags&=32767,rn=n;return}if(e!==null)e.flags|=32768,e.subtreeFlags=0,e.deletions=null;else{xn=6,rn=null;return}}else if(n=s6(n,t,ea),n!==null){rn=n;return}if(t=t.sibling,t!==null){rn=t;return}rn=t=e}while(t!==null);xn===0&&(xn=5)}function il(e,t,n){var r=yt,a=_a.transition;try{_a.transition=null,yt=1,f6(e,t,n,r)}finally{_a.transition=a,yt=r}return null}function f6(e,t,n,r){do Th();while(Hi!==null);if(it&6)throw Error(ce(327));n=e.finishedWork;var a=e.finishedLanes;if(n===null)return null;if(e.finishedWork=null,e.finishedLanes=0,n===e.current)throw Error(ce(177));e.callbackNode=null,e.callbackPriority=0;var s=n.lanes|n.childLanes;if(Kj(e,s),e===Fn&&(rn=Fn=null,zn=0),!(n.subtreeFlags&2064)&&!(n.flags&2064)||gy||(gy=!0,SR(C0,function(){return Th(),null})),s=(n.flags&15990)!==0,n.subtreeFlags&15990||s){s=_a.transition,_a.transition=null;var i=yt;yt=1;var o=it;it|=4,rS.current=null,l6(e,n),fR(n,e),R5(E1),E0=!!T1,E1=T1=null,e.current=n,u6(n),Lj(),it=o,yt=i,_a.transition=s}else e.current=n;if(gy&&(gy=!1,Hi=e,G0=a),s=e.pendingLanes,s===0&&(ro=null),Uj(n.stateNode),Lr(e,Xt()),t!==null)for(r=e.onRecoverableError,n=0;n<t.length;n++)a=t[n],r(a.value,{componentStack:a.stack,digest:a.digest});if(j0)throw j0=!1,e=X1,X1=null,e;return G0&1&&e.tag!==0&&Th(),s=e.pendingLanes,s&1?e===Z1?Mf++:(Mf=0,Z1=e):Mf=0,Mo(),null}function Th(){if(Hi!==null){var e=eF(G0),t=_a.transition,n=yt;try{if(_a.transition=null,yt=16>e?16:e,Hi===null)var r=!1;else{if(e=Hi,Hi=null,G0=0,it&6)throw Error(ce(331));var a=it;for(it|=4,Se=e.current;Se!==null;){var s=Se,i=s.child;if(Se.flags&16){var o=s.deletions;if(o!==null){for(var l=0;l<o.length;l++){var c=o[l];for(Se=c;Se!==null;){var u=Se;switch(u.tag){case 0:case 11:case 15:Af(8,u,s)}var h=u.child;if(h!==null)h.return=u,Se=h;else for(;Se!==null;){u=Se;var d=u.sibling,p=u.return;if(hR(u),u===c){Se=null;break}if(d!==null){d.return=p,Se=d;break}Se=p}}}var f=s.alternate;if(f!==null){var m=f.child;if(m!==null){f.child=null;do{var y=m.sibling;m.sibling=null,m=y}while(m!==null)}}Se=s}}if(s.subtreeFlags&2064&&i!==null)i.return=s,Se=i;else e:for(;Se!==null;){if(s=Se,s.flags&2048)switch(s.tag){case 0:case 11:case 15:Af(9,s,s.return)}var g=s.sibling;if(g!==null){g.return=s.return,Se=g;break e}Se=s.return}}var x=e.current;for(Se=x;Se!==null;){i=Se;var b=i.child;if(i.subtreeFlags&2064&&b!==null)b.return=i,Se=b;else e:for(i=x;Se!==null;){if(o=Se,o.flags&2048)try{switch(o.tag){case 0:case 11:case 15:Bx(9,o)}}catch(w){jt(o,o.return,w)}if(o===i){Se=null;break e}var v=o.sibling;if(v!==null){v.return=o.return,Se=v;break e}Se=o.return}}if(it=a,Mo(),ks&&typeof ks.onPostCommitFiberRoot=="function")try{ks.onPostCommitFiberRoot(Mx,e)}catch{}r=!0}return r}finally{yt=n,_a.transition=t}}return!1}function bE(e,t,n){t=Wh(n,t),t=eR(e,t,1),e=no(e,t,1),t=yr(),e!==null&&(_m(e,1,t),Lr(e,t))}function jt(e,t,n){if(e.tag===3)bE(e,e,n);else for(;t!==null;){if(t.tag===3){bE(t,e,n);break}else if(t.tag===1){var r=t.stateNode;if(typeof t.type.getDerivedStateFromError=="function"||typeof r.componentDidCatch=="function"&&(ro===null||!ro.has(r))){e=Wh(n,e),e=tR(t,e,1),t=no(t,e,1),e=yr(),t!==null&&(_m(t,1,e),Lr(t,e));break}}t=t.return}}function m6(e,t,n){var r=e.pingCache;r!==null&&r.delete(t),t=yr(),e.pingedLanes|=e.suspendedLanes&n,Fn===e&&(zn&n)===n&&(xn===4||xn===3&&(zn&130023424)===zn&&500>Xt()-sS?_l(e,0):aS|=n),Lr(e,t)}function wR(e,t){t===0&&(e.mode&1?(t=iy,iy<<=1,!(iy&130023424)&&(iy=4194304)):t=1);var n=yr();e=oi(e,t),e!==null&&(_m(e,t,n),Lr(e,n))}function g6(e){var t=e.memoizedState,n=0;t!==null&&(n=t.retryLane),wR(e,n)}function y6(e,t){var n=0;switch(e.tag){case 13:var r=e.stateNode,a=e.memoizedState;a!==null&&(n=a.retryLane);break;case 19:r=e.stateNode;break;default:throw Error(ce(314))}r!==null&&r.delete(t),wR(e,n)}var kR;kR=function(e,t,n){if(e!==null)if(e.memoizedProps!==t.pendingProps||zr.current)Rr=!0;else{if(!(e.lanes&n)&&!(t.flags&128))return Rr=!1,a6(e,t,n);Rr=!!(e.flags&131072)}else Rr=!1,Rt&&t.flags&1048576&&_F(t,O0,t.index);switch(t.lanes=0,t.tag){case 2:var r=t.type;l0(e,t),e=t.pendingProps;var a=zh(t,tr.current);Ch(t,n),a=J2(null,t,r,e,a,n);var s=Q2();return t.flags|=1,typeof a=="object"&&a!==null&&typeof a.render=="function"&&a.$$typeof===void 0?(t.tag=1,t.memoizedState=null,t.updateQueue=null,Pr(r)?(s=!0,R0(t)):s=!1,t.memoizedState=a.state!==null&&a.state!==void 0?a.state:null,q2(t),a.updater=Lx,t.stateNode=a,a._reactInternals=t,P1(t,r,e,n),t=W1(null,t,r,!0,s,n)):(t.tag=0,Rt&&s&&B2(t),pr(null,t,a,n),t=t.child),t;case 16:r=t.elementType;e:{switch(l0(e,t),e=t.pendingProps,a=r._init,r=a(r._payload),t.type=r,a=t.tag=b6(r),e=Va(r,e),a){case 0:t=B1(null,t,r,e,n);break e;case 1:t=uE(null,t,r,e,n);break e;case 11:t=oE(null,t,r,e,n);break e;case 14:t=lE(null,t,r,Va(r.type,e),n);break e}throw Error(ce(306,r,""))}return t;case 0:return r=t.type,a=t.pendingProps,a=t.elementType===r?a:Va(r,a),B1(e,t,r,a,n);case 1:return r=t.type,a=t.pendingProps,a=t.elementType===r?a:Va(r,a),uE(e,t,r,a,n);case 3:e:{if(sR(t),e===null)throw Error(ce(387));r=t.pendingProps,s=t.memoizedState,a=s.element,MF(e,t),L0(t,r,null,n);var i=t.memoizedState;if(r=i.element,s.isDehydrated)if(s={element:r,isDehydrated:!1,cache:i.cache,pendingSuspenseBoundaries:i.pendingSuspenseBoundaries,transitions:i.transitions},t.updateQueue.baseState=s,t.memoizedState=s,t.flags&256){a=Wh(Error(ce(423)),t),t=cE(e,t,r,n,a);break e}else if(r!==a){a=Wh(Error(ce(424)),t),t=cE(e,t,r,n,a);break e}else for(ta=to(t.stateNode.containerInfo.firstChild),oa=t,Rt=!0,Ga=null,n=AF(t,null,r,n),t.child=n;n;)n.flags=n.flags&-3|4096,n=n.sibling;else{if(Ph(),r===a){t=li(e,t,n);break e}pr(e,t,r,n)}t=t.child}return t;case 5:return FF(t),e===null&&D1(t),r=t.type,a=t.pendingProps,s=e!==null?e.memoizedProps:null,i=a.children,A1(r,a)?i=null:s!==null&&A1(r,s)&&(t.flags|=32),aR(e,t),pr(e,t,i,n),t.child;case 6:return e===null&&D1(t),null;case 13:return iR(e,t,n);case 4:return K2(t,t.stateNode.containerInfo),r=t.pendingProps,e===null?t.child=Lh(t,null,r,n):pr(e,t,r,n),t.child;case 11:return r=t.type,a=t.pendingProps,a=t.elementType===r?a:Va(r,a),oE(e,t,r,a,n);case 7:return pr(e,t,t.pendingProps,n),t.child;case 8:return pr(e,t,t.pendingProps.children,n),t.child;case 12:return pr(e,t,t.pendingProps.children,n),t.child;case 10:e:{if(r=t.type._context,a=t.pendingProps,s=t.memoizedProps,i=a.value,Ct(z0,r._currentValue),r._currentValue=i,s!==null)if(Qa(s.value,i)){if(s.children===a.children&&!zr.current){t=li(e,t,n);break e}}else for(s=t.child,s!==null&&(s.return=t);s!==null;){var o=s.dependencies;if(o!==null){i=s.child;for(var l=o.firstContext;l!==null;){if(l.context===r){if(s.tag===1){l=Qs(-1,n&-n),l.tag=2;var c=s.updateQueue;if(c!==null){c=c.shared;var u=c.pending;u===null?l.next=l:(l.next=u.next,u.next=l),c.pending=l}}s.lanes|=n,l=s.alternate,l!==null&&(l.lanes|=n),O1(s.return,n,t),o.lanes|=n;break}l=l.next}}else if(s.tag===10)i=s.type===t.type?null:s.child;else if(s.tag===18){if(i=s.return,i===null)throw Error(ce(341));i.lanes|=n,o=i.alternate,o!==null&&(o.lanes|=n),O1(i,n,t),i=s.sibling}else i=s.child;if(i!==null)i.return=s;else for(i=s;i!==null;){if(i===t){i=null;break}if(s=i.sibling,s!==null){s.return=i.return,i=s;break}i=i.return}s=i}pr(e,t,a.children,n),t=t.child}return t;case 9:return a=t.type,r=t.pendingProps.children,Ch(t,n),a=Ta(a),r=r(a),t.flags|=1,pr(e,t,r,n),t.child;case 14:return r=t.type,a=Va(r,t.pendingProps),a=Va(r.type,a),lE(e,t,r,a,n);case 15:return nR(e,t,t.type,t.pendingProps,n);case 17:return r=t.type,a=t.pendingProps,a=t.elementType===r?a:Va(r,a),l0(e,t),t.tag=1,Pr(r)?(e=!0,R0(t)):e=!1,Ch(t,n),QF(t,r,a),P1(t,r,a,n),W1(null,t,r,!0,e,n);case 19:return oR(e,t,n);case 22:return rR(e,t,n)}throw Error(ce(156,t.tag))};function SR(e,t){return ZM(e,t)}function x6(e,t,n,r){this.tag=e,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=t,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=r,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Na(e,t,n,r){return new x6(e,t,n,r)}function uS(e){return e=e.prototype,!(!e||!e.isReactComponent)}function b6(e){if(typeof e=="function")return uS(e)?1:0;if(e!=null){if(e=e.$$typeof,e===T2)return 11;if(e===E2)return 14}return 2}function so(e,t){var n=e.alternate;return n===null?(n=Na(e.tag,t,e.key,e.mode),n.elementType=e.elementType,n.type=e.type,n.stateNode=e.stateNode,n.alternate=e,e.alternate=n):(n.pendingProps=t,n.type=e.type,n.flags=0,n.subtreeFlags=0,n.deletions=null),n.flags=e.flags&14680064,n.childLanes=e.childLanes,n.lanes=e.lanes,n.child=e.child,n.memoizedProps=e.memoizedProps,n.memoizedState=e.memoizedState,n.updateQueue=e.updateQueue,t=e.dependencies,n.dependencies=t===null?null:{lanes:t.lanes,firstContext:t.firstContext},n.sibling=e.sibling,n.index=e.index,n.ref=e.ref,n}function h0(e,t,n,r,a,s){var i=2;if(r=e,typeof e=="function")uS(e)&&(i=1);else if(typeof e=="string")i=5;else e:switch(e){case hh:return Cl(n.children,a,s,t);case C2:i=8,a|=8;break;case l1:return e=Na(12,n,t,a|2),e.elementType=l1,e.lanes=s,e;case u1:return e=Na(13,n,t,a),e.elementType=u1,e.lanes=s,e;case c1:return e=Na(19,n,t,a),e.elementType=c1,e.lanes=s,e;case FM:return Ux(n,a,s,t);default:if(typeof e=="object"&&e!==null)switch(e.$$typeof){case $M:i=10;break e;case MM:i=9;break e;case T2:i=11;break e;case E2:i=14;break e;case Pi:i=16,r=null;break e}throw Error(ce(130,e==null?e:typeof e,""))}return t=Na(i,n,t,a),t.elementType=e,t.type=r,t.lanes=s,t}function Cl(e,t,n,r){return e=Na(7,e,r,t),e.lanes=n,e}function Ux(e,t,n,r){return e=Na(22,e,r,t),e.elementType=FM,e.lanes=n,e.stateNode={isHidden:!1},e}function aw(e,t,n){return e=Na(6,e,null,t),e.lanes=n,e}function sw(e,t,n){return t=Na(4,e.children!==null?e.children:[],e.key,t),t.lanes=n,t.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},t}function v6(e,t,n,r,a){this.tag=t,this.containerInfo=e,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=Lv(0),this.expirationTimes=Lv(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Lv(0),this.identifierPrefix=r,this.onRecoverableError=a,this.mutableSourceEagerHydrationData=null}function cS(e,t,n,r,a,s,i,o,l){return e=new v6(e,t,n,o,l),t===1?(t=1,s===!0&&(t|=8)):t=0,s=Na(3,null,null,t),e.current=s,s.stateNode=e,s.memoizedState={element:r,isDehydrated:n,cache:null,transitions:null,pendingSuspenseBoundaries:null},q2(s),e}function w6(e,t,n){var r=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:ch,key:r==null?null:""+r,children:e,containerInfo:t,implementation:n}}function IR(e){if(!e)return ho;e=e._reactInternals;e:{if(au(e)!==e||e.tag!==1)throw Error(ce(170));var t=e;do{switch(t.tag){case 3:t=t.stateNode.context;break e;case 1:if(Pr(t.type)){t=t.stateNode.__reactInternalMemoizedMergedChildContext;break e}}t=t.return}while(t!==null);throw Error(ce(171))}if(e.tag===1){var n=e.type;if(Pr(n))return IF(e,n,t)}return t}function NR(e,t,n,r,a,s,i,o,l){return e=cS(n,r,!0,e,a,s,i,o,l),e.context=IR(null),n=e.current,r=yr(),a=ao(n),s=Qs(r,a),s.callback=t??null,no(n,s,a),e.current.lanes=a,_m(e,a,r),Lr(e,r),e}function Vx(e,t,n,r){var a=t.current,s=yr(),i=ao(a);return n=IR(n),t.context===null?t.context=n:t.pendingContext=n,t=Qs(s,i),t.payload={element:e},r=r===void 0?null:r,r!==null&&(t.callback=r),e=no(a,t,i),e!==null&&(Xa(e,a,i,s),s0(e,a,i)),i}function q0(e){if(e=e.current,!e.child)return null;switch(e.child.tag){case 5:return e.child.stateNode;default:return e.child.stateNode}}function vE(e,t){if(e=e.memoizedState,e!==null&&e.dehydrated!==null){var n=e.retryLane;e.retryLane=n!==0&&n<t?n:t}}function hS(e,t){vE(e,t),(e=e.alternate)&&vE(e,t)}function k6(){return null}var _R=typeof reportError=="function"?reportError:function(e){console.error(e)};function dS(e){this._internalRoot=e}jx.prototype.render=dS.prototype.render=function(e){var t=this._internalRoot;if(t===null)throw Error(ce(409));Vx(e,t,null,null)};jx.prototype.unmount=dS.prototype.unmount=function(){var e=this._internalRoot;if(e!==null){this._internalRoot=null;var t=e.containerInfo;Ol(function(){Vx(null,e,null,null)}),t[ii]=null}};function jx(e){this._internalRoot=e}jx.prototype.unstable_scheduleHydration=function(e){if(e){var t=rF();e={blockedOn:null,target:e,priority:t};for(var n=0;n<Ui.length&&t!==0&&t<Ui[n].priority;n++);Ui.splice(n,0,e),n===0&&sF(e)}};function pS(e){return!(!e||e.nodeType!==1&&e.nodeType!==9&&e.nodeType!==11)}function Gx(e){return!(!e||e.nodeType!==1&&e.nodeType!==9&&e.nodeType!==11&&(e.nodeType!==8||e.nodeValue!==" react-mount-point-unstable "))}function wE(){}function S6(e,t,n,r,a){if(a){if(typeof r=="function"){var s=r;r=function(){var c=q0(i);s.call(c)}}var i=NR(t,r,e,0,null,!1,!1,"",wE);return e._reactRootContainer=i,e[ii]=i.current,Kf(e.nodeType===8?e.parentNode:e),Ol(),i}for(;a=e.lastChild;)e.removeChild(a);if(typeof r=="function"){var o=r;r=function(){var c=q0(l);o.call(c)}}var l=cS(e,0,!1,null,null,!1,!1,"",wE);return e._reactRootContainer=l,e[ii]=l.current,Kf(e.nodeType===8?e.parentNode:e),Ol(function(){Vx(t,l,n,r)}),l}function Hx(e,t,n,r,a){var s=n._reactRootContainer;if(s){var i=s;if(typeof a=="function"){var o=a;a=function(){var l=q0(i);o.call(l)}}Vx(t,i,e,a)}else i=S6(n,t,e,a,r);return q0(i)}tF=function(e){switch(e.tag){case 3:var t=e.stateNode;if(t.current.memoizedState.isDehydrated){var n=cf(t.pendingLanes);n!==0&&(M2(t,n|1),Lr(t,Xt()),!(it&6)&&(Uh=Xt()+500,Mo()))}break;case 13:Ol(function(){var r=oi(e,1);if(r!==null){var a=yr();Xa(r,e,1,a)}}),hS(e,1)}};F2=function(e){if(e.tag===13){var t=oi(e,134217728);if(t!==null){var n=yr();Xa(t,e,134217728,n)}hS(e,134217728)}};nF=function(e){if(e.tag===13){var t=ao(e),n=oi(e,t);if(n!==null){var r=yr();Xa(n,e,t,r)}hS(e,t)}};rF=function(){return yt};aF=function(e,t){var n=yt;try{return yt=e,t()}finally{yt=n}};v1=function(e,t,n){switch(t){case"input":if(p1(e,n),t=n.name,n.type==="radio"&&t!=null){for(n=e;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll("input[name="+JSON.stringify(""+t)+'][type="radio"]'),t=0;t<n.length;t++){var r=n[t];if(r!==e&&r.form===e.form){var a=Ox(r);if(!a)throw Error(ce(90));DM(r),p1(r,a)}}}break;case"textarea":zM(e,n);break;case"select":t=n.value,t!=null&&Sh(e,!!n.multiple,t,!1)}};jM=iS;GM=Ol;var I6={usingClientEntryPoint:!1,Events:[Tm,mh,Ox,UM,VM,iS]},Zp={findFiberByHostInstance:xl,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},N6={bundleType:Zp.bundleType,version:Zp.version,rendererPackageName:Zp.rendererPackageName,rendererConfig:Zp.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:hi.ReactCurrentDispatcher,findHostInstanceByFiber:function(e){return e=KM(e),e===null?null:e.stateNode},findFiberByHostInstance:Zp.findFiberByHostInstance||k6,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var yy=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!yy.isDisabled&&yy.supportsFiber)try{Mx=yy.inject(N6),ks=yy}catch{}}pa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=I6;pa.createPortal=function(e,t){var n=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!pS(t))throw Error(ce(200));return w6(e,t,null,n)};pa.createRoot=function(e,t){if(!pS(e))throw Error(ce(299));var n=!1,r="",a=_R;return t!=null&&(t.unstable_strictMode===!0&&(n=!0),t.identifierPrefix!==void 0&&(r=t.identifierPrefix),t.onRecoverableError!==void 0&&(a=t.onRecoverableError)),t=cS(e,1,!1,null,null,n,!1,r,a),e[ii]=t.current,Kf(e.nodeType===8?e.parentNode:e),new dS(t)};pa.findDOMNode=function(e){if(e==null)return null;if(e.nodeType===1)return e;var t=e._reactInternals;if(t===void 0)throw typeof e.render=="function"?Error(ce(188)):(e=Object.keys(e).join(","),Error(ce(268,e)));return e=KM(t),e=e===null?null:e.stateNode,e};pa.flushSync=function(e){return Ol(e)};pa.hydrate=function(e,t,n){if(!Gx(t))throw Error(ce(200));return Hx(null,e,t,!0,n)};pa.hydrateRoot=function(e,t,n){if(!pS(e))throw Error(ce(405));var r=n!=null&&n.hydratedSources||null,a=!1,s="",i=_R;if(n!=null&&(n.unstable_strictMode===!0&&(a=!0),n.identifierPrefix!==void 0&&(s=n.identifierPrefix),n.onRecoverableError!==void 0&&(i=n.onRecoverableError)),t=NR(t,null,e,1,n??null,a,!1,s,i),e[ii]=t.current,Kf(e),r)for(e=0;e<r.length;e++)n=r[e],a=n._getVersion,a=a(n._source),t.mutableSourceEagerHydrationData==null?t.mutableSourceEagerHydrationData=[n,a]:t.mutableSourceEagerHydrationData.push(n,a);return new jx(t)};pa.render=function(e,t,n){if(!Gx(t))throw Error(ce(200));return Hx(null,e,t,!1,n)};pa.unmountComponentAtNode=function(e){if(!Gx(e))throw Error(ce(40));return e._reactRootContainer?(Ol(function(){Hx(null,null,e,!1,function(){e._reactRootContainer=null,e[ii]=null})}),!0):!1};pa.unstable_batchedUpdates=iS;pa.unstable_renderSubtreeIntoContainer=function(e,t,n,r){if(!Gx(n))throw Error(ce(200));if(e==null||e._reactInternals===void 0)throw Error(ce(38));return Hx(e,t,n,!1,r)};pa.version="18.3.1-next-f1338f8080-20240426";function CR(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(CR)}catch(e){console.error(e)}}CR(),CM.exports=pa;var _6=CM.exports,TR,kE=_6;TR=kE.createRoot,kE.hydrateRoot;/**
 * @remix-run/router v1.21.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function rm(){return rm=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},rm.apply(this,arguments)}var qi;(function(e){e.Pop="POP",e.Push="PUSH",e.Replace="REPLACE"})(qi||(qi={}));const SE="popstate";function C6(e){e===void 0&&(e={});function t(a,s){let{pathname:i="/",search:o="",hash:l=""}=su(a.location.hash.substr(1));return!i.startsWith("/")&&!i.startsWith(".")&&(i="/"+i),Q1("",{pathname:i,search:o,hash:l},s.state&&s.state.usr||null,s.state&&s.state.key||"default")}function n(a,s){let i=a.document.querySelector("base"),o="";if(i&&i.getAttribute("href")){let l=a.location.href,c=l.indexOf("#");o=c===-1?l:l.slice(0,c)}return o+"#"+(typeof s=="string"?s:K0(s))}function r(a,s){fS(a.pathname.charAt(0)==="/","relative pathnames are not supported in hash history.push("+JSON.stringify(s)+")")}return E6(t,n,r,e)}function on(e,t){if(e===!1||e===null||typeof e>"u")throw new Error(t)}function fS(e,t){if(!e){typeof console<"u"&&console.warn(t);try{throw new Error(t)}catch{}}}function T6(){return Math.random().toString(36).substr(2,8)}function IE(e,t){return{usr:e.state,key:e.key,idx:t}}function Q1(e,t,n,r){return n===void 0&&(n=null),rm({pathname:typeof e=="string"?e:e.pathname,search:"",hash:""},typeof t=="string"?su(t):t,{state:n,key:t&&t.key||r||T6()})}function K0(e){let{pathname:t="/",search:n="",hash:r=""}=e;return n&&n!=="?"&&(t+=n.charAt(0)==="?"?n:"?"+n),r&&r!=="#"&&(t+=r.charAt(0)==="#"?r:"#"+r),t}function su(e){let t={};if(e){let n=e.indexOf("#");n>=0&&(t.hash=e.substr(n),e=e.substr(0,n));let r=e.indexOf("?");r>=0&&(t.search=e.substr(r),e=e.substr(0,r)),e&&(t.pathname=e)}return t}function E6(e,t,n,r){r===void 0&&(r={});let{window:a=document.defaultView,v5Compat:s=!1}=r,i=a.history,o=qi.Pop,l=null,c=u();c==null&&(c=0,i.replaceState(rm({},i.state,{idx:c}),""));function u(){return(i.state||{idx:null}).idx}function h(){o=qi.Pop;let y=u(),g=y==null?null:y-c;c=y,l&&l({action:o,location:m.location,delta:g})}function d(y,g){o=qi.Push;let x=Q1(m.location,y,g);n&&n(x,y),c=u()+1;let b=IE(x,c),v=m.createHref(x);try{i.pushState(b,"",v)}catch(w){if(w instanceof DOMException&&w.name==="DataCloneError")throw w;a.location.assign(v)}s&&l&&l({action:o,location:m.location,delta:1})}function p(y,g){o=qi.Replace;let x=Q1(m.location,y,g);n&&n(x,y),c=u();let b=IE(x,c),v=m.createHref(x);i.replaceState(b,"",v),s&&l&&l({action:o,location:m.location,delta:0})}function f(y){let g=a.location.origin!=="null"?a.location.origin:a.location.href,x=typeof y=="string"?y:K0(y);return x=x.replace(/ $/,"%20"),on(g,"No window.location.(origin|href) available to create URL for href: "+x),new URL(x,g)}let m={get action(){return o},get location(){return e(a,i)},listen(y){if(l)throw new Error("A history only accepts one active listener");return a.addEventListener(SE,h),l=y,()=>{a.removeEventListener(SE,h),l=null}},createHref(y){return t(a,y)},createURL:f,encodeLocation(y){let g=f(y);return{pathname:g.pathname,search:g.search,hash:g.hash}},push:d,replace:p,go(y){return i.go(y)}};return m}var NE;(function(e){e.data="data",e.deferred="deferred",e.redirect="redirect",e.error="error"})(NE||(NE={}));function A6(e,t,n){return n===void 0&&(n="/"),$6(e,t,n,!1)}function $6(e,t,n,r){let a=typeof t=="string"?su(t):t,s=mS(a.pathname||"/",n);if(s==null)return null;let i=ER(e);M6(i);let o=null;for(let l=0;o==null&&l<i.length;++l){let c=V6(s);o=W6(i[l],c,r)}return o}function ER(e,t,n,r){t===void 0&&(t=[]),n===void 0&&(n=[]),r===void 0&&(r="");let a=(s,i,o)=>{let l={relativePath:o===void 0?s.path||"":o,caseSensitive:s.caseSensitive===!0,childrenIndex:i,route:s};l.relativePath.startsWith("/")&&(on(l.relativePath.startsWith(r),'Absolute route path "'+l.relativePath+'" nested under path '+('"'+r+'" is not valid. An absolute child route path ')+"must start with the combined path of all its parent routes."),l.relativePath=l.relativePath.slice(r.length));let c=io([r,l.relativePath]),u=n.concat(l);s.children&&s.children.length>0&&(on(s.index!==!0,"Index routes must not have child routes. Please remove "+('all child routes from route path "'+c+'".')),ER(s.children,t,u,c)),!(s.path==null&&!s.index)&&t.push({path:c,score:L6(c,s.index),routesMeta:u})};return e.forEach((s,i)=>{var o;if(s.path===""||!((o=s.path)!=null&&o.includes("?")))a(s,i);else for(let l of AR(s.path))a(s,i,l)}),t}function AR(e){let t=e.split("/");if(t.length===0)return[];let[n,...r]=t,a=n.endsWith("?"),s=n.replace(/\?$/,"");if(r.length===0)return a?[s,""]:[s];let i=AR(r.join("/")),o=[];return o.push(...i.map(l=>l===""?s:[s,l].join("/"))),a&&o.push(...i),o.map(l=>e.startsWith("/")&&l===""?"/":l)}function M6(e){e.sort((t,n)=>t.score!==n.score?n.score-t.score:B6(t.routesMeta.map(r=>r.childrenIndex),n.routesMeta.map(r=>r.childrenIndex)))}const F6=/^:[\w-]+$/,R6=3,D6=2,O6=1,z6=10,P6=-2,_E=e=>e==="*";function L6(e,t){let n=e.split("/"),r=n.length;return n.some(_E)&&(r+=P6),t&&(r+=D6),n.filter(a=>!_E(a)).reduce((a,s)=>a+(F6.test(s)?R6:s===""?O6:z6),r)}function B6(e,t){return e.length===t.length&&e.slice(0,-1).every((r,a)=>r===t[a])?e[e.length-1]-t[t.length-1]:0}function W6(e,t,n){let{routesMeta:r}=e,a={},s="/",i=[];for(let o=0;o<r.length;++o){let l=r[o],c=o===r.length-1,u=s==="/"?t:t.slice(s.length)||"/",h=CE({path:l.relativePath,caseSensitive:l.caseSensitive,end:c},u),d=l.route;if(!h&&c&&n&&!r[r.length-1].route.index&&(h=CE({path:l.relativePath,caseSensitive:l.caseSensitive,end:!1},u)),!h)return null;Object.assign(a,h.params),i.push({params:a,pathname:io([s,h.pathname]),pathnameBase:q6(io([s,h.pathnameBase])),route:d}),h.pathnameBase!=="/"&&(s=io([s,h.pathnameBase]))}return i}function CE(e,t){typeof e=="string"&&(e={path:e,caseSensitive:!1,end:!0});let[n,r]=U6(e.path,e.caseSensitive,e.end),a=t.match(n);if(!a)return null;let s=a[0],i=s.replace(/(.)\/+$/,"$1"),o=a.slice(1);return{params:r.reduce((c,u,h)=>{let{paramName:d,isOptional:p}=u;if(d==="*"){let m=o[h]||"";i=s.slice(0,s.length-m.length).replace(/(.)\/+$/,"$1")}const f=o[h];return p&&!f?c[d]=void 0:c[d]=(f||"").replace(/%2F/g,"/"),c},{}),pathname:s,pathnameBase:i,pattern:e}}function U6(e,t,n){t===void 0&&(t=!1),n===void 0&&(n=!0),fS(e==="*"||!e.endsWith("*")||e.endsWith("/*"),'Route path "'+e+'" will be treated as if it were '+('"'+e.replace(/\*$/,"/*")+'" because the `*` character must ')+"always follow a `/` in the pattern. To get rid of this warning, "+('please change the route path to "'+e.replace(/\*$/,"/*")+'".'));let r=[],a="^"+e.replace(/\/*\*?$/,"").replace(/^\/*/,"/").replace(/[\\.*+^${}|()[\]]/g,"\\$&").replace(/\/:([\w-]+)(\?)?/g,(i,o,l)=>(r.push({paramName:o,isOptional:l!=null}),l?"/?([^\\/]+)?":"/([^\\/]+)"));return e.endsWith("*")?(r.push({paramName:"*"}),a+=e==="*"||e==="/*"?"(.*)$":"(?:\\/(.+)|\\/*)$"):n?a+="\\/*$":e!==""&&e!=="/"&&(a+="(?:(?=\\/|$))"),[new RegExp(a,t?void 0:"i"),r]}function V6(e){try{return e.split("/").map(t=>decodeURIComponent(t).replace(/\//g,"%2F")).join("/")}catch(t){return fS(!1,'The URL path "'+e+'" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent '+("encoding ("+t+").")),e}}function mS(e,t){if(t==="/")return e;if(!e.toLowerCase().startsWith(t.toLowerCase()))return null;let n=t.endsWith("/")?t.length-1:t.length,r=e.charAt(n);return r&&r!=="/"?null:e.slice(n)||"/"}function j6(e,t){t===void 0&&(t="/");let{pathname:n,search:r="",hash:a=""}=typeof e=="string"?su(e):e;return{pathname:n?n.startsWith("/")?n:G6(n,t):t,search:K6(r),hash:X6(a)}}function G6(e,t){let n=t.replace(/\/+$/,"").split("/");return e.split("/").forEach(a=>{a===".."?n.length>1&&n.pop():a!=="."&&n.push(a)}),n.length>1?n.join("/"):"/"}function iw(e,t,n,r){return"Cannot include a '"+e+"' character in a manually specified "+("`to."+t+"` field ["+JSON.stringify(r)+"].  Please separate it out to the ")+("`to."+n+"` field. Alternatively you may provide the full path as ")+'a string in <Link to="..."> and the router will parse it for you.'}function H6(e){return e.filter((t,n)=>n===0||t.route.path&&t.route.path.length>0)}function $R(e,t){let n=H6(e);return t?n.map((r,a)=>a===n.length-1?r.pathname:r.pathnameBase):n.map(r=>r.pathnameBase)}function MR(e,t,n,r){r===void 0&&(r=!1);let a;typeof e=="string"?a=su(e):(a=rm({},e),on(!a.pathname||!a.pathname.includes("?"),iw("?","pathname","search",a)),on(!a.pathname||!a.pathname.includes("#"),iw("#","pathname","hash",a)),on(!a.search||!a.search.includes("#"),iw("#","search","hash",a)));let s=e===""||a.pathname==="",i=s?"/":a.pathname,o;if(i==null)o=n;else{let h=t.length-1;if(!r&&i.startsWith("..")){let d=i.split("/");for(;d[0]==="..";)d.shift(),h-=1;a.pathname=d.join("/")}o=h>=0?t[h]:"/"}let l=j6(a,o),c=i&&i!=="/"&&i.endsWith("/"),u=(s||i===".")&&n.endsWith("/");return!l.pathname.endsWith("/")&&(c||u)&&(l.pathname+="/"),l}const io=e=>e.join("/").replace(/\/\/+/g,"/"),q6=e=>e.replace(/\/+$/,"").replace(/^\/*/,"/"),K6=e=>!e||e==="?"?"":e.startsWith("?")?e:"?"+e,X6=e=>!e||e==="#"?"":e.startsWith("#")?e:"#"+e;function Z6(e){return e!=null&&typeof e.status=="number"&&typeof e.statusText=="string"&&typeof e.internal=="boolean"&&"data"in e}const FR=["post","put","patch","delete"];new Set(FR);const Y6=["get",...FR];new Set(Y6);/**
 * React Router v6.28.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function am(){return am=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},am.apply(this,arguments)}const gS=ee.createContext(null),J6=ee.createContext(null),iu=ee.createContext(null),qx=ee.createContext(null),Fo=ee.createContext({outlet:null,matches:[],isDataRoute:!1}),RR=ee.createContext(null);function Q6(e,t){let{relative:n}=t===void 0?{}:t;Am()||on(!1);let{basename:r,navigator:a}=ee.useContext(iu),{hash:s,pathname:i,search:o}=OR(e,{relative:n}),l=i;return r!=="/"&&(l=i==="/"?r:io([r,i])),a.createHref({pathname:l,search:o,hash:s})}function Am(){return ee.useContext(qx)!=null}function $m(){return Am()||on(!1),ee.useContext(qx).location}function DR(e){ee.useContext(iu).static||ee.useLayoutEffect(e)}function hd(){let{isDataRoute:e}=ee.useContext(Fo);return e?fG():eG()}function eG(){Am()||on(!1);let e=ee.useContext(gS),{basename:t,future:n,navigator:r}=ee.useContext(iu),{matches:a}=ee.useContext(Fo),{pathname:s}=$m(),i=JSON.stringify($R(a,n.v7_relativeSplatPath)),o=ee.useRef(!1);return DR(()=>{o.current=!0}),ee.useCallback(function(c,u){if(u===void 0&&(u={}),!o.current)return;if(typeof c=="number"){r.go(c);return}let h=MR(c,JSON.parse(i),s,u.relative==="path");e==null&&t!=="/"&&(h.pathname=h.pathname==="/"?t:io([t,h.pathname])),(u.replace?r.replace:r.push)(h,u.state,u)},[t,r,i,s,e])}const tG=ee.createContext(null);function nG(e){let t=ee.useContext(Fo).outlet;return t&&ee.createElement(tG.Provider,{value:e},t)}function OR(e,t){let{relative:n}=t===void 0?{}:t,{future:r}=ee.useContext(iu),{matches:a}=ee.useContext(Fo),{pathname:s}=$m(),i=JSON.stringify($R(a,r.v7_relativeSplatPath));return ee.useMemo(()=>MR(e,JSON.parse(i),s,n==="path"),[e,i,s,n])}function rG(e,t){return aG(e,t)}function aG(e,t,n,r){Am()||on(!1);let{navigator:a}=ee.useContext(iu),{matches:s}=ee.useContext(Fo),i=s[s.length-1],o=i?i.params:{};i&&i.pathname;let l=i?i.pathnameBase:"/";i&&i.route;let c=$m(),u;if(t){var h;let y=typeof t=="string"?su(t):t;l==="/"||(h=y.pathname)!=null&&h.startsWith(l)||on(!1),u=y}else u=c;let d=u.pathname||"/",p=d;if(l!=="/"){let y=l.replace(/^\//,"").split("/");p="/"+d.replace(/^\//,"").split("/").slice(y.length).join("/")}let f=A6(e,{pathname:p}),m=uG(f&&f.map(y=>Object.assign({},y,{params:Object.assign({},o,y.params),pathname:io([l,a.encodeLocation?a.encodeLocation(y.pathname).pathname:y.pathname]),pathnameBase:y.pathnameBase==="/"?l:io([l,a.encodeLocation?a.encodeLocation(y.pathnameBase).pathname:y.pathnameBase])})),s,n,r);return t&&m?ee.createElement(qx.Provider,{value:{location:am({pathname:"/",search:"",hash:"",state:null,key:"default"},u),navigationType:qi.Pop}},m):m}function sG(){let e=pG(),t=Z6(e)?e.status+" "+e.statusText:e instanceof Error?e.message:JSON.stringify(e),n=e instanceof Error?e.stack:null,a={padding:"0.5rem",backgroundColor:"rgba(200,200,200, 0.5)"};return ee.createElement(ee.Fragment,null,ee.createElement("h2",null,"Unexpected Application Error!"),ee.createElement("h3",{style:{fontStyle:"italic"}},t),n?ee.createElement("pre",{style:a},n):null,null)}const iG=ee.createElement(sG,null);class oG extends ee.Component{constructor(t){super(t),this.state={location:t.location,revalidation:t.revalidation,error:t.error}}static getDerivedStateFromError(t){return{error:t}}static getDerivedStateFromProps(t,n){return n.location!==t.location||n.revalidation!=="idle"&&t.revalidation==="idle"?{error:t.error,location:t.location,revalidation:t.revalidation}:{error:t.error!==void 0?t.error:n.error,location:n.location,revalidation:t.revalidation||n.revalidation}}componentDidCatch(t,n){console.error("React Router caught the following error during render",t,n)}render(){return this.state.error!==void 0?ee.createElement(Fo.Provider,{value:this.props.routeContext},ee.createElement(RR.Provider,{value:this.state.error,children:this.props.component})):this.props.children}}function lG(e){let{routeContext:t,match:n,children:r}=e,a=ee.useContext(gS);return a&&a.static&&a.staticContext&&(n.route.errorElement||n.route.ErrorBoundary)&&(a.staticContext._deepestRenderedBoundaryId=n.route.id),ee.createElement(Fo.Provider,{value:t},r)}function uG(e,t,n,r){var a;if(t===void 0&&(t=[]),n===void 0&&(n=null),r===void 0&&(r=null),e==null){var s;if(!n)return null;if(n.errors)e=n.matches;else if((s=r)!=null&&s.v7_partialHydration&&t.length===0&&!n.initialized&&n.matches.length>0)e=n.matches;else return null}let i=e,o=(a=n)==null?void 0:a.errors;if(o!=null){let u=i.findIndex(h=>h.route.id&&(o==null?void 0:o[h.route.id])!==void 0);u>=0||on(!1),i=i.slice(0,Math.min(i.length,u+1))}let l=!1,c=-1;if(n&&r&&r.v7_partialHydration)for(let u=0;u<i.length;u++){let h=i[u];if((h.route.HydrateFallback||h.route.hydrateFallbackElement)&&(c=u),h.route.id){let{loaderData:d,errors:p}=n,f=h.route.loader&&d[h.route.id]===void 0&&(!p||p[h.route.id]===void 0);if(h.route.lazy||f){l=!0,c>=0?i=i.slice(0,c+1):i=[i[0]];break}}}return i.reduceRight((u,h,d)=>{let p,f=!1,m=null,y=null;n&&(p=o&&h.route.id?o[h.route.id]:void 0,m=h.route.errorElement||iG,l&&(c<0&&d===0?(f=!0,y=null):c===d&&(f=!0,y=h.route.hydrateFallbackElement||null)));let g=t.concat(i.slice(0,d+1)),x=()=>{let b;return p?b=m:f?b=y:h.route.Component?b=ee.createElement(h.route.Component,null):h.route.element?b=h.route.element:b=u,ee.createElement(lG,{match:h,routeContext:{outlet:u,matches:g,isDataRoute:n!=null},children:b})};return n&&(h.route.ErrorBoundary||h.route.errorElement||d===0)?ee.createElement(oG,{location:n.location,revalidation:n.revalidation,component:m,error:p,children:x(),routeContext:{outlet:null,matches:g,isDataRoute:!0}}):x()},null)}var zR=function(e){return e.UseBlocker="useBlocker",e.UseRevalidator="useRevalidator",e.UseNavigateStable="useNavigate",e}(zR||{}),X0=function(e){return e.UseBlocker="useBlocker",e.UseLoaderData="useLoaderData",e.UseActionData="useActionData",e.UseRouteError="useRouteError",e.UseNavigation="useNavigation",e.UseRouteLoaderData="useRouteLoaderData",e.UseMatches="useMatches",e.UseRevalidator="useRevalidator",e.UseNavigateStable="useNavigate",e.UseRouteId="useRouteId",e}(X0||{});function cG(e){let t=ee.useContext(gS);return t||on(!1),t}function hG(e){let t=ee.useContext(J6);return t||on(!1),t}function dG(e){let t=ee.useContext(Fo);return t||on(!1),t}function PR(e){let t=dG(),n=t.matches[t.matches.length-1];return n.route.id||on(!1),n.route.id}function pG(){var e;let t=ee.useContext(RR),n=hG(X0.UseRouteError),r=PR(X0.UseRouteError);return t!==void 0?t:(e=n.errors)==null?void 0:e[r]}function fG(){let{router:e}=cG(zR.UseNavigateStable),t=PR(X0.UseNavigateStable),n=ee.useRef(!1);return DR(()=>{n.current=!0}),ee.useCallback(function(a,s){s===void 0&&(s={}),n.current&&(typeof a=="number"?e.navigate(a):e.navigate(a,am({fromRouteId:t},s)))},[e,t])}const TE={};function mG(e,t){TE[t]||(TE[t]=!0,console.warn(t))}const EE=(e,t,n)=>mG(e,"⚠️ React Router Future Flag Warning: "+t+". "+("You can use the `"+e+"` future flag to opt-in early. ")+("For more information, see "+n+"."));function gG(e,t){(e==null?void 0:e.v7_startTransition)===void 0&&EE("v7_startTransition","React Router will begin wrapping state updates in `React.startTransition` in v7","https://reactrouter.com/v6/upgrading/future#v7_starttransition"),(e==null?void 0:e.v7_relativeSplatPath)===void 0&&!t&&EE("v7_relativeSplatPath","Relative route resolution within Splat routes is changing in v7","https://reactrouter.com/v6/upgrading/future#v7_relativesplatpath")}function yG(e){return nG(e.context)}function va(e){on(!1)}function xG(e){let{basename:t="/",children:n=null,location:r,navigationType:a=qi.Pop,navigator:s,static:i=!1,future:o}=e;Am()&&on(!1);let l=t.replace(/^\/*/,"/"),c=ee.useMemo(()=>({basename:l,navigator:s,static:i,future:am({v7_relativeSplatPath:!1},o)}),[l,o,s,i]);typeof r=="string"&&(r=su(r));let{pathname:u="/",search:h="",hash:d="",state:p=null,key:f="default"}=r,m=ee.useMemo(()=>{let y=mS(u,l);return y==null?null:{location:{pathname:y,search:h,hash:d,state:p,key:f},navigationType:a}},[l,u,h,d,p,f,a]);return m==null?null:ee.createElement(iu.Provider,{value:c},ee.createElement(qx.Provider,{children:n,value:m}))}function bG(e){let{children:t,location:n}=e;return rG(ek(t),n)}new Promise(()=>{});function ek(e,t){t===void 0&&(t=[]);let n=[];return ee.Children.forEach(e,(r,a)=>{if(!ee.isValidElement(r))return;let s=[...t,a];if(r.type===ee.Fragment){n.push.apply(n,ek(r.props.children,s));return}r.type!==va&&on(!1),!r.props.index||!r.props.children||on(!1);let i={id:r.props.id||s.join("-"),caseSensitive:r.props.caseSensitive,element:r.props.element,Component:r.props.Component,index:r.props.index,path:r.props.path,loader:r.props.loader,action:r.props.action,errorElement:r.props.errorElement,ErrorBoundary:r.props.ErrorBoundary,hasErrorBoundary:r.props.ErrorBoundary!=null||r.props.errorElement!=null,shouldRevalidate:r.props.shouldRevalidate,handle:r.props.handle,lazy:r.props.lazy};r.props.children&&(i.children=ek(r.props.children,s)),n.push(i)}),n}/**
 * React Router DOM v6.28.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function tk(){return tk=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},tk.apply(this,arguments)}function vG(e,t){if(e==null)return{};var n={},r=Object.keys(e),a,s;for(s=0;s<r.length;s++)a=r[s],!(t.indexOf(a)>=0)&&(n[a]=e[a]);return n}function wG(e){return!!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey)}function kG(e,t){return e.button===0&&(!t||t==="_self")&&!wG(e)}const SG=["onClick","relative","reloadDocument","replace","state","target","to","preventScrollReset","viewTransition"],IG="6";try{window.__reactRouterVersion=IG}catch{}const NG="startTransition",AE=mj[NG];function _G(e){let{basename:t,children:n,future:r,window:a}=e,s=ee.useRef();s.current==null&&(s.current=C6({window:a,v5Compat:!0}));let i=s.current,[o,l]=ee.useState({action:i.action,location:i.location}),{v7_startTransition:c}=r||{},u=ee.useCallback(h=>{c&&AE?AE(()=>l(h)):l(h)},[l,c]);return ee.useLayoutEffect(()=>i.listen(u),[i,u]),ee.useEffect(()=>gG(r),[r]),ee.createElement(xG,{basename:t,children:n,location:o.location,navigationType:o.action,navigator:i,future:r})}const CG=typeof window<"u"&&typeof window.document<"u"&&typeof window.document.createElement<"u",TG=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,df=ee.forwardRef(function(t,n){let{onClick:r,relative:a,reloadDocument:s,replace:i,state:o,target:l,to:c,preventScrollReset:u,viewTransition:h}=t,d=vG(t,SG),{basename:p}=ee.useContext(iu),f,m=!1;if(typeof c=="string"&&TG.test(c)&&(f=c,CG))try{let b=new URL(window.location.href),v=c.startsWith("//")?new URL(b.protocol+c):new URL(c),w=mS(v.pathname,p);v.origin===b.origin&&w!=null?c=w+v.search+v.hash:m=!0}catch{}let y=Q6(c,{relative:a}),g=EG(c,{replace:i,state:o,target:l,preventScrollReset:u,relative:a,viewTransition:h});function x(b){r&&r(b),b.defaultPrevented||g(b)}return ee.createElement("a",tk({},d,{href:f||y,onClick:m||s?r:x,ref:n,target:l}))});var $E;(function(e){e.UseScrollRestoration="useScrollRestoration",e.UseSubmit="useSubmit",e.UseSubmitFetcher="useSubmitFetcher",e.UseFetcher="useFetcher",e.useViewTransitionState="useViewTransitionState"})($E||($E={}));var ME;(function(e){e.UseFetcher="useFetcher",e.UseFetchers="useFetchers",e.UseScrollRestoration="useScrollRestoration"})(ME||(ME={}));function EG(e,t){let{target:n,replace:r,state:a,preventScrollReset:s,relative:i,viewTransition:o}=t===void 0?{}:t,l=hd(),c=$m(),u=OR(e,{relative:i});return ee.useCallback(h=>{if(kG(h,n)){h.preventDefault();let d=r!==void 0?r:K0(c)===K0(u);l(e,{replace:d,state:a,preventScrollReset:s,relative:i,viewTransition:o})}},[c,l,u,r,a,n,e,s,i,o])}var nk=function(e,t){return nk=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,r){n.__proto__=r}||function(n,r){for(var a in r)Object.prototype.hasOwnProperty.call(r,a)&&(n[a]=r[a])},nk(e,t)};function AG(e,t){if(typeof t!="function"&&t!==null)throw new TypeError("Class extends value "+String(t)+" is not a constructor or null");nk(e,t);function n(){this.constructor=e}e.prototype=t===null?Object.create(t):(n.prototype=t.prototype,new n)}var Tn=function(){return Tn=Object.assign||function(t){for(var n,r=1,a=arguments.length;r<a;r++){n=arguments[r];for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&(t[s]=n[s])}return t},Tn.apply(this,arguments)};function $G(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(e!=null&&typeof Object.getOwnPropertySymbols=="function")for(var a=0,r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]]);return n}function Uc(e,t,n,r){function a(s){return s instanceof n?s:new n(function(i){i(s)})}return new(n||(n=Promise))(function(s,i){function o(u){try{c(r.next(u))}catch(h){i(h)}}function l(u){try{c(r.throw(u))}catch(h){i(h)}}function c(u){u.done?s(u.value):a(u.value).then(o,l)}c((r=r.apply(e,[])).next())})}function Vc(e,t){var n={label:0,sent:function(){if(s[0]&1)throw s[1];return s[1]},trys:[],ops:[]},r,a,s,i=Object.create((typeof Iterator=="function"?Iterator:Object).prototype);return i.next=o(0),i.throw=o(1),i.return=o(2),typeof Symbol=="function"&&(i[Symbol.iterator]=function(){return this}),i;function o(c){return function(u){return l([c,u])}}function l(c){if(r)throw new TypeError("Generator is already executing.");for(;i&&(i=0,c[0]&&(n=0)),n;)try{if(r=1,a&&(s=c[0]&2?a.return:c[0]?a.throw||((s=a.return)&&s.call(a),0):a.next)&&!(s=s.call(a,c[1])).done)return s;switch(a=0,s&&(c=[c[0]&2,s.value]),c[0]){case 0:case 1:s=c;break;case 4:return n.label++,{value:c[1],done:!1};case 5:n.label++,a=c[1],c=[0];continue;case 7:c=n.ops.pop(),n.trys.pop();continue;default:if(s=n.trys,!(s=s.length>0&&s[s.length-1])&&(c[0]===6||c[0]===2)){n=0;continue}if(c[0]===3&&(!s||c[1]>s[0]&&c[1]<s[3])){n.label=c[1];break}if(c[0]===6&&n.label<s[1]){n.label=s[1],s=c;break}if(s&&n.label<s[2]){n.label=s[2],n.ops.push(c);break}s[2]&&n.ops.pop(),n.trys.pop();continue}c=t.call(e,n)}catch(u){c=[6,u],a=0}finally{r=s=0}if(c[0]&5)throw c[1];return{value:c[0]?c[1]:void 0,done:!0}}}function fs(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(e!=null&&typeof Object.getOwnPropertySymbols=="function"){var a=0;for(r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]])}return n}var hl=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function yS(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}function xS(e,t){return e(t={exports:{}},t.exports),t.exports}var ol=xS(function(e,t){Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function r(){var a=this;this.locked=new Map,this.addToLocked=function(s,i){var o=a.locked.get(s);o===void 0?i===void 0?a.locked.set(s,[]):a.locked.set(s,[i]):i!==void 0&&(o.unshift(i),a.locked.set(s,o))},this.isLocked=function(s){return a.locked.has(s)},this.lock=function(s){return new Promise(function(i,o){a.isLocked(s)?a.addToLocked(s,i):(a.addToLocked(s),i())})},this.unlock=function(s){var i=a.locked.get(s);if(i!==void 0&&i.length!==0){var o=i.pop();a.locked.set(s,i),o!==void 0&&setTimeout(o,0)}else a.locked.delete(s)}}return r.getInstance=function(){return r.instance===void 0&&(r.instance=new r),r.instance},r}();t.default=function(){return n.getInstance()}});yS(ol);var MG=yS(xS(function(e,t){var n=hl&&hl.__awaiter||function(u,h,d,p){return new(d||(d=Promise))(function(f,m){function y(b){try{x(p.next(b))}catch(v){m(v)}}function g(b){try{x(p.throw(b))}catch(v){m(v)}}function x(b){b.done?f(b.value):new d(function(v){v(b.value)}).then(y,g)}x((p=p.apply(u,h||[])).next())})},r=hl&&hl.__generator||function(u,h){var d,p,f,m,y={label:0,sent:function(){if(1&f[0])throw f[1];return f[1]},trys:[],ops:[]};return m={next:g(0),throw:g(1),return:g(2)},typeof Symbol=="function"&&(m[Symbol.iterator]=function(){return this}),m;function g(x){return function(b){return function(v){if(d)throw new TypeError("Generator is already executing.");for(;y;)try{if(d=1,p&&(f=2&v[0]?p.return:v[0]?p.throw||((f=p.return)&&f.call(p),0):p.next)&&!(f=f.call(p,v[1])).done)return f;switch(p=0,f&&(v=[2&v[0],f.value]),v[0]){case 0:case 1:f=v;break;case 4:return y.label++,{value:v[1],done:!1};case 5:y.label++,p=v[1],v=[0];continue;case 7:v=y.ops.pop(),y.trys.pop();continue;default:if(f=y.trys,!((f=f.length>0&&f[f.length-1])||v[0]!==6&&v[0]!==2)){y=0;continue}if(v[0]===3&&(!f||v[1]>f[0]&&v[1]<f[3])){y.label=v[1];break}if(v[0]===6&&y.label<f[1]){y.label=f[1],f=v;break}if(f&&y.label<f[2]){y.label=f[2],y.ops.push(v);break}f[2]&&y.ops.pop(),y.trys.pop();continue}v=h.call(u,y)}catch(w){v=[6,w],p=0}finally{d=f=0}if(5&v[0])throw v[1];return{value:v[0]?v[1]:void 0,done:!0}}([x,b])}}},a=hl;Object.defineProperty(t,"__esModule",{value:!0});var s="browser-tabs-lock-key",i={key:function(u){return n(a,void 0,void 0,function(){return r(this,function(h){throw new Error("Unsupported")})})},getItem:function(u){return n(a,void 0,void 0,function(){return r(this,function(h){throw new Error("Unsupported")})})},clear:function(){return n(a,void 0,void 0,function(){return r(this,function(u){return[2,window.localStorage.clear()]})})},removeItem:function(u){return n(a,void 0,void 0,function(){return r(this,function(h){throw new Error("Unsupported")})})},setItem:function(u,h){return n(a,void 0,void 0,function(){return r(this,function(d){throw new Error("Unsupported")})})},keySync:function(u){return window.localStorage.key(u)},getItemSync:function(u){return window.localStorage.getItem(u)},clearSync:function(){return window.localStorage.clear()},removeItemSync:function(u){return window.localStorage.removeItem(u)},setItemSync:function(u,h){return window.localStorage.setItem(u,h)}};function o(u){return new Promise(function(h){return setTimeout(h,u)})}function l(u){for(var h="0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz",d="",p=0;p<u;p++)d+=h[Math.floor(Math.random()*h.length)];return d}var c=function(){function u(h){this.acquiredIatSet=new Set,this.storageHandler=void 0,this.id=Date.now().toString()+l(15),this.acquireLock=this.acquireLock.bind(this),this.releaseLock=this.releaseLock.bind(this),this.releaseLock__private__=this.releaseLock__private__.bind(this),this.waitForSomethingToChange=this.waitForSomethingToChange.bind(this),this.refreshLockWhileAcquired=this.refreshLockWhileAcquired.bind(this),this.storageHandler=h,u.waiters===void 0&&(u.waiters=[])}return u.prototype.acquireLock=function(h,d){return d===void 0&&(d=5e3),n(this,void 0,void 0,function(){var p,f,m,y,g,x,b;return r(this,function(v){switch(v.label){case 0:p=Date.now()+l(4),f=Date.now()+d,m=s+"-"+h,y=this.storageHandler===void 0?i:this.storageHandler,v.label=1;case 1:return Date.now()<f?[4,o(30)]:[3,8];case 2:return v.sent(),y.getItemSync(m)!==null?[3,5]:(g=this.id+"-"+h+"-"+p,[4,o(Math.floor(25*Math.random()))]);case 3:return v.sent(),y.setItemSync(m,JSON.stringify({id:this.id,iat:p,timeoutKey:g,timeAcquired:Date.now(),timeRefreshed:Date.now()})),[4,o(30)];case 4:return v.sent(),(x=y.getItemSync(m))!==null&&(b=JSON.parse(x)).id===this.id&&b.iat===p?(this.acquiredIatSet.add(p),this.refreshLockWhileAcquired(m,p),[2,!0]):[3,7];case 5:return u.lockCorrector(this.storageHandler===void 0?i:this.storageHandler),[4,this.waitForSomethingToChange(f)];case 6:v.sent(),v.label=7;case 7:return p=Date.now()+l(4),[3,1];case 8:return[2,!1]}})})},u.prototype.refreshLockWhileAcquired=function(h,d){return n(this,void 0,void 0,function(){var p=this;return r(this,function(f){return setTimeout(function(){return n(p,void 0,void 0,function(){var m,y,g;return r(this,function(x){switch(x.label){case 0:return[4,ol.default().lock(d)];case 1:return x.sent(),this.acquiredIatSet.has(d)?(m=this.storageHandler===void 0?i:this.storageHandler,(y=m.getItemSync(h))===null?(ol.default().unlock(d),[2]):((g=JSON.parse(y)).timeRefreshed=Date.now(),m.setItemSync(h,JSON.stringify(g)),ol.default().unlock(d),this.refreshLockWhileAcquired(h,d),[2])):(ol.default().unlock(d),[2])}})})},1e3),[2]})})},u.prototype.waitForSomethingToChange=function(h){return n(this,void 0,void 0,function(){return r(this,function(d){switch(d.label){case 0:return[4,new Promise(function(p){var f=!1,m=Date.now(),y=!1;function g(){if(y||(window.removeEventListener("storage",g),u.removeFromWaiting(g),clearTimeout(x),y=!0),!f){f=!0;var b=50-(Date.now()-m);b>0?setTimeout(p,b):p(null)}}window.addEventListener("storage",g),u.addToWaiting(g);var x=setTimeout(g,Math.max(0,h-Date.now()))})];case 1:return d.sent(),[2]}})})},u.addToWaiting=function(h){this.removeFromWaiting(h),u.waiters!==void 0&&u.waiters.push(h)},u.removeFromWaiting=function(h){u.waiters!==void 0&&(u.waiters=u.waiters.filter(function(d){return d!==h}))},u.notifyWaiters=function(){u.waiters!==void 0&&u.waiters.slice().forEach(function(h){return h()})},u.prototype.releaseLock=function(h){return n(this,void 0,void 0,function(){return r(this,function(d){switch(d.label){case 0:return[4,this.releaseLock__private__(h)];case 1:return[2,d.sent()]}})})},u.prototype.releaseLock__private__=function(h){return n(this,void 0,void 0,function(){var d,p,f,m;return r(this,function(y){switch(y.label){case 0:return d=this.storageHandler===void 0?i:this.storageHandler,p=s+"-"+h,(f=d.getItemSync(p))===null?[2]:(m=JSON.parse(f)).id!==this.id?[3,2]:[4,ol.default().lock(m.iat)];case 1:y.sent(),this.acquiredIatSet.delete(m.iat),d.removeItemSync(p),ol.default().unlock(m.iat),u.notifyWaiters(),y.label=2;case 2:return[2]}})})},u.lockCorrector=function(h){for(var d=Date.now()-5e3,p=h,f=[],m=0;;){var y=p.keySync(m);if(y===null)break;f.push(y),m++}for(var g=!1,x=0;x<f.length;x++){var b=f[x];if(b.includes(s)){var v=p.getItemSync(b);if(v!==null){var w=JSON.parse(v);(w.timeRefreshed===void 0&&w.timeAcquired<d||w.timeRefreshed!==void 0&&w.timeRefreshed<d)&&(p.removeItemSync(b),g=!0)}}}g&&u.notifyWaiters()},u.waiters=void 0,u}();t.default=c}));const FG={timeoutInSeconds:60},LR={name:"auth0-spa-js",version:"2.1.3"},BR=()=>Date.now();class Kn extends Error{constructor(t,n){super(n),this.error=t,this.error_description=n,Object.setPrototypeOf(this,Kn.prototype)}static fromPayload({error:t,error_description:n}){return new Kn(t,n)}}class bS extends Kn{constructor(t,n,r,a=null){super(t,n),this.state=r,this.appState=a,Object.setPrototypeOf(this,bS.prototype)}}class sm extends Kn{constructor(){super("timeout","Timeout"),Object.setPrototypeOf(this,sm.prototype)}}class vS extends sm{constructor(t){super(),this.popup=t,Object.setPrototypeOf(this,vS.prototype)}}class wS extends Kn{constructor(t){super("cancelled","Popup closed"),this.popup=t,Object.setPrototypeOf(this,wS.prototype)}}class kS extends Kn{constructor(t,n,r){super(t,n),this.mfa_token=r,Object.setPrototypeOf(this,kS.prototype)}}class Kx extends Kn{constructor(t,n){super("missing_refresh_token",`Missing Refresh Token (audience: '${FE(t,["default"])}', scope: '${FE(n)}')`),this.audience=t,this.scope=n,Object.setPrototypeOf(this,Kx.prototype)}}function FE(e,t=[]){return e&&!t.includes(e)?e:""}const d0=()=>window.crypto,ow=()=>{const e="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_~.";let t="";return Array.from(d0().getRandomValues(new Uint8Array(43))).forEach(n=>t+=e[n%e.length]),t},RE=e=>btoa(e),rk=e=>{var{clientId:t}=e,n=fs(e,["clientId"]);return new URLSearchParams((r=>Object.keys(r).filter(a=>r[a]!==void 0).reduce((a,s)=>Object.assign(Object.assign({},a),{[s]:r[s]}),{}))(Object.assign({client_id:t},n))).toString()},DE=e=>(t=>decodeURIComponent(atob(t).split("").map(n=>"%"+("00"+n.charCodeAt(0).toString(16)).slice(-2)).join("")))(e.replace(/_/g,"/").replace(/-/g,"+")),RG=async(e,t)=>{const n=await fetch(e,t);return{ok:n.ok,json:await n.json()}},DG=async(e,t,n)=>{const r=new AbortController;let a;return t.signal=r.signal,Promise.race([RG(e,t),new Promise((s,i)=>{a=setTimeout(()=>{r.abort(),i(new Error("Timeout when executing 'fetch'"))},n)})]).finally(()=>{clearTimeout(a)})},OG=async(e,t,n,r,a,s,i)=>{return o={auth:{audience:t,scope:n},timeout:a,fetchUrl:e,fetchOptions:r,useFormData:i},l=s,new Promise(function(c,u){const h=new MessageChannel;h.port1.onmessage=function(d){d.data.error?u(new Error(d.data.error)):c(d.data),h.port1.close()},l.postMessage(o,[h.port2])});var o,l},zG=async(e,t,n,r,a,s,i=1e4)=>a?OG(e,t,n,r,i,a,s):DG(e,r,i);async function PG(e,t){var{baseUrl:n,timeout:r,audience:a,scope:s,auth0Client:i,useFormData:o}=e,l=fs(e,["baseUrl","timeout","audience","scope","auth0Client","useFormData"]);const c=o?rk(l):JSON.stringify(l);return await async function(u,h,d,p,f,m,y){let g,x=null;for(let T=0;T<3;T++)try{g=await zG(u,d,p,f,m,y,h),x=null;break}catch(A){x=A}if(x)throw x;const b=g.json,{error:v,error_description:w}=b,I=fs(b,["error","error_description"]),{ok:_}=g;if(!_){const T=w||`HTTP error. Unable to fetch ${u}`;throw v==="mfa_required"?new kS(v,T,I.mfa_token):v==="missing_refresh_token"?new Kx(d,p):new Kn(v||"request_error",T)}return I}(`${n}/oauth/token`,r,a||"default",s,{method:"POST",body:c,headers:{"Content-Type":o?"application/x-www-form-urlencoded":"application/json","Auth0-Client":btoa(JSON.stringify(i||LR))}},t,o)}const xy=(...e)=>{return(t=e.filter(Boolean).join(" ").trim().split(/\s+/),Array.from(new Set(t))).join(" ");var t};class bs{constructor(t,n="@@auth0spajs@@",r){this.prefix=n,this.suffix=r,this.clientId=t.clientId,this.scope=t.scope,this.audience=t.audience}toKey(){return[this.prefix,this.clientId,this.audience,this.scope,this.suffix].filter(Boolean).join("::")}static fromKey(t){const[n,r,a,s]=t.split("::");return new bs({clientId:r,scope:s,audience:a},n)}static fromCacheEntry(t){const{scope:n,audience:r,client_id:a}=t;return new bs({scope:n,audience:r,clientId:a})}}let LG=class{set(t,n){localStorage.setItem(t,JSON.stringify(n))}get(t){const n=window.localStorage.getItem(t);if(n)try{return JSON.parse(n)}catch{return}}remove(t){localStorage.removeItem(t)}allKeys(){return Object.keys(window.localStorage).filter(t=>t.startsWith("@@auth0spajs@@"))}},WR=class{constructor(){this.enclosedCache=function(){let t={};return{set(n,r){t[n]=r},get(n){const r=t[n];if(r)return r},remove(n){delete t[n]},allKeys:()=>Object.keys(t)}}()}};class BG{constructor(t,n,r){this.cache=t,this.keyManifest=n,this.nowProvider=r||BR}async setIdToken(t,n,r){var a;const s=this.getIdTokenCacheKey(t);await this.cache.set(s,{id_token:n,decodedToken:r}),await((a=this.keyManifest)===null||a===void 0?void 0:a.add(s))}async getIdToken(t){const n=await this.cache.get(this.getIdTokenCacheKey(t.clientId));if(!n&&t.scope&&t.audience){const r=await this.get(t);return!r||!r.id_token||!r.decodedToken?void 0:{id_token:r.id_token,decodedToken:r.decodedToken}}if(n)return{id_token:n.id_token,decodedToken:n.decodedToken}}async get(t,n=0){var r;let a=await this.cache.get(t.toKey());if(!a){const o=await this.getCacheKeys();if(!o)return;const l=this.matchExistingCacheKey(t,o);l&&(a=await this.cache.get(l))}if(!a)return;const s=await this.nowProvider(),i=Math.floor(s/1e3);return a.expiresAt-n<i?a.body.refresh_token?(a.body={refresh_token:a.body.refresh_token},await this.cache.set(t.toKey(),a),a.body):(await this.cache.remove(t.toKey()),void await((r=this.keyManifest)===null||r===void 0?void 0:r.remove(t.toKey()))):a.body}async set(t){var n;const r=new bs({clientId:t.client_id,scope:t.scope,audience:t.audience}),a=await this.wrapCacheEntry(t);await this.cache.set(r.toKey(),a),await((n=this.keyManifest)===null||n===void 0?void 0:n.add(r.toKey()))}async clear(t){var n;const r=await this.getCacheKeys();r&&(await r.filter(a=>!t||a.includes(t)).reduce(async(a,s)=>{await a,await this.cache.remove(s)},Promise.resolve()),await((n=this.keyManifest)===null||n===void 0?void 0:n.clear()))}async wrapCacheEntry(t){const n=await this.nowProvider();return{body:t,expiresAt:Math.floor(n/1e3)+t.expires_in}}async getCacheKeys(){var t;return this.keyManifest?(t=await this.keyManifest.get())===null||t===void 0?void 0:t.keys:this.cache.allKeys?this.cache.allKeys():void 0}getIdTokenCacheKey(t){return new bs({clientId:t},"@@auth0spajs@@","@@user@@").toKey()}matchExistingCacheKey(t,n){return n.filter(r=>{var a;const s=bs.fromKey(r),i=new Set(s.scope&&s.scope.split(" ")),o=((a=t.scope)===null||a===void 0?void 0:a.split(" "))||[],l=s.scope&&o.reduce((c,u)=>c&&i.has(u),!0);return s.prefix==="@@auth0spajs@@"&&s.clientId===t.clientId&&s.audience===t.audience&&l})[0]}}class WG{constructor(t,n,r){this.storage=t,this.clientId=n,this.cookieDomain=r,this.storageKey=`a0.spajs.txs.${this.clientId}`}create(t){this.storage.save(this.storageKey,t,{daysUntilExpire:1,cookieDomain:this.cookieDomain})}get(){return this.storage.get(this.storageKey)}remove(){this.storage.remove(this.storageKey,{cookieDomain:this.cookieDomain})}}const Yp=e=>typeof e=="number",UG=["iss","aud","exp","nbf","iat","jti","azp","nonce","auth_time","at_hash","c_hash","acr","amr","sub_jwk","cnf","sip_from_tag","sip_date","sip_callid","sip_cseq_num","sip_via_branch","orig","dest","mky","events","toe","txn","rph","sid","vot","vtm"],VG=e=>{if(!e.id_token)throw new Error("ID token is required but missing");const t=(s=>{const i=s.split("."),[o,l,c]=i;if(i.length!==3||!o||!l||!c)throw new Error("ID token could not be decoded");const u=JSON.parse(DE(l)),h={__raw:s},d={};return Object.keys(u).forEach(p=>{h[p]=u[p],UG.includes(p)||(d[p]=u[p])}),{encoded:{header:o,payload:l,signature:c},header:JSON.parse(DE(o)),claims:h,user:d}})(e.id_token);if(!t.claims.iss)throw new Error("Issuer (iss) claim must be a string present in the ID token");if(t.claims.iss!==e.iss)throw new Error(`Issuer (iss) claim mismatch in the ID token; expected "${e.iss}", found "${t.claims.iss}"`);if(!t.user.sub)throw new Error("Subject (sub) claim must be a string present in the ID token");if(t.header.alg!=="RS256")throw new Error(`Signature algorithm of "${t.header.alg}" is not supported. Expected the ID token to be signed with "RS256".`);if(!t.claims.aud||typeof t.claims.aud!="string"&&!Array.isArray(t.claims.aud))throw new Error("Audience (aud) claim must be a string or array of strings present in the ID token");if(Array.isArray(t.claims.aud)){if(!t.claims.aud.includes(e.aud))throw new Error(`Audience (aud) claim mismatch in the ID token; expected "${e.aud}" but was not one of "${t.claims.aud.join(", ")}"`);if(t.claims.aud.length>1){if(!t.claims.azp)throw new Error("Authorized Party (azp) claim must be a string present in the ID token when Audience (aud) claim has multiple values");if(t.claims.azp!==e.aud)throw new Error(`Authorized Party (azp) claim mismatch in the ID token; expected "${e.aud}", found "${t.claims.azp}"`)}}else if(t.claims.aud!==e.aud)throw new Error(`Audience (aud) claim mismatch in the ID token; expected "${e.aud}" but found "${t.claims.aud}"`);if(e.nonce){if(!t.claims.nonce)throw new Error("Nonce (nonce) claim must be a string present in the ID token");if(t.claims.nonce!==e.nonce)throw new Error(`Nonce (nonce) claim mismatch in the ID token; expected "${e.nonce}", found "${t.claims.nonce}"`)}if(e.max_age&&!Yp(t.claims.auth_time))throw new Error("Authentication Time (auth_time) claim must be a number present in the ID token when Max Age (max_age) is specified");if(t.claims.exp==null||!Yp(t.claims.exp))throw new Error("Expiration Time (exp) claim must be a number present in the ID token");if(!Yp(t.claims.iat))throw new Error("Issued At (iat) claim must be a number present in the ID token");const n=e.leeway||60,r=new Date(e.now||Date.now()),a=new Date(0);if(a.setUTCSeconds(t.claims.exp+n),r>a)throw new Error(`Expiration Time (exp) claim error in the ID token; current time (${r}) is after expiration time (${a})`);if(t.claims.nbf!=null&&Yp(t.claims.nbf)){const s=new Date(0);if(s.setUTCSeconds(t.claims.nbf-n),r<s)throw new Error(`Not Before time (nbf) claim in the ID token indicates that this token can't be used just yet. Current time (${r}) is before ${s}`)}if(t.claims.auth_time!=null&&Yp(t.claims.auth_time)){const s=new Date(0);if(s.setUTCSeconds(parseInt(t.claims.auth_time)+e.max_age+n),r>s)throw new Error(`Authentication Time (auth_time) claim in the ID token indicates that too much time has passed since the last end-user authentication. Current time (${r}) is after last auth at ${s}`)}if(e.organization){const s=e.organization.trim();if(s.startsWith("org_")){const i=s;if(!t.claims.org_id)throw new Error("Organization ID (org_id) claim must be a string present in the ID token");if(i!==t.claims.org_id)throw new Error(`Organization ID (org_id) claim mismatch in the ID token; expected "${i}", found "${t.claims.org_id}"`)}else{const i=s.toLowerCase();if(!t.claims.org_name)throw new Error("Organization Name (org_name) claim must be a string present in the ID token");if(i!==t.claims.org_name)throw new Error(`Organization Name (org_name) claim mismatch in the ID token; expected "${i}", found "${t.claims.org_name}"`)}}return t};var wl=xS(function(e,t){var n=hl&&hl.__assign||function(){return n=Object.assign||function(l){for(var c,u=1,h=arguments.length;u<h;u++)for(var d in c=arguments[u])Object.prototype.hasOwnProperty.call(c,d)&&(l[d]=c[d]);return l},n.apply(this,arguments)};function r(l,c){if(!c)return"";var u="; "+l;return c===!0?u:u+"="+c}function a(l,c,u){return encodeURIComponent(l).replace(/%(23|24|26|2B|5E|60|7C)/g,decodeURIComponent).replace(/\(/g,"%28").replace(/\)/g,"%29")+"="+encodeURIComponent(c).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g,decodeURIComponent)+function(h){if(typeof h.expires=="number"){var d=new Date;d.setMilliseconds(d.getMilliseconds()+864e5*h.expires),h.expires=d}return r("Expires",h.expires?h.expires.toUTCString():"")+r("Domain",h.domain)+r("Path",h.path)+r("Secure",h.secure)+r("SameSite",h.sameSite)}(u)}function s(l){for(var c={},u=l?l.split("; "):[],h=/(%[\dA-F]{2})+/gi,d=0;d<u.length;d++){var p=u[d].split("="),f=p.slice(1).join("=");f.charAt(0)==='"'&&(f=f.slice(1,-1));try{c[p[0].replace(h,decodeURIComponent)]=f.replace(h,decodeURIComponent)}catch{}}return c}function i(){return s(document.cookie)}function o(l,c,u){document.cookie=a(l,c,n({path:"/"},u))}t.__esModule=!0,t.encode=a,t.parse=s,t.getAll=i,t.get=function(l){return i()[l]},t.set=o,t.remove=function(l,c){o(l,"",n(n({},c),{expires:-1}))}});yS(wl),wl.encode,wl.parse,wl.getAll;var jG=wl.get,UR=wl.set,VR=wl.remove;const sh={get(e){const t=jG(e);if(t!==void 0)return JSON.parse(t)},save(e,t,n){let r={};window.location.protocol==="https:"&&(r={secure:!0,sameSite:"none"}),n!=null&&n.daysUntilExpire&&(r.expires=n.daysUntilExpire),n!=null&&n.cookieDomain&&(r.domain=n.cookieDomain),UR(e,JSON.stringify(t),r)},remove(e,t){let n={};t!=null&&t.cookieDomain&&(n.domain=t.cookieDomain),VR(e,n)}},GG={get(e){return sh.get(e)||sh.get(`_legacy_${e}`)},save(e,t,n){let r={};window.location.protocol==="https:"&&(r={secure:!0}),n!=null&&n.daysUntilExpire&&(r.expires=n.daysUntilExpire),n!=null&&n.cookieDomain&&(r.domain=n.cookieDomain),UR(`_legacy_${e}`,JSON.stringify(t),r),sh.save(e,t,n)},remove(e,t){let n={};t!=null&&t.cookieDomain&&(n.domain=t.cookieDomain),VR(e,n),sh.remove(e,t),sh.remove(`_legacy_${e}`,t)}},HG={get(e){if(typeof sessionStorage>"u")return;const t=sessionStorage.getItem(e);return t!=null?JSON.parse(t):void 0},save(e,t){sessionStorage.setItem(e,JSON.stringify(t))},remove(e){sessionStorage.removeItem(e)}};function qG(e,t,n){var r=t===void 0?null:t,a=function(l,c){var u=atob(l);if(c){for(var h=new Uint8Array(u.length),d=0,p=u.length;d<p;++d)h[d]=u.charCodeAt(d);return String.fromCharCode.apply(null,new Uint16Array(h.buffer))}return u}(e,n!==void 0&&n),s=a.indexOf(`
`,10)+1,i=a.substring(s)+(r?"//# sourceMappingURL="+r:""),o=new Blob([i],{type:"application/javascript"});return URL.createObjectURL(o)}var OE,zE,PE,lw,KG=(OE="Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwohZnVuY3Rpb24oKXsidXNlIHN0cmljdCI7Y2xhc3MgZSBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKHQscil7c3VwZXIociksdGhpcy5lcnJvcj10LHRoaXMuZXJyb3JfZGVzY3JpcHRpb249cixPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcyxlLnByb3RvdHlwZSl9c3RhdGljIGZyb21QYXlsb2FkKHtlcnJvcjp0LGVycm9yX2Rlc2NyaXB0aW9uOnJ9KXtyZXR1cm4gbmV3IGUodCxyKX19Y2xhc3MgdCBleHRlbmRzIGV7Y29uc3RydWN0b3IoZSxzKXtzdXBlcigibWlzc2luZ19yZWZyZXNoX3Rva2VuIixgTWlzc2luZyBSZWZyZXNoIFRva2VuIChhdWRpZW5jZTogJyR7cihlLFsiZGVmYXVsdCJdKX0nLCBzY29wZTogJyR7cihzKX0nKWApLHRoaXMuYXVkaWVuY2U9ZSx0aGlzLnNjb3BlPXMsT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsdC5wcm90b3R5cGUpfX1mdW5jdGlvbiByKGUsdD1bXSl7cmV0dXJuIGUmJiF0LmluY2x1ZGVzKGUpP2U6IiJ9ImZ1bmN0aW9uIj09dHlwZW9mIFN1cHByZXNzZWRFcnJvciYmU3VwcHJlc3NlZEVycm9yO2NvbnN0IHM9ZT0+e3ZhcntjbGllbnRJZDp0fT1lLHI9ZnVuY3Rpb24oZSx0KXt2YXIgcj17fTtmb3IodmFyIHMgaW4gZSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxzKSYmdC5pbmRleE9mKHMpPDAmJihyW3NdPWVbc10pO2lmKG51bGwhPWUmJiJmdW5jdGlvbiI9PXR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgbz0wO2ZvcihzPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7bzxzLmxlbmd0aDtvKyspdC5pbmRleE9mKHNbb10pPDAmJk9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChlLHNbb10pJiYocltzW29dXT1lW3Nbb11dKX1yZXR1cm4gcn0oZSxbImNsaWVudElkIl0pO3JldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zKChlPT5PYmplY3Qua2V5cyhlKS5maWx0ZXIoKHQ9PnZvaWQgMCE9PWVbdF0pKS5yZWR1Y2UoKCh0LHIpPT5PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdCkse1tyXTplW3JdfSkpLHt9KSkoT2JqZWN0LmFzc2lnbih7Y2xpZW50X2lkOnR9LHIpKSkudG9TdHJpbmcoKX07bGV0IG89e307Y29uc3Qgbj0oZSx0KT0+YCR7ZX18JHt0fWA7YWRkRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsKGFzeW5jKHtkYXRhOnt0aW1lb3V0OmUsYXV0aDpyLGZldGNoVXJsOmksZmV0Y2hPcHRpb25zOmMsdXNlRm9ybURhdGE6YX0scG9ydHM6W3BdfSk9PntsZXQgZjtjb25zdHthdWRpZW5jZTp1LHNjb3BlOmx9PXJ8fHt9O3RyeXtjb25zdCByPWE/KGU9Pntjb25zdCB0PW5ldyBVUkxTZWFyY2hQYXJhbXMoZSkscj17fTtyZXR1cm4gdC5mb3JFYWNoKCgoZSx0KT0+e3JbdF09ZX0pKSxyfSkoYy5ib2R5KTpKU09OLnBhcnNlKGMuYm9keSk7aWYoIXIucmVmcmVzaF90b2tlbiYmInJlZnJlc2hfdG9rZW4iPT09ci5ncmFudF90eXBlKXtjb25zdCBlPSgoZSx0KT0+b1tuKGUsdCldKSh1LGwpO2lmKCFlKXRocm93IG5ldyB0KHUsbCk7Yy5ib2R5PWE/cyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scikse3JlZnJlc2hfdG9rZW46ZX0pKTpKU09OLnN0cmluZ2lmeShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scikse3JlZnJlc2hfdG9rZW46ZX0pKX1sZXQgaCxnOyJmdW5jdGlvbiI9PXR5cGVvZiBBYm9ydENvbnRyb2xsZXImJihoPW5ldyBBYm9ydENvbnRyb2xsZXIsYy5zaWduYWw9aC5zaWduYWwpO3RyeXtnPWF3YWl0IFByb21pc2UucmFjZShbKGQ9ZSxuZXcgUHJvbWlzZSgoZT0+c2V0VGltZW91dChlLGQpKSkpLGZldGNoKGksT2JqZWN0LmFzc2lnbih7fSxjKSldKX1jYXRjaChlKXtyZXR1cm4gdm9pZCBwLnBvc3RNZXNzYWdlKHtlcnJvcjplLm1lc3NhZ2V9KX1pZighZylyZXR1cm4gaCYmaC5hYm9ydCgpLHZvaWQgcC5wb3N0TWVzc2FnZSh7ZXJyb3I6IlRpbWVvdXQgd2hlbiBleGVjdXRpbmcgJ2ZldGNoJyJ9KTtmPWF3YWl0IGcuanNvbigpLGYucmVmcmVzaF90b2tlbj8oKChlLHQscik9PntvW24odCxyKV09ZX0pKGYucmVmcmVzaF90b2tlbix1LGwpLGRlbGV0ZSBmLnJlZnJlc2hfdG9rZW4pOigoZSx0KT0+e2RlbGV0ZSBvW24oZSx0KV19KSh1LGwpLHAucG9zdE1lc3NhZ2Uoe29rOmcub2ssanNvbjpmfSl9Y2F0Y2goZSl7cC5wb3N0TWVzc2FnZSh7b2s6ITEsanNvbjp7ZXJyb3I6ZS5lcnJvcixlcnJvcl9kZXNjcmlwdGlvbjplLm1lc3NhZ2V9fSl9dmFyIGR9KSl9KCk7Cgo=",zE=null,PE=!1,function(e){return lw=lw||qG(OE,zE,PE),new Worker(lw,e)});const uw={};class XG{constructor(t,n){this.cache=t,this.clientId=n,this.manifestKey=this.createManifestKeyFrom(this.clientId)}async add(t){var n;const r=new Set(((n=await this.cache.get(this.manifestKey))===null||n===void 0?void 0:n.keys)||[]);r.add(t),await this.cache.set(this.manifestKey,{keys:[...r]})}async remove(t){const n=await this.cache.get(this.manifestKey);if(n){const r=new Set(n.keys);return r.delete(t),r.size>0?await this.cache.set(this.manifestKey,{keys:[...r]}):await this.cache.remove(this.manifestKey)}}get(){return this.cache.get(this.manifestKey)}clear(){return this.cache.remove(this.manifestKey)}createManifestKeyFrom(t){return`@@auth0spajs@@::${t}`}}const ZG={memory:()=>new WR().enclosedCache,localstorage:()=>new LG},LE=e=>ZG[e],BE=e=>{const{openUrl:t,onRedirect:n}=e,r=fs(e,["openUrl","onRedirect"]);return Object.assign(Object.assign({},r),{openUrl:t===!1||t?t:n})},cw=new MG;class YG{constructor(t){let n,r;if(this.userCache=new WR().enclosedCache,this.defaultOptions={authorizationParams:{scope:"openid profile email"},useRefreshTokensFallback:!1,useFormData:!0},this._releaseLockOnPageHide=async()=>{await cw.releaseLock("auth0.lock.getTokenSilently"),window.removeEventListener("pagehide",this._releaseLockOnPageHide)},this.options=Object.assign(Object.assign(Object.assign({},this.defaultOptions),t),{authorizationParams:Object.assign(Object.assign({},this.defaultOptions.authorizationParams),t.authorizationParams)}),typeof window<"u"&&(()=>{if(!d0())throw new Error("For security reasons, `window.crypto` is required to run `auth0-spa-js`.");if(d0().subtle===void 0)throw new Error(`
      auth0-spa-js must run on a secure origin. See https://github.com/auth0/auth0-spa-js/blob/main/FAQ.md#why-do-i-get-auth0-spa-js-must-run-on-a-secure-origin for more information.
    `)})(),t.cache&&t.cacheLocation&&console.warn("Both `cache` and `cacheLocation` options have been specified in the Auth0Client configuration; ignoring `cacheLocation` and using `cache`."),t.cache)r=t.cache;else{if(n=t.cacheLocation||"memory",!LE(n))throw new Error(`Invalid cache location "${n}"`);r=LE(n)()}this.httpTimeoutMs=t.httpTimeoutInSeconds?1e3*t.httpTimeoutInSeconds:1e4,this.cookieStorage=t.legacySameSiteCookie===!1?sh:GG,this.orgHintCookieName=`auth0.${this.options.clientId}.organization_hint`,this.isAuthenticatedCookieName=(i=>`auth0.${i}.is.authenticated`)(this.options.clientId),this.sessionCheckExpiryDays=t.sessionCheckExpiryDays||1;const a=t.useCookiesForTransactions?this.cookieStorage:HG;var s;this.scope=xy("openid",this.options.authorizationParams.scope,this.options.useRefreshTokens?"offline_access":""),this.transactionManager=new WG(a,this.options.clientId,this.options.cookieDomain),this.nowProvider=this.options.nowProvider||BR,this.cacheManager=new BG(r,r.allKeys?void 0:new XG(r,this.options.clientId),this.nowProvider),this.domainUrl=(s=this.options.domain,/^https?:\/\//.test(s)?s:`https://${s}`),this.tokenIssuer=((i,o)=>i?i.startsWith("https://")?i:`https://${i}/`:`${o}/`)(this.options.issuer,this.domainUrl),typeof window<"u"&&window.Worker&&this.options.useRefreshTokens&&n==="memory"&&(this.options.workerUrl?this.worker=new Worker(this.options.workerUrl):this.worker=new KG)}_url(t){const n=encodeURIComponent(btoa(JSON.stringify(this.options.auth0Client||LR)));return`${this.domainUrl}${t}&auth0Client=${n}`}_authorizeUrl(t){return this._url(`/authorize?${rk(t)}`)}async _verifyIdToken(t,n,r){const a=await this.nowProvider();return VG({iss:this.tokenIssuer,aud:this.options.clientId,id_token:t,nonce:n,organization:r,leeway:this.options.leeway,max_age:(s=this.options.authorizationParams.max_age,typeof s!="string"?s:parseInt(s,10)||void 0),now:a});var s}_processOrgHint(t){t?this.cookieStorage.save(this.orgHintCookieName,t,{daysUntilExpire:this.sessionCheckExpiryDays,cookieDomain:this.options.cookieDomain}):this.cookieStorage.remove(this.orgHintCookieName,{cookieDomain:this.options.cookieDomain})}async _prepareAuthorizeUrl(t,n,r){const a=RE(ow()),s=RE(ow()),i=ow(),o=(u=>{const h=new Uint8Array(u);return(d=>{const p={"+":"-","/":"_","=":""};return d.replace(/[+/=]/g,f=>p[f])})(window.btoa(String.fromCharCode(...Array.from(h))))})(await(async u=>await d0().subtle.digest({name:"SHA-256"},new TextEncoder().encode(u)))(i)),l=((u,h,d,p,f,m,y,g)=>Object.assign(Object.assign(Object.assign({client_id:u.clientId},u.authorizationParams),d),{scope:xy(h,d.scope),response_type:"code",response_mode:g||"query",state:p,nonce:f,redirect_uri:y||u.authorizationParams.redirect_uri,code_challenge:m,code_challenge_method:"S256"}))(this.options,this.scope,t,a,s,o,t.redirect_uri||this.options.authorizationParams.redirect_uri||r,n==null?void 0:n.response_mode),c=this._authorizeUrl(l);return{nonce:s,code_verifier:i,scope:l.scope,audience:l.audience||"default",redirect_uri:l.redirect_uri,state:a,url:c}}async loginWithPopup(t,n){var r;if(t=t||{},!(n=n||{}).popup&&(n.popup=(o=>{const l=window.screenX+(window.innerWidth-400)/2,c=window.screenY+(window.innerHeight-600)/2;return window.open(o,"auth0:authorize:popup",`left=${l},top=${c},width=400,height=600,resizable,scrollbars=yes,status=1`)})(""),!n.popup))throw new Error("Unable to open a popup for loginWithPopup - window.open returned `null`");const a=await this._prepareAuthorizeUrl(t.authorizationParams||{},{response_mode:"web_message"},window.location.origin);n.popup.location.href=a.url;const s=await(o=>new Promise((l,c)=>{let u;const h=setInterval(()=>{o.popup&&o.popup.closed&&(clearInterval(h),clearTimeout(d),window.removeEventListener("message",u,!1),c(new wS(o.popup)))},1e3),d=setTimeout(()=>{clearInterval(h),c(new vS(o.popup)),window.removeEventListener("message",u,!1)},1e3*(o.timeoutInSeconds||60));u=function(p){if(p.data&&p.data.type==="authorization_response"){if(clearTimeout(d),clearInterval(h),window.removeEventListener("message",u,!1),o.popup.close(),p.data.response.error)return c(Kn.fromPayload(p.data.response));l(p.data.response)}},window.addEventListener("message",u)}))(Object.assign(Object.assign({},n),{timeoutInSeconds:n.timeoutInSeconds||this.options.authorizeTimeoutInSeconds||60}));if(a.state!==s.state)throw new Kn("state_mismatch","Invalid state");const i=((r=t.authorizationParams)===null||r===void 0?void 0:r.organization)||this.options.authorizationParams.organization;await this._requestToken({audience:a.audience,scope:a.scope,code_verifier:a.code_verifier,grant_type:"authorization_code",code:s.code,redirect_uri:a.redirect_uri},{nonceIn:a.nonce,organization:i})}async getUser(){var t;const n=await this._getIdTokenFromCache();return(t=n==null?void 0:n.decodedToken)===null||t===void 0?void 0:t.user}async getIdTokenClaims(){var t;const n=await this._getIdTokenFromCache();return(t=n==null?void 0:n.decodedToken)===null||t===void 0?void 0:t.claims}async loginWithRedirect(t={}){var n;const r=BE(t),{openUrl:a,fragment:s,appState:i}=r,o=fs(r,["openUrl","fragment","appState"]),l=((n=o.authorizationParams)===null||n===void 0?void 0:n.organization)||this.options.authorizationParams.organization,c=await this._prepareAuthorizeUrl(o.authorizationParams||{}),{url:u}=c,h=fs(c,["url"]);this.transactionManager.create(Object.assign(Object.assign(Object.assign({},h),{appState:i}),l&&{organization:l}));const d=s?`${u}#${s}`:u;a?await a(d):window.location.assign(d)}async handleRedirectCallback(t=window.location.href){const n=t.split("?").slice(1);if(n.length===0)throw new Error("There are no query params available for parsing.");const{state:r,code:a,error:s,error_description:i}=(h=>{h.indexOf("#")>-1&&(h=h.substring(0,h.indexOf("#")));const d=new URLSearchParams(h);return{state:d.get("state"),code:d.get("code")||void 0,error:d.get("error")||void 0,error_description:d.get("error_description")||void 0}})(n.join("")),o=this.transactionManager.get();if(!o)throw new Kn("missing_transaction","Invalid state");if(this.transactionManager.remove(),s)throw new bS(s,i||s,r,o.appState);if(!o.code_verifier||o.state&&o.state!==r)throw new Kn("state_mismatch","Invalid state");const l=o.organization,c=o.nonce,u=o.redirect_uri;return await this._requestToken(Object.assign({audience:o.audience,scope:o.scope,code_verifier:o.code_verifier,grant_type:"authorization_code",code:a},u?{redirect_uri:u}:{}),{nonceIn:c,organization:l}),{appState:o.appState}}async checkSession(t){if(!this.cookieStorage.get(this.isAuthenticatedCookieName)){if(!this.cookieStorage.get("auth0.is.authenticated"))return;this.cookieStorage.save(this.isAuthenticatedCookieName,!0,{daysUntilExpire:this.sessionCheckExpiryDays,cookieDomain:this.options.cookieDomain}),this.cookieStorage.remove("auth0.is.authenticated")}try{await this.getTokenSilently(t)}catch{}}async getTokenSilently(t={}){var n;const r=Object.assign(Object.assign({cacheMode:"on"},t),{authorizationParams:Object.assign(Object.assign(Object.assign({},this.options.authorizationParams),t.authorizationParams),{scope:xy(this.scope,(n=t.authorizationParams)===null||n===void 0?void 0:n.scope)})}),a=await((s,i)=>{let o=uw[i];return o||(o=s().finally(()=>{delete uw[i],o=null}),uw[i]=o),o})(()=>this._getTokenSilently(r),`${this.options.clientId}::${r.authorizationParams.audience}::${r.authorizationParams.scope}`);return t.detailedResponse?a:a==null?void 0:a.access_token}async _getTokenSilently(t){const{cacheMode:n}=t,r=fs(t,["cacheMode"]);if(n!=="off"){const a=await this._getEntryFromCache({scope:r.authorizationParams.scope,audience:r.authorizationParams.audience||"default",clientId:this.options.clientId});if(a)return a}if(n!=="cache-only"){if(!await(async(a,s=3)=>{for(let i=0;i<s;i++)if(await a())return!0;return!1})(()=>cw.acquireLock("auth0.lock.getTokenSilently",5e3),10))throw new sm;try{if(window.addEventListener("pagehide",this._releaseLockOnPageHide),n!=="off"){const c=await this._getEntryFromCache({scope:r.authorizationParams.scope,audience:r.authorizationParams.audience||"default",clientId:this.options.clientId});if(c)return c}const a=this.options.useRefreshTokens?await this._getTokenUsingRefreshToken(r):await this._getTokenFromIFrame(r),{id_token:s,access_token:i,oauthTokenScope:o,expires_in:l}=a;return Object.assign(Object.assign({id_token:s,access_token:i},o?{scope:o}:null),{expires_in:l})}finally{await cw.releaseLock("auth0.lock.getTokenSilently"),window.removeEventListener("pagehide",this._releaseLockOnPageHide)}}}async getTokenWithPopup(t={},n={}){var r;const a=Object.assign(Object.assign({},t),{authorizationParams:Object.assign(Object.assign(Object.assign({},this.options.authorizationParams),t.authorizationParams),{scope:xy(this.scope,(r=t.authorizationParams)===null||r===void 0?void 0:r.scope)})});return n=Object.assign(Object.assign({},FG),n),await this.loginWithPopup(a,n),(await this.cacheManager.get(new bs({scope:a.authorizationParams.scope,audience:a.authorizationParams.audience||"default",clientId:this.options.clientId}))).access_token}async isAuthenticated(){return!!await this.getUser()}_buildLogoutUrl(t){t.clientId!==null?t.clientId=t.clientId||this.options.clientId:delete t.clientId;const n=t.logoutParams||{},{federated:r}=n,a=fs(n,["federated"]),s=r?"&federated":"";return this._url(`/v2/logout?${rk(Object.assign({clientId:t.clientId},a))}`)+s}async logout(t={}){const n=BE(t),{openUrl:r}=n,a=fs(n,["openUrl"]);t.clientId===null?await this.cacheManager.clear():await this.cacheManager.clear(t.clientId||this.options.clientId),this.cookieStorage.remove(this.orgHintCookieName,{cookieDomain:this.options.cookieDomain}),this.cookieStorage.remove(this.isAuthenticatedCookieName,{cookieDomain:this.options.cookieDomain}),this.userCache.remove("@@user@@");const s=this._buildLogoutUrl(a);r?await r(s):r!==!1&&window.location.assign(s)}async _getTokenFromIFrame(t){const n=Object.assign(Object.assign({},t.authorizationParams),{prompt:"none"}),r=this.cookieStorage.get(this.orgHintCookieName);r&&!n.organization&&(n.organization=r);const{url:a,state:s,nonce:i,code_verifier:o,redirect_uri:l,scope:c,audience:u}=await this._prepareAuthorizeUrl(n,{response_mode:"web_message"},window.location.origin);try{if(window.crossOriginIsolated)throw new Kn("login_required","The application is running in a Cross-Origin Isolated context, silently retrieving a token without refresh token is not possible.");const h=t.timeoutInSeconds||this.options.authorizeTimeoutInSeconds,d=await((f,m,y=60)=>new Promise((g,x)=>{const b=window.document.createElement("iframe");b.setAttribute("width","0"),b.setAttribute("height","0"),b.style.display="none";const v=()=>{window.document.body.contains(b)&&(window.document.body.removeChild(b),window.removeEventListener("message",w,!1))};let w;const I=setTimeout(()=>{x(new sm),v()},1e3*y);w=function(_){if(_.origin!=m||!_.data||_.data.type!=="authorization_response")return;const T=_.source;T&&T.close(),_.data.response.error?x(Kn.fromPayload(_.data.response)):g(_.data.response),clearTimeout(I),window.removeEventListener("message",w,!1),setTimeout(v,2e3)},window.addEventListener("message",w,!1),window.document.body.appendChild(b),b.setAttribute("src",f)}))(a,this.domainUrl,h);if(s!==d.state)throw new Kn("state_mismatch","Invalid state");const p=await this._requestToken(Object.assign(Object.assign({},t.authorizationParams),{code_verifier:o,code:d.code,grant_type:"authorization_code",redirect_uri:l,timeout:t.authorizationParams.timeout||this.httpTimeoutMs}),{nonceIn:i,organization:n.organization});return Object.assign(Object.assign({},p),{scope:c,oauthTokenScope:p.scope,audience:u})}catch(h){throw h.error==="login_required"&&this.logout({openUrl:!1}),h}}async _getTokenUsingRefreshToken(t){const n=await this.cacheManager.get(new bs({scope:t.authorizationParams.scope,audience:t.authorizationParams.audience||"default",clientId:this.options.clientId}));if(!(n&&n.refresh_token||this.worker)){if(this.options.useRefreshTokensFallback)return await this._getTokenFromIFrame(t);throw new Kx(t.authorizationParams.audience||"default",t.authorizationParams.scope)}const r=t.authorizationParams.redirect_uri||this.options.authorizationParams.redirect_uri||window.location.origin,a=typeof t.timeoutInSeconds=="number"?1e3*t.timeoutInSeconds:null;try{const s=await this._requestToken(Object.assign(Object.assign(Object.assign({},t.authorizationParams),{grant_type:"refresh_token",refresh_token:n&&n.refresh_token,redirect_uri:r}),a&&{timeout:a}));return Object.assign(Object.assign({},s),{scope:t.authorizationParams.scope,oauthTokenScope:s.scope,audience:t.authorizationParams.audience||"default"})}catch(s){if((s.message.indexOf("Missing Refresh Token")>-1||s.message&&s.message.indexOf("invalid refresh token")>-1)&&this.options.useRefreshTokensFallback)return await this._getTokenFromIFrame(t);throw s}}async _saveEntryInCache(t){const{id_token:n,decodedToken:r}=t,a=fs(t,["id_token","decodedToken"]);this.userCache.set("@@user@@",{id_token:n,decodedToken:r}),await this.cacheManager.setIdToken(this.options.clientId,t.id_token,t.decodedToken),await this.cacheManager.set(a)}async _getIdTokenFromCache(){const t=this.options.authorizationParams.audience||"default",n=await this.cacheManager.getIdToken(new bs({clientId:this.options.clientId,audience:t,scope:this.scope})),r=this.userCache.get("@@user@@");return n&&n.id_token===(r==null?void 0:r.id_token)?r:(this.userCache.set("@@user@@",n),n)}async _getEntryFromCache({scope:t,audience:n,clientId:r}){const a=await this.cacheManager.get(new bs({scope:t,audience:n,clientId:r}),60);if(a&&a.access_token){const{access_token:s,oauthTokenScope:i,expires_in:o}=a,l=await this._getIdTokenFromCache();return l&&Object.assign(Object.assign({id_token:l.id_token,access_token:s},i?{scope:i}:null),{expires_in:o})}}async _requestToken(t,n){const{nonceIn:r,organization:a}=n||{},s=await PG(Object.assign({baseUrl:this.domainUrl,client_id:this.options.clientId,auth0Client:this.options.auth0Client,useFormData:this.options.useFormData,timeout:this.httpTimeoutMs},t),this.worker),i=await this._verifyIdToken(s.id_token,r,a);return await this._saveEntryInCache(Object.assign(Object.assign(Object.assign(Object.assign({},s),{decodedToken:i,scope:t.scope,audience:t.audience||"default"}),s.scope?{oauthTokenScope:s.scope}:null),{client_id:this.options.clientId})),this.cookieStorage.save(this.isAuthenticatedCookieName,!0,{daysUntilExpire:this.sessionCheckExpiryDays,cookieDomain:this.options.cookieDomain}),this._processOrgHint(a||i.claims.org_id),Object.assign(Object.assign({},s),{decodedToken:i})}}var jR={isAuthenticated:!1,isLoading:!0},Ls=function(){throw new Error("You forgot to wrap your component in <Auth0Provider>.")},JG=Tn(Tn({},jR),{buildAuthorizeUrl:Ls,buildLogoutUrl:Ls,getAccessTokenSilently:Ls,getAccessTokenWithPopup:Ls,getIdTokenClaims:Ls,loginWithRedirect:Ls,loginWithPopup:Ls,logout:Ls,handleRedirectCallback:Ls}),GR=ee.createContext(JG),WE=function(e){AG(t,e);function t(n,r){var a=e.call(this,r||n)||this;return a.error=n,a.error_description=r,Object.setPrototypeOf(a,t.prototype),a}return t}(Error),QG=/[?&]code=[^&]+/,eH=/[?&]state=[^&]+/,tH=/[?&]error=[^&]+/,nH=function(e){return e===void 0&&(e=window.location.search),(QG.test(e)||tH.test(e))&&eH.test(e)},HR=function(e){return function(t){return t instanceof Error?t:t!==null&&typeof t=="object"&&"error"in t&&typeof t.error=="string"?"error_description"in t&&typeof t.error_description=="string"?new WE(t.error,t.error_description):new WE(t.error):new Error(e)}},UE=HR("Login failed"),hw=HR("Get access token failed"),qR=function(e){var t;e!=null&&e.redirectUri&&(console.warn("Using `redirectUri` has been deprecated, please use `authorizationParams.redirect_uri` instead as `redirectUri` will be no longer supported in a future version"),e.authorizationParams=e.authorizationParams||{},e.authorizationParams.redirect_uri=e.redirectUri,delete e.redirectUri),!((t=e==null?void 0:e.authorizationParams)===null||t===void 0)&&t.redirectUri&&(console.warn("Using `authorizationParams.redirectUri` has been deprecated, please use `authorizationParams.redirect_uri` instead as `authorizationParams.redirectUri` will be removed in a future version"),e.authorizationParams.redirect_uri=e.authorizationParams.redirectUri,delete e.authorizationParams.redirectUri)},rH=function(e,t){switch(t.type){case"LOGIN_POPUP_STARTED":return Tn(Tn({},e),{isLoading:!0});case"LOGIN_POPUP_COMPLETE":case"INITIALISED":return Tn(Tn({},e),{isAuthenticated:!!t.user,user:t.user,isLoading:!1,error:void 0});case"HANDLE_REDIRECT_COMPLETE":case"GET_ACCESS_TOKEN_COMPLETE":return e.user===t.user?e:Tn(Tn({},e),{isAuthenticated:!!t.user,user:t.user});case"LOGOUT":return Tn(Tn({},e),{isAuthenticated:!1,user:void 0});case"ERROR":return Tn(Tn({},e),{isLoading:!1,error:t.error})}},aH=function(e){return qR(e),Tn(Tn({},e),{auth0Client:{name:"auth0-react",version:"2.3.0"}})},sH=function(e){window.history.replaceState({},document.title,(e==null?void 0:e.returnTo)||window.location.pathname)},iH=function(e){var t=e.children,n=e.skipRedirectCallback,r=e.onRedirectCallback,a=r===void 0?sH:r,s=e.context,i=s===void 0?GR:s,o=$G(e,["children","skipRedirectCallback","onRedirectCallback","context"]),l=ee.useState(function(){return new YG(aH(o))})[0],c=ee.useReducer(rH,jR),u=c[0],h=c[1],d=ee.useRef(!1),p=ee.useCallback(function(I){return h({type:"ERROR",error:I}),I},[]);ee.useEffect(function(){d.current||(d.current=!0,function(){return Uc(void 0,void 0,void 0,function(){var I,_,T;return Vc(this,function(A){switch(A.label){case 0:return A.trys.push([0,7,,8]),I=void 0,nH()&&!n?[4,l.handleRedirectCallback()]:[3,3];case 1:return _=A.sent().appState,[4,l.getUser()];case 2:return I=A.sent(),a(_,I),[3,6];case 3:return[4,l.checkSession()];case 4:return A.sent(),[4,l.getUser()];case 5:I=A.sent(),A.label=6;case 6:return h({type:"INITIALISED",user:I}),[3,8];case 7:return T=A.sent(),p(UE(T)),[3,8];case 8:return[2]}})})}())},[l,a,n,p]);var f=ee.useCallback(function(I){return qR(I),l.loginWithRedirect(I)},[l]),m=ee.useCallback(function(I,_){return Uc(void 0,void 0,void 0,function(){var T,A;return Vc(this,function(M){switch(M.label){case 0:h({type:"LOGIN_POPUP_STARTED"}),M.label=1;case 1:return M.trys.push([1,3,,4]),[4,l.loginWithPopup(I,_)];case 2:return M.sent(),[3,4];case 3:return T=M.sent(),p(UE(T)),[2];case 4:return[4,l.getUser()];case 5:return A=M.sent(),h({type:"LOGIN_POPUP_COMPLETE",user:A}),[2]}})})},[l]),y=ee.useCallback(function(I){return I===void 0&&(I={}),Uc(void 0,void 0,void 0,function(){return Vc(this,function(_){switch(_.label){case 0:return[4,l.logout(I)];case 1:return _.sent(),(I.openUrl||I.openUrl===!1)&&h({type:"LOGOUT"}),[2]}})})},[l]),g=ee.useCallback(function(I){return Uc(void 0,void 0,void 0,function(){var _,T,A,M;return Vc(this,function(F){switch(F.label){case 0:return F.trys.push([0,2,3,5]),[4,l.getTokenSilently(I)];case 1:return _=F.sent(),[3,5];case 2:throw T=F.sent(),hw(T);case 3:return A=h,M={type:"GET_ACCESS_TOKEN_COMPLETE"},[4,l.getUser()];case 4:return A.apply(void 0,[(M.user=F.sent(),M)]),[7];case 5:return[2,_]}})})},[l]),x=ee.useCallback(function(I,_){return Uc(void 0,void 0,void 0,function(){var T,A,M,F;return Vc(this,function(C){switch(C.label){case 0:return C.trys.push([0,2,3,5]),[4,l.getTokenWithPopup(I,_)];case 1:return T=C.sent(),[3,5];case 2:throw A=C.sent(),hw(A);case 3:return M=h,F={type:"GET_ACCESS_TOKEN_COMPLETE"},[4,l.getUser()];case 4:return M.apply(void 0,[(F.user=C.sent(),F)]),[7];case 5:return[2,T]}})})},[l]),b=ee.useCallback(function(){return l.getIdTokenClaims()},[l]),v=ee.useCallback(function(I){return Uc(void 0,void 0,void 0,function(){var _,T,A;return Vc(this,function(M){switch(M.label){case 0:return M.trys.push([0,2,3,5]),[4,l.handleRedirectCallback(I)];case 1:return[2,M.sent()];case 2:throw _=M.sent(),hw(_);case 3:return T=h,A={type:"HANDLE_REDIRECT_COMPLETE"},[4,l.getUser()];case 4:return T.apply(void 0,[(A.user=M.sent(),A)]),[7];case 5:return[2]}})})},[l]),w=ee.useMemo(function(){return Tn(Tn({},u),{getAccessTokenSilently:g,getAccessTokenWithPopup:x,getIdTokenClaims:b,loginWithRedirect:f,loginWithPopup:m,logout:y,handleRedirectCallback:v})},[u,g,x,b,f,m,y,v]);return NM.createElement(i.Provider,{value:w},t)},KR=function(e){return e===void 0&&(e=GR),ee.useContext(e)};/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */var oH={xmlns:"http://www.w3.org/2000/svg",width:24,height:24,viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:2,strokeLinecap:"round",strokeLinejoin:"round"};/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const lH=e=>e.replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase().trim(),st=(e,t)=>{const n=ee.forwardRef(({color:r="currentColor",size:a=24,strokeWidth:s=2,absoluteStrokeWidth:i,className:o="",children:l,...c},u)=>ee.createElement("svg",{ref:u,...oH,width:a,height:a,stroke:r,strokeWidth:i?Number(s)*24/Number(a):s,className:["lucide",`lucide-${lH(e)}`,o].join(" "),...c},[...t.map(([h,d])=>ee.createElement(h,d)),...Array.isArray(l)?l:[l]]));return n.displayName=`${e}`,n};/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const uH=st("AlertCircle",[["circle",{cx:"12",cy:"12",r:"10",key:"1mglay"}],["line",{x1:"12",x2:"12",y1:"8",y2:"12",key:"1pkeuh"}],["line",{x1:"12",x2:"12.01",y1:"16",y2:"16",key:"4dfq90"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const cH=st("Award",[["circle",{cx:"12",cy:"8",r:"6",key:"1vp47v"}],["path",{d:"M15.477 12.89 17 22l-5-3-5 3 1.523-9.11",key:"em7aur"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const hH=st("BedDouble",[["path",{d:"M2 20v-8a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v8",key:"1k78r4"}],["path",{d:"M4 10V6a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v4",key:"fb3tl2"}],["path",{d:"M12 4v6",key:"1dcgq2"}],["path",{d:"M2 18h20",key:"ajqnye"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const dH=st("Briefcase",[["rect",{width:"20",height:"14",x:"2",y:"7",rx:"2",ry:"2",key:"eto64e"}],["path",{d:"M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16",key:"zwj3tp"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const pH=st("Building2",[["path",{d:"M6 22V4a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v18Z",key:"1b4qmf"}],["path",{d:"M6 12H4a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h2",key:"i71pzd"}],["path",{d:"M18 9h2a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2h-2",key:"10jefs"}],["path",{d:"M10 6h4",key:"1itunk"}],["path",{d:"M10 10h4",key:"tcdvrf"}],["path",{d:"M10 14h4",key:"kelpxr"}],["path",{d:"M10 18h4",key:"1ulq68"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const XR=st("Camera",[["path",{d:"M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z",key:"1tc9qg"}],["circle",{cx:"12",cy:"13",r:"3",key:"1vg3eu"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const fH=st("ChevronRight",[["path",{d:"m9 18 6-6-6-6",key:"mthhwq"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const mH=st("CreditCard",[["rect",{width:"20",height:"14",x:"2",y:"5",rx:"2",key:"ynyp8z"}],["line",{x1:"2",x2:"22",y1:"10",y2:"10",key:"1b3vmo"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const gH=st("Filter",[["polygon",{points:"22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3",key:"1yg77f"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Z0=st("Heart",[["path",{d:"M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z",key:"c3ymky"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const yH=st("Home",[["path",{d:"m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z",key:"y5dka4"}],["polyline",{points:"9 22 9 12 15 12 15 22",key:"e2us08"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const VE=st("Loader2",[["path",{d:"M21 12a9 9 0 1 1-6.219-8.56",key:"13zald"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const xH=st("LogOut",[["path",{d:"M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4",key:"1uf3rs"}],["polyline",{points:"16 17 21 12 16 7",key:"1gabdz"}],["line",{x1:"21",x2:"9",y1:"12",y2:"12",key:"1uyos4"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const p0=st("MapPin",[["path",{d:"M20 10c0 6-8 12-8 12s-8-6-8-12a8 8 0 0 1 16 0Z",key:"2oe9fu"}],["circle",{cx:"12",cy:"10",r:"3",key:"ilqhr7"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const jE=st("MessageCircle",[["path",{d:"M7.9 20A9 9 0 1 0 4 16.1L2 22Z",key:"vv11sd"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const bH=st("Minus",[["path",{d:"M5 12h14",key:"1ays0h"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const ak=st("Package",[["path",{d:"m7.5 4.27 9 5.15",key:"1c824w"}],["path",{d:"M21 8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16Z",key:"hh9hay"}],["path",{d:"m3.3 7 8.7 5 8.7-5",key:"g66t2b"}],["path",{d:"M12 22V12",key:"d0xqtd"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const vH=st("Palette",[["circle",{cx:"13.5",cy:"6.5",r:".5",fill:"currentColor",key:"1okk4w"}],["circle",{cx:"17.5",cy:"10.5",r:".5",fill:"currentColor",key:"f64h9f"}],["circle",{cx:"8.5",cy:"7.5",r:".5",fill:"currentColor",key:"fotxhn"}],["circle",{cx:"6.5",cy:"12.5",r:".5",fill:"currentColor",key:"qy21gx"}],["path",{d:"M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.012 17.461 2 12 2z",key:"12rzf8"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const ZR=st("Plus",[["path",{d:"M5 12h14",key:"1ays0h"}],["path",{d:"M12 5v14",key:"s699le"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const wH=st("Ruler",[["path",{d:"M21.3 15.3a2.4 2.4 0 0 1 0 3.4l-2.6 2.6a2.4 2.4 0 0 1-3.4 0L2.7 8.7a2.41 2.41 0 0 1 0-3.4l2.6-2.6a2.41 2.41 0 0 1 3.4 0Z",key:"icamh8"}],["path",{d:"m14.5 12.5 2-2",key:"inckbg"}],["path",{d:"m11.5 9.5 2-2",key:"fmmyf7"}],["path",{d:"m8.5 6.5 2-2",key:"vc6u1g"}],["path",{d:"m17.5 15.5 2-2",key:"wo5hmg"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const sk=st("Scissors",[["circle",{cx:"6",cy:"6",r:"3",key:"1lh9wr"}],["path",{d:"M8.12 8.12 12 12",key:"1alkpv"}],["path",{d:"M20 4 8.12 15.88",key:"xgtan2"}],["circle",{cx:"6",cy:"18",r:"3",key:"fqmcym"}],["path",{d:"M14.8 14.8 20 20",key:"ptml3r"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const kH=st("Search",[["circle",{cx:"11",cy:"11",r:"8",key:"4ej97u"}],["path",{d:"m21 21-4.3-4.3",key:"1qie3q"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const SH=st("Send",[["path",{d:"m22 2-7 20-4-9-9-4Z",key:"1q3vgg"}],["path",{d:"M22 2 11 13",key:"nzbqef"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const IH=st("Settings",[["path",{d:"M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z",key:"1qme2f"}],["circle",{cx:"12",cy:"12",r:"3",key:"1v7zrd"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const SS=st("ShoppingBag",[["path",{d:"M6 2 3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4Z",key:"hou9p0"}],["path",{d:"M3 6h18",key:"d0wm0j"}],["path",{d:"M16 10a4 4 0 0 1-8 0",key:"1ltviw"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const YR=st("ShoppingCart",[["circle",{cx:"8",cy:"21",r:"1",key:"jimo8o"}],["circle",{cx:"19",cy:"21",r:"1",key:"13723u"}],["path",{d:"M2.05 2.05h2l2.66 12.42a2 2 0 0 0 2 1.58h9.78a2 2 0 0 0 1.95-1.57l1.65-7.43H5.12",key:"9zh506"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const JR=st("Sparkles",[["path",{d:"m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z",key:"17u4zn"}],["path",{d:"M5 3v4",key:"bklmnn"}],["path",{d:"M19 17v4",key:"iiml17"}],["path",{d:"M3 5h4",key:"nem4j1"}],["path",{d:"M17 19h4",key:"lbex7p"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const NH=st("SquarePen",[["path",{d:"M12 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7",key:"1m0v6g"}],["path",{d:"M18.375 2.625a2.121 2.121 0 1 1 3 3L12 15l-4 1 1-4Z",key:"1lpok0"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const dw=st("Trash2",[["path",{d:"M3 6h18",key:"d0wm0j"}],["path",{d:"M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6",key:"4alrt4"}],["path",{d:"M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2",key:"v07s0e"}],["line",{x1:"10",x2:"10",y1:"11",y2:"17",key:"1uufr5"}],["line",{x1:"14",x2:"14",y1:"11",y2:"17",key:"xtxkd"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const _H=st("Trash",[["path",{d:"M3 6h18",key:"d0wm0j"}],["path",{d:"M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6",key:"4alrt4"}],["path",{d:"M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2",key:"v07s0e"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const CH=st("Upload",[["path",{d:"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4",key:"ih7n3h"}],["polyline",{points:"17 8 12 3 7 8",key:"t8dd8p"}],["line",{x1:"12",x2:"12",y1:"3",y2:"15",key:"widbto"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const QR=st("User",[["path",{d:"M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2",key:"975kel"}],["circle",{cx:"12",cy:"7",r:"4",key:"17ys0d"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const TH=st("Users",[["path",{d:"M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2",key:"1yyitq"}],["circle",{cx:"9",cy:"7",r:"4",key:"nufk8"}],["path",{d:"M22 21v-2a4 4 0 0 0-3-3.87",key:"kshegd"}],["path",{d:"M16 3.13a4 4 0 0 1 0 7.75",key:"1da9ce"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Vh=st("X",[["path",{d:"M18 6 6 18",key:"1bl5f8"}],["path",{d:"m6 6 12 12",key:"d8bk6v"}]]),eD=ee.createContext(void 0);function EH({children:e}){const[t,n]=ee.useState([]),[r,a]=ee.useState(!1),s=l=>{n(c=>c.find(h=>h.id===l.id)?c.map(h=>h.id===l.id?{...h,quantity:h.quantity+1}:h):[...c,{...l,quantity:1}]),a(!0)},i=l=>{n(c=>c.filter(u=>u.id!==l))},o=(l,c)=>{if(c<1){i(l);return}n(u=>u.map(h=>h.id===l?{...h,quantity:c}:h))};return N.jsx(eD.Provider,{value:{items:t,addItem:s,removeItem:i,updateQuantity:o,isCartOpen:r,setIsCartOpen:a},children:e})}function Mm(){const e=ee.useContext(eD);if(e===void 0)throw new Error("useCart must be used within a CartProvider");return e}const AH=()=>window.location.hostname==="thecodersourabh.github.io"?"https://thecodersourabh.github.io/TexWeb/":"http://localhost:4173",$H=()=>window.location.hostname==="thecodersourabh.github.io"?"https://thecodersourabh.github.io/TexWeb/#/":"http://localhost:4173/#/",tD=ee.createContext(void 0),MH=({children:e})=>{hd();const{isAuthenticated:t,loginWithRedirect:n,logout:r,user:a,isLoading:s}=KR();ee.useEffect(()=>{},[t,a]);const i={isAuthenticated:t,user:a,loading:s,logout:()=>r({logoutParams:{returnTo:$H()}}),loginWithRedirect:n};return N.jsx(tD.Provider,{value:i,children:e})},nD=()=>{const e=ee.useContext(tD);if(e===void 0)throw new Error("useAuth must be used within an AuthProvider");return e},FH=({isOpen:e,onClose:t})=>{const{user:n,logout:r}=nD(),{setIsCartOpen:a}=Mm(),s=()=>{t(),a(!0)},i=()=>{t(),r()},o=[{icon:YR,label:"Shopping Cart",action:s},{icon:ak,label:"My Orders",link:"/orders"},{icon:SS,label:"My Designs",link:"/profile/my-designs"},{icon:Z0,label:"Wishlist",link:"/profile/wishlist"},{icon:mH,label:"Payment Methods",link:"/profile/payments"},{icon:p0,label:"Saved Addresses",link:"/profile/addresses"},{icon:IH,label:"Account Settings",link:"/profile/settings"}];return e?N.jsxs("div",{className:"fixed inset-0 z-50 flex justify-end",children:[N.jsx("div",{className:"fixed inset-0 bg-black bg-opacity-50",onClick:t}),N.jsxs("div",{className:"relative w-full max-w-md bg-white h-full shadow-xl flex flex-col",children:["        ",N.jsxs("div",{className:"p-4 border-b flex justify-between items-center",children:[N.jsxs("div",{className:"flex items-center space-x-2",children:[N.jsx(QR,{className:"h-5 w-5 text-rose-600"}),N.jsx("h2",{className:"text-lg font-semibold",children:"My Profile"})]}),N.jsx("button",{onClick:t,className:"text-gray-500 hover:text-gray-700",children:N.jsx(Vh,{className:"h-5 w-5"})})]}),N.jsxs("div",{className:"flex-1 flex flex-col overflow-hidden",children:[N.jsx("div",{className:"p-4 border-b bg-gray-50",children:N.jsxs("div",{className:"flex items-center",children:[(n==null?void 0:n.picture)&&N.jsx("img",{src:n.picture,alt:n.name||"Profile",className:"w-12 h-12 rounded-full border-2 border-rose-200"}),N.jsxs("div",{className:"ml-4",children:[N.jsx("h3",{className:"font-medium text-gray-900",children:n==null?void 0:n.name}),N.jsx("p",{className:"text-sm text-gray-600",children:n==null?void 0:n.email})]})]})}),"          ",N.jsx("nav",{className:"flex-1 overflow-y-auto",children:N.jsx("ul",{className:"divide-y divide-gray-200",children:o.map((l,c)=>N.jsx("li",{children:l.action?N.jsxs("button",{onClick:l.action,className:"flex items-center space-x-3 w-full px-4 py-3 text-gray-700 hover:bg-gray-50",children:[N.jsx(l.icon,{className:"h-5 w-5"}),N.jsx("span",{children:l.label})]}):N.jsxs(df,{to:l.link,className:"flex items-center space-x-3 px-4 py-3 text-gray-700 hover:bg-gray-50",onClick:t,children:[N.jsx(l.icon,{className:"h-5 w-5"}),N.jsx("span",{children:l.label})]})},c))})}),N.jsx("div",{className:"border-t p-4",children:N.jsxs("button",{onClick:i,className:"flex items-center justify-center space-x-2 w-full px-4 py-2 text-white bg-rose-600 hover:bg-rose-700 rounded-md transition-colors",children:[N.jsx(xH,{className:"h-5 w-5"}),N.jsx("span",{children:"Logout"})]})})]})]})]}):null};function RH(){const{setIsCartOpen:e,items:t}=Mm(),{isAuthenticated:n,user:r,loginWithRedirect:a,logout:s}=nD(),[i,o]=ee.useState(!1);return N.jsx("nav",{className:"bg-white border-b border-gray-100 px-4 py-3",children:N.jsxs("div",{className:"max-w-7xl mx-auto flex items-center justify-between",children:[N.jsxs("div",{className:"flex items-center space-x-8",children:[N.jsxs(df,{to:"/",className:"flex items-center space-x-2",children:[N.jsx(sk,{className:"h-6 w-6 text-rose-600"}),N.jsx("span",{className:"text-xl font-semibold",children:"FabricCraft"})]}),N.jsxs("div",{className:"hidden md:flex space-x-6",children:[N.jsx(df,{to:"/",className:"text-gray-600 hover:text-gray-900",children:"Home"}),N.jsx(df,{to:"/about",className:"text-gray-600 hover:text-gray-900",children:"About"}),N.jsx(df,{to:"/design",className:"text-gray-600 hover:text-gray-900",children:"Create Own Design"})]})]}),N.jsxs("div",{className:"flex items-center space-x-6",children:[N.jsx("button",{className:"text-gray-600 hover:text-gray-900",children:N.jsx(Z0,{className:"h-5 w-5"})}),N.jsxs("button",{onClick:()=>e(!0),className:"text-gray-600 hover:text-gray-900 relative",children:[N.jsx(YR,{className:"h-5 w-5"}),t.length>0&&N.jsx("span",{className:"absolute -top-2 -right-2 bg-rose-600 text-white text-xs w-5 h-5 rounded-full flex items-center justify-center",children:t.length})]}),n?N.jsxs("button",{onClick:()=>o(!0),className:"flex items-center space-x-2 hover:opacity-75 transition-opacity",children:[N.jsx("img",{src:r==null?void 0:r.picture,className:"h-8 w-8 rounded-full border-2 border-rose-200"}),N.jsx("span",{className:"text-sm text-gray-700 hidden md:inline",children:r==null?void 0:r.name})]}):N.jsxs("button",{onClick:()=>a(),className:"text-sm text-gray-600 hover:text-gray-900 flex items-center space-x-1",children:[N.jsx(QR,{className:"h-5 w-5"}),N.jsx("span",{children:"Sign In"})]}),N.jsx(FH,{isOpen:i,onClose:()=>o(!1)})]})]})})}function DH(){const[e,t]=ee.useState(!1),[n,r]=ee.useState([{text:"Hi! I'm here to help with your fabric design questions. How can I assist you today?",isBot:!0}]),[a,s]=ee.useState(""),i=o=>{o.preventDefault(),a.trim()&&(r([...n,{text:a,isBot:!1}]),s(""),setTimeout(()=>{r(l=>[...l,{text:"Thanks for your message! A design specialist will respond shortly. In the meantime, feel free to browse our featured collections.",isBot:!0}])},1e3))};return N.jsx("div",{className:"fixed bottom-6 right-6 z-50",children:e?N.jsxs("div",{className:"bg-white rounded-lg shadow-xl w-[360px] h-[480px] flex flex-col",children:[N.jsxs("div",{className:"p-4 bg-rose-600 text-white rounded-t-lg flex justify-between items-center",children:[N.jsxs("div",{className:"flex items-center space-x-2",children:[N.jsx(jE,{className:"h-5 w-5"}),N.jsx("span",{className:"font-semibold",children:"Design Assistant"})]}),N.jsx("button",{onClick:()=>t(!1),className:"text-white hover:text-rose-200 transition",children:N.jsx(Vh,{className:"h-5 w-5"})})]}),N.jsx("div",{className:"flex-1 overflow-y-auto p-4 space-y-4",children:n.map((o,l)=>N.jsx("div",{className:`flex ${o.isBot?"justify-start":"justify-end"}`,children:N.jsx("div",{className:`max-w-[80%] p-3 rounded-lg ${o.isBot?"bg-gray-100 text-gray-800":"bg-rose-600 text-white"}`,children:o.text})},l))}),N.jsx("form",{onSubmit:i,className:"p-4 border-t",children:N.jsxs("div",{className:"flex space-x-2",children:[N.jsx("input",{type:"text",value:a,onChange:o=>s(o.target.value),placeholder:"Type your message...",className:"flex-1 border rounded-full px-4 py-2 focus:outline-none focus:border-rose-600"}),N.jsx("button",{type:"submit",className:"bg-rose-600 text-white p-2 rounded-full hover:bg-rose-700 transition",children:N.jsx(SH,{className:"h-5 w-5"})})]})})]}):N.jsx("button",{onClick:()=>t(!0),className:"bg-rose-600 text-white p-4 rounded-full shadow-lg hover:bg-rose-700 transition",children:N.jsx(jE,{className:"h-6 w-6"})})})}function OH(){const{items:e,removeItem:t,updateQuantity:n,isCartOpen:r,setIsCartOpen:a}=Mm(),s=e.reduce((i,o)=>i+o.price*o.quantity,0);return r?N.jsxs("div",{className:"fixed inset-0 z-50 flex justify-end",children:[N.jsx("div",{className:"fixed inset-0 bg-black bg-opacity-50",onClick:()=>a(!1)}),N.jsxs("div",{className:"relative w-full max-w-md bg-white h-full shadow-xl flex flex-col",children:[N.jsxs("div",{className:"p-4 border-b flex justify-between items-center",children:[N.jsxs("div",{className:"flex items-center space-x-2",children:[N.jsx(SS,{className:"h-5 w-5"}),N.jsx("h2",{className:"text-lg font-semibold",children:"Shopping Cart"})]}),N.jsx("button",{onClick:()=>a(!1),className:"text-gray-500 hover:text-gray-700",children:N.jsx(Vh,{className:"h-5 w-5"})})]}),e.length===0?N.jsx("div",{className:"flex-1 flex items-center justify-center",children:N.jsx("p",{className:"text-gray-500",children:"Your cart is empty"})}):N.jsxs(N.Fragment,{children:[N.jsx("div",{className:"flex-1 overflow-y-auto p-4 space-y-4",children:e.map(i=>N.jsxs("div",{className:"flex items-center space-x-4 border-b pb-4",children:[N.jsx("img",{src:i.image,alt:i.name,className:"w-20 h-20 object-cover rounded"}),N.jsxs("div",{className:"flex-1",children:[N.jsx("h3",{className:"font-medium",children:i.name}),N.jsxs("p",{className:"text-gray-600",children:["$",i.price.toFixed(2)]}),N.jsxs("div",{className:"flex items-center space-x-2 mt-2",children:[N.jsx("button",{onClick:()=>n(i.id,i.quantity-1),className:"p-1 rounded-full hover:bg-gray-100",children:N.jsx(bH,{className:"h-4 w-4"})}),N.jsx("span",{children:i.quantity}),N.jsx("button",{onClick:()=>n(i.id,i.quantity+1),className:"p-1 rounded-full hover:bg-gray-100",children:N.jsx(ZR,{className:"h-4 w-4"})})]})]}),N.jsx("button",{onClick:()=>t(i.id),className:"text-gray-400 hover:text-gray-600",children:N.jsx(Vh,{className:"h-5 w-5"})})]},i.id))}),N.jsxs("div",{className:"border-t p-4 space-y-4",children:[N.jsxs("div",{className:"flex justify-between text-lg font-semibold",children:[N.jsx("span",{children:"Total"}),N.jsxs("span",{children:["$",s.toFixed(2)]})]}),N.jsx("button",{className:"w-full bg-rose-600 text-white py-3 rounded-full hover:bg-rose-700 transition",children:"Checkout"})]})]})]})]}):null}function zH(){return N.jsxs("div",{className:"min-h-screen bg-white",children:[N.jsxs("div",{className:"relative h-[400px] bg-cover bg-center",style:{backgroundImage:'url("https://images.unsplash.com/photo-1459156212016-c812468e2115?auto=format&fit=crop&q=80")'},children:[N.jsx("div",{className:"absolute inset-0 bg-black bg-opacity-50"}),N.jsx("div",{className:"absolute inset-0 flex items-center justify-center",children:N.jsxs("div",{className:"text-center text-white max-w-3xl px-4",children:[N.jsx("h1",{className:"text-5xl font-bold mb-4",children:"Crafting Dreams into Fabric"}),N.jsx("p",{className:"text-xl",children:"Since 1970, we've been transforming creative visions into beautiful, custom-made fabrics."})]})})]}),N.jsx("div",{className:"max-w-7xl mx-auto py-16 px-4",children:N.jsxs("div",{className:"text-center max-w-3xl mx-auto",children:[N.jsx("h2",{className:"text-3xl font-bold mb-6",children:"Our Mission"}),N.jsx("p",{className:"text-lg text-gray-600 leading-relaxed",children:"At FabricCraft, we believe that every piece of fabric tells a story. Our mission is to empower creators, designers, and dreamers to bring their unique visions to life through high-quality, custom-printed fabrics."})]})}),N.jsx("div",{className:"bg-gray-50 py-16",children:N.jsx("div",{className:"max-w-7xl mx-auto px-4",children:N.jsxs("div",{className:"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-8",children:[N.jsx(by,{icon:N.jsx(vH,{className:"h-8 w-8"}),title:"Premium Quality",description:"We use the finest materials and advanced printing technology to ensure vibrant, long-lasting results."}),N.jsx(by,{icon:N.jsx(TH,{className:"h-8 w-8"}),title:"Expert Support",description:"Our team of design specialists is here to help you every step of the way."}),N.jsx(by,{icon:N.jsx(cH,{className:"h-8 w-8"}),title:"Satisfaction Guaranteed",description:"We stand behind our products with a 100% satisfaction guarantee."}),N.jsx(by,{icon:N.jsx(JR,{className:"h-8 w-8"}),title:"Endless Possibilities",description:"From custom bedding to designer prints, bring any design to life."})]})})}),N.jsx("div",{className:"max-w-7xl mx-auto py-16 px-4",children:N.jsxs("div",{className:"grid grid-cols-1 md:grid-cols-2 gap-12 items-center",children:[N.jsx("div",{children:N.jsx("img",{src:"https://images.unsplash.com/photo-1544367567-0f2fcb009e0b?auto=format&fit=crop&q=80",alt:"Fabric Workshop",className:"rounded-lg shadow-lg"})}),N.jsxs("div",{children:[N.jsx("h2",{className:"text-3xl font-bold mb-6",children:"Our Story"}),N.jsxs("div",{className:"space-y-4 text-gray-600",children:[N.jsx("p",{children:"Founded in 1970, FabricCraft began as a small family-owned textile shop with a big dream: to revolutionize custom fabric printing."}),N.jsx("p",{children:"Today, we've grown into a leading digital fabric printing service, combining traditional craftsmanship with cutting-edge technology to deliver exceptional quality and creativity to designers worldwide."}),N.jsx("p",{children:"Our commitment to innovation, sustainability, and customer satisfaction has made us the trusted choice for both individual creators and industry professionals."})]})]})]})})]})}const by=({icon:e,title:t,description:n})=>N.jsxs("div",{className:"bg-white p-6 rounded-xl shadow-sm hover:shadow-md transition",children:[N.jsx("div",{className:"text-rose-600 mb-4",children:e}),N.jsx("h3",{className:"text-xl font-semibold mb-2",children:t}),N.jsx("p",{className:"text-gray-600",children:n})]}),pw=({title:e,image:t,icon:n})=>N.jsxs("div",{className:"group relative rounded-xl overflow-hidden shadow-lg hover:shadow-xl transition",children:[N.jsx("div",{className:"absolute inset-0 bg-gradient-to-t from-black/60 to-black/0 z-10"}),N.jsx("img",{src:t,alt:e,className:"w-full h-[300px] object-cover group-hover:scale-105 transition duration-300"}),N.jsx("div",{className:"absolute bottom-0 left-0 right-0 p-6 z-20",children:N.jsxs("div",{className:"flex items-center space-x-2 text-white",children:[N.jsx("div",{className:"bg-rose-600 p-2 rounded-full",children:n}),N.jsx("h3",{className:"text-xl font-semibold",children:e})]})})]}),PH=()=>{const{addItem:e}=Mm(),t=hd();return N.jsxs(N.Fragment,{children:[N.jsxs("div",{className:"relative h-[500px] bg-cover bg-center",style:{backgroundImage:'url("https://images.unsplash.com/photo-1528578950694-9f79b45a3397?auto=format&fit=crop&q=80")'},children:[N.jsx("div",{className:"absolute inset-0 bg-black bg-opacity-40"}),N.jsx("div",{className:"absolute inset-0 flex items-center justify-center",children:N.jsxs("div",{className:"text-center text-white",children:[N.jsx("h1",{className:"text-5xl font-bold mb-4",children:"Design Your Dream Fabric"}),N.jsx("p",{className:"text-xl mb-8",children:"Turn your creativity into beautiful custom fabrics"}),N.jsx("button",{onClick:()=>t("/design"),className:"bg-rose-600 text-white px-8 py-3 rounded-full hover:bg-rose-700 transition",children:"Start Designing"})]})})]}),N.jsx("div",{className:"bg-gray-50 py-16",children:N.jsx("div",{className:"max-w-7xl mx-auto px-4",children:N.jsxs("div",{className:"grid grid-cols-1 lg:grid-cols-2 gap-12 items-center",children:[N.jsxs("div",{className:"space-y-6",children:[N.jsx("div",{className:"inline-block bg-rose-100 text-rose-600 px-4 py-1 rounded-full text-sm font-semibold",children:"NEW"}),N.jsx("h2",{className:"text-4xl font-bold",children:"Extra-Wide Cotton Sateen Fabrics"}),N.jsx("p",{className:"text-lg text-gray-600 leading-relaxed",children:'With 116" (over 9½ feet!) of printed width, these two 100% cotton fabrics are perfect for large scale projects like bedding, table linens and quilt backings. Now available by the yard featuring your choice of any Spoonflower print.'}),N.jsxs("div",{className:"flex items-center space-x-4",children:[N.jsxs("div",{className:"flex items-center space-x-2 text-gray-600",children:[N.jsx(wH,{className:"h-5 w-5"}),N.jsx("span",{children:'116" Width'})]}),N.jsxs("div",{className:"flex items-center space-x-2 text-gray-600",children:[N.jsx(sk,{className:"h-5 w-5"}),N.jsx("span",{children:"100% Cotton"})]})]}),N.jsx("button",{onClick:()=>e({id:"cotton-sateen",name:"Extra-Wide Cotton Sateen Fabric",price:24.99,image:"https://images.unsplash.com/photo-1544367567-0f2fcb009e0b?auto=format&fit=crop&q=80"}),className:"bg-rose-600 text-white px-6 py-3 rounded-full hover:bg-rose-700 transition",children:"Shop Now"})]}),N.jsx("div",{className:"relative",children:N.jsx("img",{src:"https://images.unsplash.com/photo-1544367567-0f2fcb009e0b?auto=format&fit=crop&q=80",alt:"Extra-Wide Cotton Sateen Fabric",className:"rounded-lg shadow-xl"})})]})})}),N.jsxs("div",{className:"max-w-7xl mx-auto py-16 px-4",children:[N.jsx("h2",{className:"text-3xl font-bold mb-12 text-center",children:"Featured Collections"}),N.jsxs("div",{className:"grid grid-cols-1 md:grid-cols-3 gap-8",children:[N.jsx(pw,{title:"Custom Bedding",image:"https://images.unsplash.com/photo-1522771739844-6a9f6d5f14af?auto=format&fit=crop&q=80",icon:N.jsx(hH,{className:"h-6 w-6"})}),N.jsx(pw,{title:"Designer Prints",image:"https://images.unsplash.com/photo-1528458909336-e7a0adfed0a5?auto=format&fit=crop&q=80",icon:N.jsx(JR,{className:"h-6 w-6"})}),N.jsx(pw,{title:"Seasonal Fabrics",image:"https://images.unsplash.com/photo-1544365558-35aa4afcf11f?auto=format&fit=crop&q=80",icon:N.jsx(sk,{className:"h-6 w-6"})})]})]}),N.jsx("div",{className:"bg-gray py-12",children:N.jsx("div",{className:"max-w-7xl mx-auto px-4"})})]})},Ni={min:0,max:50},LH={min:0,max:100},IS={XS:{neck:13.75,chest:35,waist:29,hips:35,shoulder:16,sleeveLength:24,inseam:30,thigh:20,height:64},S:{neck:14.25,chest:37,waist:31,hips:37,shoulder:16.5,sleeveLength:24.5,inseam:31,thigh:21,height:66},M:{neck:14.75,chest:39,waist:33,hips:39,shoulder:17.5,sleeveLength:25.5,inseam:32,thigh:22,height:68},L:{neck:15.25,chest:41,waist:35,hips:41,shoulder:18.5,sleeveLength:26,inseam:33,thigh:23,height:70},XL:{neck:15.75,chest:43,waist:37,hips:43,shoulder:19.5,sleeveLength:26.5,inseam:34,thigh:24,height:72},"2XL":{neck:16.25,chest:45,waist:39,hips:45,shoulder:20.5,sleeveLength:27,inseam:35,thigh:25,height:74}};function BH(e,t){const n=ee.useRef();return ee.useCallback((...a)=>{n.current&&clearTimeout(n.current),n.current=setTimeout(()=>{e(...a)},t)},[e,t])}const rD=ee.memo(function({value:t,onChange:n,min:r,max:a,step:s,label:i,unit:o="",showValue:l=!0,debounceMs:c=150}){const u=ee.useRef(null),h=ee.useRef(null),d=ee.useRef(),[p,f]=ee.useState(t),[m,y]=ee.useState(!1),g=ee.useRef(t);ee.useEffect(()=>{m||(f(t),g.current=t)},[t,m]);const x=BH(n,c),b=ee.useCallback(()=>{d.current&&cancelAnimationFrame(d.current),d.current=requestAnimationFrame(()=>{if(h.current){const T=(p-r)/(a-r)*100;h.current.style.width=`${T}%`}})},[p,r,a]);ee.useEffect(()=>(b(),()=>{d.current&&cancelAnimationFrame(d.current)}),[b]);const v=ee.useCallback(T=>{const A=Math.min(Math.max(T,r),a);f(A),m?(x(A),g.current=A):n(A)},[r,a,m,n,x]),w=ee.useCallback(()=>{y(!1),g.current!==p&&n(p)},[p,n]),I=ee.useCallback(T=>{T.preventDefault(),y(!0);const A=F=>{if(u.current){const C=u.current.getBoundingClientRect(),D=Math.min(Math.max((F.clientX-C.left)/C.width,0),1),L=r+(a-r)*D,O=Math.round(L/s)*s;v(O)}},M=()=>{w(),document.removeEventListener("mousemove",A),document.removeEventListener("mouseup",M)};document.addEventListener("mousemove",A,{passive:!0}),document.addEventListener("mouseup",M)},[r,a,s,v,w]),_=ee.useCallback(T=>{T.preventDefault(),y(!0);const A=F=>{if(u.current&&F.touches[0]){const C=u.current.getBoundingClientRect(),D=Math.min(Math.max((F.touches[0].clientX-C.left)/C.width,0),1),L=r+(a-r)*D,O=Math.round(L/s)*s;v(O)}},M=()=>{w(),document.removeEventListener("touchmove",A),document.removeEventListener("touchend",M)};document.addEventListener("touchmove",A,{passive:!1}),document.addEventListener("touchend",M)},[r,a,s,v,w]);return N.jsxs("div",{className:"flex flex-col space-y-1",children:[i&&N.jsxs("div",{className:"flex justify-between items-center text-xs text-gray-600",children:[N.jsx("span",{children:i}),l&&N.jsxs("span",{className:"tabular-nums font-medium",children:[p.toFixed(1),o]})]}),N.jsxs("div",{className:"range-container relative h-6 flex items-center cursor-pointer touch-none",onMouseDown:I,onTouchStart:_,children:[N.jsx("div",{className:"absolute inset-0 h-1 bg-gray-200 rounded-full",children:N.jsx("div",{ref:h,className:"absolute h-full bg-rose-600 rounded-full",style:{willChange:"width"}})}),N.jsx("input",{ref:u,type:"range",value:p,onChange:T=>v(parseFloat(T.target.value)),min:r,max:a,step:s,className:"absolute w-full h-full opacity-0 cursor-pointer touch-none"}),N.jsx("div",{className:"absolute w-4 h-4 bg-white border-2 border-rose-600 rounded-full shadow transform -translate-x-1/2 hover:scale-110 active:scale-95 transition-transform",style:{left:`${(p-r)/(a-r)*100}%`,willChange:"transform",transform:`translateX(-50%) ${m?"scale(1.1)":""}`,transition:m?"none":"all 0.1s ease"}})]})]})});function aD({title:e,defaultOpen:t=!0,children:n,onStateChange:r}){const[a,s]=ee.useState(t),i=ee.useRef(null),[o,l]=ee.useState("auto");ee.useEffect(()=>{if(i.current){const u=i.current.scrollHeight;l(`${u}px`)}},[n]);const c=()=>{const u=!a;s(u),r&&r(u)};return N.jsxs("div",{className:"settings-section",children:[N.jsxs("div",{className:"section-header",onClick:c,children:[N.jsx("h2",{className:"section-title",children:e}),N.jsx("span",{className:`section-toggle ${a?"open":""}`,children:"▼"})]}),N.jsx("div",{ref:i,className:`section-content ${a?"":"closed"}`,style:{maxHeight:a?o:"0"},children:n})]})}function WH({settings:e,onSettingsChange:t,onStateChange:n}){return N.jsx(aD,{title:"Basic",defaultOpen:!0,onStateChange:n,children:N.jsxs("div",{className:"setting-fields",children:[N.jsxs("div",{className:"setting-field",children:[N.jsx("label",{children:"Type"}),N.jsxs("select",{value:e.itemType,onChange:r=>t({...e,itemType:r.target.value}),className:"compact-input",children:[N.jsx("option",{value:"T-shirt",children:"T-Shirt"}),N.jsx("option",{value:"Pants",children:"Pants"}),N.jsx("option",{value:"Full Body",children:"Full Body"})]})]}),N.jsxs("div",{className:"setting-field",children:[N.jsx("label",{children:"Size"}),N.jsxs("select",{value:e.standardSize,onChange:r=>{const a=r.target.value;t({...e,standardSize:a,measurements:IS[a]})},className:"compact-input",children:[N.jsx("option",{value:"XS",children:"XS"}),N.jsx("option",{value:"S",children:"S"}),N.jsx("option",{value:"M",children:"M"}),N.jsx("option",{value:"L",children:"L"}),N.jsx("option",{value:"XL",children:"XL"}),N.jsx("option",{value:"2XL",children:"2XL"})]})]}),N.jsxs("div",{className:"setting-field",children:[N.jsx("label",{children:"Color"}),N.jsxs("div",{className:"flex items-center gap-1",children:[N.jsx("input",{type:"color",value:e.color,onChange:r=>t({...e,color:r.target.value}),className:"w-6 h-6 rounded cursor-pointer"}),N.jsx("span",{className:"text-xs text-gray-600",children:e.color.toUpperCase()})]})]}),N.jsxs("div",{className:"setting-field",children:[N.jsx("label",{children:"Zoom"}),N.jsx(rD,{value:e.zoom??1,min:.5,max:2,step:.1,onChange:r=>t({...e,zoom:r})}),"        "]})]})})}function UH({measurements:e,itemType:t,onMeasurementChange:n,onStateChange:r}){const a=()=>{const s=[{key:"neck",label:"Neck (inches)",range:Ni},{key:"chest",label:"Chest (inches)",range:Ni},{key:"waist",label:"Waist (inches)",range:Ni},{key:"hips",label:"Hips (inches)",range:Ni}],i=[{key:"shoulder",label:"Shoulder Width (inches)",range:Ni},{key:"sleeveLength",label:"Sleeve Length (inches)",range:Ni}],o=[{key:"inseam",label:"Inseam Length (inches)",range:Ni},{key:"thigh",label:"Thigh Circumference (inches)",range:Ni}],l={key:"height",label:"Height (inches)",range:LH};switch(t){case"Full Body":return[...s,...i,...o,l];case"T-shirt":return[...s,...i];case"Pants":return[...s,...o];default:return s}};return N.jsx(aD,{title:"Measurements",defaultOpen:!0,onStateChange:r,children:N.jsxs("div",{className:"setting-fields",children:[a().map(s=>{var i,o;return N.jsx("div",{className:"setting-field",children:N.jsx(rD,{value:e[s.key]||0,onChange:l=>n(s.key,l),min:((i=s.range)==null?void 0:i.min)||0,max:((o=s.range)==null?void 0:o.max)||50,step:.5,label:s.label,unit:" in",showValue:!0})},s.key)}),"      "]})})}const VH=ee.memo(function({settings:t,isPanelOpen:n,onPanelToggle:r,onSettingsChange:a,onMeasurementChange:s}){const i=ee.useRef(null),o=ee.useRef(0),l=ee.useRef(0),[c,u]=ee.useState(!1),[h,d]=ee.useState({basic:!0,measurements:!0}),p=b=>v=>{d(w=>({...w,[b]:v}))},f=!h.basic&&!h.measurements,m=h.basic&&!h.measurements||!h.basic&&h.measurements,y=ee.useCallback(b=>{i.current&&(o.current=b.touches[0].clientY,l.current=i.current.getBoundingClientRect().top,u(!0))},[]),g=ee.useCallback(b=>{if(!c||!i.current)return;const v=b.touches[0].clientY-o.current;l.current+v,(n&&v>0||!n&&v<0)&&(i.current.style.transform=`translateY(${v}px)`,b.preventDefault())},[c,n]),x=ee.useCallback(b=>{if(!c||!i.current)return;const v=b.changedTouches[0].clientY-o.current;Math.abs(v)>75&&(n&&v>0||!n&&v<0)&&r(),i.current.style.transform="",u(!1)},[c,n,r]);return ee.useEffect(()=>{const b=i.current;if(b)return b.addEventListener("touchstart",y,{passive:!1}),document.addEventListener("touchmove",g,{passive:!1}),document.addEventListener("touchend",x),()=>{b.removeEventListener("touchstart",y),document.removeEventListener("touchmove",g),document.removeEventListener("touchend",x)}},[y,g,x]),N.jsxs("div",{ref:i,className:`design-settings ${n?"open":"closed"} ${f?"all-collapsed":m?"one-collapsed":""}`,style:{touchAction:c?"none":"pan-y",transition:c?"none":void 0},children:[N.jsxs("div",{className:"settings-header",children:[N.jsx("span",{className:"text-sm font-semibold text-gray-900",children:"Settings"}),N.jsx("button",{className:"toggle-button",onClick:r,"aria-label":n?"Hide Settings":"Show Settings",children:N.jsx("span",{className:"toggle-icon",children:n?"▼":"▲"})})]}),N.jsxs("div",{className:`settings-content ${n?"":"invisible"}`,children:[N.jsx(WH,{settings:t,onSettingsChange:a,onStateChange:p("basic")}),N.jsx(UH,{measurements:t.measurements,itemType:t.itemType,onMeasurementChange:s,onStateChange:p("measurements")})]})]})});/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const NS="177",ik=0,jH=1,_S=2,GE=1,HE=100,qE=204,KE=205,XE=3,GH=0,sD=300,ok=1e3,kl=1001,lk=1002,HH=1003,qH=1004,KH=1005,Xx=1006,XH=1007,CS=1008,ZH=1008,iD=1009,YH=1015,oD=1023,JH=2300,QH=2301,e8=0,TS="",fr="srgb",ZE="srgb-linear",YE="linear",fw="srgb",jc=7680,JE=519,QE=35044,Sl=2e3,uk=2001;class Zx{addEventListener(t,n){this._listeners===void 0&&(this._listeners={});const r=this._listeners;r[t]===void 0&&(r[t]=[]),r[t].indexOf(n)===-1&&r[t].push(n)}hasEventListener(t,n){const r=this._listeners;return r===void 0?!1:r[t]!==void 0&&r[t].indexOf(n)!==-1}removeEventListener(t,n){const r=this._listeners;if(r===void 0)return;const a=r[t];if(a!==void 0){const s=a.indexOf(n);s!==-1&&a.splice(s,1)}}dispatchEvent(t){const n=this._listeners;if(n===void 0)return;const r=n[t.type];if(r!==void 0){t.target=this;const a=r.slice(0);for(let s=0,i=a.length;s<i;s++)a[s].call(this,t);t.target=null}}}const Hn=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let eA=1234567;const Ff=Math.PI/180,Y0=180/Math.PI;function dd(){const e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,n=Math.random()*4294967295|0,r=Math.random()*4294967295|0;return(Hn[e&255]+Hn[e>>8&255]+Hn[e>>16&255]+Hn[e>>24&255]+"-"+Hn[t&255]+Hn[t>>8&255]+"-"+Hn[t>>16&15|64]+Hn[t>>24&255]+"-"+Hn[n&63|128]+Hn[n>>8&255]+"-"+Hn[n>>16&255]+Hn[n>>24&255]+Hn[r&255]+Hn[r>>8&255]+Hn[r>>16&255]+Hn[r>>24&255]).toLowerCase()}function Qe(e,t,n){return Math.max(t,Math.min(n,e))}function ES(e,t){return(e%t+t)%t}function t8(e,t,n,r,a){return r+(e-t)*(a-r)/(n-t)}function n8(e,t,n){return e!==t?(n-e)/(t-e):0}function Rf(e,t,n){return(1-n)*e+n*t}function r8(e,t,n,r){return Rf(e,t,1-Math.exp(-n*r))}function a8(e,t=1){return t-Math.abs(ES(e,t*2)-t)}function s8(e,t,n){return e<=t?0:e>=n?1:(e=(e-t)/(n-t),e*e*(3-2*e))}function i8(e,t,n){return e<=t?0:e>=n?1:(e=(e-t)/(n-t),e*e*e*(e*(e*6-15)+10))}function o8(e,t){return e+Math.floor(Math.random()*(t-e+1))}function l8(e,t){return e+Math.random()*(t-e)}function u8(e){return e*(.5-Math.random())}function c8(e){e!==void 0&&(eA=e);let t=eA+=1831565813;return t=Math.imul(t^t>>>15,t|1),t^=t+Math.imul(t^t>>>7,t|61),((t^t>>>14)>>>0)/4294967296}function h8(e){return e*Ff}function d8(e){return e*Y0}function p8(e){return(e&e-1)===0&&e!==0}function f8(e){return Math.pow(2,Math.ceil(Math.log(e)/Math.LN2))}function m8(e){return Math.pow(2,Math.floor(Math.log(e)/Math.LN2))}function g8(e,t,n,r,a){const s=Math.cos,i=Math.sin,o=s(n/2),l=i(n/2),c=s((t+r)/2),u=i((t+r)/2),h=s((t-r)/2),d=i((t-r)/2),p=s((r-t)/2),f=i((r-t)/2);switch(a){case"XYX":e.set(o*u,l*h,l*d,o*c);break;case"YZY":e.set(l*d,o*u,l*h,o*c);break;case"ZXZ":e.set(l*h,l*d,o*u,o*c);break;case"XZX":e.set(o*u,l*f,l*p,o*c);break;case"YXY":e.set(l*p,o*u,l*f,o*c);break;case"ZYZ":e.set(l*f,l*p,o*u,o*c);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+a)}}function ih(e,t){switch(t.constructor){case Float32Array:return e;case Uint32Array:return e/4294967295;case Uint16Array:return e/65535;case Uint8Array:return e/255;case Int32Array:return Math.max(e/2147483647,-1);case Int16Array:return Math.max(e/32767,-1);case Int8Array:return Math.max(e/127,-1);default:throw new Error("Invalid component type.")}}function dr(e,t){switch(t.constructor){case Float32Array:return e;case Uint32Array:return Math.round(e*4294967295);case Uint16Array:return Math.round(e*65535);case Uint8Array:return Math.round(e*255);case Int32Array:return Math.round(e*2147483647);case Int16Array:return Math.round(e*32767);case Int8Array:return Math.round(e*127);default:throw new Error("Invalid component type.")}}const ck={DEG2RAD:Ff,RAD2DEG:Y0,generateUUID:dd,clamp:Qe,euclideanModulo:ES,mapLinear:t8,inverseLerp:n8,lerp:Rf,damp:r8,pingpong:a8,smoothstep:s8,smootherstep:i8,randInt:o8,randFloat:l8,randFloatSpread:u8,seededRandom:c8,degToRad:h8,radToDeg:d8,isPowerOfTwo:p8,ceilPowerOfTwo:f8,floorPowerOfTwo:m8,setQuaternionFromProperEuler:g8,normalize:dr,denormalize:ih};class Qn{constructor(t=0,n=0){Qn.prototype.isVector2=!0,this.x=t,this.y=n}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,n){return this.x=t,this.y=n,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,n){switch(t){case 0:this.x=n;break;case 1:this.y=n;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,n){return this.x=t.x+n.x,this.y=t.y+n.y,this}addScaledVector(t,n){return this.x+=t.x*n,this.y+=t.y*n,this}sub(t){return this.x-=t.x,this.y-=t.y,this}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,n){return this.x=t.x-n.x,this.y=t.y-n.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const n=this.x,r=this.y,a=t.elements;return this.x=a[0]*n+a[3]*r+a[6],this.y=a[1]*n+a[4]*r+a[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,n){return this.x=Qe(this.x,t.x,n.x),this.y=Qe(this.y,t.y,n.y),this}clampScalar(t,n){return this.x=Qe(this.x,t,n),this.y=Qe(this.y,t,n),this}clampLength(t,n){const r=this.length();return this.divideScalar(r||1).multiplyScalar(Qe(r,t,n))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(t){const n=Math.sqrt(this.lengthSq()*t.lengthSq());if(n===0)return Math.PI/2;const r=this.dot(t)/n;return Math.acos(Qe(r,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const n=this.x-t.x,r=this.y-t.y;return n*n+r*r}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,n){return this.x+=(t.x-this.x)*n,this.y+=(t.y-this.y)*n,this}lerpVectors(t,n,r){return this.x=t.x+(n.x-t.x)*r,this.y=t.y+(n.y-t.y)*r,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,n=0){return this.x=t[n],this.y=t[n+1],this}toArray(t=[],n=0){return t[n]=this.x,t[n+1]=this.y,t}fromBufferAttribute(t,n){return this.x=t.getX(n),this.y=t.getY(n),this}rotateAround(t,n){const r=Math.cos(n),a=Math.sin(n),s=this.x-t.x,i=this.y-t.y;return this.x=s*r-i*a+t.x,this.y=s*a+i*r+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class pd{constructor(t=0,n=0,r=0,a=1){this.isQuaternion=!0,this._x=t,this._y=n,this._z=r,this._w=a}static slerpFlat(t,n,r,a,s,i,o){let l=r[a+0],c=r[a+1],u=r[a+2],h=r[a+3];const d=s[i+0],p=s[i+1],f=s[i+2],m=s[i+3];if(o===0){t[n+0]=l,t[n+1]=c,t[n+2]=u,t[n+3]=h;return}if(o===1){t[n+0]=d,t[n+1]=p,t[n+2]=f,t[n+3]=m;return}if(h!==m||l!==d||c!==p||u!==f){let y=1-o;const g=l*d+c*p+u*f+h*m,x=g>=0?1:-1,b=1-g*g;if(b>Number.EPSILON){const w=Math.sqrt(b),I=Math.atan2(w,g*x);y=Math.sin(y*I)/w,o=Math.sin(o*I)/w}const v=o*x;if(l=l*y+d*v,c=c*y+p*v,u=u*y+f*v,h=h*y+m*v,y===1-o){const w=1/Math.sqrt(l*l+c*c+u*u+h*h);l*=w,c*=w,u*=w,h*=w}}t[n]=l,t[n+1]=c,t[n+2]=u,t[n+3]=h}static multiplyQuaternionsFlat(t,n,r,a,s,i){const o=r[a],l=r[a+1],c=r[a+2],u=r[a+3],h=s[i],d=s[i+1],p=s[i+2],f=s[i+3];return t[n]=o*f+u*h+l*p-c*d,t[n+1]=l*f+u*d+c*h-o*p,t[n+2]=c*f+u*p+o*d-l*h,t[n+3]=u*f-o*h-l*d-c*p,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,n,r,a){return this._x=t,this._y=n,this._z=r,this._w=a,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,n=!0){const r=t._x,a=t._y,s=t._z,i=t._order,o=Math.cos,l=Math.sin,c=o(r/2),u=o(a/2),h=o(s/2),d=l(r/2),p=l(a/2),f=l(s/2);switch(i){case"XYZ":this._x=d*u*h+c*p*f,this._y=c*p*h-d*u*f,this._z=c*u*f+d*p*h,this._w=c*u*h-d*p*f;break;case"YXZ":this._x=d*u*h+c*p*f,this._y=c*p*h-d*u*f,this._z=c*u*f-d*p*h,this._w=c*u*h+d*p*f;break;case"ZXY":this._x=d*u*h-c*p*f,this._y=c*p*h+d*u*f,this._z=c*u*f+d*p*h,this._w=c*u*h-d*p*f;break;case"ZYX":this._x=d*u*h-c*p*f,this._y=c*p*h+d*u*f,this._z=c*u*f-d*p*h,this._w=c*u*h+d*p*f;break;case"YZX":this._x=d*u*h+c*p*f,this._y=c*p*h+d*u*f,this._z=c*u*f-d*p*h,this._w=c*u*h-d*p*f;break;case"XZY":this._x=d*u*h-c*p*f,this._y=c*p*h-d*u*f,this._z=c*u*f+d*p*h,this._w=c*u*h+d*p*f;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+i)}return n===!0&&this._onChangeCallback(),this}setFromAxisAngle(t,n){const r=n/2,a=Math.sin(r);return this._x=t.x*a,this._y=t.y*a,this._z=t.z*a,this._w=Math.cos(r),this._onChangeCallback(),this}setFromRotationMatrix(t){const n=t.elements,r=n[0],a=n[4],s=n[8],i=n[1],o=n[5],l=n[9],c=n[2],u=n[6],h=n[10],d=r+o+h;if(d>0){const p=.5/Math.sqrt(d+1);this._w=.25/p,this._x=(u-l)*p,this._y=(s-c)*p,this._z=(i-a)*p}else if(r>o&&r>h){const p=2*Math.sqrt(1+r-o-h);this._w=(u-l)/p,this._x=.25*p,this._y=(a+i)/p,this._z=(s+c)/p}else if(o>h){const p=2*Math.sqrt(1+o-r-h);this._w=(s-c)/p,this._x=(a+i)/p,this._y=.25*p,this._z=(l+u)/p}else{const p=2*Math.sqrt(1+h-r-o);this._w=(i-a)/p,this._x=(s+c)/p,this._y=(l+u)/p,this._z=.25*p}return this._onChangeCallback(),this}setFromUnitVectors(t,n){let r=t.dot(n)+1;return r<Number.EPSILON?(r=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=r):(this._x=0,this._y=-t.z,this._z=t.y,this._w=r)):(this._x=t.y*n.z-t.z*n.y,this._y=t.z*n.x-t.x*n.z,this._z=t.x*n.y-t.y*n.x,this._w=r),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(Qe(this.dot(t),-1,1)))}rotateTowards(t,n){const r=this.angleTo(t);if(r===0)return this;const a=Math.min(1,n/r);return this.slerp(t,a),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return t===0?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t){return this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,n){const r=t._x,a=t._y,s=t._z,i=t._w,o=n._x,l=n._y,c=n._z,u=n._w;return this._x=r*u+i*o+a*c-s*l,this._y=a*u+i*l+s*o-r*c,this._z=s*u+i*c+r*l-a*o,this._w=i*u-r*o-a*l-s*c,this._onChangeCallback(),this}slerp(t,n){if(n===0)return this;if(n===1)return this.copy(t);const r=this._x,a=this._y,s=this._z,i=this._w;let o=i*t._w+r*t._x+a*t._y+s*t._z;if(o<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,o=-o):this.copy(t),o>=1)return this._w=i,this._x=r,this._y=a,this._z=s,this;const l=1-o*o;if(l<=Number.EPSILON){const p=1-n;return this._w=p*i+n*this._w,this._x=p*r+n*this._x,this._y=p*a+n*this._y,this._z=p*s+n*this._z,this.normalize(),this}const c=Math.sqrt(l),u=Math.atan2(c,o),h=Math.sin((1-n)*u)/c,d=Math.sin(n*u)/c;return this._w=i*h+this._w*d,this._x=r*h+this._x*d,this._y=a*h+this._y*d,this._z=s*h+this._z*d,this._onChangeCallback(),this}slerpQuaternions(t,n,r){return this.copy(t).slerp(n,r)}random(){const t=2*Math.PI*Math.random(),n=2*Math.PI*Math.random(),r=Math.random(),a=Math.sqrt(1-r),s=Math.sqrt(r);return this.set(a*Math.sin(t),a*Math.cos(t),s*Math.sin(n),s*Math.cos(n))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,n=0){return this._x=t[n],this._y=t[n+1],this._z=t[n+2],this._w=t[n+3],this._onChangeCallback(),this}toArray(t=[],n=0){return t[n]=this._x,t[n+1]=this._y,t[n+2]=this._z,t[n+3]=this._w,t}fromBufferAttribute(t,n){return this._x=t.getX(n),this._y=t.getY(n),this._z=t.getZ(n),this._w=t.getW(n),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class ie{constructor(t=0,n=0,r=0){ie.prototype.isVector3=!0,this.x=t,this.y=n,this.z=r}set(t,n,r){return r===void 0&&(r=this.z),this.x=t,this.y=n,this.z=r,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,n){switch(t){case 0:this.x=n;break;case 1:this.y=n;break;case 2:this.z=n;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,n){return this.x=t.x+n.x,this.y=t.y+n.y,this.z=t.z+n.z,this}addScaledVector(t,n){return this.x+=t.x*n,this.y+=t.y*n,this.z+=t.z*n,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,n){return this.x=t.x-n.x,this.y=t.y-n.y,this.z=t.z-n.z,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,n){return this.x=t.x*n.x,this.y=t.y*n.y,this.z=t.z*n.z,this}applyEuler(t){return this.applyQuaternion(tA.setFromEuler(t))}applyAxisAngle(t,n){return this.applyQuaternion(tA.setFromAxisAngle(t,n))}applyMatrix3(t){const n=this.x,r=this.y,a=this.z,s=t.elements;return this.x=s[0]*n+s[3]*r+s[6]*a,this.y=s[1]*n+s[4]*r+s[7]*a,this.z=s[2]*n+s[5]*r+s[8]*a,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const n=this.x,r=this.y,a=this.z,s=t.elements,i=1/(s[3]*n+s[7]*r+s[11]*a+s[15]);return this.x=(s[0]*n+s[4]*r+s[8]*a+s[12])*i,this.y=(s[1]*n+s[5]*r+s[9]*a+s[13])*i,this.z=(s[2]*n+s[6]*r+s[10]*a+s[14])*i,this}applyQuaternion(t){const n=this.x,r=this.y,a=this.z,s=t.x,i=t.y,o=t.z,l=t.w,c=2*(i*a-o*r),u=2*(o*n-s*a),h=2*(s*r-i*n);return this.x=n+l*c+i*h-o*u,this.y=r+l*u+o*c-s*h,this.z=a+l*h+s*u-i*c,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const n=this.x,r=this.y,a=this.z,s=t.elements;return this.x=s[0]*n+s[4]*r+s[8]*a,this.y=s[1]*n+s[5]*r+s[9]*a,this.z=s[2]*n+s[6]*r+s[10]*a,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,n){return this.x=Qe(this.x,t.x,n.x),this.y=Qe(this.y,t.y,n.y),this.z=Qe(this.z,t.z,n.z),this}clampScalar(t,n){return this.x=Qe(this.x,t,n),this.y=Qe(this.y,t,n),this.z=Qe(this.z,t,n),this}clampLength(t,n){const r=this.length();return this.divideScalar(r||1).multiplyScalar(Qe(r,t,n))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,n){return this.x+=(t.x-this.x)*n,this.y+=(t.y-this.y)*n,this.z+=(t.z-this.z)*n,this}lerpVectors(t,n,r){return this.x=t.x+(n.x-t.x)*r,this.y=t.y+(n.y-t.y)*r,this.z=t.z+(n.z-t.z)*r,this}cross(t){return this.crossVectors(this,t)}crossVectors(t,n){const r=t.x,a=t.y,s=t.z,i=n.x,o=n.y,l=n.z;return this.x=a*l-s*o,this.y=s*i-r*l,this.z=r*o-a*i,this}projectOnVector(t){const n=t.lengthSq();if(n===0)return this.set(0,0,0);const r=t.dot(this)/n;return this.copy(t).multiplyScalar(r)}projectOnPlane(t){return mw.copy(this).projectOnVector(t),this.sub(mw)}reflect(t){return this.sub(mw.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const n=Math.sqrt(this.lengthSq()*t.lengthSq());if(n===0)return Math.PI/2;const r=this.dot(t)/n;return Math.acos(Qe(r,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const n=this.x-t.x,r=this.y-t.y,a=this.z-t.z;return n*n+r*r+a*a}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,n,r){const a=Math.sin(n)*t;return this.x=a*Math.sin(r),this.y=Math.cos(n)*t,this.z=a*Math.cos(r),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,n,r){return this.x=t*Math.sin(n),this.y=r,this.z=t*Math.cos(n),this}setFromMatrixPosition(t){const n=t.elements;return this.x=n[12],this.y=n[13],this.z=n[14],this}setFromMatrixScale(t){const n=this.setFromMatrixColumn(t,0).length(),r=this.setFromMatrixColumn(t,1).length(),a=this.setFromMatrixColumn(t,2).length();return this.x=n,this.y=r,this.z=a,this}setFromMatrixColumn(t,n){return this.fromArray(t.elements,n*4)}setFromMatrix3Column(t,n){return this.fromArray(t.elements,n*3)}setFromEuler(t){return this.x=t._x,this.y=t._y,this.z=t._z,this}setFromColor(t){return this.x=t.r,this.y=t.g,this.z=t.b,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,n=0){return this.x=t[n],this.y=t[n+1],this.z=t[n+2],this}toArray(t=[],n=0){return t[n]=this.x,t[n+1]=this.y,t[n+2]=this.z,t}fromBufferAttribute(t,n){return this.x=t.getX(n),this.y=t.getY(n),this.z=t.getZ(n),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=Math.random()*Math.PI*2,n=Math.random()*2-1,r=Math.sqrt(1-n*n);return this.x=r*Math.cos(t),this.y=n,this.z=r*Math.sin(t),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const mw=new ie,tA=new pd;class di{constructor(t,n,r,a,s,i,o,l,c){di.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],t!==void 0&&this.set(t,n,r,a,s,i,o,l,c)}set(t,n,r,a,s,i,o,l,c){const u=this.elements;return u[0]=t,u[1]=a,u[2]=o,u[3]=n,u[4]=s,u[5]=l,u[6]=r,u[7]=i,u[8]=c,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const n=this.elements,r=t.elements;return n[0]=r[0],n[1]=r[1],n[2]=r[2],n[3]=r[3],n[4]=r[4],n[5]=r[5],n[6]=r[6],n[7]=r[7],n[8]=r[8],this}extractBasis(t,n,r){return t.setFromMatrix3Column(this,0),n.setFromMatrix3Column(this,1),r.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const n=t.elements;return this.set(n[0],n[4],n[8],n[1],n[5],n[9],n[2],n[6],n[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,n){const r=t.elements,a=n.elements,s=this.elements,i=r[0],o=r[3],l=r[6],c=r[1],u=r[4],h=r[7],d=r[2],p=r[5],f=r[8],m=a[0],y=a[3],g=a[6],x=a[1],b=a[4],v=a[7],w=a[2],I=a[5],_=a[8];return s[0]=i*m+o*x+l*w,s[3]=i*y+o*b+l*I,s[6]=i*g+o*v+l*_,s[1]=c*m+u*x+h*w,s[4]=c*y+u*b+h*I,s[7]=c*g+u*v+h*_,s[2]=d*m+p*x+f*w,s[5]=d*y+p*b+f*I,s[8]=d*g+p*v+f*_,this}multiplyScalar(t){const n=this.elements;return n[0]*=t,n[3]*=t,n[6]*=t,n[1]*=t,n[4]*=t,n[7]*=t,n[2]*=t,n[5]*=t,n[8]*=t,this}determinant(){const t=this.elements,n=t[0],r=t[1],a=t[2],s=t[3],i=t[4],o=t[5],l=t[6],c=t[7],u=t[8];return n*i*u-n*o*c-r*s*u+r*o*l+a*s*c-a*i*l}invert(){const t=this.elements,n=t[0],r=t[1],a=t[2],s=t[3],i=t[4],o=t[5],l=t[6],c=t[7],u=t[8],h=u*i-o*c,d=o*l-u*s,p=c*s-i*l,f=n*h+r*d+a*p;if(f===0)return this.set(0,0,0,0,0,0,0,0,0);const m=1/f;return t[0]=h*m,t[1]=(a*c-u*r)*m,t[2]=(o*r-a*i)*m,t[3]=d*m,t[4]=(u*n-a*l)*m,t[5]=(a*s-o*n)*m,t[6]=p*m,t[7]=(r*l-c*n)*m,t[8]=(i*n-r*s)*m,this}transpose(){let t;const n=this.elements;return t=n[1],n[1]=n[3],n[3]=t,t=n[2],n[2]=n[6],n[6]=t,t=n[5],n[5]=n[7],n[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const n=this.elements;return t[0]=n[0],t[1]=n[3],t[2]=n[6],t[3]=n[1],t[4]=n[4],t[5]=n[7],t[6]=n[2],t[7]=n[5],t[8]=n[8],this}setUvTransform(t,n,r,a,s,i,o){const l=Math.cos(s),c=Math.sin(s);return this.set(r*l,r*c,-r*(l*i+c*o)+i+t,-a*c,a*l,-a*(-c*i+l*o)+o+n,0,0,1),this}scale(t,n){return this.premultiply(gw.makeScale(t,n)),this}rotate(t){return this.premultiply(gw.makeRotation(-t)),this}translate(t,n){return this.premultiply(gw.makeTranslation(t,n)),this}makeTranslation(t,n){return t.isVector2?this.set(1,0,t.x,0,1,t.y,0,0,1):this.set(1,0,t,0,1,n,0,0,1),this}makeRotation(t){const n=Math.cos(t),r=Math.sin(t);return this.set(n,-r,0,r,n,0,0,0,1),this}makeScale(t,n){return this.set(t,0,0,0,n,0,0,0,1),this}equals(t){const n=this.elements,r=t.elements;for(let a=0;a<9;a++)if(n[a]!==r[a])return!1;return!0}fromArray(t,n=0){for(let r=0;r<9;r++)this.elements[r]=t[r+n];return this}toArray(t=[],n=0){const r=this.elements;return t[n]=r[0],t[n+1]=r[1],t[n+2]=r[2],t[n+3]=r[3],t[n+4]=r[4],t[n+5]=r[5],t[n+6]=r[6],t[n+7]=r[7],t[n+8]=r[8],t}clone(){return new this.constructor().fromArray(this.elements)}}const gw=new di;function y8(e){for(let t=e.length-1;t>=0;--t)if(e[t]>=65535)return!0;return!1}function hk(e){return document.createElementNS("http://www.w3.org/1999/xhtml",e)}const nA={};function rA(e){e in nA||(nA[e]=!0,console.warn(e))}const aA=new di().set(.4123908,.3575843,.1804808,.212639,.7151687,.0721923,.0193308,.1191948,.9505322),sA=new di().set(3.2409699,-1.5373832,-.4986108,-.9692436,1.8759675,.0415551,.0556301,-.203977,1.0569715);function x8(){const e={enabled:!0,workingColorSpace:ZE,spaces:{},convert:function(a,s,i){return this.enabled===!1||s===i||!s||!i||(this.spaces[s].transfer===fw&&(a.r=ei(a.r),a.g=ei(a.g),a.b=ei(a.b)),this.spaces[s].primaries!==this.spaces[i].primaries&&(a.applyMatrix3(this.spaces[s].toXYZ),a.applyMatrix3(this.spaces[i].fromXYZ)),this.spaces[i].transfer===fw&&(a.r=Eh(a.r),a.g=Eh(a.g),a.b=Eh(a.b))),a},workingToColorSpace:function(a,s){return this.convert(a,this.workingColorSpace,s)},colorSpaceToWorking:function(a,s){return this.convert(a,s,this.workingColorSpace)},getPrimaries:function(a){return this.spaces[a].primaries},getTransfer:function(a){return a===TS?YE:this.spaces[a].transfer},getLuminanceCoefficients:function(a,s=this.workingColorSpace){return a.fromArray(this.spaces[s].luminanceCoefficients)},define:function(a){Object.assign(this.spaces,a)},_getMatrix:function(a,s,i){return a.copy(this.spaces[s].toXYZ).multiply(this.spaces[i].fromXYZ)},_getDrawingBufferColorSpace:function(a){return this.spaces[a].outputColorSpaceConfig.drawingBufferColorSpace},_getUnpackColorSpace:function(a=this.workingColorSpace){return this.spaces[a].workingColorSpaceConfig.unpackColorSpace},fromWorkingColorSpace:function(a,s){return rA("THREE.ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace()."),e.workingToColorSpace(a,s)},toWorkingColorSpace:function(a,s){return rA("THREE.ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking()."),e.colorSpaceToWorking(a,s)}},t=[.64,.33,.3,.6,.15,.06],n=[.2126,.7152,.0722],r=[.3127,.329];return e.define({[ZE]:{primaries:t,whitePoint:r,transfer:YE,toXYZ:aA,fromXYZ:sA,luminanceCoefficients:n,workingColorSpaceConfig:{unpackColorSpace:fr},outputColorSpaceConfig:{drawingBufferColorSpace:fr}},[fr]:{primaries:t,whitePoint:r,transfer:fw,toXYZ:aA,fromXYZ:sA,luminanceCoefficients:n,outputColorSpaceConfig:{drawingBufferColorSpace:fr}}}),e}const Oa=x8();function ei(e){return e<.04045?e*.0773993808:Math.pow(e*.9478672986+.0521327014,2.4)}function Eh(e){return e<.0031308?e*12.92:1.055*Math.pow(e,.41666)-.055}let Gc;class lD{static getDataURL(t,n="image/png"){if(/^data:/i.test(t.src)||typeof HTMLCanvasElement>"u")return t.src;let r;if(t instanceof HTMLCanvasElement)r=t;else{Gc===void 0&&(Gc=hk("canvas")),Gc.width=t.width,Gc.height=t.height;const a=Gc.getContext("2d");t instanceof ImageData?a.putImageData(t,0,0):a.drawImage(t,0,0,t.width,t.height),r=Gc}return r.toDataURL(n)}static sRGBToLinear(t){if(typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&t instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&t instanceof ImageBitmap){const n=hk("canvas");n.width=t.width,n.height=t.height;const r=n.getContext("2d");r.drawImage(t,0,0,t.width,t.height);const a=r.getImageData(0,0,t.width,t.height),s=a.data;for(let i=0;i<s.length;i++)s[i]=ei(s[i]/255)*255;return r.putImageData(a,0,0),n}else if(t.data){const n=t.data.slice(0);for(let r=0;r<n.length;r++)n instanceof Uint8Array||n instanceof Uint8ClampedArray?n[r]=Math.floor(ei(n[r]/255)*255):n[r]=ei(n[r]);return{data:n,width:t.width,height:t.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),t}}let b8=0;class uD{constructor(t=null){this.isSource=!0,Object.defineProperty(this,"id",{value:b8++}),this.uuid=dd(),this.data=t,this.dataReady=!0,this.version=0}getSize(t){const n=this.data;return n instanceof HTMLVideoElement?t.set(n.videoWidth,n.videoHeight):n!==null?t.set(n.width,n.height,n.depth||0):t.set(0,0,0),t}set needsUpdate(t){t===!0&&this.version++}toJSON(t){const n=t===void 0||typeof t=="string";if(!n&&t.images[this.uuid]!==void 0)return t.images[this.uuid];const r={uuid:this.uuid,url:""},a=this.data;if(a!==null){let s;if(Array.isArray(a)){s=[];for(let i=0,o=a.length;i<o;i++)a[i].isDataTexture?s.push(yw(a[i].image)):s.push(yw(a[i]))}else s=yw(a);r.url=s}return n||(t.images[this.uuid]=r),r}}function yw(e){return typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap?lD.getDataURL(e):e.data?{data:Array.from(e.data),width:e.width,height:e.height,type:e.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let v8=0;const xw=new ie;class ti extends Zx{constructor(t=ti.DEFAULT_IMAGE,n=ti.DEFAULT_MAPPING,r=kl,a=kl,s=Xx,i=CS,o=oD,l=iD,c=ti.DEFAULT_ANISOTROPY,u=TS){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:v8++}),this.uuid=dd(),this.name="",this.source=new uD(t),this.mipmaps=[],this.mapping=n,this.channel=0,this.wrapS=r,this.wrapT=a,this.magFilter=s,this.minFilter=i,this.anisotropy=c,this.format=o,this.internalFormat=null,this.type=l,this.offset=new Qn(0,0),this.repeat=new Qn(1,1),this.center=new Qn(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new di,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=u,this.userData={},this.updateRanges=[],this.version=0,this.onUpdate=null,this.renderTarget=null,this.isRenderTargetTexture=!1,this.isArrayTexture=!!(t&&t.depth&&t.depth>1),this.pmremVersion=0}get width(){return this.source.getSize(xw).x}get height(){return this.source.getSize(xw).y}get depth(){return this.source.getSize(xw).z}get image(){return this.source.data}set image(t=null){this.source.data=t}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}addUpdateRange(t,n){this.updateRanges.push({start:t,count:n})}clearUpdateRanges(){this.updateRanges.length=0}clone(){return new this.constructor().copy(this)}copy(t){return this.name=t.name,this.source=t.source,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.channel=t.channel,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.colorSpace=t.colorSpace,this.renderTarget=t.renderTarget,this.isRenderTargetTexture=t.isRenderTargetTexture,this.isArrayTexture=t.isArrayTexture,this.userData=JSON.parse(JSON.stringify(t.userData)),this.needsUpdate=!0,this}setValues(t){for(const n in t){const r=t[n];if(r===void 0){console.warn(`THREE.Texture.setValues(): parameter '${n}' has value of undefined.`);continue}const a=this[n];if(a===void 0){console.warn(`THREE.Texture.setValues(): property '${n}' does not exist.`);continue}a&&r&&a.isVector2&&r.isVector2||a&&r&&a.isVector3&&r.isVector3||a&&r&&a.isMatrix3&&r.isMatrix3?a.copy(r):this[n]=r}}toJSON(t){const n=t===void 0||typeof t=="string";if(!n&&t.textures[this.uuid]!==void 0)return t.textures[this.uuid];const r={metadata:{version:4.7,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(t).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(r.userData=this.userData),n||(t.textures[this.uuid]=r),r}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(this.mapping!==sD)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case ok:t.x=t.x-Math.floor(t.x);break;case kl:t.x=t.x<0?0:1;break;case lk:Math.abs(Math.floor(t.x)%2)===1?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x);break}if(t.y<0||t.y>1)switch(this.wrapT){case ok:t.y=t.y-Math.floor(t.y);break;case kl:t.y=t.y<0?0:1;break;case lk:Math.abs(Math.floor(t.y)%2)===1?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y);break}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){t===!0&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(t){t===!0&&this.pmremVersion++}}ti.DEFAULT_IMAGE=null;ti.DEFAULT_MAPPING=sD;ti.DEFAULT_ANISOTROPY=1;class fd{constructor(t=0,n=0,r=0,a=1){fd.prototype.isVector4=!0,this.x=t,this.y=n,this.z=r,this.w=a}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,n,r,a){return this.x=t,this.y=n,this.z=r,this.w=a,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,n){switch(t){case 0:this.x=n;break;case 1:this.y=n;break;case 2:this.z=n;break;case 3:this.w=n;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w!==void 0?t.w:1,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,n){return this.x=t.x+n.x,this.y=t.y+n.y,this.z=t.z+n.z,this.w=t.w+n.w,this}addScaledVector(t,n){return this.x+=t.x*n,this.y+=t.y*n,this.z+=t.z*n,this.w+=t.w*n,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,n){return this.x=t.x-n.x,this.y=t.y-n.y,this.z=t.z-n.z,this.w=t.w-n.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const n=this.x,r=this.y,a=this.z,s=this.w,i=t.elements;return this.x=i[0]*n+i[4]*r+i[8]*a+i[12]*s,this.y=i[1]*n+i[5]*r+i[9]*a+i[13]*s,this.z=i[2]*n+i[6]*r+i[10]*a+i[14]*s,this.w=i[3]*n+i[7]*r+i[11]*a+i[15]*s,this}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this.w/=t.w,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const n=Math.sqrt(1-t.w*t.w);return n<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/n,this.y=t.y/n,this.z=t.z/n),this}setAxisAngleFromRotationMatrix(t){let n,r,a,s;const l=t.elements,c=l[0],u=l[4],h=l[8],d=l[1],p=l[5],f=l[9],m=l[2],y=l[6],g=l[10];if(Math.abs(u-d)<.01&&Math.abs(h-m)<.01&&Math.abs(f-y)<.01){if(Math.abs(u+d)<.1&&Math.abs(h+m)<.1&&Math.abs(f+y)<.1&&Math.abs(c+p+g-3)<.1)return this.set(1,0,0,0),this;n=Math.PI;const b=(c+1)/2,v=(p+1)/2,w=(g+1)/2,I=(u+d)/4,_=(h+m)/4,T=(f+y)/4;return b>v&&b>w?b<.01?(r=0,a=.707106781,s=.707106781):(r=Math.sqrt(b),a=I/r,s=_/r):v>w?v<.01?(r=.707106781,a=0,s=.707106781):(a=Math.sqrt(v),r=I/a,s=T/a):w<.01?(r=.707106781,a=.707106781,s=0):(s=Math.sqrt(w),r=_/s,a=T/s),this.set(r,a,s,n),this}let x=Math.sqrt((y-f)*(y-f)+(h-m)*(h-m)+(d-u)*(d-u));return Math.abs(x)<.001&&(x=1),this.x=(y-f)/x,this.y=(h-m)/x,this.z=(d-u)/x,this.w=Math.acos((c+p+g-1)/2),this}setFromMatrixPosition(t){const n=t.elements;return this.x=n[12],this.y=n[13],this.z=n[14],this.w=n[15],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,n){return this.x=Qe(this.x,t.x,n.x),this.y=Qe(this.y,t.y,n.y),this.z=Qe(this.z,t.z,n.z),this.w=Qe(this.w,t.w,n.w),this}clampScalar(t,n){return this.x=Qe(this.x,t,n),this.y=Qe(this.y,t,n),this.z=Qe(this.z,t,n),this.w=Qe(this.w,t,n),this}clampLength(t,n){const r=this.length();return this.divideScalar(r||1).multiplyScalar(Qe(r,t,n))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,n){return this.x+=(t.x-this.x)*n,this.y+=(t.y-this.y)*n,this.z+=(t.z-this.z)*n,this.w+=(t.w-this.w)*n,this}lerpVectors(t,n,r){return this.x=t.x+(n.x-t.x)*r,this.y=t.y+(n.y-t.y)*r,this.z=t.z+(n.z-t.z)*r,this.w=t.w+(n.w-t.w)*r,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,n=0){return this.x=t[n],this.y=t[n+1],this.z=t[n+2],this.w=t[n+3],this}toArray(t=[],n=0){return t[n]=this.x,t[n+1]=this.y,t[n+2]=this.z,t[n+3]=this.w,t}fromBufferAttribute(t,n){return this.x=t.getX(n),this.y=t.getY(n),this.z=t.getZ(n),this.w=t.getW(n),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class Fm{constructor(t=new ie(1/0,1/0,1/0),n=new ie(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=t,this.max=n}set(t,n){return this.min.copy(t),this.max.copy(n),this}setFromArray(t){this.makeEmpty();for(let n=0,r=t.length;n<r;n+=3)this.expandByPoint(za.fromArray(t,n));return this}setFromBufferAttribute(t){this.makeEmpty();for(let n=0,r=t.count;n<r;n++)this.expandByPoint(za.fromBufferAttribute(t,n));return this}setFromPoints(t){this.makeEmpty();for(let n=0,r=t.length;n<r;n++)this.expandByPoint(t[n]);return this}setFromCenterAndSize(t,n){const r=za.copy(n).multiplyScalar(.5);return this.min.copy(t).sub(r),this.max.copy(t).add(r),this}setFromObject(t,n=!1){return this.makeEmpty(),this.expandByObject(t,n)}clone(){return new this.constructor().copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t,n=!1){t.updateWorldMatrix(!1,!1);const r=t.geometry;if(r!==void 0){const s=r.getAttribute("position");if(n===!0&&s!==void 0&&t.isInstancedMesh!==!0)for(let i=0,o=s.count;i<o;i++)t.isMesh===!0?t.getVertexPosition(i,za):za.fromBufferAttribute(s,i),za.applyMatrix4(t.matrixWorld),this.expandByPoint(za);else t.boundingBox!==void 0?(t.boundingBox===null&&t.computeBoundingBox(),vy.copy(t.boundingBox)):(r.boundingBox===null&&r.computeBoundingBox(),vy.copy(r.boundingBox)),vy.applyMatrix4(t.matrixWorld),this.union(vy)}const a=t.children;for(let s=0,i=a.length;s<i;s++)this.expandByObject(a[s],n);return this}containsPoint(t){return t.x>=this.min.x&&t.x<=this.max.x&&t.y>=this.min.y&&t.y<=this.max.y&&t.z>=this.min.z&&t.z<=this.max.z}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,n){return n.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return t.max.x>=this.min.x&&t.min.x<=this.max.x&&t.max.y>=this.min.y&&t.min.y<=this.max.y&&t.max.z>=this.min.z&&t.min.z<=this.max.z}intersectsSphere(t){return this.clampPoint(t.center,za),za.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let n,r;return t.normal.x>0?(n=t.normal.x*this.min.x,r=t.normal.x*this.max.x):(n=t.normal.x*this.max.x,r=t.normal.x*this.min.x),t.normal.y>0?(n+=t.normal.y*this.min.y,r+=t.normal.y*this.max.y):(n+=t.normal.y*this.max.y,r+=t.normal.y*this.min.y),t.normal.z>0?(n+=t.normal.z*this.min.z,r+=t.normal.z*this.max.z):(n+=t.normal.z*this.max.z,r+=t.normal.z*this.min.z),n<=-t.constant&&r>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(Jp),wy.subVectors(this.max,Jp),Hc.subVectors(t.a,Jp),qc.subVectors(t.b,Jp),Kc.subVectors(t.c,Jp),_i.subVectors(qc,Hc),Ci.subVectors(Kc,qc),Qo.subVectors(Hc,Kc);let n=[0,-_i.z,_i.y,0,-Ci.z,Ci.y,0,-Qo.z,Qo.y,_i.z,0,-_i.x,Ci.z,0,-Ci.x,Qo.z,0,-Qo.x,-_i.y,_i.x,0,-Ci.y,Ci.x,0,-Qo.y,Qo.x,0];return!bw(n,Hc,qc,Kc,wy)||(n=[1,0,0,0,1,0,0,0,1],!bw(n,Hc,qc,Kc,wy))?!1:(ky.crossVectors(_i,Ci),n=[ky.x,ky.y,ky.z],bw(n,Hc,qc,Kc,wy))}clampPoint(t,n){return n.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return this.clampPoint(t,za).distanceTo(t)}getBoundingSphere(t){return this.isEmpty()?t.makeEmpty():(this.getCenter(t.center),t.radius=this.getSize(za).length()*.5),t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()?this:(Bs[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),Bs[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),Bs[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),Bs[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),Bs[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),Bs[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),Bs[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),Bs[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(Bs),this)}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}toJSON(){return{min:this.min.toArray(),max:this.max.toArray()}}fromJSON(t){return this.min.fromArray(t.min),this.max.fromArray(t.max),this}}const Bs=[new ie,new ie,new ie,new ie,new ie,new ie,new ie,new ie],za=new ie,vy=new Fm,Hc=new ie,qc=new ie,Kc=new ie,_i=new ie,Ci=new ie,Qo=new ie,Jp=new ie,wy=new ie,ky=new ie,el=new ie;function bw(e,t,n,r,a){for(let s=0,i=e.length-3;s<=i;s+=3){el.fromArray(e,s);const o=a.x*Math.abs(el.x)+a.y*Math.abs(el.y)+a.z*Math.abs(el.z),l=t.dot(el),c=n.dot(el),u=r.dot(el);if(Math.max(-Math.max(l,c,u),Math.min(l,c,u))>o)return!1}return!0}const w8=new Fm,Qp=new ie,vw=new ie;class AS{constructor(t=new ie,n=-1){this.isSphere=!0,this.center=t,this.radius=n}set(t,n){return this.center.copy(t),this.radius=n,this}setFromPoints(t,n){const r=this.center;n!==void 0?r.copy(n):w8.setFromPoints(t).getCenter(r);let a=0;for(let s=0,i=t.length;s<i;s++)a=Math.max(a,r.distanceToSquared(t[s]));return this.radius=Math.sqrt(a),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const n=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=n*n}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,n){const r=this.center.distanceToSquared(t);return n.copy(t),r>this.radius*this.radius&&(n.sub(this.center).normalize(),n.multiplyScalar(this.radius).add(this.center)),n}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){if(this.isEmpty())return this.center.copy(t),this.radius=0,this;Qp.subVectors(t,this.center);const n=Qp.lengthSq();if(n>this.radius*this.radius){const r=Math.sqrt(n),a=(r-this.radius)*.5;this.center.addScaledVector(Qp,a/r),this.radius+=a}return this}union(t){return t.isEmpty()?this:this.isEmpty()?(this.copy(t),this):(this.center.equals(t.center)===!0?this.radius=Math.max(this.radius,t.radius):(vw.subVectors(t.center,this.center).setLength(t.radius),this.expandByPoint(Qp.copy(t.center).add(vw)),this.expandByPoint(Qp.copy(t.center).sub(vw))),this)}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return new this.constructor().copy(this)}toJSON(){return{radius:this.radius,center:this.center.toArray()}}fromJSON(t){return this.radius=t.radius,this.center.fromArray(t.center),this}}const Ws=new ie,ww=new ie,Sy=new ie,Ti=new ie,kw=new ie,Iy=new ie,Sw=new ie;class k8{constructor(t=new ie,n=new ie(0,0,-1)){this.origin=t,this.direction=n}set(t,n){return this.origin.copy(t),this.direction.copy(n),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,n){return n.copy(this.origin).addScaledVector(this.direction,t)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,Ws)),this}closestPointToPoint(t,n){n.subVectors(t,this.origin);const r=n.dot(this.direction);return r<0?n.copy(this.origin):n.copy(this.origin).addScaledVector(this.direction,r)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const n=Ws.subVectors(t,this.origin).dot(this.direction);return n<0?this.origin.distanceToSquared(t):(Ws.copy(this.origin).addScaledVector(this.direction,n),Ws.distanceToSquared(t))}distanceSqToSegment(t,n,r,a){ww.copy(t).add(n).multiplyScalar(.5),Sy.copy(n).sub(t).normalize(),Ti.copy(this.origin).sub(ww);const s=t.distanceTo(n)*.5,i=-this.direction.dot(Sy),o=Ti.dot(this.direction),l=-Ti.dot(Sy),c=Ti.lengthSq(),u=Math.abs(1-i*i);let h,d,p,f;if(u>0)if(h=i*l-o,d=i*o-l,f=s*u,h>=0)if(d>=-f)if(d<=f){const m=1/u;h*=m,d*=m,p=h*(h+i*d+2*o)+d*(i*h+d+2*l)+c}else d=s,h=Math.max(0,-(i*d+o)),p=-h*h+d*(d+2*l)+c;else d=-s,h=Math.max(0,-(i*d+o)),p=-h*h+d*(d+2*l)+c;else d<=-f?(h=Math.max(0,-(-i*s+o)),d=h>0?-s:Math.min(Math.max(-s,-l),s),p=-h*h+d*(d+2*l)+c):d<=f?(h=0,d=Math.min(Math.max(-s,-l),s),p=d*(d+2*l)+c):(h=Math.max(0,-(i*s+o)),d=h>0?s:Math.min(Math.max(-s,-l),s),p=-h*h+d*(d+2*l)+c);else d=i>0?-s:s,h=Math.max(0,-(i*d+o)),p=-h*h+d*(d+2*l)+c;return r&&r.copy(this.origin).addScaledVector(this.direction,h),a&&a.copy(ww).addScaledVector(Sy,d),p}intersectSphere(t,n){Ws.subVectors(t.center,this.origin);const r=Ws.dot(this.direction),a=Ws.dot(Ws)-r*r,s=t.radius*t.radius;if(a>s)return null;const i=Math.sqrt(s-a),o=r-i,l=r+i;return l<0?null:o<0?this.at(l,n):this.at(o,n)}intersectsSphere(t){return t.radius<0?!1:this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const n=t.normal.dot(this.direction);if(n===0)return t.distanceToPoint(this.origin)===0?0:null;const r=-(this.origin.dot(t.normal)+t.constant)/n;return r>=0?r:null}intersectPlane(t,n){const r=this.distanceToPlane(t);return r===null?null:this.at(r,n)}intersectsPlane(t){const n=t.distanceToPoint(this.origin);return n===0||t.normal.dot(this.direction)*n<0}intersectBox(t,n){let r,a,s,i,o,l;const c=1/this.direction.x,u=1/this.direction.y,h=1/this.direction.z,d=this.origin;return c>=0?(r=(t.min.x-d.x)*c,a=(t.max.x-d.x)*c):(r=(t.max.x-d.x)*c,a=(t.min.x-d.x)*c),u>=0?(s=(t.min.y-d.y)*u,i=(t.max.y-d.y)*u):(s=(t.max.y-d.y)*u,i=(t.min.y-d.y)*u),r>i||s>a||((s>r||isNaN(r))&&(r=s),(i<a||isNaN(a))&&(a=i),h>=0?(o=(t.min.z-d.z)*h,l=(t.max.z-d.z)*h):(o=(t.max.z-d.z)*h,l=(t.min.z-d.z)*h),r>l||o>a)||((o>r||r!==r)&&(r=o),(l<a||a!==a)&&(a=l),a<0)?null:this.at(r>=0?r:a,n)}intersectsBox(t){return this.intersectBox(t,Ws)!==null}intersectTriangle(t,n,r,a,s){kw.subVectors(n,t),Iy.subVectors(r,t),Sw.crossVectors(kw,Iy);let i=this.direction.dot(Sw),o;if(i>0){if(a)return null;o=1}else if(i<0)o=-1,i=-i;else return null;Ti.subVectors(this.origin,t);const l=o*this.direction.dot(Iy.crossVectors(Ti,Iy));if(l<0)return null;const c=o*this.direction.dot(kw.cross(Ti));if(c<0||l+c>i)return null;const u=-o*Ti.dot(Sw);return u<0?null:this.at(u/i,s)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class Rn{constructor(t,n,r,a,s,i,o,l,c,u,h,d,p,f,m,y){Rn.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],t!==void 0&&this.set(t,n,r,a,s,i,o,l,c,u,h,d,p,f,m,y)}set(t,n,r,a,s,i,o,l,c,u,h,d,p,f,m,y){const g=this.elements;return g[0]=t,g[4]=n,g[8]=r,g[12]=a,g[1]=s,g[5]=i,g[9]=o,g[13]=l,g[2]=c,g[6]=u,g[10]=h,g[14]=d,g[3]=p,g[7]=f,g[11]=m,g[15]=y,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new Rn().fromArray(this.elements)}copy(t){const n=this.elements,r=t.elements;return n[0]=r[0],n[1]=r[1],n[2]=r[2],n[3]=r[3],n[4]=r[4],n[5]=r[5],n[6]=r[6],n[7]=r[7],n[8]=r[8],n[9]=r[9],n[10]=r[10],n[11]=r[11],n[12]=r[12],n[13]=r[13],n[14]=r[14],n[15]=r[15],this}copyPosition(t){const n=this.elements,r=t.elements;return n[12]=r[12],n[13]=r[13],n[14]=r[14],this}setFromMatrix3(t){const n=t.elements;return this.set(n[0],n[3],n[6],0,n[1],n[4],n[7],0,n[2],n[5],n[8],0,0,0,0,1),this}extractBasis(t,n,r){return t.setFromMatrixColumn(this,0),n.setFromMatrixColumn(this,1),r.setFromMatrixColumn(this,2),this}makeBasis(t,n,r){return this.set(t.x,n.x,r.x,0,t.y,n.y,r.y,0,t.z,n.z,r.z,0,0,0,0,1),this}extractRotation(t){const n=this.elements,r=t.elements,a=1/Xc.setFromMatrixColumn(t,0).length(),s=1/Xc.setFromMatrixColumn(t,1).length(),i=1/Xc.setFromMatrixColumn(t,2).length();return n[0]=r[0]*a,n[1]=r[1]*a,n[2]=r[2]*a,n[3]=0,n[4]=r[4]*s,n[5]=r[5]*s,n[6]=r[6]*s,n[7]=0,n[8]=r[8]*i,n[9]=r[9]*i,n[10]=r[10]*i,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,this}makeRotationFromEuler(t){const n=this.elements,r=t.x,a=t.y,s=t.z,i=Math.cos(r),o=Math.sin(r),l=Math.cos(a),c=Math.sin(a),u=Math.cos(s),h=Math.sin(s);if(t.order==="XYZ"){const d=i*u,p=i*h,f=o*u,m=o*h;n[0]=l*u,n[4]=-l*h,n[8]=c,n[1]=p+f*c,n[5]=d-m*c,n[9]=-o*l,n[2]=m-d*c,n[6]=f+p*c,n[10]=i*l}else if(t.order==="YXZ"){const d=l*u,p=l*h,f=c*u,m=c*h;n[0]=d+m*o,n[4]=f*o-p,n[8]=i*c,n[1]=i*h,n[5]=i*u,n[9]=-o,n[2]=p*o-f,n[6]=m+d*o,n[10]=i*l}else if(t.order==="ZXY"){const d=l*u,p=l*h,f=c*u,m=c*h;n[0]=d-m*o,n[4]=-i*h,n[8]=f+p*o,n[1]=p+f*o,n[5]=i*u,n[9]=m-d*o,n[2]=-i*c,n[6]=o,n[10]=i*l}else if(t.order==="ZYX"){const d=i*u,p=i*h,f=o*u,m=o*h;n[0]=l*u,n[4]=f*c-p,n[8]=d*c+m,n[1]=l*h,n[5]=m*c+d,n[9]=p*c-f,n[2]=-c,n[6]=o*l,n[10]=i*l}else if(t.order==="YZX"){const d=i*l,p=i*c,f=o*l,m=o*c;n[0]=l*u,n[4]=m-d*h,n[8]=f*h+p,n[1]=h,n[5]=i*u,n[9]=-o*u,n[2]=-c*u,n[6]=p*h+f,n[10]=d-m*h}else if(t.order==="XZY"){const d=i*l,p=i*c,f=o*l,m=o*c;n[0]=l*u,n[4]=-h,n[8]=c*u,n[1]=d*h+m,n[5]=i*u,n[9]=p*h-f,n[2]=f*h-p,n[6]=o*u,n[10]=m*h+d}return n[3]=0,n[7]=0,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,this}makeRotationFromQuaternion(t){return this.compose(S8,t,I8)}lookAt(t,n,r){const a=this.elements;return Jr.subVectors(t,n),Jr.lengthSq()===0&&(Jr.z=1),Jr.normalize(),Ei.crossVectors(r,Jr),Ei.lengthSq()===0&&(Math.abs(r.z)===1?Jr.x+=1e-4:Jr.z+=1e-4,Jr.normalize(),Ei.crossVectors(r,Jr)),Ei.normalize(),Ny.crossVectors(Jr,Ei),a[0]=Ei.x,a[4]=Ny.x,a[8]=Jr.x,a[1]=Ei.y,a[5]=Ny.y,a[9]=Jr.y,a[2]=Ei.z,a[6]=Ny.z,a[10]=Jr.z,this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,n){const r=t.elements,a=n.elements,s=this.elements,i=r[0],o=r[4],l=r[8],c=r[12],u=r[1],h=r[5],d=r[9],p=r[13],f=r[2],m=r[6],y=r[10],g=r[14],x=r[3],b=r[7],v=r[11],w=r[15],I=a[0],_=a[4],T=a[8],A=a[12],M=a[1],F=a[5],C=a[9],D=a[13],L=a[2],O=a[6],q=a[10],H=a[14],z=a[3],K=a[7],Z=a[11],J=a[15];return s[0]=i*I+o*M+l*L+c*z,s[4]=i*_+o*F+l*O+c*K,s[8]=i*T+o*C+l*q+c*Z,s[12]=i*A+o*D+l*H+c*J,s[1]=u*I+h*M+d*L+p*z,s[5]=u*_+h*F+d*O+p*K,s[9]=u*T+h*C+d*q+p*Z,s[13]=u*A+h*D+d*H+p*J,s[2]=f*I+m*M+y*L+g*z,s[6]=f*_+m*F+y*O+g*K,s[10]=f*T+m*C+y*q+g*Z,s[14]=f*A+m*D+y*H+g*J,s[3]=x*I+b*M+v*L+w*z,s[7]=x*_+b*F+v*O+w*K,s[11]=x*T+b*C+v*q+w*Z,s[15]=x*A+b*D+v*H+w*J,this}multiplyScalar(t){const n=this.elements;return n[0]*=t,n[4]*=t,n[8]*=t,n[12]*=t,n[1]*=t,n[5]*=t,n[9]*=t,n[13]*=t,n[2]*=t,n[6]*=t,n[10]*=t,n[14]*=t,n[3]*=t,n[7]*=t,n[11]*=t,n[15]*=t,this}determinant(){const t=this.elements,n=t[0],r=t[4],a=t[8],s=t[12],i=t[1],o=t[5],l=t[9],c=t[13],u=t[2],h=t[6],d=t[10],p=t[14],f=t[3],m=t[7],y=t[11],g=t[15];return f*(+s*l*h-a*c*h-s*o*d+r*c*d+a*o*p-r*l*p)+m*(+n*l*p-n*c*d+s*i*d-a*i*p+a*c*u-s*l*u)+y*(+n*c*h-n*o*p-s*i*h+r*i*p+s*o*u-r*c*u)+g*(-a*o*u-n*l*h+n*o*d+a*i*h-r*i*d+r*l*u)}transpose(){const t=this.elements;let n;return n=t[1],t[1]=t[4],t[4]=n,n=t[2],t[2]=t[8],t[8]=n,n=t[6],t[6]=t[9],t[9]=n,n=t[3],t[3]=t[12],t[12]=n,n=t[7],t[7]=t[13],t[13]=n,n=t[11],t[11]=t[14],t[14]=n,this}setPosition(t,n,r){const a=this.elements;return t.isVector3?(a[12]=t.x,a[13]=t.y,a[14]=t.z):(a[12]=t,a[13]=n,a[14]=r),this}invert(){const t=this.elements,n=t[0],r=t[1],a=t[2],s=t[3],i=t[4],o=t[5],l=t[6],c=t[7],u=t[8],h=t[9],d=t[10],p=t[11],f=t[12],m=t[13],y=t[14],g=t[15],x=h*y*c-m*d*c+m*l*p-o*y*p-h*l*g+o*d*g,b=f*d*c-u*y*c-f*l*p+i*y*p+u*l*g-i*d*g,v=u*m*c-f*h*c+f*o*p-i*m*p-u*o*g+i*h*g,w=f*h*l-u*m*l-f*o*d+i*m*d+u*o*y-i*h*y,I=n*x+r*b+a*v+s*w;if(I===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const _=1/I;return t[0]=x*_,t[1]=(m*d*s-h*y*s-m*a*p+r*y*p+h*a*g-r*d*g)*_,t[2]=(o*y*s-m*l*s+m*a*c-r*y*c-o*a*g+r*l*g)*_,t[3]=(h*l*s-o*d*s-h*a*c+r*d*c+o*a*p-r*l*p)*_,t[4]=b*_,t[5]=(u*y*s-f*d*s+f*a*p-n*y*p-u*a*g+n*d*g)*_,t[6]=(f*l*s-i*y*s-f*a*c+n*y*c+i*a*g-n*l*g)*_,t[7]=(i*d*s-u*l*s+u*a*c-n*d*c-i*a*p+n*l*p)*_,t[8]=v*_,t[9]=(f*h*s-u*m*s-f*r*p+n*m*p+u*r*g-n*h*g)*_,t[10]=(i*m*s-f*o*s+f*r*c-n*m*c-i*r*g+n*o*g)*_,t[11]=(u*o*s-i*h*s-u*r*c+n*h*c+i*r*p-n*o*p)*_,t[12]=w*_,t[13]=(u*m*a-f*h*a+f*r*d-n*m*d-u*r*y+n*h*y)*_,t[14]=(f*o*a-i*m*a-f*r*l+n*m*l+i*r*y-n*o*y)*_,t[15]=(i*h*a-u*o*a+u*r*l-n*h*l-i*r*d+n*o*d)*_,this}scale(t){const n=this.elements,r=t.x,a=t.y,s=t.z;return n[0]*=r,n[4]*=a,n[8]*=s,n[1]*=r,n[5]*=a,n[9]*=s,n[2]*=r,n[6]*=a,n[10]*=s,n[3]*=r,n[7]*=a,n[11]*=s,this}getMaxScaleOnAxis(){const t=this.elements,n=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],r=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],a=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(n,r,a))}makeTranslation(t,n,r){return t.isVector3?this.set(1,0,0,t.x,0,1,0,t.y,0,0,1,t.z,0,0,0,1):this.set(1,0,0,t,0,1,0,n,0,0,1,r,0,0,0,1),this}makeRotationX(t){const n=Math.cos(t),r=Math.sin(t);return this.set(1,0,0,0,0,n,-r,0,0,r,n,0,0,0,0,1),this}makeRotationY(t){const n=Math.cos(t),r=Math.sin(t);return this.set(n,0,r,0,0,1,0,0,-r,0,n,0,0,0,0,1),this}makeRotationZ(t){const n=Math.cos(t),r=Math.sin(t);return this.set(n,-r,0,0,r,n,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,n){const r=Math.cos(n),a=Math.sin(n),s=1-r,i=t.x,o=t.y,l=t.z,c=s*i,u=s*o;return this.set(c*i+r,c*o-a*l,c*l+a*o,0,c*o+a*l,u*o+r,u*l-a*i,0,c*l-a*o,u*l+a*i,s*l*l+r,0,0,0,0,1),this}makeScale(t,n,r){return this.set(t,0,0,0,0,n,0,0,0,0,r,0,0,0,0,1),this}makeShear(t,n,r,a,s,i){return this.set(1,r,s,0,t,1,i,0,n,a,1,0,0,0,0,1),this}compose(t,n,r){const a=this.elements,s=n._x,i=n._y,o=n._z,l=n._w,c=s+s,u=i+i,h=o+o,d=s*c,p=s*u,f=s*h,m=i*u,y=i*h,g=o*h,x=l*c,b=l*u,v=l*h,w=r.x,I=r.y,_=r.z;return a[0]=(1-(m+g))*w,a[1]=(p+v)*w,a[2]=(f-b)*w,a[3]=0,a[4]=(p-v)*I,a[5]=(1-(d+g))*I,a[6]=(y+x)*I,a[7]=0,a[8]=(f+b)*_,a[9]=(y-x)*_,a[10]=(1-(d+m))*_,a[11]=0,a[12]=t.x,a[13]=t.y,a[14]=t.z,a[15]=1,this}decompose(t,n,r){const a=this.elements;let s=Xc.set(a[0],a[1],a[2]).length();const i=Xc.set(a[4],a[5],a[6]).length(),o=Xc.set(a[8],a[9],a[10]).length();this.determinant()<0&&(s=-s),t.x=a[12],t.y=a[13],t.z=a[14],Pa.copy(this);const c=1/s,u=1/i,h=1/o;return Pa.elements[0]*=c,Pa.elements[1]*=c,Pa.elements[2]*=c,Pa.elements[4]*=u,Pa.elements[5]*=u,Pa.elements[6]*=u,Pa.elements[8]*=h,Pa.elements[9]*=h,Pa.elements[10]*=h,n.setFromRotationMatrix(Pa),r.x=s,r.y=i,r.z=o,this}makePerspective(t,n,r,a,s,i,o=Sl){const l=this.elements,c=2*s/(n-t),u=2*s/(r-a),h=(n+t)/(n-t),d=(r+a)/(r-a);let p,f;if(o===Sl)p=-(i+s)/(i-s),f=-2*i*s/(i-s);else if(o===uk)p=-i/(i-s),f=-i*s/(i-s);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+o);return l[0]=c,l[4]=0,l[8]=h,l[12]=0,l[1]=0,l[5]=u,l[9]=d,l[13]=0,l[2]=0,l[6]=0,l[10]=p,l[14]=f,l[3]=0,l[7]=0,l[11]=-1,l[15]=0,this}makeOrthographic(t,n,r,a,s,i,o=Sl){const l=this.elements,c=1/(n-t),u=1/(r-a),h=1/(i-s),d=(n+t)*c,p=(r+a)*u;let f,m;if(o===Sl)f=(i+s)*h,m=-2*h;else if(o===uk)f=s*h,m=-1*h;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+o);return l[0]=2*c,l[4]=0,l[8]=0,l[12]=-d,l[1]=0,l[5]=2*u,l[9]=0,l[13]=-p,l[2]=0,l[6]=0,l[10]=m,l[14]=-f,l[3]=0,l[7]=0,l[11]=0,l[15]=1,this}equals(t){const n=this.elements,r=t.elements;for(let a=0;a<16;a++)if(n[a]!==r[a])return!1;return!0}fromArray(t,n=0){for(let r=0;r<16;r++)this.elements[r]=t[r+n];return this}toArray(t=[],n=0){const r=this.elements;return t[n]=r[0],t[n+1]=r[1],t[n+2]=r[2],t[n+3]=r[3],t[n+4]=r[4],t[n+5]=r[5],t[n+6]=r[6],t[n+7]=r[7],t[n+8]=r[8],t[n+9]=r[9],t[n+10]=r[10],t[n+11]=r[11],t[n+12]=r[12],t[n+13]=r[13],t[n+14]=r[14],t[n+15]=r[15],t}}const Xc=new ie,Pa=new Rn,S8=new ie(0,0,0),I8=new ie(1,1,1),Ei=new ie,Ny=new ie,Jr=new ie,iA=new Rn,oA=new pd;class po{constructor(t=0,n=0,r=0,a=po.DEFAULT_ORDER){this.isEuler=!0,this._x=t,this._y=n,this._z=r,this._order=a}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,n,r,a=this._order){return this._x=t,this._y=n,this._z=r,this._order=a,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,n=this._order,r=!0){const a=t.elements,s=a[0],i=a[4],o=a[8],l=a[1],c=a[5],u=a[9],h=a[2],d=a[6],p=a[10];switch(n){case"XYZ":this._y=Math.asin(Qe(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-u,p),this._z=Math.atan2(-i,s)):(this._x=Math.atan2(d,c),this._z=0);break;case"YXZ":this._x=Math.asin(-Qe(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(o,p),this._z=Math.atan2(l,c)):(this._y=Math.atan2(-h,s),this._z=0);break;case"ZXY":this._x=Math.asin(Qe(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(-h,p),this._z=Math.atan2(-i,c)):(this._y=0,this._z=Math.atan2(l,s));break;case"ZYX":this._y=Math.asin(-Qe(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(d,p),this._z=Math.atan2(l,s)):(this._x=0,this._z=Math.atan2(-i,c));break;case"YZX":this._z=Math.asin(Qe(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-u,c),this._y=Math.atan2(-h,s)):(this._x=0,this._y=Math.atan2(o,p));break;case"XZY":this._z=Math.asin(-Qe(i,-1,1)),Math.abs(i)<.9999999?(this._x=Math.atan2(d,c),this._y=Math.atan2(o,s)):(this._x=Math.atan2(-u,p),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+n)}return this._order=n,r===!0&&this._onChangeCallback(),this}setFromQuaternion(t,n,r){return iA.makeRotationFromQuaternion(t),this.setFromRotationMatrix(iA,n,r)}setFromVector3(t,n=this._order){return this.set(t.x,t.y,t.z,n)}reorder(t){return oA.setFromEuler(this),this.setFromQuaternion(oA,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],t[3]!==void 0&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],n=0){return t[n]=this._x,t[n+1]=this._y,t[n+2]=this._z,t[n+3]=this._order,t}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}po.DEFAULT_ORDER="XYZ";class N8{constructor(){this.mask=1}set(t){this.mask=(1<<t|0)>>>0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return(this.mask&t.mask)!==0}isEnabled(t){return(this.mask&(1<<t|0))!==0}}let _8=0;const lA=new ie,Zc=new pd,Us=new Rn,_y=new ie,ef=new ie,C8=new ie,T8=new pd,uA=new ie(1,0,0),cA=new ie(0,1,0),hA=new ie(0,0,1),dA={type:"added"},E8={type:"removed"},Yc={type:"childadded",child:null},Iw={type:"childremoved",child:null};class Br extends Zx{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:_8++}),this.uuid=dd(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Br.DEFAULT_UP.clone();const t=new ie,n=new po,r=new pd,a=new ie(1,1,1);function s(){r.setFromEuler(n,!1)}function i(){n.setFromQuaternion(r,void 0,!1)}n._onChange(s),r._onChange(i),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:n},quaternion:{configurable:!0,enumerable:!0,value:r},scale:{configurable:!0,enumerable:!0,value:a},modelViewMatrix:{value:new Rn},normalMatrix:{value:new di}}),this.matrix=new Rn,this.matrixWorld=new Rn,this.matrixAutoUpdate=Br.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=Br.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new N8,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.customDepthMaterial=void 0,this.customDistanceMaterial=void 0,this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,n){this.quaternion.setFromAxisAngle(t,n)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,n){return Zc.setFromAxisAngle(t,n),this.quaternion.multiply(Zc),this}rotateOnWorldAxis(t,n){return Zc.setFromAxisAngle(t,n),this.quaternion.premultiply(Zc),this}rotateX(t){return this.rotateOnAxis(uA,t)}rotateY(t){return this.rotateOnAxis(cA,t)}rotateZ(t){return this.rotateOnAxis(hA,t)}translateOnAxis(t,n){return lA.copy(t).applyQuaternion(this.quaternion),this.position.add(lA.multiplyScalar(n)),this}translateX(t){return this.translateOnAxis(uA,t)}translateY(t){return this.translateOnAxis(cA,t)}translateZ(t){return this.translateOnAxis(hA,t)}localToWorld(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(Us.copy(this.matrixWorld).invert())}lookAt(t,n,r){t.isVector3?_y.copy(t):_y.set(t,n,r);const a=this.parent;this.updateWorldMatrix(!0,!1),ef.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Us.lookAt(ef,_y,this.up):Us.lookAt(_y,ef,this.up),this.quaternion.setFromRotationMatrix(Us),a&&(Us.extractRotation(a.matrixWorld),Zc.setFromRotationMatrix(Us),this.quaternion.premultiply(Zc.invert()))}add(t){if(arguments.length>1){for(let n=0;n<arguments.length;n++)this.add(arguments[n]);return this}return t===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(t.removeFromParent(),t.parent=this,this.children.push(t),t.dispatchEvent(dA),Yc.child=t,this.dispatchEvent(Yc),Yc.child=null):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let r=0;r<arguments.length;r++)this.remove(arguments[r]);return this}const n=this.children.indexOf(t);return n!==-1&&(t.parent=null,this.children.splice(n,1),t.dispatchEvent(E8),Iw.child=t,this.dispatchEvent(Iw),Iw.child=null),this}removeFromParent(){const t=this.parent;return t!==null&&t.remove(this),this}clear(){return this.remove(...this.children)}attach(t){return this.updateWorldMatrix(!0,!1),Us.copy(this.matrixWorld).invert(),t.parent!==null&&(t.parent.updateWorldMatrix(!0,!1),Us.multiply(t.parent.matrixWorld)),t.applyMatrix4(Us),t.removeFromParent(),t.parent=this,this.children.push(t),t.updateWorldMatrix(!1,!0),t.dispatchEvent(dA),Yc.child=t,this.dispatchEvent(Yc),Yc.child=null,this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,n){if(this[t]===n)return this;for(let r=0,a=this.children.length;r<a;r++){const i=this.children[r].getObjectByProperty(t,n);if(i!==void 0)return i}}getObjectsByProperty(t,n,r=[]){this[t]===n&&r.push(this);const a=this.children;for(let s=0,i=a.length;s<i;s++)a[s].getObjectsByProperty(t,n,r);return r}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(ef,t,C8),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(ef,T8,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const n=this.matrixWorld.elements;return t.set(n[8],n[9],n[10]).normalize()}raycast(){}traverse(t){t(this);const n=this.children;for(let r=0,a=n.length;r<a;r++)n[r].traverse(t)}traverseVisible(t){if(this.visible===!1)return;t(this);const n=this.children;for(let r=0,a=n.length;r<a;r++)n[r].traverseVisible(t)}traverseAncestors(t){const n=this.parent;n!==null&&(t(n),n.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,t=!0);const n=this.children;for(let r=0,a=n.length;r<a;r++)n[r].updateMatrixWorld(t)}updateWorldMatrix(t,n){const r=this.parent;if(t===!0&&r!==null&&r.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),n===!0){const a=this.children;for(let s=0,i=a.length;s<i;s++)a[s].updateWorldMatrix(!1,!0)}}toJSON(t){const n=t===void 0||typeof t=="string",r={};n&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},r.metadata={version:4.7,type:"Object",generator:"Object3D.toJSON"});const a={};a.uuid=this.uuid,a.type=this.type,this.name!==""&&(a.name=this.name),this.castShadow===!0&&(a.castShadow=!0),this.receiveShadow===!0&&(a.receiveShadow=!0),this.visible===!1&&(a.visible=!1),this.frustumCulled===!1&&(a.frustumCulled=!1),this.renderOrder!==0&&(a.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(a.userData=this.userData),a.layers=this.layers.mask,a.matrix=this.matrix.toArray(),a.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(a.matrixAutoUpdate=!1),this.isInstancedMesh&&(a.type="InstancedMesh",a.count=this.count,a.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(a.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(a.type="BatchedMesh",a.perObjectFrustumCulled=this.perObjectFrustumCulled,a.sortObjects=this.sortObjects,a.drawRanges=this._drawRanges,a.reservedRanges=this._reservedRanges,a.geometryInfo=this._geometryInfo.map(o=>({...o,boundingBox:o.boundingBox?o.boundingBox.toJSON():void 0,boundingSphere:o.boundingSphere?o.boundingSphere.toJSON():void 0})),a.instanceInfo=this._instanceInfo.map(o=>({...o})),a.availableInstanceIds=this._availableInstanceIds.slice(),a.availableGeometryIds=this._availableGeometryIds.slice(),a.nextIndexStart=this._nextIndexStart,a.nextVertexStart=this._nextVertexStart,a.geometryCount=this._geometryCount,a.maxInstanceCount=this._maxInstanceCount,a.maxVertexCount=this._maxVertexCount,a.maxIndexCount=this._maxIndexCount,a.geometryInitialized=this._geometryInitialized,a.matricesTexture=this._matricesTexture.toJSON(t),a.indirectTexture=this._indirectTexture.toJSON(t),this._colorsTexture!==null&&(a.colorsTexture=this._colorsTexture.toJSON(t)),this.boundingSphere!==null&&(a.boundingSphere=this.boundingSphere.toJSON()),this.boundingBox!==null&&(a.boundingBox=this.boundingBox.toJSON()));function s(o,l){return o[l.uuid]===void 0&&(o[l.uuid]=l.toJSON(t)),l.uuid}if(this.isScene)this.background&&(this.background.isColor?a.background=this.background.toJSON():this.background.isTexture&&(a.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(a.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){a.geometry=s(t.geometries,this.geometry);const o=this.geometry.parameters;if(o!==void 0&&o.shapes!==void 0){const l=o.shapes;if(Array.isArray(l))for(let c=0,u=l.length;c<u;c++){const h=l[c];s(t.shapes,h)}else s(t.shapes,l)}}if(this.isSkinnedMesh&&(a.bindMode=this.bindMode,a.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(s(t.skeletons,this.skeleton),a.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const o=[];for(let l=0,c=this.material.length;l<c;l++)o.push(s(t.materials,this.material[l]));a.material=o}else a.material=s(t.materials,this.material);if(this.children.length>0){a.children=[];for(let o=0;o<this.children.length;o++)a.children.push(this.children[o].toJSON(t).object)}if(this.animations.length>0){a.animations=[];for(let o=0;o<this.animations.length;o++){const l=this.animations[o];a.animations.push(s(t.animations,l))}}if(n){const o=i(t.geometries),l=i(t.materials),c=i(t.textures),u=i(t.images),h=i(t.shapes),d=i(t.skeletons),p=i(t.animations),f=i(t.nodes);o.length>0&&(r.geometries=o),l.length>0&&(r.materials=l),c.length>0&&(r.textures=c),u.length>0&&(r.images=u),h.length>0&&(r.shapes=h),d.length>0&&(r.skeletons=d),p.length>0&&(r.animations=p),f.length>0&&(r.nodes=f)}return r.object=a,r;function i(o){const l=[];for(const c in o){const u=o[c];delete u.metadata,l.push(u)}return l}}clone(t){return new this.constructor().copy(this,t)}copy(t,n=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldAutoUpdate=t.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.animations=t.animations.slice(),this.userData=JSON.parse(JSON.stringify(t.userData)),n===!0)for(let r=0;r<t.children.length;r++){const a=t.children[r];this.add(a.clone())}return this}}Br.DEFAULT_UP=new ie(0,1,0);Br.DEFAULT_MATRIX_AUTO_UPDATE=!0;Br.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const La=new ie,Vs=new ie,Nw=new ie,js=new ie,Jc=new ie,Qc=new ie,pA=new ie,_w=new ie,Cw=new ie,Tw=new ie,Ew=new fd,Aw=new fd,$w=new fd;class qa{constructor(t=new ie,n=new ie,r=new ie){this.a=t,this.b=n,this.c=r}static getNormal(t,n,r,a){a.subVectors(r,n),La.subVectors(t,n),a.cross(La);const s=a.lengthSq();return s>0?a.multiplyScalar(1/Math.sqrt(s)):a.set(0,0,0)}static getBarycoord(t,n,r,a,s){La.subVectors(a,n),Vs.subVectors(r,n),Nw.subVectors(t,n);const i=La.dot(La),o=La.dot(Vs),l=La.dot(Nw),c=Vs.dot(Vs),u=Vs.dot(Nw),h=i*c-o*o;if(h===0)return s.set(0,0,0),null;const d=1/h,p=(c*l-o*u)*d,f=(i*u-o*l)*d;return s.set(1-p-f,f,p)}static containsPoint(t,n,r,a){return this.getBarycoord(t,n,r,a,js)===null?!1:js.x>=0&&js.y>=0&&js.x+js.y<=1}static getInterpolation(t,n,r,a,s,i,o,l){return this.getBarycoord(t,n,r,a,js)===null?(l.x=0,l.y=0,"z"in l&&(l.z=0),"w"in l&&(l.w=0),null):(l.setScalar(0),l.addScaledVector(s,js.x),l.addScaledVector(i,js.y),l.addScaledVector(o,js.z),l)}static getInterpolatedAttribute(t,n,r,a,s,i){return Ew.setScalar(0),Aw.setScalar(0),$w.setScalar(0),Ew.fromBufferAttribute(t,n),Aw.fromBufferAttribute(t,r),$w.fromBufferAttribute(t,a),i.setScalar(0),i.addScaledVector(Ew,s.x),i.addScaledVector(Aw,s.y),i.addScaledVector($w,s.z),i}static isFrontFacing(t,n,r,a){return La.subVectors(r,n),Vs.subVectors(t,n),La.cross(Vs).dot(a)<0}set(t,n,r){return this.a.copy(t),this.b.copy(n),this.c.copy(r),this}setFromPointsAndIndices(t,n,r,a){return this.a.copy(t[n]),this.b.copy(t[r]),this.c.copy(t[a]),this}setFromAttributeAndIndices(t,n,r,a){return this.a.fromBufferAttribute(t,n),this.b.fromBufferAttribute(t,r),this.c.fromBufferAttribute(t,a),this}clone(){return new this.constructor().copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return La.subVectors(this.c,this.b),Vs.subVectors(this.a,this.b),La.cross(Vs).length()*.5}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return qa.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,n){return qa.getBarycoord(t,this.a,this.b,this.c,n)}getInterpolation(t,n,r,a,s){return qa.getInterpolation(t,this.a,this.b,this.c,n,r,a,s)}containsPoint(t){return qa.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return qa.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,n){const r=this.a,a=this.b,s=this.c;let i,o;Jc.subVectors(a,r),Qc.subVectors(s,r),_w.subVectors(t,r);const l=Jc.dot(_w),c=Qc.dot(_w);if(l<=0&&c<=0)return n.copy(r);Cw.subVectors(t,a);const u=Jc.dot(Cw),h=Qc.dot(Cw);if(u>=0&&h<=u)return n.copy(a);const d=l*h-u*c;if(d<=0&&l>=0&&u<=0)return i=l/(l-u),n.copy(r).addScaledVector(Jc,i);Tw.subVectors(t,s);const p=Jc.dot(Tw),f=Qc.dot(Tw);if(f>=0&&p<=f)return n.copy(s);const m=p*c-l*f;if(m<=0&&c>=0&&f<=0)return o=c/(c-f),n.copy(r).addScaledVector(Qc,o);const y=u*f-p*h;if(y<=0&&h-u>=0&&p-f>=0)return pA.subVectors(s,a),o=(h-u)/(h-u+(p-f)),n.copy(a).addScaledVector(pA,o);const g=1/(y+m+d);return i=m*g,o=d*g,n.copy(r).addScaledVector(Jc,i).addScaledVector(Qc,o)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}const cD={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Ai={h:0,s:0,l:0},Cy={h:0,s:0,l:0};function Mw(e,t,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?e+(t-e)*6*n:n<1/2?t:n<2/3?e+(t-e)*6*(2/3-n):e}class fo{constructor(t,n,r){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(t,n,r)}set(t,n,r){if(n===void 0&&r===void 0){const a=t;a&&a.isColor?this.copy(a):typeof a=="number"?this.setHex(a):typeof a=="string"&&this.setStyle(a)}else this.setRGB(t,n,r);return this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t,n=fr){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(t&255)/255,Oa.colorSpaceToWorking(this,n),this}setRGB(t,n,r,a=Oa.workingColorSpace){return this.r=t,this.g=n,this.b=r,Oa.colorSpaceToWorking(this,a),this}setHSL(t,n,r,a=Oa.workingColorSpace){if(t=ES(t,1),n=Qe(n,0,1),r=Qe(r,0,1),n===0)this.r=this.g=this.b=r;else{const s=r<=.5?r*(1+n):r+n-r*n,i=2*r-s;this.r=Mw(i,s,t+1/3),this.g=Mw(i,s,t),this.b=Mw(i,s,t-1/3)}return Oa.colorSpaceToWorking(this,a),this}setStyle(t,n=fr){function r(s){s!==void 0&&parseFloat(s)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let a;if(a=/^(\w+)\(([^\)]*)\)/.exec(t)){let s;const i=a[1],o=a[2];switch(i){case"rgb":case"rgba":if(s=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return r(s[4]),this.setRGB(Math.min(255,parseInt(s[1],10))/255,Math.min(255,parseInt(s[2],10))/255,Math.min(255,parseInt(s[3],10))/255,n);if(s=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return r(s[4]),this.setRGB(Math.min(100,parseInt(s[1],10))/100,Math.min(100,parseInt(s[2],10))/100,Math.min(100,parseInt(s[3],10))/100,n);break;case"hsl":case"hsla":if(s=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return r(s[4]),this.setHSL(parseFloat(s[1])/360,parseFloat(s[2])/100,parseFloat(s[3])/100,n);break;default:console.warn("THREE.Color: Unknown color model "+t)}}else if(a=/^\#([A-Fa-f\d]+)$/.exec(t)){const s=a[1],i=s.length;if(i===3)return this.setRGB(parseInt(s.charAt(0),16)/15,parseInt(s.charAt(1),16)/15,parseInt(s.charAt(2),16)/15,n);if(i===6)return this.setHex(parseInt(s,16),n);console.warn("THREE.Color: Invalid hex color "+t)}else if(t&&t.length>0)return this.setColorName(t,n);return this}setColorName(t,n=fr){const r=cD[t.toLowerCase()];return r!==void 0?this.setHex(r,n):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copySRGBToLinear(t){return this.r=ei(t.r),this.g=ei(t.g),this.b=ei(t.b),this}copyLinearToSRGB(t){return this.r=Eh(t.r),this.g=Eh(t.g),this.b=Eh(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(t=fr){return Oa.workingToColorSpace(qn.copy(this),t),Math.round(Qe(qn.r*255,0,255))*65536+Math.round(Qe(qn.g*255,0,255))*256+Math.round(Qe(qn.b*255,0,255))}getHexString(t=fr){return("000000"+this.getHex(t).toString(16)).slice(-6)}getHSL(t,n=Oa.workingColorSpace){Oa.workingToColorSpace(qn.copy(this),n);const r=qn.r,a=qn.g,s=qn.b,i=Math.max(r,a,s),o=Math.min(r,a,s);let l,c;const u=(o+i)/2;if(o===i)l=0,c=0;else{const h=i-o;switch(c=u<=.5?h/(i+o):h/(2-i-o),i){case r:l=(a-s)/h+(a<s?6:0);break;case a:l=(s-r)/h+2;break;case s:l=(r-a)/h+4;break}l/=6}return t.h=l,t.s=c,t.l=u,t}getRGB(t,n=Oa.workingColorSpace){return Oa.workingToColorSpace(qn.copy(this),n),t.r=qn.r,t.g=qn.g,t.b=qn.b,t}getStyle(t=fr){Oa.workingToColorSpace(qn.copy(this),t);const n=qn.r,r=qn.g,a=qn.b;return t!==fr?`color(${t} ${n.toFixed(3)} ${r.toFixed(3)} ${a.toFixed(3)})`:`rgb(${Math.round(n*255)},${Math.round(r*255)},${Math.round(a*255)})`}offsetHSL(t,n,r){return this.getHSL(Ai),this.setHSL(Ai.h+t,Ai.s+n,Ai.l+r)}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,n){return this.r=t.r+n.r,this.g=t.g+n.g,this.b=t.b+n.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,n){return this.r+=(t.r-this.r)*n,this.g+=(t.g-this.g)*n,this.b+=(t.b-this.b)*n,this}lerpColors(t,n,r){return this.r=t.r+(n.r-t.r)*r,this.g=t.g+(n.g-t.g)*r,this.b=t.b+(n.b-t.b)*r,this}lerpHSL(t,n){this.getHSL(Ai),t.getHSL(Cy);const r=Rf(Ai.h,Cy.h,n),a=Rf(Ai.s,Cy.s,n),s=Rf(Ai.l,Cy.l,n);return this.setHSL(r,a,s),this}setFromVector3(t){return this.r=t.x,this.g=t.y,this.b=t.z,this}applyMatrix3(t){const n=this.r,r=this.g,a=this.b,s=t.elements;return this.r=s[0]*n+s[3]*r+s[6]*a,this.g=s[1]*n+s[4]*r+s[7]*a,this.b=s[2]*n+s[5]*r+s[8]*a,this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,n=0){return this.r=t[n],this.g=t[n+1],this.b=t[n+2],this}toArray(t=[],n=0){return t[n]=this.r,t[n+1]=this.g,t[n+2]=this.b,t}fromBufferAttribute(t,n){return this.r=t.getX(n),this.g=t.getY(n),this.b=t.getZ(n),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const qn=new fo;fo.NAMES=cD;let A8=0;class hD extends Zx{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:A8++}),this.uuid=dd(),this.name="",this.type="Material",this.blending=GE,this.side=ik,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=qE,this.blendDst=KE,this.blendEquation=HE,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new fo(0,0,0),this.blendAlpha=0,this.depthFunc=XE,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=JE,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=jc,this.stencilZFail=jc,this.stencilZPass=jc,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.allowOverride=!0,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(t){this._alphaTest>0!=t>0&&this.version++,this._alphaTest=t}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(t){if(t!==void 0)for(const n in t){const r=t[n];if(r===void 0){console.warn(`THREE.Material: parameter '${n}' has value of undefined.`);continue}const a=this[n];if(a===void 0){console.warn(`THREE.Material: '${n}' is not a property of THREE.${this.type}.`);continue}a&&a.isColor?a.set(r):a&&a.isVector3&&r&&r.isVector3?a.copy(r):this[n]=r}}toJSON(t){const n=t===void 0||typeof t=="string";n&&(t={textures:{},images:{}});const r={metadata:{version:4.7,type:"Material",generator:"Material.toJSON"}};r.uuid=this.uuid,r.type=this.type,this.name!==""&&(r.name=this.name),this.color&&this.color.isColor&&(r.color=this.color.getHex()),this.roughness!==void 0&&(r.roughness=this.roughness),this.metalness!==void 0&&(r.metalness=this.metalness),this.sheen!==void 0&&(r.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(r.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(r.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(r.emissive=this.emissive.getHex()),this.emissiveIntensity!==void 0&&this.emissiveIntensity!==1&&(r.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(r.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(r.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(r.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(r.shininess=this.shininess),this.clearcoat!==void 0&&(r.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(r.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(r.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(r.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(r.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,r.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.dispersion!==void 0&&(r.dispersion=this.dispersion),this.iridescence!==void 0&&(r.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(r.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(r.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(r.iridescenceMap=this.iridescenceMap.toJSON(t).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(r.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(t).uuid),this.anisotropy!==void 0&&(r.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(r.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(r.anisotropyMap=this.anisotropyMap.toJSON(t).uuid),this.map&&this.map.isTexture&&(r.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(r.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(r.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(r.lightMap=this.lightMap.toJSON(t).uuid,r.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(r.aoMap=this.aoMap.toJSON(t).uuid,r.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(r.bumpMap=this.bumpMap.toJSON(t).uuid,r.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(r.normalMap=this.normalMap.toJSON(t).uuid,r.normalMapType=this.normalMapType,r.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(r.displacementMap=this.displacementMap.toJSON(t).uuid,r.displacementScale=this.displacementScale,r.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(r.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(r.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(r.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(r.specularMap=this.specularMap.toJSON(t).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(r.specularIntensityMap=this.specularIntensityMap.toJSON(t).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(r.specularColorMap=this.specularColorMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(r.envMap=this.envMap.toJSON(t).uuid,this.combine!==void 0&&(r.combine=this.combine)),this.envMapRotation!==void 0&&(r.envMapRotation=this.envMapRotation.toArray()),this.envMapIntensity!==void 0&&(r.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(r.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(r.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(r.gradientMap=this.gradientMap.toJSON(t).uuid),this.transmission!==void 0&&(r.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(r.transmissionMap=this.transmissionMap.toJSON(t).uuid),this.thickness!==void 0&&(r.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(r.thicknessMap=this.thicknessMap.toJSON(t).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(r.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(r.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(r.size=this.size),this.shadowSide!==null&&(r.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(r.sizeAttenuation=this.sizeAttenuation),this.blending!==GE&&(r.blending=this.blending),this.side!==ik&&(r.side=this.side),this.vertexColors===!0&&(r.vertexColors=!0),this.opacity<1&&(r.opacity=this.opacity),this.transparent===!0&&(r.transparent=!0),this.blendSrc!==qE&&(r.blendSrc=this.blendSrc),this.blendDst!==KE&&(r.blendDst=this.blendDst),this.blendEquation!==HE&&(r.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(r.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(r.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(r.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(r.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(r.blendAlpha=this.blendAlpha),this.depthFunc!==XE&&(r.depthFunc=this.depthFunc),this.depthTest===!1&&(r.depthTest=this.depthTest),this.depthWrite===!1&&(r.depthWrite=this.depthWrite),this.colorWrite===!1&&(r.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(r.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==JE&&(r.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(r.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(r.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==jc&&(r.stencilFail=this.stencilFail),this.stencilZFail!==jc&&(r.stencilZFail=this.stencilZFail),this.stencilZPass!==jc&&(r.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(r.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(r.rotation=this.rotation),this.polygonOffset===!0&&(r.polygonOffset=!0),this.polygonOffsetFactor!==0&&(r.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(r.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(r.linewidth=this.linewidth),this.dashSize!==void 0&&(r.dashSize=this.dashSize),this.gapSize!==void 0&&(r.gapSize=this.gapSize),this.scale!==void 0&&(r.scale=this.scale),this.dithering===!0&&(r.dithering=!0),this.alphaTest>0&&(r.alphaTest=this.alphaTest),this.alphaHash===!0&&(r.alphaHash=!0),this.alphaToCoverage===!0&&(r.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(r.premultipliedAlpha=!0),this.forceSinglePass===!0&&(r.forceSinglePass=!0),this.wireframe===!0&&(r.wireframe=!0),this.wireframeLinewidth>1&&(r.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(r.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(r.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(r.flatShading=!0),this.visible===!1&&(r.visible=!1),this.toneMapped===!1&&(r.toneMapped=!1),this.fog===!1&&(r.fog=!1),Object.keys(this.userData).length>0&&(r.userData=this.userData);function a(s){const i=[];for(const o in s){const l=s[o];delete l.metadata,i.push(l)}return i}if(n){const s=a(t.textures),i=a(t.images);s.length>0&&(r.textures=s),i.length>0&&(r.images=i)}return r}clone(){return new this.constructor().copy(this)}copy(t){this.name=t.name,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.blendColor.copy(t.blendColor),this.blendAlpha=t.blendAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const n=t.clippingPlanes;let r=null;if(n!==null){const a=n.length;r=new Array(a);for(let s=0;s!==a;++s)r[s]=n[s].clone()}return this.clippingPlanes=r,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaHash=t.alphaHash,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.forceSinglePass=t.forceSinglePass,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){t===!0&&this.version++}}class $8 extends hD{constructor(t){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new fo(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new po,this.combine=GH,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}const nn=new ie,Ty=new Qn;let M8=0;class Dr{constructor(t,n,r=!1){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,Object.defineProperty(this,"id",{value:M8++}),this.name="",this.array=t,this.itemSize=n,this.count=t!==void 0?t.length/n:0,this.normalized=r,this.usage=QE,this.updateRanges=[],this.gpuType=YH,this.version=0}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}setUsage(t){return this.usage=t,this}addUpdateRange(t,n){this.updateRanges.push({start:t,count:n})}clearUpdateRanges(){this.updateRanges.length=0}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this.gpuType=t.gpuType,this}copyAt(t,n,r){t*=this.itemSize,r*=n.itemSize;for(let a=0,s=this.itemSize;a<s;a++)this.array[t+a]=n.array[r+a];return this}copyArray(t){return this.array.set(t),this}applyMatrix3(t){if(this.itemSize===2)for(let n=0,r=this.count;n<r;n++)Ty.fromBufferAttribute(this,n),Ty.applyMatrix3(t),this.setXY(n,Ty.x,Ty.y);else if(this.itemSize===3)for(let n=0,r=this.count;n<r;n++)nn.fromBufferAttribute(this,n),nn.applyMatrix3(t),this.setXYZ(n,nn.x,nn.y,nn.z);return this}applyMatrix4(t){for(let n=0,r=this.count;n<r;n++)nn.fromBufferAttribute(this,n),nn.applyMatrix4(t),this.setXYZ(n,nn.x,nn.y,nn.z);return this}applyNormalMatrix(t){for(let n=0,r=this.count;n<r;n++)nn.fromBufferAttribute(this,n),nn.applyNormalMatrix(t),this.setXYZ(n,nn.x,nn.y,nn.z);return this}transformDirection(t){for(let n=0,r=this.count;n<r;n++)nn.fromBufferAttribute(this,n),nn.transformDirection(t),this.setXYZ(n,nn.x,nn.y,nn.z);return this}set(t,n=0){return this.array.set(t,n),this}getComponent(t,n){let r=this.array[t*this.itemSize+n];return this.normalized&&(r=ih(r,this.array)),r}setComponent(t,n,r){return this.normalized&&(r=dr(r,this.array)),this.array[t*this.itemSize+n]=r,this}getX(t){let n=this.array[t*this.itemSize];return this.normalized&&(n=ih(n,this.array)),n}setX(t,n){return this.normalized&&(n=dr(n,this.array)),this.array[t*this.itemSize]=n,this}getY(t){let n=this.array[t*this.itemSize+1];return this.normalized&&(n=ih(n,this.array)),n}setY(t,n){return this.normalized&&(n=dr(n,this.array)),this.array[t*this.itemSize+1]=n,this}getZ(t){let n=this.array[t*this.itemSize+2];return this.normalized&&(n=ih(n,this.array)),n}setZ(t,n){return this.normalized&&(n=dr(n,this.array)),this.array[t*this.itemSize+2]=n,this}getW(t){let n=this.array[t*this.itemSize+3];return this.normalized&&(n=ih(n,this.array)),n}setW(t,n){return this.normalized&&(n=dr(n,this.array)),this.array[t*this.itemSize+3]=n,this}setXY(t,n,r){return t*=this.itemSize,this.normalized&&(n=dr(n,this.array),r=dr(r,this.array)),this.array[t+0]=n,this.array[t+1]=r,this}setXYZ(t,n,r,a){return t*=this.itemSize,this.normalized&&(n=dr(n,this.array),r=dr(r,this.array),a=dr(a,this.array)),this.array[t+0]=n,this.array[t+1]=r,this.array[t+2]=a,this}setXYZW(t,n,r,a,s){return t*=this.itemSize,this.normalized&&(n=dr(n,this.array),r=dr(r,this.array),a=dr(a,this.array),s=dr(s,this.array)),this.array[t+0]=n,this.array[t+1]=r,this.array[t+2]=a,this.array[t+3]=s,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(t.name=this.name),this.usage!==QE&&(t.usage=this.usage),t}}class F8 extends Dr{constructor(t,n,r){super(new Uint16Array(t),n,r)}}class R8 extends Dr{constructor(t,n,r){super(new Uint32Array(t),n,r)}}class Ah extends Dr{constructor(t,n,r){super(new Float32Array(t),n,r)}}let D8=0;const ya=new Rn,Fw=new Br,eh=new ie,Qr=new Fm,tf=new Fm,Cn=new ie;class Rm extends Zx{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:D8++}),this.uuid=dd(),this.name="",this.type="BufferGeometry",this.index=null,this.indirect=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(y8(t)?R8:F8)(t,1):this.index=t,this}setIndirect(t){return this.indirect=t,this}getIndirect(){return this.indirect}getAttribute(t){return this.attributes[t]}setAttribute(t,n){return this.attributes[t]=n,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return this.attributes[t]!==void 0}addGroup(t,n,r=0){this.groups.push({start:t,count:n,materialIndex:r})}clearGroups(){this.groups=[]}setDrawRange(t,n){this.drawRange.start=t,this.drawRange.count=n}applyMatrix4(t){const n=this.attributes.position;n!==void 0&&(n.applyMatrix4(t),n.needsUpdate=!0);const r=this.attributes.normal;if(r!==void 0){const s=new di().getNormalMatrix(t);r.applyNormalMatrix(s),r.needsUpdate=!0}const a=this.attributes.tangent;return a!==void 0&&(a.transformDirection(t),a.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(t){return ya.makeRotationFromQuaternion(t),this.applyMatrix4(ya),this}rotateX(t){return ya.makeRotationX(t),this.applyMatrix4(ya),this}rotateY(t){return ya.makeRotationY(t),this.applyMatrix4(ya),this}rotateZ(t){return ya.makeRotationZ(t),this.applyMatrix4(ya),this}translate(t,n,r){return ya.makeTranslation(t,n,r),this.applyMatrix4(ya),this}scale(t,n,r){return ya.makeScale(t,n,r),this.applyMatrix4(ya),this}lookAt(t){return Fw.lookAt(t),Fw.updateMatrix(),this.applyMatrix4(Fw.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(eh).negate(),this.translate(eh.x,eh.y,eh.z),this}setFromPoints(t){const n=this.getAttribute("position");if(n===void 0){const r=[];for(let a=0,s=t.length;a<s;a++){const i=t[a];r.push(i.x,i.y,i.z||0)}this.setAttribute("position",new Ah(r,3))}else{const r=Math.min(t.length,n.count);for(let a=0;a<r;a++){const s=t[a];n.setXYZ(a,s.x,s.y,s.z||0)}t.length>n.count&&console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),n.needsUpdate=!0}return this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Fm);const t=this.attributes.position,n=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),this.boundingBox.set(new ie(-1/0,-1/0,-1/0),new ie(1/0,1/0,1/0));return}if(t!==void 0){if(this.boundingBox.setFromBufferAttribute(t),n)for(let r=0,a=n.length;r<a;r++){const s=n[r];Qr.setFromBufferAttribute(s),this.morphTargetsRelative?(Cn.addVectors(this.boundingBox.min,Qr.min),this.boundingBox.expandByPoint(Cn),Cn.addVectors(this.boundingBox.max,Qr.max),this.boundingBox.expandByPoint(Cn)):(this.boundingBox.expandByPoint(Qr.min),this.boundingBox.expandByPoint(Qr.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new AS);const t=this.attributes.position,n=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),this.boundingSphere.set(new ie,1/0);return}if(t){const r=this.boundingSphere.center;if(Qr.setFromBufferAttribute(t),n)for(let s=0,i=n.length;s<i;s++){const o=n[s];tf.setFromBufferAttribute(o),this.morphTargetsRelative?(Cn.addVectors(Qr.min,tf.min),Qr.expandByPoint(Cn),Cn.addVectors(Qr.max,tf.max),Qr.expandByPoint(Cn)):(Qr.expandByPoint(tf.min),Qr.expandByPoint(tf.max))}Qr.getCenter(r);let a=0;for(let s=0,i=t.count;s<i;s++)Cn.fromBufferAttribute(t,s),a=Math.max(a,r.distanceToSquared(Cn));if(n)for(let s=0,i=n.length;s<i;s++){const o=n[s],l=this.morphTargetsRelative;for(let c=0,u=o.count;c<u;c++)Cn.fromBufferAttribute(o,c),l&&(eh.fromBufferAttribute(t,c),Cn.add(eh)),a=Math.max(a,r.distanceToSquared(Cn))}this.boundingSphere.radius=Math.sqrt(a),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,n=this.attributes;if(t===null||n.position===void 0||n.normal===void 0||n.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const r=n.position,a=n.normal,s=n.uv;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new Dr(new Float32Array(4*r.count),4));const i=this.getAttribute("tangent"),o=[],l=[];for(let T=0;T<r.count;T++)o[T]=new ie,l[T]=new ie;const c=new ie,u=new ie,h=new ie,d=new Qn,p=new Qn,f=new Qn,m=new ie,y=new ie;function g(T,A,M){c.fromBufferAttribute(r,T),u.fromBufferAttribute(r,A),h.fromBufferAttribute(r,M),d.fromBufferAttribute(s,T),p.fromBufferAttribute(s,A),f.fromBufferAttribute(s,M),u.sub(c),h.sub(c),p.sub(d),f.sub(d);const F=1/(p.x*f.y-f.x*p.y);isFinite(F)&&(m.copy(u).multiplyScalar(f.y).addScaledVector(h,-p.y).multiplyScalar(F),y.copy(h).multiplyScalar(p.x).addScaledVector(u,-f.x).multiplyScalar(F),o[T].add(m),o[A].add(m),o[M].add(m),l[T].add(y),l[A].add(y),l[M].add(y))}let x=this.groups;x.length===0&&(x=[{start:0,count:t.count}]);for(let T=0,A=x.length;T<A;++T){const M=x[T],F=M.start,C=M.count;for(let D=F,L=F+C;D<L;D+=3)g(t.getX(D+0),t.getX(D+1),t.getX(D+2))}const b=new ie,v=new ie,w=new ie,I=new ie;function _(T){w.fromBufferAttribute(a,T),I.copy(w);const A=o[T];b.copy(A),b.sub(w.multiplyScalar(w.dot(A))).normalize(),v.crossVectors(I,A);const F=v.dot(l[T])<0?-1:1;i.setXYZW(T,b.x,b.y,b.z,F)}for(let T=0,A=x.length;T<A;++T){const M=x[T],F=M.start,C=M.count;for(let D=F,L=F+C;D<L;D+=3)_(t.getX(D+0)),_(t.getX(D+1)),_(t.getX(D+2))}}computeVertexNormals(){const t=this.index,n=this.getAttribute("position");if(n!==void 0){let r=this.getAttribute("normal");if(r===void 0)r=new Dr(new Float32Array(n.count*3),3),this.setAttribute("normal",r);else for(let d=0,p=r.count;d<p;d++)r.setXYZ(d,0,0,0);const a=new ie,s=new ie,i=new ie,o=new ie,l=new ie,c=new ie,u=new ie,h=new ie;if(t)for(let d=0,p=t.count;d<p;d+=3){const f=t.getX(d+0),m=t.getX(d+1),y=t.getX(d+2);a.fromBufferAttribute(n,f),s.fromBufferAttribute(n,m),i.fromBufferAttribute(n,y),u.subVectors(i,s),h.subVectors(a,s),u.cross(h),o.fromBufferAttribute(r,f),l.fromBufferAttribute(r,m),c.fromBufferAttribute(r,y),o.add(u),l.add(u),c.add(u),r.setXYZ(f,o.x,o.y,o.z),r.setXYZ(m,l.x,l.y,l.z),r.setXYZ(y,c.x,c.y,c.z)}else for(let d=0,p=n.count;d<p;d+=3)a.fromBufferAttribute(n,d+0),s.fromBufferAttribute(n,d+1),i.fromBufferAttribute(n,d+2),u.subVectors(i,s),h.subVectors(a,s),u.cross(h),r.setXYZ(d+0,u.x,u.y,u.z),r.setXYZ(d+1,u.x,u.y,u.z),r.setXYZ(d+2,u.x,u.y,u.z);this.normalizeNormals(),r.needsUpdate=!0}}normalizeNormals(){const t=this.attributes.normal;for(let n=0,r=t.count;n<r;n++)Cn.fromBufferAttribute(t,n),Cn.normalize(),t.setXYZ(n,Cn.x,Cn.y,Cn.z)}toNonIndexed(){function t(o,l){const c=o.array,u=o.itemSize,h=o.normalized,d=new c.constructor(l.length*u);let p=0,f=0;for(let m=0,y=l.length;m<y;m++){o.isInterleavedBufferAttribute?p=l[m]*o.data.stride+o.offset:p=l[m]*u;for(let g=0;g<u;g++)d[f++]=c[p++]}return new Dr(d,u,h)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const n=new Rm,r=this.index.array,a=this.attributes;for(const o in a){const l=a[o],c=t(l,r);n.setAttribute(o,c)}const s=this.morphAttributes;for(const o in s){const l=[],c=s[o];for(let u=0,h=c.length;u<h;u++){const d=c[u],p=t(d,r);l.push(p)}n.morphAttributes[o]=l}n.morphTargetsRelative=this.morphTargetsRelative;const i=this.groups;for(let o=0,l=i.length;o<l;o++){const c=i[o];n.addGroup(c.start,c.count,c.materialIndex)}return n}toJSON(){const t={metadata:{version:4.7,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,this.name!==""&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),this.parameters!==void 0){const l=this.parameters;for(const c in l)l[c]!==void 0&&(t[c]=l[c]);return t}t.data={attributes:{}};const n=this.index;n!==null&&(t.data.index={type:n.array.constructor.name,array:Array.prototype.slice.call(n.array)});const r=this.attributes;for(const l in r){const c=r[l];t.data.attributes[l]=c.toJSON(t.data)}const a={};let s=!1;for(const l in this.morphAttributes){const c=this.morphAttributes[l],u=[];for(let h=0,d=c.length;h<d;h++){const p=c[h];u.push(p.toJSON(t.data))}u.length>0&&(a[l]=u,s=!0)}s&&(t.data.morphAttributes=a,t.data.morphTargetsRelative=this.morphTargetsRelative);const i=this.groups;i.length>0&&(t.data.groups=JSON.parse(JSON.stringify(i)));const o=this.boundingSphere;return o!==null&&(t.data.boundingSphere=o.toJSON()),t}clone(){return new this.constructor().copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const n={};this.name=t.name;const r=t.index;r!==null&&this.setIndex(r.clone());const a=t.attributes;for(const c in a){const u=a[c];this.setAttribute(c,u.clone(n))}const s=t.morphAttributes;for(const c in s){const u=[],h=s[c];for(let d=0,p=h.length;d<p;d++)u.push(h[d].clone(n));this.morphAttributes[c]=u}this.morphTargetsRelative=t.morphTargetsRelative;const i=t.groups;for(let c=0,u=i.length;c<u;c++){const h=i[c];this.addGroup(h.start,h.count,h.materialIndex)}const o=t.boundingBox;o!==null&&(this.boundingBox=o.clone());const l=t.boundingSphere;return l!==null&&(this.boundingSphere=l.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const fA=new Rn,tl=new k8,Ey=new AS,mA=new ie,Ay=new ie,$y=new ie,My=new ie,Rw=new ie,Fy=new ie,gA=new ie,Ry=new ie;class dD extends Br{constructor(t=new Rm,n=new $8){super(),this.isMesh=!0,this.type="Mesh",this.geometry=t,this.material=n,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.count=1,this.updateMorphTargets()}copy(t,n){return super.copy(t,n),t.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),t.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}updateMorphTargets(){const n=this.geometry.morphAttributes,r=Object.keys(n);if(r.length>0){const a=n[r[0]];if(a!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,i=a.length;s<i;s++){const o=a[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=s}}}}getVertexPosition(t,n){const r=this.geometry,a=r.attributes.position,s=r.morphAttributes.position,i=r.morphTargetsRelative;n.fromBufferAttribute(a,t);const o=this.morphTargetInfluences;if(s&&o){Fy.set(0,0,0);for(let l=0,c=s.length;l<c;l++){const u=o[l],h=s[l];u!==0&&(Rw.fromBufferAttribute(h,t),i?Fy.addScaledVector(Rw,u):Fy.addScaledVector(Rw.sub(n),u))}n.add(Fy)}return n}raycast(t,n){const r=this.geometry,a=this.material,s=this.matrixWorld;a!==void 0&&(r.boundingSphere===null&&r.computeBoundingSphere(),Ey.copy(r.boundingSphere),Ey.applyMatrix4(s),tl.copy(t.ray).recast(t.near),!(Ey.containsPoint(tl.origin)===!1&&(tl.intersectSphere(Ey,mA)===null||tl.origin.distanceToSquared(mA)>(t.far-t.near)**2))&&(fA.copy(s).invert(),tl.copy(t.ray).applyMatrix4(fA),!(r.boundingBox!==null&&tl.intersectsBox(r.boundingBox)===!1)&&this._computeIntersections(t,n,tl)))}_computeIntersections(t,n,r){let a;const s=this.geometry,i=this.material,o=s.index,l=s.attributes.position,c=s.attributes.uv,u=s.attributes.uv1,h=s.attributes.normal,d=s.groups,p=s.drawRange;if(o!==null)if(Array.isArray(i))for(let f=0,m=d.length;f<m;f++){const y=d[f],g=i[y.materialIndex],x=Math.max(y.start,p.start),b=Math.min(o.count,Math.min(y.start+y.count,p.start+p.count));for(let v=x,w=b;v<w;v+=3){const I=o.getX(v),_=o.getX(v+1),T=o.getX(v+2);a=Dy(this,g,t,r,c,u,h,I,_,T),a&&(a.faceIndex=Math.floor(v/3),a.face.materialIndex=y.materialIndex,n.push(a))}}else{const f=Math.max(0,p.start),m=Math.min(o.count,p.start+p.count);for(let y=f,g=m;y<g;y+=3){const x=o.getX(y),b=o.getX(y+1),v=o.getX(y+2);a=Dy(this,i,t,r,c,u,h,x,b,v),a&&(a.faceIndex=Math.floor(y/3),n.push(a))}}else if(l!==void 0)if(Array.isArray(i))for(let f=0,m=d.length;f<m;f++){const y=d[f],g=i[y.materialIndex],x=Math.max(y.start,p.start),b=Math.min(l.count,Math.min(y.start+y.count,p.start+p.count));for(let v=x,w=b;v<w;v+=3){const I=v,_=v+1,T=v+2;a=Dy(this,g,t,r,c,u,h,I,_,T),a&&(a.faceIndex=Math.floor(v/3),a.face.materialIndex=y.materialIndex,n.push(a))}}else{const f=Math.max(0,p.start),m=Math.min(l.count,p.start+p.count);for(let y=f,g=m;y<g;y+=3){const x=y,b=y+1,v=y+2;a=Dy(this,i,t,r,c,u,h,x,b,v),a&&(a.faceIndex=Math.floor(y/3),n.push(a))}}}}function O8(e,t,n,r,a,s,i,o){let l;if(t.side===jH?l=r.intersectTriangle(i,s,a,!0,o):l=r.intersectTriangle(a,s,i,t.side===ik,o),l===null)return null;Ry.copy(o),Ry.applyMatrix4(e.matrixWorld);const c=n.ray.origin.distanceTo(Ry);return c<n.near||c>n.far?null:{distance:c,point:Ry.clone(),object:e}}function Dy(e,t,n,r,a,s,i,o,l,c){e.getVertexPosition(o,Ay),e.getVertexPosition(l,$y),e.getVertexPosition(c,My);const u=O8(e,t,n,r,Ay,$y,My,gA);if(u){const h=new ie;qa.getBarycoord(gA,Ay,$y,My,h),a&&(u.uv=qa.getInterpolatedAttribute(a,o,l,c,h,new Qn)),s&&(u.uv1=qa.getInterpolatedAttribute(s,o,l,c,h,new Qn)),i&&(u.normal=qa.getInterpolatedAttribute(i,o,l,c,h,new ie),u.normal.dot(r.direction)>0&&u.normal.multiplyScalar(-1));const d={a:o,b:l,c,normal:new ie,materialIndex:0};qa.getNormal(Ay,$y,My,d.normal),u.face=d,u.barycoord=h}return u}class pD extends Br{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new Rn,this.projectionMatrix=new Rn,this.projectionMatrixInverse=new Rn,this.coordinateSystem=Sl}copy(t,n){return super.copy(t,n),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this.coordinateSystem=t.coordinateSystem,this}getWorldDirection(t){return super.getWorldDirection(t).negate()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,n){super.updateWorldMatrix(t,n),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}const $i=new ie,yA=new Qn,xA=new Qn;class z8 extends pD{constructor(t=50,n=1,r=.1,a=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=r,this.far=a,this.focus=10,this.aspect=n,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(t,n){return super.copy(t,n),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=t.view===null?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this}setFocalLength(t){const n=.5*this.getFilmHeight()/t;this.fov=Y0*2*Math.atan(n),this.updateProjectionMatrix()}getFocalLength(){const t=Math.tan(Ff*.5*this.fov);return .5*this.getFilmHeight()/t}getEffectiveFOV(){return Y0*2*Math.atan(Math.tan(Ff*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}getViewBounds(t,n,r){$i.set(-1,-1,.5).applyMatrix4(this.projectionMatrixInverse),n.set($i.x,$i.y).multiplyScalar(-t/$i.z),$i.set(1,1,.5).applyMatrix4(this.projectionMatrixInverse),r.set($i.x,$i.y).multiplyScalar(-t/$i.z)}getViewSize(t,n){return this.getViewBounds(t,yA,xA),n.subVectors(xA,yA)}setViewOffset(t,n,r,a,s,i){this.aspect=t/n,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=n,this.view.offsetX=r,this.view.offsetY=a,this.view.width=s,this.view.height=i,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=this.near;let n=t*Math.tan(Ff*.5*this.fov)/this.zoom,r=2*n,a=this.aspect*r,s=-.5*a;const i=this.view;if(this.view!==null&&this.view.enabled){const l=i.fullWidth,c=i.fullHeight;s+=i.offsetX*a/l,n-=i.offsetY*r/c,a*=i.width/l,r*=i.height/c}const o=this.filmOffset;o!==0&&(s+=t*o/this.getFilmWidth()),this.projectionMatrix.makePerspective(s,s+a,n,n-r,t,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const n=super.toJSON(t);return n.object.fov=this.fov,n.object.zoom=this.zoom,n.object.near=this.near,n.object.far=this.far,n.object.focus=this.focus,n.object.aspect=this.aspect,this.view!==null&&(n.object.view=Object.assign({},this.view)),n.object.filmGauge=this.filmGauge,n.object.filmOffset=this.filmOffset,n}}class J0 extends Br{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.backgroundRotation=new po,this.environmentIntensity=1,this.environmentRotation=new po,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,n){return super.copy(t,n),t.background!==null&&(this.background=t.background.clone()),t.environment!==null&&(this.environment=t.environment.clone()),t.fog!==null&&(this.fog=t.fog.clone()),this.backgroundBlurriness=t.backgroundBlurriness,this.backgroundIntensity=t.backgroundIntensity,this.backgroundRotation.copy(t.backgroundRotation),this.environmentIntensity=t.environmentIntensity,this.environmentRotation.copy(t.environmentRotation),t.overrideMaterial!==null&&(this.overrideMaterial=t.overrideMaterial.clone()),this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const n=super.toJSON(t);return this.fog!==null&&(n.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(n.object.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(n.object.backgroundIntensity=this.backgroundIntensity),n.object.backgroundRotation=this.backgroundRotation.toArray(),this.environmentIntensity!==1&&(n.object.environmentIntensity=this.environmentIntensity),n.object.environmentRotation=this.environmentRotation.toArray(),n}}const Dw=new ie,P8=new ie,L8=new di;class th{constructor(t=new ie(1,0,0),n=0){this.isPlane=!0,this.normal=t,this.constant=n}set(t,n){return this.normal.copy(t),this.constant=n,this}setComponents(t,n,r,a){return this.normal.set(t,n,r),this.constant=a,this}setFromNormalAndCoplanarPoint(t,n){return this.normal.copy(t),this.constant=-n.dot(this.normal),this}setFromCoplanarPoints(t,n,r){const a=Dw.subVectors(r,n).cross(P8.subVectors(t,n)).normalize();return this.setFromNormalAndCoplanarPoint(a,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,n){return n.copy(t).addScaledVector(this.normal,-this.distanceToPoint(t))}intersectLine(t,n){const r=t.delta(Dw),a=this.normal.dot(r);if(a===0)return this.distanceToPoint(t.start)===0?n.copy(t.start):null;const s=-(t.start.dot(this.normal)+this.constant)/a;return s<0||s>1?null:n.copy(t.start).addScaledVector(r,s)}intersectsLine(t){const n=this.distanceToPoint(t.start),r=this.distanceToPoint(t.end);return n<0&&r>0||r<0&&n>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,n){const r=n||L8.getNormalMatrix(t),a=this.coplanarPoint(Dw).applyMatrix4(t),s=this.normal.applyMatrix3(r).normalize();return this.constant=-a.dot(s),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return new this.constructor().copy(this)}}const nl=new AS,Oy=new ie;class B8{constructor(t=new th,n=new th,r=new th,a=new th,s=new th,i=new th){this.planes=[t,n,r,a,s,i]}set(t,n,r,a,s,i){const o=this.planes;return o[0].copy(t),o[1].copy(n),o[2].copy(r),o[3].copy(a),o[4].copy(s),o[5].copy(i),this}copy(t){const n=this.planes;for(let r=0;r<6;r++)n[r].copy(t.planes[r]);return this}setFromProjectionMatrix(t,n=Sl){const r=this.planes,a=t.elements,s=a[0],i=a[1],o=a[2],l=a[3],c=a[4],u=a[5],h=a[6],d=a[7],p=a[8],f=a[9],m=a[10],y=a[11],g=a[12],x=a[13],b=a[14],v=a[15];if(r[0].setComponents(l-s,d-c,y-p,v-g).normalize(),r[1].setComponents(l+s,d+c,y+p,v+g).normalize(),r[2].setComponents(l+i,d+u,y+f,v+x).normalize(),r[3].setComponents(l-i,d-u,y-f,v-x).normalize(),r[4].setComponents(l-o,d-h,y-m,v-b).normalize(),n===Sl)r[5].setComponents(l+o,d+h,y+m,v+b).normalize();else if(n===uk)r[5].setComponents(o,h,m,b).normalize();else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+n);return this}intersectsObject(t){if(t.boundingSphere!==void 0)t.boundingSphere===null&&t.computeBoundingSphere(),nl.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);else{const n=t.geometry;n.boundingSphere===null&&n.computeBoundingSphere(),nl.copy(n.boundingSphere).applyMatrix4(t.matrixWorld)}return this.intersectsSphere(nl)}intersectsSprite(t){return nl.center.set(0,0,0),nl.radius=.7071067811865476,nl.applyMatrix4(t.matrixWorld),this.intersectsSphere(nl)}intersectsSphere(t){const n=this.planes,r=t.center,a=-t.radius;for(let s=0;s<6;s++)if(n[s].distanceToPoint(r)<a)return!1;return!0}intersectsBox(t){const n=this.planes;for(let r=0;r<6;r++){const a=n[r];if(Oy.x=a.normal.x>0?t.max.x:t.min.x,Oy.y=a.normal.y>0?t.max.y:t.min.y,Oy.z=a.normal.z>0?t.max.z:t.min.z,a.distanceToPoint(Oy)<0)return!1}return!0}containsPoint(t){const n=this.planes;for(let r=0;r<6;r++)if(n[r].distanceToPoint(t)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}class Ow extends ti{constructor(t,n,r,a,s,i,o,l,c,u,h,d){super(null,i,o,l,c,u,a,s,h,d),this.isCompressedTexture=!0,this.image={width:n,height:r},this.mipmaps=t,this.flipY=!1,this.generateMipmaps=!1}}class Yx extends Rm{constructor(t=1,n=1,r=1,a=1){super(),this.type="PlaneGeometry",this.parameters={width:t,height:n,widthSegments:r,heightSegments:a};const s=t/2,i=n/2,o=Math.floor(r),l=Math.floor(a),c=o+1,u=l+1,h=t/o,d=n/l,p=[],f=[],m=[],y=[];for(let g=0;g<u;g++){const x=g*d-i;for(let b=0;b<c;b++){const v=b*h-s;f.push(v,-x,0),m.push(0,0,1),y.push(b/o),y.push(1-g/l)}}for(let g=0;g<l;g++)for(let x=0;x<o;x++){const b=x+c*g,v=x+c*(g+1),w=x+1+c*(g+1),I=x+1+c*g;p.push(b,v,I),p.push(v,w,I)}this.setIndex(p),this.setAttribute("position",new Ah(f,3)),this.setAttribute("normal",new Ah(m,3)),this.setAttribute("uv",new Ah(y,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Yx(t.width,t.height,t.widthSegments,t.heightSegments)}}class fD extends hD{constructor(t){super(),this.isMeshStandardMaterial=!0,this.type="MeshStandardMaterial",this.defines={STANDARD:""},this.color=new fo(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new fo(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=e8,this.normalScale=new Qn(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new po,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.defines={STANDARD:""},this.color.copy(t.color),this.roughness=t.roughness,this.metalness=t.metalness,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.envMapIntensity=t.envMapIntensity,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}const bA={enabled:!1,files:{},add:function(e,t){this.enabled!==!1&&(this.files[e]=t)},get:function(e){if(this.enabled!==!1)return this.files[e]},remove:function(e){delete this.files[e]},clear:function(){this.files={}}};class W8{constructor(t,n,r){const a=this;let s=!1,i=0,o=0,l;const c=[];this.onStart=void 0,this.onLoad=t,this.onProgress=n,this.onError=r,this.itemStart=function(u){o++,s===!1&&a.onStart!==void 0&&a.onStart(u,i,o),s=!0},this.itemEnd=function(u){i++,a.onProgress!==void 0&&a.onProgress(u,i,o),i===o&&(s=!1,a.onLoad!==void 0&&a.onLoad())},this.itemError=function(u){a.onError!==void 0&&a.onError(u)},this.resolveURL=function(u){return l?l(u):u},this.setURLModifier=function(u){return l=u,this},this.addHandler=function(u,h){return c.push(u,h),this},this.removeHandler=function(u){const h=c.indexOf(u);return h!==-1&&c.splice(h,2),this},this.getHandler=function(u){for(let h=0,d=c.length;h<d;h+=2){const p=c[h],f=c[h+1];if(p.global&&(p.lastIndex=0),p.test(u))return f}return null}}}const U8=new W8;class $S{constructor(t){this.manager=t!==void 0?t:U8,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(t,n){const r=this;return new Promise(function(a,s){r.load(t,a,n,s)})}parse(){}setCrossOrigin(t){return this.crossOrigin=t,this}setWithCredentials(t){return this.withCredentials=t,this}setPath(t){return this.path=t,this}setResourcePath(t){return this.resourcePath=t,this}setRequestHeader(t){return this.requestHeader=t,this}}$S.DEFAULT_MATERIAL_NAME="__DEFAULT";class V8 extends $S{constructor(t){super(t)}load(t,n,r,a){this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const s=this,i=bA.get(t);if(i!==void 0)return s.manager.itemStart(t),setTimeout(function(){n&&n(i),s.manager.itemEnd(t)},0),i;const o=hk("img");function l(){u(),bA.add(t,this),n&&n(this),s.manager.itemEnd(t)}function c(h){u(),a&&a(h),s.manager.itemError(t),s.manager.itemEnd(t)}function u(){o.removeEventListener("load",l,!1),o.removeEventListener("error",c,!1)}return o.addEventListener("load",l,!1),o.addEventListener("error",c,!1),t.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(o.crossOrigin=this.crossOrigin),s.manager.itemStart(t),o.src=t,o}}class mD extends $S{constructor(t){super(t)}load(t,n,r,a){const s=new ti,i=new V8(this.manager);return i.setCrossOrigin(this.crossOrigin),i.setPath(this.path),i.load(t,function(o){s.image=o,s.needsUpdate=!0,n!==void 0&&n(s)},r,a),s}}class gD extends Br{constructor(t,n=1){super(),this.isLight=!0,this.type="Light",this.color=new fo(t),this.intensity=n}dispose(){}copy(t,n){return super.copy(t,n),this.color.copy(t.color),this.intensity=t.intensity,this}toJSON(t){const n=super.toJSON(t);return n.object.color=this.color.getHex(),n.object.intensity=this.intensity,this.groundColor!==void 0&&(n.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(n.object.distance=this.distance),this.angle!==void 0&&(n.object.angle=this.angle),this.decay!==void 0&&(n.object.decay=this.decay),this.penumbra!==void 0&&(n.object.penumbra=this.penumbra),this.shadow!==void 0&&(n.object.shadow=this.shadow.toJSON()),this.target!==void 0&&(n.object.target=this.target.uuid),n}}const zw=new Rn,vA=new ie,wA=new ie;class j8{constructor(t){this.camera=t,this.intensity=1,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new Qn(512,512),this.mapType=iD,this.map=null,this.mapPass=null,this.matrix=new Rn,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new B8,this._frameExtents=new Qn(1,1),this._viewportCount=1,this._viewports=[new fd(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(t){const n=this.camera,r=this.matrix;vA.setFromMatrixPosition(t.matrixWorld),n.position.copy(vA),wA.setFromMatrixPosition(t.target.matrixWorld),n.lookAt(wA),n.updateMatrixWorld(),zw.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(zw),r.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),r.multiply(zw)}getViewport(t){return this._viewports[t]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(t){return this.camera=t.camera.clone(),this.intensity=t.intensity,this.bias=t.bias,this.radius=t.radius,this.autoUpdate=t.autoUpdate,this.needsUpdate=t.needsUpdate,this.normalBias=t.normalBias,this.blurSamples=t.blurSamples,this.mapSize.copy(t.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const t={};return this.intensity!==1&&(t.intensity=this.intensity),this.bias!==0&&(t.bias=this.bias),this.normalBias!==0&&(t.normalBias=this.normalBias),this.radius!==1&&(t.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}}class G8 extends pD{constructor(t=-1,n=1,r=1,a=-1,s=.1,i=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=n,this.top=r,this.bottom=a,this.near=s,this.far=i,this.updateProjectionMatrix()}copy(t,n){return super.copy(t,n),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=t.view===null?null:Object.assign({},t.view),this}setViewOffset(t,n,r,a,s,i){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=n,this.view.offsetX=r,this.view.offsetY=a,this.view.width=s,this.view.height=i,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=(this.right-this.left)/(2*this.zoom),n=(this.top-this.bottom)/(2*this.zoom),r=(this.right+this.left)/2,a=(this.top+this.bottom)/2;let s=r-t,i=r+t,o=a+n,l=a-n;if(this.view!==null&&this.view.enabled){const c=(this.right-this.left)/this.view.fullWidth/this.zoom,u=(this.top-this.bottom)/this.view.fullHeight/this.zoom;s+=c*this.view.offsetX,i=s+c*this.view.width,o-=u*this.view.offsetY,l=o-u*this.view.height}this.projectionMatrix.makeOrthographic(s,i,o,l,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const n=super.toJSON(t);return n.object.zoom=this.zoom,n.object.left=this.left,n.object.right=this.right,n.object.top=this.top,n.object.bottom=this.bottom,n.object.near=this.near,n.object.far=this.far,this.view!==null&&(n.object.view=Object.assign({},this.view)),n}}class H8 extends j8{constructor(){super(new G8(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class yD extends gD{constructor(t,n){super(t,n),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(Br.DEFAULT_UP),this.updateMatrix(),this.target=new Br,this.shadow=new H8}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}class xD extends gD{constructor(t,n){super(t,n),this.isAmbientLight=!0,this.type="AmbientLight"}}const MS="\\[\\]\\.:\\/",q8=new RegExp("["+MS+"]","g"),FS="[^"+MS+"]",K8="[^"+MS.replace("\\.","")+"]",X8=/((?:WC+[\/:])*)/.source.replace("WC",FS),Z8=/(WCOD+)?/.source.replace("WCOD",K8),Y8=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",FS),J8=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",FS),Q8=new RegExp("^"+X8+Z8+Y8+J8+"$"),eq=["material","materials","bones","map"];class tq{constructor(t,n,r){const a=r||lt.parseTrackName(n);this._targetGroup=t,this._bindings=t.subscribe_(n,a)}getValue(t,n){this.bind();const r=this._targetGroup.nCachedObjects_,a=this._bindings[r];a!==void 0&&a.getValue(t,n)}setValue(t,n){const r=this._bindings;for(let a=this._targetGroup.nCachedObjects_,s=r.length;a!==s;++a)r[a].setValue(t,n)}bind(){const t=this._bindings;for(let n=this._targetGroup.nCachedObjects_,r=t.length;n!==r;++n)t[n].bind()}unbind(){const t=this._bindings;for(let n=this._targetGroup.nCachedObjects_,r=t.length;n!==r;++n)t[n].unbind()}}class lt{constructor(t,n,r){this.path=n,this.parsedPath=r||lt.parseTrackName(n),this.node=lt.findNode(t,this.parsedPath.nodeName),this.rootNode=t,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(t,n,r){return t&&t.isAnimationObjectGroup?new lt.Composite(t,n,r):new lt(t,n,r)}static sanitizeNodeName(t){return t.replace(/\s/g,"_").replace(q8,"")}static parseTrackName(t){const n=Q8.exec(t);if(n===null)throw new Error("PropertyBinding: Cannot parse trackName: "+t);const r={nodeName:n[2],objectName:n[3],objectIndex:n[4],propertyName:n[5],propertyIndex:n[6]},a=r.nodeName&&r.nodeName.lastIndexOf(".");if(a!==void 0&&a!==-1){const s=r.nodeName.substring(a+1);eq.indexOf(s)!==-1&&(r.nodeName=r.nodeName.substring(0,a),r.objectName=s)}if(r.propertyName===null||r.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+t);return r}static findNode(t,n){if(n===void 0||n===""||n==="."||n===-1||n===t.name||n===t.uuid)return t;if(t.skeleton){const r=t.skeleton.getBoneByName(n);if(r!==void 0)return r}if(t.children){const r=function(s){for(let i=0;i<s.length;i++){const o=s[i];if(o.name===n||o.uuid===n)return o;const l=r(o.children);if(l)return l}return null},a=r(t.children);if(a)return a}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(t,n){t[n]=this.targetObject[this.propertyName]}_getValue_array(t,n){const r=this.resolvedProperty;for(let a=0,s=r.length;a!==s;++a)t[n++]=r[a]}_getValue_arrayElement(t,n){t[n]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(t,n){this.resolvedProperty.toArray(t,n)}_setValue_direct(t,n){this.targetObject[this.propertyName]=t[n]}_setValue_direct_setNeedsUpdate(t,n){this.targetObject[this.propertyName]=t[n],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(t,n){this.targetObject[this.propertyName]=t[n],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(t,n){const r=this.resolvedProperty;for(let a=0,s=r.length;a!==s;++a)r[a]=t[n++]}_setValue_array_setNeedsUpdate(t,n){const r=this.resolvedProperty;for(let a=0,s=r.length;a!==s;++a)r[a]=t[n++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(t,n){const r=this.resolvedProperty;for(let a=0,s=r.length;a!==s;++a)r[a]=t[n++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(t,n){this.resolvedProperty[this.propertyIndex]=t[n]}_setValue_arrayElement_setNeedsUpdate(t,n){this.resolvedProperty[this.propertyIndex]=t[n],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(t,n){this.resolvedProperty[this.propertyIndex]=t[n],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(t,n){this.resolvedProperty.fromArray(t,n)}_setValue_fromArray_setNeedsUpdate(t,n){this.resolvedProperty.fromArray(t,n),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(t,n){this.resolvedProperty.fromArray(t,n),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(t,n){this.bind(),this.getValue(t,n)}_setValue_unbound(t,n){this.bind(),this.setValue(t,n)}bind(){let t=this.node;const n=this.parsedPath,r=n.objectName,a=n.propertyName;let s=n.propertyIndex;if(t||(t=lt.findNode(this.rootNode,n.nodeName),this.node=t),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!t){console.warn("THREE.PropertyBinding: No target node found for track: "+this.path+".");return}if(r){let c=n.objectIndex;switch(r){case"materials":if(!t.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!t.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}t=t.material.materials;break;case"bones":if(!t.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}t=t.skeleton.bones;for(let u=0;u<t.length;u++)if(t[u].name===c){c=u;break}break;case"map":if("map"in t){t=t.map;break}if(!t.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!t.material.map){console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);return}t=t.material.map;break;default:if(t[r]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}t=t[r]}if(c!==void 0){if(t[c]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,t);return}t=t[c]}}const i=t[a];if(i===void 0){const c=n.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+c+"."+a+" but it wasn't found.",t);return}let o=this.Versioning.None;this.targetObject=t,t.isMaterial===!0?o=this.Versioning.NeedsUpdate:t.isObject3D===!0&&(o=this.Versioning.MatrixWorldNeedsUpdate);let l=this.BindingType.Direct;if(s!==void 0){if(a==="morphTargetInfluences"){if(!t.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(!t.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}t.morphTargetDictionary[s]!==void 0&&(s=t.morphTargetDictionary[s])}l=this.BindingType.ArrayElement,this.resolvedProperty=i,this.propertyIndex=s}else i.fromArray!==void 0&&i.toArray!==void 0?(l=this.BindingType.HasFromToArray,this.resolvedProperty=i):Array.isArray(i)?(l=this.BindingType.EntireArray,this.resolvedProperty=i):this.propertyName=a;this.getValue=this.GetterByBindingType[l],this.setValue=this.SetterByBindingTypeAndVersioning[l][o]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}lt.Composite=tq;lt.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};lt.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};lt.prototype.GetterByBindingType=[lt.prototype._getValue_direct,lt.prototype._getValue_array,lt.prototype._getValue_arrayElement,lt.prototype._getValue_toArray];lt.prototype.SetterByBindingTypeAndVersioning=[[lt.prototype._setValue_direct,lt.prototype._setValue_direct_setNeedsUpdate,lt.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[lt.prototype._setValue_array,lt.prototype._setValue_array_setNeedsUpdate,lt.prototype._setValue_array_setMatrixWorldNeedsUpdate],[lt.prototype._setValue_arrayElement,lt.prototype._setValue_arrayElement_setNeedsUpdate,lt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[lt.prototype._setValue_fromArray,lt.prototype._setValue_fromArray_setNeedsUpdate,lt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:NS}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=NS);const kA={POSITION:["byte","byte normalized","unsigned byte","unsigned byte normalized","short","short normalized","unsigned short","unsigned short normalized"],NORMAL:["byte normalized","short normalized"],TANGENT:["byte normalized","short normalized"],TEXCOORD:["byte","byte normalized","unsigned byte","short","short normalized","unsigned short"]};class im{constructor(){this.textureUtils=null,this.pluginCallbacks=[],this.register(function(t){return new dq(t)}),this.register(function(t){return new pq(t)}),this.register(function(t){return new yq(t)}),this.register(function(t){return new xq(t)}),this.register(function(t){return new bq(t)}),this.register(function(t){return new vq(t)}),this.register(function(t){return new fq(t)}),this.register(function(t){return new mq(t)}),this.register(function(t){return new gq(t)}),this.register(function(t){return new wq(t)}),this.register(function(t){return new kq(t)}),this.register(function(t){return new Sq(t)}),this.register(function(t){return new Iq(t)}),this.register(function(t){return new Nq(t)})}register(t){return this.pluginCallbacks.indexOf(t)===-1&&this.pluginCallbacks.push(t),this}unregister(t){return this.pluginCallbacks.indexOf(t)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t),1),this}setTextureUtils(t){return this.textureUtils=t,this}parse(t,n,r,a){const s=new hq,i=[];for(let o=0,l=this.pluginCallbacks.length;o<l;o++)i.push(this.pluginCallbacks[o](s));s.setPlugins(i),s.setTextureUtils(this.textureUtils),s.writeAsync(t,n,a).catch(r)}parseAsync(t,n){const r=this;return new Promise(function(a,s){r.parse(t,a,s,n)})}}const Ze={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,BYTE:5120,UNSIGNED_BYTE:5121,SHORT:5122,UNSIGNED_SHORT:5123,INT:5124,UNSIGNED_INT:5125,FLOAT:5126,ARRAY_BUFFER:34962,ELEMENT_ARRAY_BUFFER:34963,NEAREST:9728,LINEAR:9729,NEAREST_MIPMAP_NEAREST:9984,LINEAR_MIPMAP_NEAREST:9985,NEAREST_MIPMAP_LINEAR:9986,LINEAR_MIPMAP_LINEAR:9987,CLAMP_TO_EDGE:33071,MIRRORED_REPEAT:33648,REPEAT:10497},Pw="KHR_mesh_quantization",na={};na[HH]=Ze.NEAREST;na[qH]=Ze.NEAREST_MIPMAP_NEAREST;na[KH]=Ze.NEAREST_MIPMAP_LINEAR;na[Xx]=Ze.LINEAR;na[XH]=Ze.LINEAR_MIPMAP_NEAREST;na[CS]=Ze.LINEAR_MIPMAP_LINEAR;na[kl]=Ze.CLAMP_TO_EDGE;na[ok]=Ze.REPEAT;na[lk]=Ze.MIRRORED_REPEAT;const SA={scale:"scale",position:"translation",quaternion:"rotation",morphTargetInfluences:"weights"},nq=new fo,IA=12,rq=1179937895,aq=2,NA=8,sq=1313821514,iq=5130562;function pf(e,t){return e.length===t.length&&e.every(function(n,r){return n===t[r]})}function oq(e){return new TextEncoder().encode(e).buffer}function lq(e){return pf(e.elements,[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}function uq(e,t,n){const r={min:new Array(e.itemSize).fill(Number.POSITIVE_INFINITY),max:new Array(e.itemSize).fill(Number.NEGATIVE_INFINITY)};for(let a=t;a<t+n;a++)for(let s=0;s<e.itemSize;s++){let i;e.itemSize>4?i=e.array[a*e.itemSize+s]:(s===0?i=e.getX(a):s===1?i=e.getY(a):s===2?i=e.getZ(a):s===3&&(i=e.getW(a)),e.normalized===!0&&(i=ck.normalize(i,e.array))),r.min[s]=Math.min(r.min[s],i),r.max[s]=Math.max(r.max[s],i)}return r}function bD(e){return Math.ceil(e/4)*4}function Lw(e,t=0){const n=bD(e.byteLength);if(n!==e.byteLength){const r=new Uint8Array(n);if(r.set(new Uint8Array(e)),t!==0)for(let a=e.byteLength;a<n;a++)r[a]=t;return r.buffer}return e}function _A(){return typeof document>"u"&&typeof OffscreenCanvas<"u"?new OffscreenCanvas(1,1):document.createElement("canvas")}function cq(e,t){if(e.toBlob!==void 0)return new Promise(r=>e.toBlob(r,t));let n;return t==="image/jpeg"?n=.92:t==="image/webp"&&(n=.8),e.convertToBlob({type:t,quality:n})}class hq{constructor(){this.plugins=[],this.options={},this.pending=[],this.buffers=[],this.byteOffset=0,this.buffers=[],this.nodeMap=new Map,this.skins=[],this.extensionsUsed={},this.extensionsRequired={},this.uids=new Map,this.uid=0,this.json={asset:{version:"2.0",generator:"THREE.GLTFExporter r"+NS}},this.cache={meshes:new Map,attributes:new Map,attributesNormalized:new Map,materials:new Map,textures:new Map,images:new Map},this.textureUtils=null}setPlugins(t){this.plugins=t}setTextureUtils(t){this.textureUtils=t}async writeAsync(t,n,r={}){this.options=Object.assign({binary:!1,trs:!1,onlyVisible:!0,maxTextureSize:1/0,animations:[],includeCustomExtensions:!1},r),this.options.animations.length>0&&(this.options.trs=!0),await this.processInputAsync(t),await Promise.all(this.pending);const a=this,s=a.buffers,i=a.json;r=a.options;const o=a.extensionsUsed,l=a.extensionsRequired,c=new Blob(s,{type:"application/octet-stream"}),u=Object.keys(o),h=Object.keys(l);if(u.length>0&&(i.extensionsUsed=u),h.length>0&&(i.extensionsRequired=h),i.buffers&&i.buffers.length>0&&(i.buffers[0].byteLength=c.size),r.binary===!0){const d=new FileReader;d.readAsArrayBuffer(c),d.onloadend=function(){const p=Lw(d.result),f=new DataView(new ArrayBuffer(NA));f.setUint32(0,p.byteLength,!0),f.setUint32(4,iq,!0);const m=Lw(oq(JSON.stringify(i)),32),y=new DataView(new ArrayBuffer(NA));y.setUint32(0,m.byteLength,!0),y.setUint32(4,sq,!0);const g=new ArrayBuffer(IA),x=new DataView(g);x.setUint32(0,rq,!0),x.setUint32(4,aq,!0);const b=IA+y.byteLength+m.byteLength+f.byteLength+p.byteLength;x.setUint32(8,b,!0);const v=new Blob([g,y,m,f,p],{type:"application/octet-stream"}),w=new FileReader;w.readAsArrayBuffer(v),w.onloadend=function(){n(w.result)}}}else if(i.buffers&&i.buffers.length>0){const d=new FileReader;d.readAsDataURL(c),d.onloadend=function(){const p=d.result;i.buffers[0].uri=p,n(i)}}else n(i)}serializeUserData(t,n){if(Object.keys(t.userData).length===0)return;const r=this.options,a=this.extensionsUsed;try{const s=JSON.parse(JSON.stringify(t.userData));if(r.includeCustomExtensions&&s.gltfExtensions){n.extensions===void 0&&(n.extensions={});for(const i in s.gltfExtensions)n.extensions[i]=s.gltfExtensions[i],a[i]=!0;delete s.gltfExtensions}Object.keys(s).length>0&&(n.extras=s)}catch(s){console.warn("THREE.GLTFExporter: userData of '"+t.name+"' won't be serialized because of JSON.stringify error - "+s.message)}}getUID(t,n=!1){if(this.uids.has(t)===!1){const a=new Map;a.set(!0,this.uid++),a.set(!1,this.uid++),this.uids.set(t,a)}return this.uids.get(t).get(n)}isNormalizedNormalAttribute(t){if(this.cache.attributesNormalized.has(t))return!1;const r=new ie;for(let a=0,s=t.count;a<s;a++)if(Math.abs(r.fromBufferAttribute(t,a).length()-1)>5e-4)return!1;return!0}createNormalizedNormalAttribute(t){const n=this.cache;if(n.attributesNormalized.has(t))return n.attributesNormalized.get(t);const r=t.clone(),a=new ie;for(let s=0,i=r.count;s<i;s++)a.fromBufferAttribute(r,s),a.x===0&&a.y===0&&a.z===0?a.setX(1):a.normalize(),r.setXYZ(s,a.x,a.y,a.z);return n.attributesNormalized.set(t,r),r}applyTextureTransform(t,n){let r=!1;const a={};(n.offset.x!==0||n.offset.y!==0)&&(a.offset=n.offset.toArray(),r=!0),n.rotation!==0&&(a.rotation=n.rotation,r=!0),(n.repeat.x!==1||n.repeat.y!==1)&&(a.scale=n.repeat.toArray(),r=!0),r&&(t.extensions=t.extensions||{},t.extensions.KHR_texture_transform=a,this.extensionsUsed.KHR_texture_transform=!0)}async buildMetalRoughTextureAsync(t,n){if(t===n)return t;function r(p){return p.colorSpace===fr?function(m){return m<.04045?m*.0773993808:Math.pow(m*.9478672986+.0521327014,2.4)}:function(m){return m}}t instanceof Ow&&(t=await this.decompressTextureAsync(t)),n instanceof Ow&&(n=await this.decompressTextureAsync(n));const a=t?t.image:null,s=n?n.image:null,i=Math.max(a?a.width:0,s?s.width:0),o=Math.max(a?a.height:0,s?s.height:0),l=_A();l.width=i,l.height=o;const c=l.getContext("2d",{willReadFrequently:!0});c.fillStyle="#00ffff",c.fillRect(0,0,i,o);const u=c.getImageData(0,0,i,o);if(a){c.drawImage(a,0,0,i,o);const p=r(t),f=c.getImageData(0,0,i,o).data;for(let m=2;m<f.length;m+=4)u.data[m]=p(f[m]/256)*256}if(s){c.drawImage(s,0,0,i,o);const p=r(n),f=c.getImageData(0,0,i,o).data;for(let m=1;m<f.length;m+=4)u.data[m]=p(f[m]/256)*256}c.putImageData(u,0,0);const d=(t||n).clone();return d.source=new uD(l),d.colorSpace=TS,d.channel=(t||n).channel,t&&n&&t.channel!==n.channel&&console.warn("THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match."),console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures."),d}async decompressTextureAsync(t,n=1/0){if(this.textureUtils===null)throw new Error("THREE.GLTFExporter: setTextureUtils() must be called to process compressed textures.");return await this.textureUtils.decompress(t,n)}processBuffer(t){const n=this.json,r=this.buffers;return n.buffers||(n.buffers=[{byteLength:0}]),r.push(t),0}processBufferView(t,n,r,a,s){const i=this.json;i.bufferViews||(i.bufferViews=[]);let o;switch(n){case Ze.BYTE:case Ze.UNSIGNED_BYTE:o=1;break;case Ze.SHORT:case Ze.UNSIGNED_SHORT:o=2;break;default:o=4}let l=t.itemSize*o;s===Ze.ARRAY_BUFFER&&(l=Math.ceil(l/4)*4);const c=bD(a*l),u=new DataView(new ArrayBuffer(c));let h=0;for(let f=r;f<r+a;f++){for(let m=0;m<t.itemSize;m++){let y;t.itemSize>4?y=t.array[f*t.itemSize+m]:(m===0?y=t.getX(f):m===1?y=t.getY(f):m===2?y=t.getZ(f):m===3&&(y=t.getW(f)),t.normalized===!0&&(y=ck.normalize(y,t.array))),n===Ze.FLOAT?u.setFloat32(h,y,!0):n===Ze.INT?u.setInt32(h,y,!0):n===Ze.UNSIGNED_INT?u.setUint32(h,y,!0):n===Ze.SHORT?u.setInt16(h,y,!0):n===Ze.UNSIGNED_SHORT?u.setUint16(h,y,!0):n===Ze.BYTE?u.setInt8(h,y):n===Ze.UNSIGNED_BYTE&&u.setUint8(h,y),h+=o}h%l!==0&&(h+=l-h%l)}const d={buffer:this.processBuffer(u.buffer),byteOffset:this.byteOffset,byteLength:c};return s!==void 0&&(d.target=s),s===Ze.ARRAY_BUFFER&&(d.byteStride=l),this.byteOffset+=c,i.bufferViews.push(d),{id:i.bufferViews.length-1,byteLength:0}}processBufferViewImage(t){const n=this,r=n.json;return r.bufferViews||(r.bufferViews=[]),new Promise(function(a){const s=new FileReader;s.readAsArrayBuffer(t),s.onloadend=function(){const i=Lw(s.result),o={buffer:n.processBuffer(i),byteOffset:n.byteOffset,byteLength:i.byteLength};n.byteOffset+=i.byteLength,a(r.bufferViews.push(o)-1)}})}processAccessor(t,n,r,a){const s=this.json,i={1:"SCALAR",2:"VEC2",3:"VEC3",4:"VEC4",9:"MAT3",16:"MAT4"};let o;if(t.array.constructor===Float32Array)o=Ze.FLOAT;else if(t.array.constructor===Int32Array)o=Ze.INT;else if(t.array.constructor===Uint32Array)o=Ze.UNSIGNED_INT;else if(t.array.constructor===Int16Array)o=Ze.SHORT;else if(t.array.constructor===Uint16Array)o=Ze.UNSIGNED_SHORT;else if(t.array.constructor===Int8Array)o=Ze.BYTE;else if(t.array.constructor===Uint8Array)o=Ze.UNSIGNED_BYTE;else throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type: "+t.array.constructor.name);if(r===void 0&&(r=0),(a===void 0||a===1/0)&&(a=t.count),a===0)return null;const l=uq(t,r,a);let c;n!==void 0&&(c=t===n.index?Ze.ELEMENT_ARRAY_BUFFER:Ze.ARRAY_BUFFER);const u=this.processBufferView(t,o,r,a,c),h={bufferView:u.id,byteOffset:u.byteOffset,componentType:o,count:a,max:l.max,min:l.min,type:i[t.itemSize]};return t.normalized===!0&&(h.normalized=!0),s.accessors||(s.accessors=[]),s.accessors.push(h)-1}processImage(t,n,r,a="image/png"){if(t!==null){const s=this,i=s.cache,o=s.json,l=s.options,c=s.pending;i.images.has(t)||i.images.set(t,{});const u=i.images.get(t),h=a+":flipY/"+r.toString();if(u[h]!==void 0)return u[h];o.images||(o.images=[]);const d={mimeType:a},p=_A();p.width=Math.min(t.width,l.maxTextureSize),p.height=Math.min(t.height,l.maxTextureSize);const f=p.getContext("2d",{willReadFrequently:!0});if(r===!0&&(f.translate(0,p.height),f.scale(1,-1)),t.data!==void 0){n!==oD&&console.error("GLTFExporter: Only RGBAFormat is supported.",n),(t.width>l.maxTextureSize||t.height>l.maxTextureSize)&&console.warn("GLTFExporter: Image size is bigger than maxTextureSize",t);const y=new Uint8ClampedArray(t.height*t.width*4);for(let g=0;g<y.length;g+=4)y[g+0]=t.data[g+0],y[g+1]=t.data[g+1],y[g+2]=t.data[g+2],y[g+3]=t.data[g+3];f.putImageData(new ImageData(y,t.width,t.height),0,0)}else if(typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&t instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&t instanceof ImageBitmap||typeof OffscreenCanvas<"u"&&t instanceof OffscreenCanvas)f.drawImage(t,0,0,p.width,p.height);else throw new Error("THREE.GLTFExporter: Invalid image type. Use HTMLImageElement, HTMLCanvasElement, ImageBitmap or OffscreenCanvas.");l.binary===!0?c.push(cq(p,a).then(y=>s.processBufferViewImage(y)).then(y=>{d.bufferView=y})):d.uri=lD.getDataURL(p,a);const m=o.images.push(d)-1;return u[h]=m,m}else throw new Error("THREE.GLTFExporter: No valid image data found. Unable to process texture.")}processSampler(t){const n=this.json;n.samplers||(n.samplers=[]);const r={magFilter:na[t.magFilter],minFilter:na[t.minFilter],wrapS:na[t.wrapS],wrapT:na[t.wrapT]};return n.samplers.push(r)-1}async processTextureAsync(t){const r=this.options,a=this.cache,s=this.json;if(a.textures.has(t))return a.textures.get(t);s.textures||(s.textures=[]),t instanceof Ow&&(t=await this.decompressTextureAsync(t,r.maxTextureSize));let i=t.userData.mimeType;i==="image/webp"&&(i="image/png");const o={sampler:this.processSampler(t),source:this.processImage(t.image,t.format,t.flipY,i)};t.name&&(o.name=t.name),await this._invokeAllAsync(async function(c){c.writeTexture&&await c.writeTexture(t,o)});const l=s.textures.push(o)-1;return a.textures.set(t,l),l}async processMaterialAsync(t){const n=this.cache,r=this.json;if(n.materials.has(t))return n.materials.get(t);if(t.isShaderMaterial)return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."),null;r.materials||(r.materials=[]);const a={pbrMetallicRoughness:{}};t.isMeshStandardMaterial!==!0&&t.isMeshBasicMaterial!==!0&&console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");const s=t.color.toArray().concat([t.opacity]);if(pf(s,[1,1,1,1])||(a.pbrMetallicRoughness.baseColorFactor=s),t.isMeshStandardMaterial?(a.pbrMetallicRoughness.metallicFactor=t.metalness,a.pbrMetallicRoughness.roughnessFactor=t.roughness):(a.pbrMetallicRoughness.metallicFactor=0,a.pbrMetallicRoughness.roughnessFactor=1),t.metalnessMap||t.roughnessMap){const o=await this.buildMetalRoughTextureAsync(t.metalnessMap,t.roughnessMap),l={index:await this.processTextureAsync(o),texCoord:o.channel};this.applyTextureTransform(l,o),a.pbrMetallicRoughness.metallicRoughnessTexture=l}if(t.map){const o={index:await this.processTextureAsync(t.map),texCoord:t.map.channel};this.applyTextureTransform(o,t.map),a.pbrMetallicRoughness.baseColorTexture=o}if(t.emissive){const o=t.emissive;if(Math.max(o.r,o.g,o.b)>0&&(a.emissiveFactor=t.emissive.toArray()),t.emissiveMap){const c={index:await this.processTextureAsync(t.emissiveMap),texCoord:t.emissiveMap.channel};this.applyTextureTransform(c,t.emissiveMap),a.emissiveTexture=c}}if(t.normalMap){const o={index:await this.processTextureAsync(t.normalMap),texCoord:t.normalMap.channel};t.normalScale&&t.normalScale.x!==1&&(o.scale=t.normalScale.x),this.applyTextureTransform(o,t.normalMap),a.normalTexture=o}if(t.aoMap){const o={index:await this.processTextureAsync(t.aoMap),texCoord:t.aoMap.channel};t.aoMapIntensity!==1&&(o.strength=t.aoMapIntensity),this.applyTextureTransform(o,t.aoMap),a.occlusionTexture=o}t.transparent?a.alphaMode="BLEND":t.alphaTest>0&&(a.alphaMode="MASK",a.alphaCutoff=t.alphaTest),t.side===_S&&(a.doubleSided=!0),t.name!==""&&(a.name=t.name),this.serializeUserData(t,a),await this._invokeAllAsync(async function(o){o.writeMaterialAsync&&await o.writeMaterialAsync(t,a)});const i=r.materials.push(a)-1;return n.materials.set(t,i),i}async processMeshAsync(t){const n=this.cache,r=this.json,a=[t.geometry.uuid];if(Array.isArray(t.material))for(let v=0,w=t.material.length;v<w;v++)a.push(t.material[v].uuid);else a.push(t.material.uuid);const s=a.join(":");if(n.meshes.has(s))return n.meshes.get(s);const i=t.geometry;let o;t.isLineSegments?o=Ze.LINES:t.isLineLoop?o=Ze.LINE_LOOP:t.isLine?o=Ze.LINE_STRIP:t.isPoints?o=Ze.POINTS:o=t.material.wireframe?Ze.LINES:Ze.TRIANGLES;const l={},c={},u=[],h=[],d={uv:"TEXCOORD_0",uv1:"TEXCOORD_1",uv2:"TEXCOORD_2",uv3:"TEXCOORD_3",color:"COLOR_0",skinWeight:"WEIGHTS_0",skinIndex:"JOINTS_0"},p=i.getAttribute("normal");p!==void 0&&!this.isNormalizedNormalAttribute(p)&&(console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."),i.setAttribute("normal",this.createNormalizedNormalAttribute(p)));let f=null;for(let v in i.attributes){if(v.slice(0,5)==="morph")continue;const w=i.attributes[v];if(v=d[v]||v.toUpperCase(),/^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(v)||(v="_"+v),n.attributes.has(this.getUID(w))){c[v]=n.attributes.get(this.getUID(w));continue}f=null;const _=w.array;v==="JOINTS_0"&&!(_ instanceof Uint16Array)&&!(_ instanceof Uint8Array)?(console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'),f=new Dr(new Uint16Array(_),w.itemSize,w.normalized)):(_ instanceof Uint32Array||_ instanceof Int32Array)&&!v.startsWith("_")&&(console.warn(`GLTFExporter: Attribute "${v}" converted to type FLOAT.`),f=im.Utils.toFloat32BufferAttribute(w));const T=this.processAccessor(f||w,i);T!==null&&(v.startsWith("_")||this.detectMeshQuantization(v,w),c[v]=T,n.attributes.set(this.getUID(w),T))}if(p!==void 0&&i.setAttribute("normal",p),Object.keys(c).length===0)return null;if(t.morphTargetInfluences!==void 0&&t.morphTargetInfluences.length>0){const v=[],w=[],I={};if(t.morphTargetDictionary!==void 0)for(const _ in t.morphTargetDictionary)I[t.morphTargetDictionary[_]]=_;for(let _=0;_<t.morphTargetInfluences.length;++_){const T={};let A=!1;for(const M in i.morphAttributes){if(M!=="position"&&M!=="normal"){A||(console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."),A=!0);continue}const F=i.morphAttributes[M][_],C=M.toUpperCase(),D=i.attributes[M];if(n.attributes.has(this.getUID(F,!0))){T[C]=n.attributes.get(this.getUID(F,!0));continue}const L=F.clone();if(!i.morphTargetsRelative)for(let O=0,q=F.count;O<q;O++)for(let H=0;H<F.itemSize;H++)H===0&&L.setX(O,F.getX(O)-D.getX(O)),H===1&&L.setY(O,F.getY(O)-D.getY(O)),H===2&&L.setZ(O,F.getZ(O)-D.getZ(O)),H===3&&L.setW(O,F.getW(O)-D.getW(O));T[C]=this.processAccessor(L,i),n.attributes.set(this.getUID(D,!0),T[C])}h.push(T),v.push(t.morphTargetInfluences[_]),t.morphTargetDictionary!==void 0&&w.push(I[_])}l.weights=v,w.length>0&&(l.extras={},l.extras.targetNames=w)}const m=Array.isArray(t.material);if(m&&i.groups.length===0)return null;let y=!1;if(m&&i.index===null){const v=[];for(let w=0,I=i.attributes.position.count;w<I;w++)v[w]=w;i.setIndex(v),y=!0}const g=m?t.material:[t.material],x=m?i.groups:[{materialIndex:0,start:void 0,count:void 0}];for(let v=0,w=x.length;v<w;v++){const I={mode:o,attributes:c};if(this.serializeUserData(i,I),h.length>0&&(I.targets=h),i.index!==null){let T=this.getUID(i.index);(x[v].start!==void 0||x[v].count!==void 0)&&(T+=":"+x[v].start+":"+x[v].count),n.attributes.has(T)?I.indices=n.attributes.get(T):(I.indices=this.processAccessor(i.index,i,x[v].start,x[v].count),n.attributes.set(T,I.indices)),I.indices===null&&delete I.indices}const _=await this.processMaterialAsync(g[x[v].materialIndex]);_!==null&&(I.material=_),u.push(I)}y===!0&&i.setIndex(null),l.primitives=u,r.meshes||(r.meshes=[]),await this._invokeAllAsync(function(v){v.writeMesh&&v.writeMesh(t,l)});const b=r.meshes.push(l)-1;return n.meshes.set(s,b),b}detectMeshQuantization(t,n){if(this.extensionsUsed[Pw])return;let r;switch(n.array.constructor){case Int8Array:r="byte";break;case Uint8Array:r="unsigned byte";break;case Int16Array:r="short";break;case Uint16Array:r="unsigned short";break;default:return}n.normalized&&(r+=" normalized");const a=t.split("_",1)[0];kA[a]&&kA[a].includes(r)&&(this.extensionsUsed[Pw]=!0,this.extensionsRequired[Pw]=!0)}processCamera(t){const n=this.json;n.cameras||(n.cameras=[]);const r=t.isOrthographicCamera,a={type:r?"orthographic":"perspective"};return r?a.orthographic={xmag:t.right*2,ymag:t.top*2,zfar:t.far<=0?.001:t.far,znear:t.near<0?0:t.near}:a.perspective={aspectRatio:t.aspect,yfov:ck.degToRad(t.fov),zfar:t.far<=0?.001:t.far,znear:t.near<0?0:t.near},t.name!==""&&(a.name=t.type),n.cameras.push(a)-1}processAnimation(t,n){const r=this.json,a=this.nodeMap;r.animations||(r.animations=[]),t=im.Utils.mergeMorphTargetTracks(t.clone(),n);const s=t.tracks,i=[],o=[];for(let l=0;l<s.length;++l){const c=s[l],u=lt.parseTrackName(c.name);let h=lt.findNode(n,u.nodeName);const d=SA[u.propertyName];if(u.objectName==="bones"&&(h.isSkinnedMesh===!0?h=h.skeleton.getBoneByName(u.objectIndex):h=void 0),!h||!d){console.warn('THREE.GLTFExporter: Could not export animation track "%s".',c.name);continue}const p=1;let f=c.values.length/c.times.length;d===SA.morphTargetInfluences&&(f/=h.morphTargetInfluences.length);let m;c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline===!0?(m="CUBICSPLINE",f/=3):c.getInterpolation()===JH?m="STEP":m="LINEAR",o.push({input:this.processAccessor(new Dr(c.times,p)),output:this.processAccessor(new Dr(c.values,f)),interpolation:m}),i.push({sampler:o.length-1,target:{node:a.get(h),path:d}})}return r.animations.push({name:t.name||"clip_"+r.animations.length,samplers:o,channels:i}),r.animations.length-1}processSkin(t){const n=this.json,r=this.nodeMap,a=n.nodes[r.get(t)],s=t.skeleton;if(s===void 0)return null;const i=t.skeleton.bones[0];if(i===void 0)return null;const o=[],l=new Float32Array(s.bones.length*16),c=new Rn;for(let h=0;h<s.bones.length;++h)o.push(r.get(s.bones[h])),c.copy(s.boneInverses[h]),c.multiply(t.bindMatrix).toArray(l,h*16);return n.skins===void 0&&(n.skins=[]),n.skins.push({inverseBindMatrices:this.processAccessor(new Dr(l,16)),joints:o,skeleton:r.get(i)}),a.skin=n.skins.length-1}async processNodeAsync(t){const n=this.json,r=this.options,a=this.nodeMap;n.nodes||(n.nodes=[]);const s={};if(r.trs){const o=t.quaternion.toArray(),l=t.position.toArray(),c=t.scale.toArray();pf(o,[0,0,0,1])||(s.rotation=o),pf(l,[0,0,0])||(s.translation=l),pf(c,[1,1,1])||(s.scale=c)}else t.matrixAutoUpdate&&t.updateMatrix(),lq(t.matrix)===!1&&(s.matrix=t.matrix.elements);if(t.name!==""&&(s.name=String(t.name)),this.serializeUserData(t,s),t.isMesh||t.isLine||t.isPoints){const o=await this.processMeshAsync(t);o!==null&&(s.mesh=o)}else t.isCamera&&(s.camera=this.processCamera(t));t.isSkinnedMesh&&this.skins.push(t);const i=n.nodes.push(s)-1;if(a.set(t,i),t.children.length>0){const o=[];for(let l=0,c=t.children.length;l<c;l++){const u=t.children[l];if(u.visible||r.onlyVisible===!1){const h=await this.processNodeAsync(u);h!==null&&o.push(h)}}o.length>0&&(s.children=o)}return await this._invokeAllAsync(function(o){o.writeNode&&o.writeNode(t,s)}),i}async processSceneAsync(t){const n=this.json,r=this.options;n.scenes||(n.scenes=[],n.scene=0);const a={};t.name!==""&&(a.name=t.name),n.scenes.push(a);const s=[];for(let i=0,o=t.children.length;i<o;i++){const l=t.children[i];if(l.visible||r.onlyVisible===!1){const c=await this.processNodeAsync(l);c!==null&&s.push(c)}}s.length>0&&(a.nodes=s),this.serializeUserData(t,a)}async processObjectsAsync(t){const n=new J0;n.name="AuxScene";for(let r=0;r<t.length;r++)n.children.push(t[r]);await this.processSceneAsync(n)}async processInputAsync(t){const n=this.options;t=t instanceof Array?t:[t],await this._invokeAllAsync(function(a){a.beforeParse&&a.beforeParse(t)});const r=[];for(let a=0;a<t.length;a++)t[a]instanceof J0?await this.processSceneAsync(t[a]):r.push(t[a]);r.length>0&&await this.processObjectsAsync(r);for(let a=0;a<this.skins.length;++a)this.processSkin(this.skins[a]);for(let a=0;a<n.animations.length;++a)this.processAnimation(n.animations[a],t[0]);await this._invokeAllAsync(function(a){a.afterParse&&a.afterParse(t)})}async _invokeAllAsync(t){for(let n=0,r=this.plugins.length;n<r;n++)await t(this.plugins[n])}}class dq{constructor(t){this.writer=t,this.name="KHR_lights_punctual"}writeNode(t,n){if(!t.isLight)return;if(!t.isDirectionalLight&&!t.isPointLight&&!t.isSpotLight){console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.",t);return}const r=this.writer,a=r.json,s=r.extensionsUsed,i={};t.name&&(i.name=t.name),i.color=t.color.toArray(),i.intensity=t.intensity,t.isDirectionalLight?i.type="directional":t.isPointLight?(i.type="point",t.distance>0&&(i.range=t.distance)):t.isSpotLight&&(i.type="spot",t.distance>0&&(i.range=t.distance),i.spot={},i.spot.innerConeAngle=(1-t.penumbra)*t.angle,i.spot.outerConeAngle=t.angle),t.decay!==void 0&&t.decay!==2&&console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."),t.target&&(t.target.parent!==t||t.target.position.x!==0||t.target.position.y!==0||t.target.position.z!==-1)&&console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."),s[this.name]||(a.extensions=a.extensions||{},a.extensions[this.name]={lights:[]},s[this.name]=!0);const o=a.extensions[this.name].lights;o.push(i),n.extensions=n.extensions||{},n.extensions[this.name]={light:o.length-1}}}class pq{constructor(t){this.writer=t,this.name="KHR_materials_unlit"}async writeMaterialAsync(t,n){if(!t.isMeshBasicMaterial)return;const a=this.writer.extensionsUsed;n.extensions=n.extensions||{},n.extensions[this.name]={},a[this.name]=!0,n.pbrMetallicRoughness.metallicFactor=0,n.pbrMetallicRoughness.roughnessFactor=.9}}class fq{constructor(t){this.writer=t,this.name="KHR_materials_clearcoat"}async writeMaterialAsync(t,n){if(!t.isMeshPhysicalMaterial||t.clearcoat===0)return;const r=this.writer,a=r.extensionsUsed,s={};if(s.clearcoatFactor=t.clearcoat,t.clearcoatMap){const i={index:await r.processTextureAsync(t.clearcoatMap),texCoord:t.clearcoatMap.channel};r.applyTextureTransform(i,t.clearcoatMap),s.clearcoatTexture=i}if(s.clearcoatRoughnessFactor=t.clearcoatRoughness,t.clearcoatRoughnessMap){const i={index:await r.processTextureAsync(t.clearcoatRoughnessMap),texCoord:t.clearcoatRoughnessMap.channel};r.applyTextureTransform(i,t.clearcoatRoughnessMap),s.clearcoatRoughnessTexture=i}if(t.clearcoatNormalMap){const i={index:await r.processTextureAsync(t.clearcoatNormalMap),texCoord:t.clearcoatNormalMap.channel};t.clearcoatNormalScale.x!==1&&(i.scale=t.clearcoatNormalScale.x),r.applyTextureTransform(i,t.clearcoatNormalMap),s.clearcoatNormalTexture=i}n.extensions=n.extensions||{},n.extensions[this.name]=s,a[this.name]=!0}}class mq{constructor(t){this.writer=t,this.name="KHR_materials_dispersion"}async writeMaterialAsync(t,n){if(!t.isMeshPhysicalMaterial||t.dispersion===0)return;const a=this.writer.extensionsUsed,s={};s.dispersion=t.dispersion,n.extensions=n.extensions||{},n.extensions[this.name]=s,a[this.name]=!0}}class gq{constructor(t){this.writer=t,this.name="KHR_materials_iridescence"}async writeMaterialAsync(t,n){if(!t.isMeshPhysicalMaterial||t.iridescence===0)return;const r=this.writer,a=r.extensionsUsed,s={};if(s.iridescenceFactor=t.iridescence,t.iridescenceMap){const i={index:await r.processTextureAsync(t.iridescenceMap),texCoord:t.iridescenceMap.channel};r.applyTextureTransform(i,t.iridescenceMap),s.iridescenceTexture=i}if(s.iridescenceIor=t.iridescenceIOR,s.iridescenceThicknessMinimum=t.iridescenceThicknessRange[0],s.iridescenceThicknessMaximum=t.iridescenceThicknessRange[1],t.iridescenceThicknessMap){const i={index:await r.processTextureAsync(t.iridescenceThicknessMap),texCoord:t.iridescenceThicknessMap.channel};r.applyTextureTransform(i,t.iridescenceThicknessMap),s.iridescenceThicknessTexture=i}n.extensions=n.extensions||{},n.extensions[this.name]=s,a[this.name]=!0}}class yq{constructor(t){this.writer=t,this.name="KHR_materials_transmission"}async writeMaterialAsync(t,n){if(!t.isMeshPhysicalMaterial||t.transmission===0)return;const r=this.writer,a=r.extensionsUsed,s={};if(s.transmissionFactor=t.transmission,t.transmissionMap){const i={index:await r.processTextureAsync(t.transmissionMap),texCoord:t.transmissionMap.channel};r.applyTextureTransform(i,t.transmissionMap),s.transmissionTexture=i}n.extensions=n.extensions||{},n.extensions[this.name]=s,a[this.name]=!0}}class xq{constructor(t){this.writer=t,this.name="KHR_materials_volume"}async writeMaterialAsync(t,n){if(!t.isMeshPhysicalMaterial||t.transmission===0)return;const r=this.writer,a=r.extensionsUsed,s={};if(s.thicknessFactor=t.thickness,t.thicknessMap){const i={index:await r.processTextureAsync(t.thicknessMap),texCoord:t.thicknessMap.channel};r.applyTextureTransform(i,t.thicknessMap),s.thicknessTexture=i}t.attenuationDistance!==1/0&&(s.attenuationDistance=t.attenuationDistance),s.attenuationColor=t.attenuationColor.toArray(),n.extensions=n.extensions||{},n.extensions[this.name]=s,a[this.name]=!0}}class bq{constructor(t){this.writer=t,this.name="KHR_materials_ior"}async writeMaterialAsync(t,n){if(!t.isMeshPhysicalMaterial||t.ior===1.5)return;const a=this.writer.extensionsUsed,s={};s.ior=t.ior,n.extensions=n.extensions||{},n.extensions[this.name]=s,a[this.name]=!0}}class vq{constructor(t){this.writer=t,this.name="KHR_materials_specular"}async writeMaterialAsync(t,n){if(!t.isMeshPhysicalMaterial||t.specularIntensity===1&&t.specularColor.equals(nq)&&!t.specularIntensityMap&&!t.specularColorMap)return;const r=this.writer,a=r.extensionsUsed,s={};if(t.specularIntensityMap){const i={index:await r.processTextureAsync(t.specularIntensityMap),texCoord:t.specularIntensityMap.channel};r.applyTextureTransform(i,t.specularIntensityMap),s.specularTexture=i}if(t.specularColorMap){const i={index:await r.processTextureAsync(t.specularColorMap),texCoord:t.specularColorMap.channel};r.applyTextureTransform(i,t.specularColorMap),s.specularColorTexture=i}s.specularFactor=t.specularIntensity,s.specularColorFactor=t.specularColor.toArray(),n.extensions=n.extensions||{},n.extensions[this.name]=s,a[this.name]=!0}}class wq{constructor(t){this.writer=t,this.name="KHR_materials_sheen"}async writeMaterialAsync(t,n){if(!t.isMeshPhysicalMaterial||t.sheen==0)return;const r=this.writer,a=r.extensionsUsed,s={};if(t.sheenRoughnessMap){const i={index:await r.processTextureAsync(t.sheenRoughnessMap),texCoord:t.sheenRoughnessMap.channel};r.applyTextureTransform(i,t.sheenRoughnessMap),s.sheenRoughnessTexture=i}if(t.sheenColorMap){const i={index:await r.processTextureAsync(t.sheenColorMap),texCoord:t.sheenColorMap.channel};r.applyTextureTransform(i,t.sheenColorMap),s.sheenColorTexture=i}s.sheenRoughnessFactor=t.sheenRoughness,s.sheenColorFactor=t.sheenColor.toArray(),n.extensions=n.extensions||{},n.extensions[this.name]=s,a[this.name]=!0}}class kq{constructor(t){this.writer=t,this.name="KHR_materials_anisotropy"}async writeMaterialAsync(t,n){if(!t.isMeshPhysicalMaterial||t.anisotropy==0)return;const r=this.writer,a=r.extensionsUsed,s={};if(t.anisotropyMap){const i={index:await r.processTextureAsync(t.anisotropyMap)};r.applyTextureTransform(i,t.anisotropyMap),s.anisotropyTexture=i}s.anisotropyStrength=t.anisotropy,s.anisotropyRotation=t.anisotropyRotation,n.extensions=n.extensions||{},n.extensions[this.name]=s,a[this.name]=!0}}class Sq{constructor(t){this.writer=t,this.name="KHR_materials_emissive_strength"}async writeMaterialAsync(t,n){if(!t.isMeshStandardMaterial||t.emissiveIntensity===1)return;const a=this.writer.extensionsUsed,s={};s.emissiveStrength=t.emissiveIntensity,n.extensions=n.extensions||{},n.extensions[this.name]=s,a[this.name]=!0}}class Iq{constructor(t){this.writer=t,this.name="EXT_materials_bump"}async writeMaterialAsync(t,n){if(!t.isMeshStandardMaterial||t.bumpScale===1&&!t.bumpMap)return;const r=this.writer,a=r.extensionsUsed,s={};if(t.bumpMap){const i={index:await r.processTextureAsync(t.bumpMap),texCoord:t.bumpMap.channel};r.applyTextureTransform(i,t.bumpMap),s.bumpTexture=i}s.bumpFactor=t.bumpScale,n.extensions=n.extensions||{},n.extensions[this.name]=s,a[this.name]=!0}}class Nq{constructor(t){this.writer=t,this.name="EXT_mesh_gpu_instancing"}writeNode(t,n){if(!t.isInstancedMesh)return;const r=this.writer,a=t,s=new Float32Array(a.count*3),i=new Float32Array(a.count*4),o=new Float32Array(a.count*3),l=new Rn,c=new ie,u=new pd,h=new ie;for(let p=0;p<a.count;p++)a.getMatrixAt(p,l),l.decompose(c,u,h),c.toArray(s,p*3),u.toArray(i,p*4),h.toArray(o,p*3);const d={TRANSLATION:r.processAccessor(new Dr(s,3)),ROTATION:r.processAccessor(new Dr(i,4)),SCALE:r.processAccessor(new Dr(o,3))};a.instanceColor&&(d._COLOR_0=r.processAccessor(a.instanceColor)),n.extensions=n.extensions||{},n.extensions[this.name]={attributes:d},r.extensionsUsed[this.name]=!0,r.extensionsRequired[this.name]=!0}}im.Utils={insertKeyframe:function(e,t){const r=e.getValueSize(),a=new e.TimeBufferType(e.times.length+1),s=new e.ValueBufferType(e.values.length+r),i=e.createInterpolant(new e.ValueBufferType(r));let o;if(e.times.length===0){a[0]=t;for(let l=0;l<r;l++)s[l]=0;o=0}else if(t<e.times[0]){if(Math.abs(e.times[0]-t)<.001)return 0;a[0]=t,a.set(e.times,1),s.set(i.evaluate(t),0),s.set(e.values,r),o=0}else if(t>e.times[e.times.length-1]){if(Math.abs(e.times[e.times.length-1]-t)<.001)return e.times.length-1;a[a.length-1]=t,a.set(e.times,0),s.set(e.values,0),s.set(i.evaluate(t),e.values.length),o=a.length-1}else for(let l=0;l<e.times.length;l++){if(Math.abs(e.times[l]-t)<.001)return l;if(e.times[l]<t&&e.times[l+1]>t){a.set(e.times.slice(0,l+1),0),a[l+1]=t,a.set(e.times.slice(l+1),l+2),s.set(e.values.slice(0,(l+1)*r),0),s.set(i.evaluate(t),(l+1)*r),s.set(e.values.slice((l+1)*r),(l+2)*r),o=l+1;break}}return e.times=a,e.values=s,o},mergeMorphTargetTracks:function(e,t){const n=[],r={},a=e.tracks;for(let s=0;s<a.length;++s){let i=a[s];const o=lt.parseTrackName(i.name),l=lt.findNode(t,o.nodeName);if(o.propertyName!=="morphTargetInfluences"||o.propertyIndex===void 0){n.push(i);continue}if(i.createInterpolant!==i.InterpolantFactoryMethodDiscrete&&i.createInterpolant!==i.InterpolantFactoryMethodLinear){if(i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."),i=i.clone(),i.setInterpolation(QH)}const c=l.morphTargetInfluences.length,u=l.morphTargetDictionary[o.propertyIndex];if(u===void 0)throw new Error("THREE.GLTFExporter: Morph target name not found: "+o.propertyIndex);let h;if(r[l.uuid]===void 0){h=i.clone();const p=new h.ValueBufferType(c*h.times.length);for(let f=0;f<h.times.length;f++)p[f*c+u]=h.values[f];h.name=(o.nodeName||"")+".morphTargetInfluences",h.values=p,r[l.uuid]=h,n.push(h);continue}const d=i.createInterpolant(new i.ValueBufferType(1));h=r[l.uuid];for(let p=0;p<h.times.length;p++)h.values[p*c+u]=d.evaluate(h.times[p]);for(let p=0;p<i.times.length;p++){const f=this.insertKeyframe(h,i.times[p]);h.values[f*c+u]=i.values[p]}}return e.tracks=n,e},toFloat32BufferAttribute:function(e){const t=new Dr(new Float32Array(e.count*e.itemSize),e.itemSize,!1);if(!e.normalized&&!e.isInterleavedBufferAttribute)return t.array.set(e.array),t;for(let n=0,r=e.count;n<r;n++)for(let a=0;a<e.itemSize;a++)t.setComponent(n,a,e.getComponent(n,a));return t}};class Bw{static isValidImageFile(t){return t.type.startsWith("image/")}static async createMaterialFromImage(t){const n=URL.createObjectURL(t);try{const r=await new Promise((o,l)=>{const c=new Image;c.onload=()=>o(c),c.onerror=l,c.src=n}),a=r.width/r.height,s=await new Promise((o,l)=>{new mD().load(n,c=>{c.colorSpace=fr,c.encoding=void 0,c.needsUpdate=!0,c.generateMipmaps=!0,c.minFilter=ZH,c.magFilter=Xx,o(c)},void 0,l)});return{material:new fD({map:s,transparent:!0,roughness:.5,metalness:0,side:_S,envMapIntensity:1,color:16777215}),aspectRatio:a}}finally{URL.revokeObjectURL(n)}}static async convertImageToTexture(t){try{const{material:n,aspectRatio:r}=await this.createMaterialFromImage(t),a=new Yx(r,1),s=new dD(a,n);s.name="ImagePlane";const i=new J0,o=new xD(16777215,.5);i.add(o);const l=new yD(16777215,1);l.position.set(5,5,5),l.castShadow=!0,i.add(l),i.add(s);const c=new im,u=await new Promise((h,d)=>{c.parse(i,p=>{p instanceof ArrayBuffer?h(new Blob([p],{type:"model/gltf-binary"})):d(new Error("Failed to export GLB"))},p=>d(p),{binary:!0,includeCustomExtensions:!0,embedImages:!0})});return new Promise((h,d)=>{const p=new FileReader;p.onload=()=>h(p.result),p.onerror=d,p.readAsDataURL(u)})}catch(n){return console.error("Error converting image to GLB:",n),null}}}var _q=Object.defineProperty,Cq=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(t,n)=>(typeof require<"u"?require:t)[n]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')}),RS=(e,t)=>{for(var n in t)_q(e,n,{get:t[n],enumerable:!0})},Ri={};RS(Ri,{Abs:()=>gd,Acos:()=>lu,Acosh:()=>uu,AdadeltaOptimizer:()=>eN,AdagradOptimizer:()=>tN,AdamOptimizer:()=>nN,AdamaxOptimizer:()=>rN,Add:()=>Do,AddN:()=>cu,All:()=>yd,Any:()=>xd,ArgMax:()=>bd,ArgMin:()=>vd,Asin:()=>hu,Asinh:()=>du,Atan:()=>pu,Atan2:()=>mu,Atanh:()=>fu,AvgPool:()=>gu,AvgPool3D:()=>wd,AvgPool3DGrad:()=>Pm,AvgPoolGrad:()=>zm,BackendWasm:()=>TU,BatchMatMul:()=>yu,BatchToSpaceND:()=>kd,Bincount:()=>Sd,BitwiseAnd:()=>Id,BroadcastArgs:()=>Lm,BroadcastTo:()=>RD,Callback:()=>CP,CallbackList:()=>vz,Cast:()=>xu,Ceil:()=>bu,ClipByValue:()=>Oo,Complex:()=>nb,ComplexAbs:()=>Bm,Concat:()=>Nd,Conv2D:()=>vu,Conv2DBackpropFilter:()=>rb,Conv2DBackpropInput:()=>wu,Conv3D:()=>ku,Conv3DBackpropFilterV2:()=>_d,Conv3DBackpropInputV2:()=>Cd,Cos:()=>Su,Cosh:()=>Iu,CropAndResize:()=>Ed,Cumprod:()=>Td,Cumsum:()=>Nu,CustomCallback:()=>kz,DataStorage:()=>Qx,DenseBincount:()=>Wm,DepthToSpace:()=>Ad,DepthwiseConv2dNative:()=>_u,DepthwiseConv2dNativeBackpropFilter:()=>ab,DepthwiseConv2dNativeBackpropInput:()=>sb,Diag:()=>Um,Dilation2D:()=>Cu,Dilation2DBackpropFilter:()=>Hh,Dilation2DBackpropInput:()=>Gh,Draw:()=>ib,ENV:()=>LS,EarlyStopping:()=>TP,Einsum:()=>ob,Elu:()=>Eu,EluGrad:()=>$d,Environment:()=>MD,Equal:()=>Md,Erf:()=>Au,Exp:()=>$u,ExpandDims:()=>Fd,Expm1:()=>Mu,FFT:()=>lb,Fill:()=>Vm,FlipLeftRight:()=>Rd,Floor:()=>Fu,FloorDiv:()=>Ru,FromPixels:()=>nx,FusedBatchNorm:()=>Du,FusedConv2D:()=>Pl,FusedDepthwiseConv2D:()=>Ll,GPGPUContext:()=>w0,GatherNd:()=>Od,GatherV2:()=>Dd,GraphModel:()=>V_,Greater:()=>zd,GreaterEqual:()=>Ou,History:()=>wz,IFFT:()=>ub,Identity:()=>zu,Imag:()=>cb,InputSpec:()=>Zt,IsFinite:()=>Pu,IsInf:()=>Lu,IsNan:()=>Bu,KernelBackend:()=>Dm,LRN:()=>ju,LRNGrad:()=>jd,LayerVariable:()=>dz,LayersModel:()=>ri,LeakyRelu:()=>Wu,Less:()=>Pd,LessEqual:()=>Ld,LinSpace:()=>Bd,Log:()=>Uu,Log1p:()=>Vu,LogSoftmax:()=>OD,LogicalAnd:()=>Wd,LogicalNot:()=>Ud,LogicalOr:()=>Vd,LogicalXor:()=>DD,LowerBound:()=>x7,MathBackendCPU:()=>H_,MathBackendWebGL:()=>vC,MatrixBandPart:()=>b7,Max:()=>Gu,MaxPool:()=>qu,MaxPool3D:()=>Gd,MaxPool3DGrad:()=>Gm,MaxPoolGrad:()=>jm,MaxPoolWithArgmax:()=>Hm,Maximum:()=>Hu,Mean:()=>Ku,Min:()=>Xu,Minimum:()=>Zu,MirrorPad:()=>Yu,Mod:()=>Ju,MomentumOptimizer:()=>aN,Multinomial:()=>Hd,Multiply:()=>Qu,Neg:()=>qd,NonMaxSuppressionV3:()=>Xd,NonMaxSuppressionV4:()=>Zd,NonMaxSuppressionV5:()=>Yd,NotEqual:()=>Kd,OP_SCOPE_SUFFIX:()=>jS,OneHot:()=>ec,OnesLike:()=>Jd,Optimizer:()=>xi,OptimizerConstructors:()=>GO,Pack:()=>Qd,PadV2:()=>tc,Pool:()=>v7,Pow:()=>nc,Prelu:()=>rc,Prod:()=>ac,RMSPropOptimizer:()=>sN,RNN:()=>bi,RaggedGather:()=>hb,RaggedRange:()=>db,RaggedTensorToTensor:()=>pb,Range:()=>qm,Rank:()=>fk,Real:()=>fb,RealDiv:()=>Tu,Reciprocal:()=>sc,Reduction:()=>Yn,Relu:()=>ic,Relu6:()=>uc,Reshape:()=>ep,ResizeBilinear:()=>lc,ResizeBilinearGrad:()=>np,ResizeNearestNeighbor:()=>oc,ResizeNearestNeighborGrad:()=>tp,Reverse:()=>cc,RotateWithOffset:()=>yp,Round:()=>hc,Rsqrt:()=>dc,SGDOptimizer:()=>Zb,ScatterNd:()=>rp,SearchSorted:()=>sp,Select:()=>ip,Selu:()=>pc,Sequential:()=>uv,Sigmoid:()=>yc,Sign:()=>gc,Sin:()=>fc,Sinh:()=>mc,Slice:()=>op,Softmax:()=>wc,Softplus:()=>xc,SpaceToBatchND:()=>lp,SparseFillEmptyRows:()=>Km,SparseReshape:()=>cp,SparseSegmentMean:()=>Xm,SparseSegmentSum:()=>Zm,SparseToDense:()=>hp,SplitV:()=>up,Sqrt:()=>bc,Square:()=>Ym,SquaredDifference:()=>kc,StaticRegexReplace:()=>Jm,Step:()=>Po,StridedSlice:()=>dp,StringNGrams:()=>Qm,StringSplit:()=>eg,StringToHashBucketFast:()=>tg,Sub:()=>Sc,Sum:()=>vc,SymbolicTensor:()=>ns,Tan:()=>Ic,Tanh:()=>Nc,Tensor:()=>ze,TensorBuffer:()=>Yt,TensorScatterUpdate:()=>ap,Tile:()=>zo,TopK:()=>pp,Transform:()=>fp,Transpose:()=>ni,Unique:()=>ng,Unpack:()=>mp,UnsortedSegmentSum:()=>rg,UpperBound:()=>w7,Variable:()=>Bl,ZerosLike:()=>gp,_FusedMatMul:()=>zl,abs:()=>Kt,acos:()=>XS,acosh:()=>ZS,add:()=>te,addN:()=>c3,all:()=>bb,any:()=>dm,argMax:()=>jl,argMin:()=>YS,asin:()=>JS,asinh:()=>QS,atan:()=>eI,atan2:()=>tI,atanh:()=>nI,avgPool:()=>mi,avgPool3d:()=>aI,backend:()=>GS,backend_util:()=>E,basicLSTMCell:()=>f3,batchNorm:()=>_c,batchNorm2d:()=>sI,batchNorm3d:()=>iI,batchNorm4d:()=>oI,batchToSpaceND:()=>cg,bincount:()=>lI,bitwiseAnd:()=>m3,booleanMaskAsync:()=>aO,broadcastArgs:()=>g3,broadcastTo:()=>Tl,broadcast_util:()=>xp,browser:()=>Sg,buffer:()=>Ve,callbacks:()=>goe,cast:()=>le,ceil:()=>uI,clipByValue:()=>Ln,clone:()=>Is,complex:()=>ui,concat:()=>xt,concat1d:()=>cI,concat2d:()=>hI,concat3d:()=>dI,concat4d:()=>pI,constraints:()=>gz,conv1d:()=>vb,conv2d:()=>nr,conv2dTranspose:()=>wb,conv3d:()=>mI,conv3dTranspose:()=>gI,copyRegisteredKernels:()=>N7,cos:()=>hg,cosh:()=>kb,cosineWindow:()=>Gb,cumprod:()=>mm,cumsum:()=>Sb,customGrad:()=>Es,data:()=>JP,denseBincount:()=>sx,deprecationWarn:()=>ZD,depthToSpace:()=>yI,depthwiseConv2d:()=>Cc,deregisterOp:()=>boe,device_util:()=>og,diag:()=>x3,dilation2d:()=>xI,disableDeprecationWarnings:()=>t9,dispose:()=>Fe,disposeVariables:()=>n9,div:()=>xe,divNoNan:()=>bI,dot:()=>vI,dropout:()=>XI,einsum:()=>pl,elu:()=>bp,enableDebugMode:()=>e9,enableProdMode:()=>Q7,enclosingPowerOfTwo:()=>ZI,engine:()=>wa,ensureShape:()=>v3,env:()=>X,equal:()=>Vr,erf:()=>Ib,euclideanNorm:()=>SI,exp:()=>Bn,expandDims:()=>yn,expm1:()=>II,eye:()=>Nb,fft:()=>wg,fill:()=>Wr,findBackend:()=>l9,findBackendFactory:()=>u9,floor:()=>wp,floorDiv:()=>xb,forceHalfFloat:()=>kB,fused:()=>ed,gather:()=>kp,gatherND:()=>lO,gather_util:()=>lN,getBackend:()=>YD,getGradient:()=>dk,getKernel:()=>um,getKernelsForBackend:()=>rx,getThreadsCount:()=>SAe,gpgpu_util:()=>Q4,grad:()=>WX,grads:()=>UX,greater:()=>or,greaterEqual:()=>gi,ifft:()=>Qh,imag:()=>dg,image:()=>ra,inTopKAsync:()=>uO,initializers:()=>yz,input:()=>Oz,io:()=>Mn,irfft:()=>Pb,isFinite:()=>NI,isInf:()=>_I,isNaN:()=>CI,keep:()=>an,kernel_impls:()=>Fs,layers:()=>xz,leakyRelu:()=>pg,less:()=>Xh,lessEqual:()=>Bo,linalg:()=>QI,linspace:()=>N3,loadGraphModel:()=>Nle,loadGraphModelSync:()=>_le,loadLayersModel:()=>hse,localResponseNormalization:()=>TI,log:()=>jr,log1p:()=>fg,logSigmoid:()=>EI,logSoftmax:()=>Cb,logSumExp:()=>mg,logicalAnd:()=>Aa,logicalNot:()=>gg,logicalOr:()=>Tb,logicalXor:()=>AI,losses:()=>wO,lowerBound:()=>C3,matMul:()=>We,math:()=>MO,max:()=>la,maxPool:()=>pn,maxPool3d:()=>$I,maxPoolWithArgmax:()=>T3,maximum:()=>Ms,mean:()=>Dt,memory:()=>wk,meshgrid:()=>E3,metrics:()=>IP,min:()=>Kh,minimum:()=>wo,mirrorPad:()=>MI,mod:()=>FI,model:()=>fse,models:()=>NP,moments:()=>yg,movingAverage:()=>sO,mul:()=>U,multiRNNCell:()=>A3,multinomial:()=>$3,neg:()=>Nt,nextFrame:()=>uN,norm:()=>vp,notEqual:()=>ql,oneHot:()=>Zh,ones:()=>gr,onesLike:()=>Gr,op:()=>W,outerProduct:()=>M3,pad:()=>ss,pad1d:()=>F3,pad2d:()=>R3,pad3d:()=>D3,pad4d:()=>O3,pool:()=>RI,pow:()=>Ts,prelu:()=>bg,print:()=>KS,prod:()=>DI,profile:()=>r9,raggedGather:()=>z3,raggedRange:()=>P3,raggedTensorToTensor:()=>L3,rand:()=>B3,randomGamma:()=>j3,randomNormal:()=>Ab,randomStandardNormal:()=>G3,randomUniform:()=>Wo,randomUniformInt:()=>H3,range:()=>Kl,ready:()=>i9,real:()=>Yh,reciprocal:()=>BI,registerBackend:()=>yb,registerCallbackConstructor:()=>gse,registerGradient:()=>zD,registerKernel:()=>ag,registerOp:()=>xoe,regularizers:()=>_P,relu:()=>ht,relu6:()=>$b,removeBackend:()=>o9,reshape:()=>V,reverse:()=>da,reverse1d:()=>q3,reverse2d:()=>K3,reverse3d:()=>X3,reverse4d:()=>Z3,rfft:()=>kg,round:()=>Mb,rsqrt:()=>Fb,scalar:()=>_e,scatterND:()=>iO,scatter_util:()=>Wb,searchSorted:()=>Eb,selu:()=>Rb,separableConv2d:()=>Sp,sequential:()=>mse,serialization:()=>se,setBackend:()=>s9,setPlatform:()=>c9,setThreadsCount:()=>kAe,setWasmPath:()=>vAe,setWasmPaths:()=>wAe,setWebGLContext:()=>S4,setdiff1dAsync:()=>Y3,shared:()=>q_,sigmoid:()=>Ca,sign:()=>WI,signal:()=>vO,sin:()=>Db,sinh:()=>Ob,slice:()=>Ke,slice1d:()=>vg,slice2d:()=>zb,slice3d:()=>Ip,slice4d:()=>Jh,slice_util:()=>ln,softmax:()=>Uo,softplus:()=>Tc,spaceToBatchND:()=>xg,sparse:()=>kO,sparseToDense:()=>oO,spectral:()=>bO,split:()=>xr,sqrt:()=>wn,square:()=>gt,squaredDifference:()=>Lb,squeeze:()=>Vo,stack:()=>Jt,step:()=>Ec,stridedSlice:()=>UI,string:()=>SO,sub:()=>me,sum:()=>ke,sumOutType:()=>gb,tan:()=>VI,tanh:()=>vo,tensor:()=>er,tensor1d:()=>ut,tensor2d:()=>Ns,tensor3d:()=>Bb,tensor4d:()=>ko,tensor5d:()=>J3,tensor6d:()=>Q3,tensorScatterUpdate:()=>tO,tensor_util:()=>Za,test_util:()=>W3,tidy:()=>j,tile:()=>Or,time:()=>a9,topk:()=>GI,train:()=>ul,transpose:()=>Ue,truncatedNormal:()=>Vb,unique:()=>HI,unregisterGradient:()=>I7,unregisterKernel:()=>S7,unsortedSegmentSum:()=>jb,unstack:()=>Vt,upcastType:()=>ca,upperBound:()=>nO,util:()=>k,valueAndGrad:()=>VX,valueAndGrads:()=>jX,variable:()=>qI,variableGrads:()=>_3,version:()=>AAe,version_converter:()=>Tle,version_core:()=>fee,version_cpu:()=>Ece,version_layers:()=>MN,version_wasm:()=>IAe,version_webgl:()=>x0e,webgl:()=>b0e,webgl_util:()=>k4,where:()=>vn,whereAsync:()=>KI,zeros:()=>Ot,zerosLike:()=>Ye});var Tq=Object.create,DS=Object.defineProperty,Eq=Object.getOwnPropertyDescriptor,Aq=Object.getOwnPropertyNames,$q=Object.getPrototypeOf,Mq=Object.prototype.hasOwnProperty,en=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),Re=(e,t)=>{for(var n in t)DS(e,n,{get:t[n],enumerable:!0})},Fq=(e,t,n,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let a of Aq(t))!Mq.call(e,a)&&a!==n&&DS(e,a,{get:()=>t[a],enumerable:!(r=Eq(t,a))||r.enumerable});return e},Ro=(e,t,n)=>(n=e!=null?Tq($q(e)):{},Fq(!e||!e.__esModule?DS(n,"default",{value:e,enumerable:!0}):n,e)),Rq=en((e,t)=>{t.exports=r;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function r(C,D,L){this.low=C|0,this.high=D|0,this.unsigned=!!L}r.prototype.__isLong__,Object.defineProperty(r.prototype,"__isLong__",{value:!0});function a(C){return(C&&C.__isLong__)===!0}r.isLong=a;var s={},i={};function o(C,D){var L,O,q;return D?(C>>>=0,(q=0<=C&&C<256)&&(O=i[C],O)?O:(L=c(C,(C|0)<0?-1:0,!0),q&&(i[C]=L),L)):(C|=0,(q=-128<=C&&C<128)&&(O=s[C],O)?O:(L=c(C,C<0?-1:0,!1),q&&(s[C]=L),L))}r.fromInt=o;function l(C,D){if(isNaN(C))return D?v:b;if(D){if(C<0)return v;if(C>=y)return A}else{if(C<=-g)return M;if(C+1>=g)return T}return C<0?l(-C,D).neg():c(C%m|0,C/m|0,D)}r.fromNumber=l;function c(C,D,L){return new r(C,D,L)}r.fromBits=c;var u=Math.pow;function h(C,D,L){if(C.length===0)throw Error("empty string");if(C==="NaN"||C==="Infinity"||C==="+Infinity"||C==="-Infinity")return b;if(typeof D=="number"?(L=D,D=!1):D=!!D,L=L||10,L<2||36<L)throw RangeError("radix");var O;if((O=C.indexOf("-"))>0)throw Error("interior hyphen");if(O===0)return h(C.substring(1),D,L).neg();for(var q=l(u(L,8)),H=b,z=0;z<C.length;z+=8){var K=Math.min(8,C.length-z),Z=parseInt(C.substring(z,z+K),L);if(K<8){var J=l(u(L,K));H=H.mul(J).add(l(Z))}else H=H.mul(q),H=H.add(l(Z))}return H.unsigned=D,H}r.fromString=h;function d(C,D){return typeof C=="number"?l(C,D):typeof C=="string"?h(C,D):c(C.low,C.high,typeof D=="boolean"?D:C.unsigned)}r.fromValue=d;var p=65536,f=1<<24,m=p*p,y=m*m,g=y/2,x=o(f),b=o(0);r.ZERO=b;var v=o(0,!0);r.UZERO=v;var w=o(1);r.ONE=w;var I=o(1,!0);r.UONE=I;var _=o(-1);r.NEG_ONE=_;var T=c(-1,2147483647,!1);r.MAX_VALUE=T;var A=c(-1,-1,!0);r.MAX_UNSIGNED_VALUE=A;var M=c(0,-2147483648,!1);r.MIN_VALUE=M;var F=r.prototype;F.toInt=function(){return this.unsigned?this.low>>>0:this.low},F.toNumber=function(){return this.unsigned?(this.high>>>0)*m+(this.low>>>0):this.high*m+(this.low>>>0)},F.toString=function(C){if(C=C||10,C<2||36<C)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(M)){var D=l(C),L=this.div(D),O=L.mul(D).sub(this);return L.toString(C)+O.toInt().toString(C)}else return"-"+this.neg().toString(C);for(var q=l(u(C,6),this.unsigned),H=this,z="";;){var K=H.div(q),Z=H.sub(K.mul(q)).toInt()>>>0,J=Z.toString(C);if(H=K,H.isZero())return J+z;for(;J.length<6;)J="0"+J;z=""+J+z}},F.getHighBits=function(){return this.high},F.getHighBitsUnsigned=function(){return this.high>>>0},F.getLowBits=function(){return this.low},F.getLowBitsUnsigned=function(){return this.low>>>0},F.getNumBitsAbs=function(){if(this.isNegative())return this.eq(M)?64:this.neg().getNumBitsAbs();for(var C=this.high!=0?this.high:this.low,D=31;D>0&&!(C&1<<D);D--);return this.high!=0?D+33:D+1},F.isZero=function(){return this.high===0&&this.low===0},F.eqz=F.isZero,F.isNegative=function(){return!this.unsigned&&this.high<0},F.isPositive=function(){return this.unsigned||this.high>=0},F.isOdd=function(){return(this.low&1)===1},F.isEven=function(){return(this.low&1)===0},F.equals=function(C){return a(C)||(C=d(C)),this.unsigned!==C.unsigned&&this.high>>>31===1&&C.high>>>31===1?!1:this.high===C.high&&this.low===C.low},F.eq=F.equals,F.notEquals=function(C){return!this.eq(C)},F.neq=F.notEquals,F.ne=F.notEquals,F.lessThan=function(C){return this.comp(C)<0},F.lt=F.lessThan,F.lessThanOrEqual=function(C){return this.comp(C)<=0},F.lte=F.lessThanOrEqual,F.le=F.lessThanOrEqual,F.greaterThan=function(C){return this.comp(C)>0},F.gt=F.greaterThan,F.greaterThanOrEqual=function(C){return this.comp(C)>=0},F.gte=F.greaterThanOrEqual,F.ge=F.greaterThanOrEqual,F.compare=function(C){if(a(C)||(C=d(C)),this.eq(C))return 0;var D=this.isNegative(),L=C.isNegative();return D&&!L?-1:!D&&L?1:this.unsigned?C.high>>>0>this.high>>>0||C.high===this.high&&C.low>>>0>this.low>>>0?-1:1:this.sub(C).isNegative()?-1:1},F.comp=F.compare,F.negate=function(){return!this.unsigned&&this.eq(M)?M:this.not().add(w)},F.neg=F.negate,F.add=function(C){a(C)||(C=d(C));var D=this.high>>>16,L=this.high&65535,O=this.low>>>16,q=this.low&65535,H=C.high>>>16,z=C.high&65535,K=C.low>>>16,Z=C.low&65535,J=0,Q=0,ne=0,oe=0;return oe+=q+Z,ne+=oe>>>16,oe&=65535,ne+=O+K,Q+=ne>>>16,ne&=65535,Q+=L+z,J+=Q>>>16,Q&=65535,J+=D+H,J&=65535,c(ne<<16|oe,J<<16|Q,this.unsigned)},F.subtract=function(C){return a(C)||(C=d(C)),this.add(C.neg())},F.sub=F.subtract,F.multiply=function(C){if(this.isZero())return b;if(a(C)||(C=d(C)),n){var D=n.mul(this.low,this.high,C.low,C.high);return c(D,n.get_high(),this.unsigned)}if(C.isZero())return b;if(this.eq(M))return C.isOdd()?M:b;if(C.eq(M))return this.isOdd()?M:b;if(this.isNegative())return C.isNegative()?this.neg().mul(C.neg()):this.neg().mul(C).neg();if(C.isNegative())return this.mul(C.neg()).neg();if(this.lt(x)&&C.lt(x))return l(this.toNumber()*C.toNumber(),this.unsigned);var L=this.high>>>16,O=this.high&65535,q=this.low>>>16,H=this.low&65535,z=C.high>>>16,K=C.high&65535,Z=C.low>>>16,J=C.low&65535,Q=0,ne=0,oe=0,ue=0;return ue+=H*J,oe+=ue>>>16,ue&=65535,oe+=q*J,ne+=oe>>>16,oe&=65535,oe+=H*Z,ne+=oe>>>16,oe&=65535,ne+=O*J,Q+=ne>>>16,ne&=65535,ne+=q*Z,Q+=ne>>>16,ne&=65535,ne+=H*K,Q+=ne>>>16,ne&=65535,Q+=L*J+O*Z+q*K+H*z,Q&=65535,c(oe<<16|ue,Q<<16|ne,this.unsigned)},F.mul=F.multiply,F.divide=function(C){if(a(C)||(C=d(C)),C.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&this.high===-2147483648&&C.low===-1&&C.high===-1)return this;var D=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,C.low,C.high);return c(D,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?v:b;var L,O,q;if(this.unsigned){if(C.unsigned||(C=C.toUnsigned()),C.gt(this))return v;if(C.gt(this.shru(1)))return I;q=v}else{if(this.eq(M)){if(C.eq(w)||C.eq(_))return M;if(C.eq(M))return w;var H=this.shr(1);return L=H.div(C).shl(1),L.eq(b)?C.isNegative()?w:_:(O=this.sub(C.mul(L)),q=L.add(O.div(C)),q)}else if(C.eq(M))return this.unsigned?v:b;if(this.isNegative())return C.isNegative()?this.neg().div(C.neg()):this.neg().div(C).neg();if(C.isNegative())return this.div(C.neg()).neg();q=b}for(O=this;O.gte(C);){L=Math.max(1,Math.floor(O.toNumber()/C.toNumber()));for(var z=Math.ceil(Math.log(L)/Math.LN2),K=z<=48?1:u(2,z-48),Z=l(L),J=Z.mul(C);J.isNegative()||J.gt(O);)L-=K,Z=l(L,this.unsigned),J=Z.mul(C);Z.isZero()&&(Z=w),q=q.add(Z),O=O.sub(J)}return q},F.div=F.divide,F.modulo=function(C){if(a(C)||(C=d(C)),n){var D=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,C.low,C.high);return c(D,n.get_high(),this.unsigned)}return this.sub(this.div(C).mul(C))},F.mod=F.modulo,F.rem=F.modulo,F.not=function(){return c(~this.low,~this.high,this.unsigned)},F.and=function(C){return a(C)||(C=d(C)),c(this.low&C.low,this.high&C.high,this.unsigned)},F.or=function(C){return a(C)||(C=d(C)),c(this.low|C.low,this.high|C.high,this.unsigned)},F.xor=function(C){return a(C)||(C=d(C)),c(this.low^C.low,this.high^C.high,this.unsigned)},F.shiftLeft=function(C){return a(C)&&(C=C.toInt()),(C&=63)===0?this:C<32?c(this.low<<C,this.high<<C|this.low>>>32-C,this.unsigned):c(0,this.low<<C-32,this.unsigned)},F.shl=F.shiftLeft,F.shiftRight=function(C){return a(C)&&(C=C.toInt()),(C&=63)===0?this:C<32?c(this.low>>>C|this.high<<32-C,this.high>>C,this.unsigned):c(this.high>>C-32,this.high>=0?0:-1,this.unsigned)},F.shr=F.shiftRight,F.shiftRightUnsigned=function(C){if(a(C)&&(C=C.toInt()),C&=63,C===0)return this;var D=this.high;if(C<32){var L=this.low;return c(L>>>C|D<<32-C,D>>>C,this.unsigned)}else return C===32?c(D,0,this.unsigned):c(D>>>C-32,0,this.unsigned)},F.shru=F.shiftRightUnsigned,F.shr_u=F.shiftRightUnsigned,F.toSigned=function(){return this.unsigned?c(this.low,this.high,!1):this},F.toUnsigned=function(){return this.unsigned?this:c(this.low,this.high,!0)},F.toBytes=function(C){return C?this.toBytesLE():this.toBytesBE()},F.toBytesLE=function(){var C=this.high,D=this.low;return[D&255,D>>>8&255,D>>>16&255,D>>>24,C&255,C>>>8&255,C>>>16&255,C>>>24]},F.toBytesBE=function(){var C=this.high,D=this.low;return[C>>>24,C>>>16&255,C>>>8&255,C&255,D>>>24,D>>>16&255,D>>>8&255,D&255]},r.fromBytes=function(C,D,L){return L?r.fromBytesLE(C,D):r.fromBytesBE(C,D)},r.fromBytesLE=function(C,D){return new r(C[0]|C[1]<<8|C[2]<<16|C[3]<<24,C[4]|C[5]<<8|C[6]<<16|C[7]<<24,D)},r.fromBytesBE=function(C,D){return new r(C[4]<<24|C[5]<<16|C[6]<<8|C[7],C[0]<<24|C[1]<<16|C[2]<<8|C[3],D)}}),Dq=en(()=>{}),Oq=en(()=>{}),zq=en((e,t)=>{(function(n,r,a){function s(c){var u=this,h=l();u.next=function(){var d=2091639*u.s0+u.c*23283064365386963e-26;return u.s0=u.s1,u.s1=u.s2,u.s2=d-(u.c=d|0)},u.c=1,u.s0=h(" "),u.s1=h(" "),u.s2=h(" "),u.s0-=h(c),u.s0<0&&(u.s0+=1),u.s1-=h(c),u.s1<0&&(u.s1+=1),u.s2-=h(c),u.s2<0&&(u.s2+=1),h=null}function i(c,u){return u.c=c.c,u.s0=c.s0,u.s1=c.s1,u.s2=c.s2,u}function o(c,u){var h=new s(c),d=u&&u.state,p=h.next;return p.int32=function(){return h.next()*4294967296|0},p.double=function(){return p()+(p()*2097152|0)*11102230246251565e-32},p.quick=p,d&&(typeof d=="object"&&i(d,h),p.state=function(){return i(h,{})}),p}function l(){var c=4022871197,u=function(h){h=String(h);for(var d=0;d<h.length;d++){c+=h.charCodeAt(d);var p=.02519603282416938*c;c=p>>>0,p-=c,p*=c,c=p>>>0,p-=c,c+=p*4294967296}return(c>>>0)*23283064365386963e-26};return u}r&&r.exports?r.exports=o:a&&a.amd?a(function(){return o}):this.alea=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),Pq=en((e,t)=>{(function(n,r,a){function s(l){var c=this,u="";c.x=0,c.y=0,c.z=0,c.w=0,c.next=function(){var d=c.x^c.x<<11;return c.x=c.y,c.y=c.z,c.z=c.w,c.w^=c.w>>>19^d^d>>>8},l===(l|0)?c.x=l:u+=l;for(var h=0;h<u.length+64;h++)c.x^=u.charCodeAt(h)|0,c.next()}function i(l,c){return c.x=l.x,c.y=l.y,c.z=l.z,c.w=l.w,c}function o(l,c){var u=new s(l),h=c&&c.state,d=function(){return(u.next()>>>0)/4294967296};return d.double=function(){do var p=u.next()>>>11,f=(u.next()>>>0)/4294967296,m=(p+f)/(1<<21);while(m===0);return m},d.int32=u.next,d.quick=d,h&&(typeof h=="object"&&i(h,u),d.state=function(){return i(u,{})}),d}r&&r.exports?r.exports=o:a&&a.amd?a(function(){return o}):this.xor128=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),Lq=en((e,t)=>{(function(n,r,a){function s(l){var c=this,u="";c.next=function(){var d=c.x^c.x>>>2;return c.x=c.y,c.y=c.z,c.z=c.w,c.w=c.v,(c.d=c.d+362437|0)+(c.v=c.v^c.v<<4^(d^d<<1))|0},c.x=0,c.y=0,c.z=0,c.w=0,c.v=0,l===(l|0)?c.x=l:u+=l;for(var h=0;h<u.length+64;h++)c.x^=u.charCodeAt(h)|0,h==u.length&&(c.d=c.x<<10^c.x>>>4),c.next()}function i(l,c){return c.x=l.x,c.y=l.y,c.z=l.z,c.w=l.w,c.v=l.v,c.d=l.d,c}function o(l,c){var u=new s(l),h=c&&c.state,d=function(){return(u.next()>>>0)/4294967296};return d.double=function(){do var p=u.next()>>>11,f=(u.next()>>>0)/4294967296,m=(p+f)/(1<<21);while(m===0);return m},d.int32=u.next,d.quick=d,h&&(typeof h=="object"&&i(h,u),d.state=function(){return i(u,{})}),d}r&&r.exports?r.exports=o:a&&a.amd?a(function(){return o}):this.xorwow=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),Bq=en((e,t)=>{(function(n,r,a){function s(l){var c=this;c.next=function(){var h=c.x,d=c.i,p,f;return p=h[d],p^=p>>>7,f=p^p<<24,p=h[d+1&7],f^=p^p>>>10,p=h[d+3&7],f^=p^p>>>3,p=h[d+4&7],f^=p^p<<7,p=h[d+7&7],p=p^p<<13,f^=p^p<<9,h[d]=f,c.i=d+1&7,f};function u(h,d){var p,f=[];if(d===(d|0))f[0]=d;else for(d=""+d,p=0;p<d.length;++p)f[p&7]=f[p&7]<<15^d.charCodeAt(p)+f[p+1&7]<<13;for(;f.length<8;)f.push(0);for(p=0;p<8&&f[p]===0;++p);for(p==8?f[7]=-1:f[p],h.x=f,h.i=0,p=256;p>0;--p)h.next()}u(c,l)}function i(l,c){return c.x=l.x.slice(),c.i=l.i,c}function o(l,c){l==null&&(l=+new Date);var u=new s(l),h=c&&c.state,d=function(){return(u.next()>>>0)/4294967296};return d.double=function(){do var p=u.next()>>>11,f=(u.next()>>>0)/4294967296,m=(p+f)/(1<<21);while(m===0);return m},d.int32=u.next,d.quick=d,h&&(h.x&&i(h,u),d.state=function(){return i(u,{})}),d}r&&r.exports?r.exports=o:a&&a.amd?a(function(){return o}):this.xorshift7=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),Wq=en((e,t)=>{(function(n,r,a){function s(l){var c=this;c.next=function(){var h=c.w,d=c.X,p=c.i,f,m;return c.w=h=h+1640531527|0,m=d[p+34&127],f=d[p=p+1&127],m^=m<<13,f^=f<<17,m^=m>>>15,f^=f>>>12,m=d[p]=m^f,c.i=p,m+(h^h>>>16)|0};function u(h,d){var p,f,m,y,g,x=[],b=128;for(d===(d|0)?(f=d,d=null):(d=d+"\0",f=0,b=Math.max(b,d.length)),m=0,y=-32;y<b;++y)d&&(f^=d.charCodeAt((y+32)%d.length)),y===0&&(g=f),f^=f<<10,f^=f>>>15,f^=f<<4,f^=f>>>13,y>=0&&(g=g+1640531527|0,p=x[y&127]^=f+g,m=p==0?m+1:0);for(m>=128&&(x[(d&&d.length||0)&127]=-1),m=127,y=4*128;y>0;--y)f=x[m+34&127],p=x[m=m+1&127],f^=f<<13,p^=p<<17,f^=f>>>15,p^=p>>>12,x[m]=f^p;h.w=g,h.X=x,h.i=m}u(c,l)}function i(l,c){return c.i=l.i,c.w=l.w,c.X=l.X.slice(),c}function o(l,c){l==null&&(l=+new Date);var u=new s(l),h=c&&c.state,d=function(){return(u.next()>>>0)/4294967296};return d.double=function(){do var p=u.next()>>>11,f=(u.next()>>>0)/4294967296,m=(p+f)/(1<<21);while(m===0);return m},d.int32=u.next,d.quick=d,h&&(h.X&&i(h,u),d.state=function(){return i(u,{})}),d}r&&r.exports?r.exports=o:a&&a.amd?a(function(){return o}):this.xor4096=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),Uq=en((e,t)=>{(function(n,r,a){function s(l){var c=this,u="";c.next=function(){var d=c.b,p=c.c,f=c.d,m=c.a;return d=d<<25^d>>>7^p,p=p-f|0,f=f<<24^f>>>8^m,m=m-d|0,c.b=d=d<<20^d>>>12^p,c.c=p=p-f|0,c.d=f<<16^p>>>16^m,c.a=m-d|0},c.a=0,c.b=0,c.c=-1640531527,c.d=1367130551,l===Math.floor(l)?(c.a=l/4294967296|0,c.b=l|0):u+=l;for(var h=0;h<u.length+20;h++)c.b^=u.charCodeAt(h)|0,c.next()}function i(l,c){return c.a=l.a,c.b=l.b,c.c=l.c,c.d=l.d,c}function o(l,c){var u=new s(l),h=c&&c.state,d=function(){return(u.next()>>>0)/4294967296};return d.double=function(){do var p=u.next()>>>11,f=(u.next()>>>0)/4294967296,m=(p+f)/(1<<21);while(m===0);return m},d.int32=u.next,d.quick=d,h&&(typeof h=="object"&&i(h,u),d.state=function(){return i(u,{})}),d}r&&r.exports?r.exports=o:a&&a.amd?a(function(){return o}):this.tychei=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),Vq=en(()=>{}),jq=en((e,t)=>{(function(n,r,a){var s=256,i=6,o=52,l="random",c=a.pow(s,i),u=a.pow(2,o),h=u*2,d=s-1,p;function f(w,I,_){var T=[];I=I==!0?{entropy:!0}:I||{};var A=x(g(I.entropy?[w,v(r)]:w??b(),3),T),M=new m(T),F=function(){for(var C=M.g(i),D=c,L=0;C<u;)C=(C+L)*s,D*=s,L=M.g(1);for(;C>=h;)C/=2,D/=2,L>>>=1;return(C+L)/D};return F.int32=function(){return M.g(4)|0},F.quick=function(){return M.g(4)/4294967296},F.double=F,x(v(M.S),r),(I.pass||_||function(C,D,L,O){return O&&(O.S&&y(O,M),C.state=function(){return y(M,{})}),L?(a[l]=C,D):C})(F,A,"global"in I?I.global:this==a,I.state)}function m(w){var I,_=w.length,T=this,A=0,M=T.i=T.j=0,F=T.S=[];for(_||(w=[_++]);A<s;)F[A]=A++;for(A=0;A<s;A++)F[A]=F[M=d&M+w[A%_]+(I=F[A])],F[M]=I;(T.g=function(C){for(var D,L=0,O=T.i,q=T.j,H=T.S;C--;)D=H[O=d&O+1],L=L*s+H[d&(H[O]=H[q=d&q+D])+(H[q]=D)];return T.i=O,T.j=q,L})(s)}function y(w,I){return I.i=w.i,I.j=w.j,I.S=w.S.slice(),I}function g(w,I){var _=[],T=typeof w,A;if(I&&T=="object")for(A in w)try{_.push(g(w[A],I-1))}catch{}return _.length?_:T=="string"?w:w+"\0"}function x(w,I){for(var _=w+"",T,A=0;A<_.length;)I[d&A]=d&(T^=I[d&A]*19)+_.charCodeAt(A++);return v(I)}function b(){try{var w;return p&&(w=p.randomBytes)?w=w(s):(w=new Uint8Array(s),(n.crypto||n.msCrypto).getRandomValues(w)),v(w)}catch{var I=n.navigator,_=I&&I.plugins;return[+new Date,n,_,n.screen,v(r)]}}function v(w){return String.fromCharCode.apply(0,w)}if(x(a.random(),r),typeof t=="object"&&t.exports){t.exports=f;try{p=Vq()}catch{}}else typeof define=="function"&&define.amd?define(function(){return f}):a["seed"+l]=f})(typeof self<"u"?self:e,[],Math)}),Jx=en((e,t)=>{var n=zq(),r=Pq(),a=Lq(),s=Bq(),i=Wq(),o=Uq(),l=jq();l.alea=n,l.xor128=r,l.xorwow=a,l.xorshift7=s,l.xor4096=i,l.tychei=o,t.exports=l}),vD=en(()=>{}),OS=en(()=>{}),wD=en(()=>{}),Gq=en(()=>{}),Hq=en(()=>{}),qq=en(()=>{}),Kq=en((e,t)=>{var n=(()=>{var r=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(r=r||__filename),function(a){a=a||{};function s(){return z.buffer!=ge&&Xe(z.buffer),Te}function i(){return z.buffer!=ge&&Xe(z.buffer),$e}function o(){return z.buffer!=ge&&Xe(z.buffer),Pe}function l(){return z.buffer!=ge&&Xe(z.buffer),je}function c(){return z.buffer!=ge&&Xe(z.buffer),ft}var u=typeof a<"u"?a:{},h,d;u.ready=new Promise(function(P,Y){h=P,d=Y});var p;typeof process<"u"&&process.listeners&&(p={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var f=Object.assign({},u),m=(P,Y)=>{throw Y},y=typeof window=="object",g=typeof importScripts=="function",x=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",b=u.ENVIRONMENT_IS_PTHREAD||!1,v="";function w(P){return u.locateFile?u.locateFile(P,v):v+P}var I,_,T;function A(P){P instanceof Os||O("exiting due to exception: "+P)}if(x){var M=OS(),F=wD();g?v=F.dirname(v)+"/":v=__dirname+"/",I=(Y,de)=>(Y=ki(Y)?new URL(Y):F.normalize(Y),M.readFileSync(Y,de?void 0:"utf8")),T=Y=>{var de=I(Y,!0);return de.buffer||(de=new Uint8Array(de)),de},_=(Y,de,Ae)=>{Y=ki(Y)?new URL(Y):F.normalize(Y),M.readFile(Y,function(Oe,Be){Oe?Ae(Oe):de(Be.buffer)})},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",function(Y){if(!(Y instanceof Os))throw Y}),process.on("unhandledRejection",function(Y){throw Y}),m=(Y,de)=>{if(Lt())throw process.exitCode=Y,de;A(de),process.exit(Y)},u.inspect=function(){return"[Emscripten Module object]"};let P;try{P=Gq()}catch(Y){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),Y}global.Worker=P.Worker}else(y||g)&&(g?v=self.location.href:typeof document<"u"&&document.currentScript&&(v=document.currentScript.src),typeof r<"u"&&r&&(v=r),v.indexOf("blob:")!==0?v=v.substr(0,v.replace(/[?#].*/,"").lastIndexOf("/")+1):v="",x||(I=P=>{var Y=new XMLHttpRequest;return Y.open("GET",P,!1),Y.send(null),Y.responseText},g&&(T=P=>{var Y=new XMLHttpRequest;return Y.open("GET",P,!1),Y.responseType="arraybuffer",Y.send(null),new Uint8Array(Y.response)}),_=(P,Y,de)=>{var Ae=new XMLHttpRequest;Ae.open("GET",P,!0),Ae.responseType="arraybuffer",Ae.onload=()=>{if(Ae.status==200||Ae.status==0&&Ae.response){Y(Ae.response);return}de()},Ae.onerror=de,Ae.send(null)}));x&&typeof performance>"u"&&(global.performance=Hq().performance);var C=console.log.bind(console),D=console.warn.bind(console);x&&(C=P=>M.writeSync(1,P+`
`),D=P=>M.writeSync(2,P+`
`));var L=u.print||C,O=u.printErr||D;Object.assign(u,f),f=null,u.arguments&&u.arguments,u.thisProgram&&u.thisProgram,u.quit&&(m=u.quit);var q;u.wasmBinary&&(q=u.wasmBinary);var H=u.noExitRuntime||!0;typeof WebAssembly!="object"&&Ds("no native wasm support detected");var z,K,Z=!1,J;function Q(P,Y){P||Ds(Y)}var ne=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function oe(P,Y,de){Y>>>=0;for(var Ae=Y+de,Oe=Y;P[Oe]&&!(Oe>=Ae);)++Oe;if(Oe-Y>16&&P.buffer&&ne)return ne.decode(P.buffer instanceof SharedArrayBuffer?P.slice(Y,Oe):P.subarray(Y,Oe));for(var Be="";Y<Oe;){var be=P[Y++];if(!(be&128)){Be+=String.fromCharCode(be);continue}var Ce=P[Y++]&63;if((be&224)==192){Be+=String.fromCharCode((be&31)<<6|Ce);continue}var Ft=P[Y++]&63;if((be&240)==224?be=(be&15)<<12|Ce<<6|Ft:be=(be&7)<<18|Ce<<12|Ft<<6|P[Y++]&63,be<65536)Be+=String.fromCharCode(be);else{var Zr=be-65536;Be+=String.fromCharCode(55296|Zr>>10,56320|Zr&1023)}}return Be}function ue(P,Y){return P>>>=0,P?oe(i(),P,Y):""}function ve(P,Y,de,Ae){if(de>>>=0,!(Ae>0))return 0;for(var Oe=de,Be=de+Ae-1,be=0;be<P.length;++be){var Ce=P.charCodeAt(be);if(Ce>=55296&&Ce<=57343){var Ft=P.charCodeAt(++be);Ce=65536+((Ce&1023)<<10)|Ft&1023}if(Ce<=127){if(de>=Be)break;Y[de++>>>0]=Ce}else if(Ce<=2047){if(de+1>=Be)break;Y[de++>>>0]=192|Ce>>6,Y[de++>>>0]=128|Ce&63}else if(Ce<=65535){if(de+2>=Be)break;Y[de++>>>0]=224|Ce>>12,Y[de++>>>0]=128|Ce>>6&63,Y[de++>>>0]=128|Ce&63}else{if(de+3>=Be)break;Y[de++>>>0]=240|Ce>>18,Y[de++>>>0]=128|Ce>>12&63,Y[de++>>>0]=128|Ce>>6&63,Y[de++>>>0]=128|Ce&63}}return Y[de>>>0]=0,de-Oe}function we(P,Y,de){return ve(P,i(),Y,de)}var ge,Te,$e,Pe,je,ft;b&&(ge=u.buffer);function Xe(P){ge=P,u.HEAP8=Te=new Int8Array(P),u.HEAP16=new Int16Array(P),u.HEAP32=Pe=new Int32Array(P),u.HEAPU8=$e=new Uint8Array(P),u.HEAPU16=new Uint16Array(P),u.HEAPU32=je=new Uint32Array(P),u.HEAPF32=new Float32Array(P),u.HEAPF64=ft=new Float64Array(P)}var tt=u.INITIAL_MEMORY||16777216;if(b)z=u.wasmMemory,ge=u.buffer;else if(u.wasmMemory)z=u.wasmMemory;else if(z=new WebAssembly.Memory({initial:tt/65536,maximum:65536,shared:!0}),!(z.buffer instanceof SharedArrayBuffer))throw O("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),x&&O("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");z&&(ge=z.buffer),tt=ge.byteLength,Xe(ge);var De,ot=[],kt=[],_r=[];function Lt(){return H}function ur(){if(u.preRun)for(typeof u.preRun=="function"&&(u.preRun=[u.preRun]);u.preRun.length;)ga(u.preRun.shift());St(ot)}function In(){!b&&St(kt)}function cr(){if(!b){if(u.postRun)for(typeof u.postRun=="function"&&(u.postRun=[u.postRun]);u.postRun.length;)hr(u.postRun.shift());St(_r)}}function ga(P){ot.unshift(P)}function Cr(P){kt.unshift(P)}function hr(P){_r.unshift(P)}var Nn=0,Kr=null;function wi(P){Nn++,u.monitorRunDependencies&&u.monitorRunDependencies(Nn)}function Lp(P){if(Nn--,u.monitorRunDependencies&&u.monitorRunDependencies(Nn),Nn==0&&Kr){var Y=Kr;Kr=null,Y()}}function Ds(P){u.onAbort&&u.onAbort(P),P="Aborted("+P+")",O(P),Z=!0,J=1,P+=". Build with -sASSERTIONS for more info.";var Y=new WebAssembly.RuntimeError(P);throw d(Y),Y}var Bp="data:application/octet-stream;base64,";function os(P){return P.startsWith(Bp)}function ki(P){return P.startsWith("file://")}var _n;_n="tfjs-backend-wasm-threaded-simd.wasm",os(_n)||(_n=w(_n));function Bg(P){try{if(P==_n&&q)return new Uint8Array(q);if(T)return T(P);throw"both async and sync fetching of the wasm failed"}catch(Y){Ds(Y)}}function Wg(){if(!q&&(y||g)){if(typeof fetch=="function"&&!ki(_n))return fetch(_n,{credentials:"same-origin"}).then(function(P){if(!P.ok)throw"failed to load wasm binary file at '"+_n+"'";return P.arrayBuffer()}).catch(function(){return Bg(_n)});if(_)return new Promise(function(P,Y){_(_n,function(de){P(new Uint8Array(de))},Y)})}return Promise.resolve().then(function(){return Bg(_n)})}function Ug(){var P={env:sT,wasi_snapshot_preview1:sT};function Y(be,Ce){var Ft=be.exports;if(u.asm=Ft,zs(u.asm._emscripten_tls_init),De=u.asm.__indirect_function_table,Cr(u.asm.__wasm_call_ctors),K=Ce,!b){var Zr=ye.unusedWorkers.length;ye.unusedWorkers.forEach(function(Ps){ye.loadWasmModuleToWorker(Ps,function(){--Zr||Lp()})})}}b||wi();function de(be){Y(be.instance,be.module)}function Ae(be){return Wg().then(function(Ce){return WebAssembly.instantiate(Ce,P)}).then(function(Ce){return Ce}).then(be,function(Ce){O("failed to asynchronously prepare wasm: "+Ce),Ds(Ce)})}function Oe(){return!q&&typeof WebAssembly.instantiateStreaming=="function"&&!os(_n)&&!ki(_n)&&!x&&typeof fetch=="function"?fetch(_n,{credentials:"same-origin"}).then(function(be){var Ce=WebAssembly.instantiateStreaming(be,P);return Ce.then(de,function(Ft){return O("wasm streaming compile failed: "+Ft),O("falling back to ArrayBuffer instantiation"),Ae(de)})}):Ae(de)}if(u.instantiateWasm)try{var Be=u.instantiateWasm(P,Y);return Be}catch(be){O("Module.instantiateWasm callback failed with error: "+be),d(be)}return Oe().catch(d),{}}var Vg={};function Os(P){this.name="ExitStatus",this.message="Program terminated with exit("+P+")",this.status=P}function Pc(P){var Y=ye.pthreads[P];delete ye.pthreads[P],Y.terminate(),$v(P),ye.runningWorkers.splice(ye.runningWorkers.indexOf(Y),1),Y.pthread_ptr=0}function jg(P){var Y=ye.pthreads[P];Y.postMessage({cmd:"cancel"})}function Yo(P){var Y=ye.pthreads[P];Q(Y),ye.returnWorkerToPool(Y)}function Jo(P){var Y=ye.getNewWorker();if(!Y)return 6;ye.runningWorkers.push(Y),ye.pthreads[P.pthread_ptr]=Y,Y.pthread_ptr=P.pthread_ptr;var de={cmd:"run",start_routine:P.startRoutine,arg:P.arg,pthread_ptr:P.pthread_ptr};return Y.runPthread=()=>{x&&Y.ref(),Y.postMessage(de,P.transferList),delete Y.runPthread},Y.loaded&&Y.runPthread(),0}function Gg(P){if(b)return Lc(1,1,P);J=P,Lt()||(ye.terminateAllThreads(),u.onExit&&u.onExit(P),Z=!0),m(P,new Os(P))}function ae(P,Y){if(J=P,!Y&&b)throw qe(P),"unwind";Gg(P)}var he=ae;function Ee(P){if(P instanceof Os||P=="unwind")return J;m(1,P)}var ye={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],pthreads:{},init:function(){b?ye.initWorker():ye.initMainThread()},initMainThread:function(){for(var P=8;P--;)ye.allocateUnusedWorker()},initWorker:function(){H=!1},setExitStatus:function(P){J=P},terminateAllThreads:function(){for(var P of Object.values(ye.pthreads))ye.returnWorkerToPool(P);for(var P of ye.unusedWorkers)P.terminate();ye.unusedWorkers=[]},returnWorkerToPool:function(P){var Y=P.pthread_ptr;delete ye.pthreads[Y],ye.unusedWorkers.push(P),ye.runningWorkers.splice(ye.runningWorkers.indexOf(P),1),P.pthread_ptr=0,x&&P.unref(),$v(Y)},receiveObjectTransfer:function(P){},threadInitTLS:function(){ye.tlsInitFunctions.forEach(P=>P())},loadWasmModuleToWorker:function(P,Y){P.onmessage=Be=>{var be=Be.data,Ce=be.cmd;if(P.pthread_ptr&&(ye.currentProxiedOperationCallerThread=P.pthread_ptr),be.targetThread&&be.targetThread!=Xg()){var Ft=ye.pthreads[be.targetThread];Ft?Ft.postMessage(be,be.transferList):O('Internal error! Worker sent a message "'+Ce+'" to target pthread '+be.targetThread+", but that thread no longer exists!"),ye.currentProxiedOperationCallerThread=void 0;return}Ce==="processProxyingQueue"?Tv(be.queue):Ce==="spawnThread"?Jo(be):Ce==="cleanupThread"?Yo(be.thread):Ce==="killThread"?Pc(be.thread):Ce==="cancelThread"?jg(be.thread):Ce==="loaded"?(P.loaded=!0,x&&P.unref(),Y&&Y(P),P.runPthread&&P.runPthread()):Ce==="print"?L("Thread "+be.threadId+": "+be.text):Ce==="printErr"?O("Thread "+be.threadId+": "+be.text):Ce==="alert"?alert("Thread "+be.threadId+": "+be.text):be.target==="setimmediate"?P.postMessage(be):Ce==="callHandler"?u[be.handler](...be.args):Ce&&O("worker sent an unknown command "+Ce),ye.currentProxiedOperationCallerThread=void 0},P.onerror=Be=>{var be="worker sent an error!";throw O(be+" "+Be.filename+":"+Be.lineno+": "+Be.message),Be},x&&(P.on("message",function(Be){P.onmessage({data:Be})}),P.on("error",function(Be){P.onerror(Be)}),P.on("detachedExit",function(){}));var de=[],Ae=["onExit","onAbort","print","printErr"];for(var Oe of Ae)u.hasOwnProperty(Oe)&&de.push(Oe);P.postMessage({cmd:"load",handlers:de,urlOrBlob:u.mainScriptUrlOrBlob||r,wasmMemory:z,wasmModule:K})},allocateUnusedWorker:function(){var P,Y=w("tfjs-backend-wasm-threaded-simd.worker.js");P=new Worker(Y),ye.unusedWorkers.push(P)},getNewWorker:function(){return ye.unusedWorkers.length==0&&(ye.allocateUnusedWorker(),ye.loadWasmModuleToWorker(ye.unusedWorkers[0])),ye.unusedWorkers.pop()}};u.PThread=ye;function St(P){for(;P.length>0;)P.shift()(u)}function Tt(){var P=Xg(),Y=o()[P+52>>>2],de=o()[P+56>>>2],Ae=Y-de;cT(Y,Ae),Zg(Y)}u.establishStackSpace=Tt;function qe(P){if(b)return Lc(2,0,P);try{he(P)}catch(Y){Ee(Y)}}var Le=[];function qt(P){var Y=Le[P];return Y||(P>=Le.length&&(Le.length=P+1),Le[P]=Y=De.get(P)),Y}function Xr(P,Y){var de=qt(P)(Y);Lt()?ye.setExitStatus(de):uT(de)}u.invokeEntryPoint=Xr;function zs(P){ye.tlsInitFunctions.push(P)}function Hg(P){iT(P,!g,1,!y),ye.threadInitTLS()}function Wp(P){b?postMessage({cmd:"cleanupThread",thread:P}):Yo(P)}function qg(P,Y,de,Ae){return b?Lc(3,1,P,Y,de,Ae):Vn(P,Y,de,Ae)}function Vn(P,Y,de,Ae){if(typeof SharedArrayBuffer>"u")return O("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var Oe=[],Be=0;if(b&&(Oe.length===0||Be))return qg(P,Y,de,Ae);var be={startRoutine:de,pthread_ptr:P,arg:Ae,transferList:Oe};return b?(be.cmd="spawnThread",postMessage(be,Oe),0):Jo(be)}function Si(){return 65536}var Kg=!0;function TV(){return Kg}function Tv(P){Atomics.store(o(),P>>2,1),Xg()&&lT(P),Atomics.compareExchange(o(),P>>2,1,0)}u.executeNotifiedProxyingQueue=Tv;function EV(P,Y,de,Ae){if(P==Y)setTimeout(()=>Tv(Ae));else if(b)postMessage({targetThread:P,cmd:"processProxyingQueue",queue:Ae});else{var Oe=ye.pthreads[P];if(!Oe)return;Oe.postMessage({cmd:"processProxyingQueue",queue:Ae})}return 1}function AV(P,Y,de){return-1}function $V(){Ds("")}function Up(P){Up.shown||(Up.shown={}),Up.shown[P]||(Up.shown[P]=1,x&&(P="warning: "+P),O(P))}function MV(){x||g||Up("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")}function FV(){return Date.now()}function eT(){return 4294901760}function RV(){return eT()}var Ev;x?Ev=()=>{var P=process.hrtime();return P[0]*1e3+P[1]/1e6}:Ev=()=>performance.timeOrigin+performance.now();function DV(P,Y,de){i().copyWithin(P>>>0,Y>>>0,Y+de>>>0)}function OV(){return x?qq().cpus().length:navigator.hardwareConcurrency}function zV(P){var Y=Mv(),de=P();return Zg(Y),de}function Lc(P,Y){var de=arguments.length-2,Ae=arguments;return zV(()=>{for(var Oe=de,Be=Yg(Oe*8),be=Be>>3,Ce=0;Ce<de;Ce++){var Ft=Ae[2+Ce];c()[be+Ce>>>0]=Ft}return oT(P,Oe,Be,Y)})}var Av=[];function PV(P,Y,de){Av.length=Y;for(var Ae=de>>3,Oe=0;Oe<Y;Oe++)Av[Oe]=c()[Ae+Oe>>>0];var Be=P<0,be=Be?Vg[-P-1]:qV[P];return be.apply(null,Av)}function LV(P){try{return z.grow(P-ge.byteLength+65535>>>16),Xe(z.buffer),1}catch{}}function BV(P){var Y=i().length;if(P=P>>>0,P<=Y)return!1;var de=eT();if(P>de)return!1;let Ae=(Ft,Zr)=>Ft+(Zr-Ft%Zr)%Zr;for(var Oe=1;Oe<=4;Oe*=2){var Be=Y*(1+.2/Oe);Be=Math.min(Be,P+100663296);var be=Math.min(de,Ae(Math.max(P,Be),65536)),Ce=LV(be);if(Ce)return!0}return!1}function WV(){throw"unwind"}function tT(P){return b?Lc(4,1,P):52}function nT(P,Y,de,Ae,Oe){return b?Lc(5,1,P,Y,de,Ae,Oe):70}var UV=[null,[],[]];function VV(P,Y){var de=UV[P];Y===0||Y===10?((P===1?L:O)(oe(de,0)),de.length=0):de.push(Y)}function rT(P,Y,de,Ae){if(b)return Lc(6,1,P,Y,de,Ae);for(var Oe=0,Be=0;Be<de;Be++){var be=l()[Y>>>2],Ce=l()[Y+4>>>2];Y+=8;for(var Ft=0;Ft<Ce;Ft++)VV(P,i()[be+Ft>>>0]);Oe+=Ce}return l()[Ae>>>2]=Oe,0}function aT(P){var Y=u["_"+P];return Y}function jV(P,Y){s().set(P,Y>>>0)}function GV(P,Y,de,Ae,Oe){var Be={string:Yr=>{var Bc=0;if(Yr!=null&&Yr!==0){var pT=(Yr.length<<2)+1;Bc=Yg(pT),we(Yr,Bc,pT)}return Bc},array:Yr=>{var Bc=Yg(Yr.length);return jV(Yr,Bc),Bc}};function be(Yr){return Y==="string"?ue(Yr):Y==="boolean"?!!Yr:Yr}var Ce=aT(P),Ft=[],Zr=0;if(Ae)for(var Ps=0;Ps<Ae.length;Ps++){var dT=Be[de[Ps]];dT?(Zr===0&&(Zr=Mv()),Ft[Ps]=dT(Ae[Ps])):Ft[Ps]=Ae[Ps]}var Fv=Ce.apply(null,Ft);function XV(Yr){return Zr!==0&&Zg(Zr),be(Yr)}return Fv=XV(Fv),Fv}function HV(P,Y,de,Ae){de=de||[];var Oe=de.every(be=>be==="number"||be==="boolean"),Be=Y!=="string";return Be&&Oe&&!Ae?aT(P):function(){return GV(P,Y,de,arguments)}}ye.init();var qV=[null,Gg,qe,qg,tT,nT,rT],sT={__emscripten_init_main_thread_js:Hg,__emscripten_thread_cleanup:Wp,__pthread_create_js:Vn,_emscripten_default_pthread_stack_size:Si,_emscripten_get_now_is_monotonic:TV,_emscripten_notify_task_queue:EV,_emscripten_set_offscreencanvas_size:AV,abort:$V,emscripten_check_blocking_allowed:MV,emscripten_date_now:FV,emscripten_get_heap_max:RV,emscripten_get_now:Ev,emscripten_memcpy_big:DV,emscripten_num_logical_cores:OV,emscripten_receive_on_main_thread_js:PV,emscripten_resize_heap:BV,emscripten_unwind_to_js_event_loop:WV,exit:he,fd_close:tT,fd_seek:nT,fd_write:rT,memory:z||u.wasmMemory};Ug(),u.___wasm_call_ctors=function(){return(u.___wasm_call_ctors=u.asm.__wasm_call_ctors).apply(null,arguments)},u._init=function(){return(u._init=u.asm.init).apply(null,arguments)},u._init_with_threads_count=function(){return(u._init_with_threads_count=u.asm.init_with_threads_count).apply(null,arguments)},u._get_threads_count=function(){return(u._get_threads_count=u.asm.get_threads_count).apply(null,arguments)},u._register_tensor=function(){return(u._register_tensor=u.asm.register_tensor).apply(null,arguments)},u._dispose_data=function(){return(u._dispose_data=u.asm.dispose_data).apply(null,arguments)},u._dispose=function(){return(u._dispose=u.asm.dispose).apply(null,arguments)},u._Abs=function(){return(u._Abs=u.asm.Abs).apply(null,arguments)},u._Acos=function(){return(u._Acos=u.asm.Acos).apply(null,arguments)},u._Acosh=function(){return(u._Acosh=u.asm.Acosh).apply(null,arguments)},u._Add=function(){return(u._Add=u.asm.Add).apply(null,arguments)},u._AddN=function(){return(u._AddN=u.asm.AddN).apply(null,arguments)},u._All=function(){return(u._All=u.asm.All).apply(null,arguments)},u._Any=function(){return(u._Any=u.asm.Any).apply(null,arguments)},u._ArgMax=function(){return(u._ArgMax=u.asm.ArgMax).apply(null,arguments)},u._ArgMin=function(){return(u._ArgMin=u.asm.ArgMin).apply(null,arguments)},u._Asin=function(){return(u._Asin=u.asm.Asin).apply(null,arguments)},u._Asinh=function(){return(u._Asinh=u.asm.Asinh).apply(null,arguments)},u._Atan=function(){return(u._Atan=u.asm.Atan).apply(null,arguments)},u._Atan2=function(){return(u._Atan2=u.asm.Atan2).apply(null,arguments)},u._Atanh=function(){return(u._Atanh=u.asm.Atanh).apply(null,arguments)},u._AvgPool=function(){return(u._AvgPool=u.asm.AvgPool).apply(null,arguments)},u._AvgPool3D=function(){return(u._AvgPool3D=u.asm.AvgPool3D).apply(null,arguments)},u._AvgPool3DGrad=function(){return(u._AvgPool3DGrad=u.asm.AvgPool3DGrad).apply(null,arguments)},u._AvgPoolGrad=function(){return(u._AvgPoolGrad=u.asm.AvgPoolGrad).apply(null,arguments)},u._BatchMatMul=function(){return(u._BatchMatMul=u.asm.BatchMatMul).apply(null,arguments)},u._Bincount=function(){return(u._Bincount=u.asm.Bincount).apply(null,arguments)},u._BitwiseAnd=function(){return(u._BitwiseAnd=u.asm.BitwiseAnd).apply(null,arguments)},u._Ceil=function(){return(u._Ceil=u.asm.Ceil).apply(null,arguments)},u._ClipByValue=function(){return(u._ClipByValue=u.asm.ClipByValue).apply(null,arguments)},u._Conv2D=function(){return(u._Conv2D=u.asm.Conv2D).apply(null,arguments)},u._Conv2DBackpropInput=function(){return(u._Conv2DBackpropInput=u.asm.Conv2DBackpropInput).apply(null,arguments)},u._Conv3D=function(){return(u._Conv3D=u.asm.Conv3D).apply(null,arguments)},u._Conv3DBackpropFilterV2=function(){return(u._Conv3DBackpropFilterV2=u.asm.Conv3DBackpropFilterV2).apply(null,arguments)},u._Conv3DBackpropInputV2=function(){return(u._Conv3DBackpropInputV2=u.asm.Conv3DBackpropInputV2).apply(null,arguments)},u._Cos=function(){return(u._Cos=u.asm.Cos).apply(null,arguments)},u._Cosh=function(){return(u._Cosh=u.asm.Cosh).apply(null,arguments)},u._CropAndResize=function(){return(u._CropAndResize=u.asm.CropAndResize).apply(null,arguments)},u._Cumprod=function(){return(u._Cumprod=u.asm.Cumprod).apply(null,arguments)},u._Cumsum=function(){return(u._Cumsum=u.asm.Cumsum).apply(null,arguments)},u._DenseBincount=function(){return(u._DenseBincount=u.asm.DenseBincount).apply(null,arguments)},u._DepthToSpace=function(){return(u._DepthToSpace=u.asm.DepthToSpace).apply(null,arguments)},u._DepthwiseConv2dNative=function(){return(u._DepthwiseConv2dNative=u.asm.DepthwiseConv2dNative).apply(null,arguments)},u._Diag=function(){return(u._Diag=u.asm.Diag).apply(null,arguments)},u._Dilation2D=function(){return(u._Dilation2D=u.asm.Dilation2D).apply(null,arguments)},u._Dilation2DBackpropFilter=function(){return(u._Dilation2DBackpropFilter=u.asm.Dilation2DBackpropFilter).apply(null,arguments)},u._Dilation2DBackpropInput=function(){return(u._Dilation2DBackpropInput=u.asm.Dilation2DBackpropInput).apply(null,arguments)},u._Elu=function(){return(u._Elu=u.asm.Elu).apply(null,arguments)},u._EluGrad=function(){return(u._EluGrad=u.asm.EluGrad).apply(null,arguments)},u._Equal=function(){return(u._Equal=u.asm.Equal).apply(null,arguments)},u._Erf=function(){return(u._Erf=u.asm.Erf).apply(null,arguments)},u._Exp=function(){return(u._Exp=u.asm.Exp).apply(null,arguments)},u._Expm1=function(){return(u._Expm1=u.asm.Expm1).apply(null,arguments)},u._FlipLeftRight=function(){return(u._FlipLeftRight=u.asm.FlipLeftRight).apply(null,arguments)},u._Floor=function(){return(u._Floor=u.asm.Floor).apply(null,arguments)},u._FloorDiv=function(){return(u._FloorDiv=u.asm.FloorDiv).apply(null,arguments)},u._FusedBatchNorm=function(){return(u._FusedBatchNorm=u.asm.FusedBatchNorm).apply(null,arguments)},u._FusedConv2D=function(){return(u._FusedConv2D=u.asm.FusedConv2D).apply(null,arguments)},u._FusedDepthwiseConv2D=function(){return(u._FusedDepthwiseConv2D=u.asm.FusedDepthwiseConv2D).apply(null,arguments)},u._Gather=function(){return(u._Gather=u.asm.Gather).apply(null,arguments)},u._GatherNd=function(){return(u._GatherNd=u.asm.GatherNd).apply(null,arguments)},u._Greater=function(){return(u._Greater=u.asm.Greater).apply(null,arguments)},u._GreaterEqual=function(){return(u._GreaterEqual=u.asm.GreaterEqual).apply(null,arguments)},u._IsFinite=function(){return(u._IsFinite=u.asm.IsFinite).apply(null,arguments)},u._IsInf=function(){return(u._IsInf=u.asm.IsInf).apply(null,arguments)},u._IsNan=function(){return(u._IsNan=u.asm.IsNan).apply(null,arguments)},u._LRN=function(){return(u._LRN=u.asm.LRN).apply(null,arguments)},u._LRNGrad=function(){return(u._LRNGrad=u.asm.LRNGrad).apply(null,arguments)},u._LeakyRelu=function(){return(u._LeakyRelu=u.asm.LeakyRelu).apply(null,arguments)},u._Less=function(){return(u._Less=u.asm.Less).apply(null,arguments)},u._LessEqual=function(){return(u._LessEqual=u.asm.LessEqual).apply(null,arguments)},u._LinSpace=function(){return(u._LinSpace=u.asm.LinSpace).apply(null,arguments)},u._Log=function(){return(u._Log=u.asm.Log).apply(null,arguments)},u._Log1p=function(){return(u._Log1p=u.asm.Log1p).apply(null,arguments)},u._LogicalAnd=function(){return(u._LogicalAnd=u.asm.LogicalAnd).apply(null,arguments)},u._LogicalNot=function(){return(u._LogicalNot=u.asm.LogicalNot).apply(null,arguments)},u._LogicalOr=function(){return(u._LogicalOr=u.asm.LogicalOr).apply(null,arguments)},u._LogicalXor=function(){return(u._LogicalXor=u.asm.LogicalXor).apply(null,arguments)},u._Max=function(){return(u._Max=u.asm.Max).apply(null,arguments)},u._MaxPool=function(){return(u._MaxPool=u.asm.MaxPool).apply(null,arguments)},u._MaxPool3D=function(){return(u._MaxPool3D=u.asm.MaxPool3D).apply(null,arguments)},u._MaxPool3DGrad=function(){return(u._MaxPool3DGrad=u.asm.MaxPool3DGrad).apply(null,arguments)},u._MaxPoolGrad=function(){return(u._MaxPoolGrad=u.asm.MaxPoolGrad).apply(null,arguments)},u._MaxPoolWithArgmax=function(){return(u._MaxPoolWithArgmax=u.asm.MaxPoolWithArgmax).apply(null,arguments)},u._Maximum=function(){return(u._Maximum=u.asm.Maximum).apply(null,arguments)},u._Mean=function(){return(u._Mean=u.asm.Mean).apply(null,arguments)},u._Min=function(){return(u._Min=u.asm.Min).apply(null,arguments)},u._Minimum=function(){return(u._Minimum=u.asm.Minimum).apply(null,arguments)},u._MirrorPad=function(){return(u._MirrorPad=u.asm.MirrorPad).apply(null,arguments)},u._Mod=function(){return(u._Mod=u.asm.Mod).apply(null,arguments)},u._Multinomial=function(){return(u._Multinomial=u.asm.Multinomial).apply(null,arguments)},u._Multiply=function(){return(u._Multiply=u.asm.Multiply).apply(null,arguments)},u._Neg=function(){return(u._Neg=u.asm.Neg).apply(null,arguments)},u._NonMaxSuppressionV3=function(){return(u._NonMaxSuppressionV3=u.asm.NonMaxSuppressionV3).apply(null,arguments)},u._NonMaxSuppressionV4=function(){return(u._NonMaxSuppressionV4=u.asm.NonMaxSuppressionV4).apply(null,arguments)},u._NonMaxSuppressionV5=function(){return(u._NonMaxSuppressionV5=u.asm.NonMaxSuppressionV5).apply(null,arguments)},u._NotEqual=function(){return(u._NotEqual=u.asm.NotEqual).apply(null,arguments)},u._OneHot=function(){return(u._OneHot=u.asm.OneHot).apply(null,arguments)},u._PadV2=function(){return(u._PadV2=u.asm.PadV2).apply(null,arguments)},u._Pow=function(){return(u._Pow=u.asm.Pow).apply(null,arguments)},u._Prelu=function(){return(u._Prelu=u.asm.Prelu).apply(null,arguments)},u._Prod=function(){return(u._Prod=u.asm.Prod).apply(null,arguments)},u._RealDiv=function(){return(u._RealDiv=u.asm.RealDiv).apply(null,arguments)},u._Reciprocal=function(){return(u._Reciprocal=u.asm.Reciprocal).apply(null,arguments)},u._Relu=function(){return(u._Relu=u.asm.Relu).apply(null,arguments)},u._Relu6=function(){return(u._Relu6=u.asm.Relu6).apply(null,arguments)},u._ResizeBilinear=function(){return(u._ResizeBilinear=u.asm.ResizeBilinear).apply(null,arguments)},u._ResizeBilinearGrad=function(){return(u._ResizeBilinearGrad=u.asm.ResizeBilinearGrad).apply(null,arguments)},u._ResizeNearestNeighbor=function(){return(u._ResizeNearestNeighbor=u.asm.ResizeNearestNeighbor).apply(null,arguments)},u._ResizeNearestNeighborGrad=function(){return(u._ResizeNearestNeighborGrad=u.asm.ResizeNearestNeighborGrad).apply(null,arguments)},u._Reverse=function(){return(u._Reverse=u.asm.Reverse).apply(null,arguments)},u._RotateWithOffset=function(){return(u._RotateWithOffset=u.asm.RotateWithOffset).apply(null,arguments)},u._Round=function(){return(u._Round=u.asm.Round).apply(null,arguments)},u._Rsqrt=function(){return(u._Rsqrt=u.asm.Rsqrt).apply(null,arguments)},u._ScatterNd=function(){return(u._ScatterNd=u.asm.ScatterNd).apply(null,arguments)},u._SearchSorted=function(){return(u._SearchSorted=u.asm.SearchSorted).apply(null,arguments)},u._SelectV2=function(){return(u._SelectV2=u.asm.SelectV2).apply(null,arguments)},u._Selu=function(){return(u._Selu=u.asm.Selu).apply(null,arguments)},u._Sigmoid=function(){return(u._Sigmoid=u.asm.Sigmoid).apply(null,arguments)},u._Sign=function(){return(u._Sign=u.asm.Sign).apply(null,arguments)},u._Sin=function(){return(u._Sin=u.asm.Sin).apply(null,arguments)},u._Sinh=function(){return(u._Sinh=u.asm.Sinh).apply(null,arguments)},u._Softmax=function(){return(u._Softmax=u.asm.Softmax).apply(null,arguments)},u._Softplus=function(){return(u._Softplus=u.asm.Softplus).apply(null,arguments)},u._SparseFillEmptyRows=function(){return(u._SparseFillEmptyRows=u.asm.SparseFillEmptyRows).apply(null,arguments)},u._SparseReshape=function(){return(u._SparseReshape=u.asm.SparseReshape).apply(null,arguments)},u._SparseSegmentReduction=function(){return(u._SparseSegmentReduction=u.asm.SparseSegmentReduction).apply(null,arguments)},u._SparseToDense=function(){return(u._SparseToDense=u.asm.SparseToDense).apply(null,arguments)},u._Sqrt=function(){return(u._Sqrt=u.asm.Sqrt).apply(null,arguments)},u._Square=function(){return(u._Square=u.asm.Square).apply(null,arguments)},u._SquaredDifference=function(){return(u._SquaredDifference=u.asm.SquaredDifference).apply(null,arguments)},u._Step=function(){return(u._Step=u.asm.Step).apply(null,arguments)},u._StridedSlice=function(){return(u._StridedSlice=u.asm.StridedSlice).apply(null,arguments)},u._Sub=function(){return(u._Sub=u.asm.Sub).apply(null,arguments)},u._Sum=function(){return(u._Sum=u.asm.Sum).apply(null,arguments)},u._Tan=function(){return(u._Tan=u.asm.Tan).apply(null,arguments)},u._Tanh=function(){return(u._Tanh=u.asm.Tanh).apply(null,arguments)},u._TensorScatterUpdate=function(){return(u._TensorScatterUpdate=u.asm.TensorScatterUpdate).apply(null,arguments)},u._Tile=function(){return(u._Tile=u.asm.Tile).apply(null,arguments)},u._TopK=function(){return(u._TopK=u.asm.TopK).apply(null,arguments)},u._Transform=function(){return(u._Transform=u.asm.Transform).apply(null,arguments)},u._Transpose=function(){return(u._Transpose=u.asm.Transpose).apply(null,arguments)},u.__FusedMatMul=function(){return(u.__FusedMatMul=u.asm._FusedMatMul).apply(null,arguments)},u._malloc=function(){return(u._malloc=u.asm.malloc).apply(null,arguments)},u._free=function(){return(u._free=u.asm.free).apply(null,arguments)},u.__emscripten_tls_init=function(){return(u.__emscripten_tls_init=u.asm._emscripten_tls_init).apply(null,arguments)};var Xg=u._pthread_self=function(){return(Xg=u._pthread_self=u.asm.pthread_self).apply(null,arguments)};u.___errno_location=function(){return(u.___errno_location=u.asm.__errno_location).apply(null,arguments)};var iT=u.__emscripten_thread_init=function(){return(iT=u.__emscripten_thread_init=u.asm._emscripten_thread_init).apply(null,arguments)};u.__emscripten_thread_crashed=function(){return(u.__emscripten_thread_crashed=u.asm._emscripten_thread_crashed).apply(null,arguments)},u._emscripten_main_thread_process_queued_calls=function(){return(u._emscripten_main_thread_process_queued_calls=u.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},u._emscripten_main_browser_thread_id=function(){return(u._emscripten_main_browser_thread_id=u.asm.emscripten_main_browser_thread_id).apply(null,arguments)};var oT=u._emscripten_run_in_main_runtime_thread_js=function(){return(oT=u._emscripten_run_in_main_runtime_thread_js=u.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)};u._emscripten_dispatch_to_thread_=function(){return(u._emscripten_dispatch_to_thread_=u.asm.emscripten_dispatch_to_thread_).apply(null,arguments)};var lT=u.__emscripten_proxy_execute_task_queue=function(){return(lT=u.__emscripten_proxy_execute_task_queue=u.asm._emscripten_proxy_execute_task_queue).apply(null,arguments)},$v=u.__emscripten_thread_free_data=function(){return($v=u.__emscripten_thread_free_data=u.asm._emscripten_thread_free_data).apply(null,arguments)},uT=u.__emscripten_thread_exit=function(){return(uT=u.__emscripten_thread_exit=u.asm._emscripten_thread_exit).apply(null,arguments)},cT=u._emscripten_stack_set_limits=function(){return(cT=u._emscripten_stack_set_limits=u.asm.emscripten_stack_set_limits).apply(null,arguments)},Mv=u.stackSave=function(){return(Mv=u.stackSave=u.asm.stackSave).apply(null,arguments)},Zg=u.stackRestore=function(){return(Zg=u.stackRestore=u.asm.stackRestore).apply(null,arguments)},Yg=u.stackAlloc=function(){return(Yg=u.stackAlloc=u.asm.stackAlloc).apply(null,arguments)};u.dynCall_iijjiiii=function(){return(u.dynCall_iijjiiii=u.asm.dynCall_iijjiiii).apply(null,arguments)},u.dynCall_jiji=function(){return(u.dynCall_jiji=u.asm.dynCall_jiji).apply(null,arguments)},u.keepRuntimeAlive=Lt,u.wasmMemory=z,u.cwrap=HV,u.ExitStatus=Os,u.PThread=ye;var Jg;Kr=function P(){Jg||hT(),Jg||(Kr=P)};function hT(P){if(Nn>0)return;if(b){h(u),In(),startWorker(u);return}if(ur(),Nn>0)return;function Y(){Jg||(Jg=!0,u.calledRun=!0,!Z&&(In(),h(u),u.onRuntimeInitialized&&u.onRuntimeInitialized(),cr()))}u.setStatus?(u.setStatus("Running..."),setTimeout(function(){setTimeout(function(){u.setStatus("")},1),Y()},1)):Y()}if(u.preInit)for(typeof u.preInit=="function"&&(u.preInit=[u.preInit]);u.preInit.length>0;)u.preInit.pop()();hT();var Qg;p&&(Qg={uncaughtException:process.listeners("uncaughtException").filter(function(P){return!p.uncaughtException.indexOf(P)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(P){return!p.unhandledRejection.indexOf(P)>-1})});var ey;if(typeof WasmBackendModule<"u")ey=WasmBackendModule;else if(typeof a<"u")ey=a;else throw new Error("Could not find wasm module in post.js");if(Qg){var KV=ey._dispose;ey._dispose=function(){KV(),Qg.uncaughtException.forEach(function(P){process.removeListener("uncaughtException",P)}),Qg.unhandledRejection.forEach(function(P){process.removeListener("unhandledRejection",P)})}}return a.ready}})();typeof e=="object"&&typeof t=="object"?t.exports=n:typeof define=="function"&&define.amd?define([],function(){return n}):typeof e=="object"&&(e.WasmBackendModuleThreadedSimd=n)}),Xq=en((e,t)=>{t.exports.wasmWorkerContents=`"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",data=>onmessage({data:data}));var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8")+"//# sourceURL="+f)},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}var initializedJS=false;var pendingNotifiedProxyingQueues=[];function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"
");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=(info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports};self.onunhandledrejection=e=>{throw e.reason??e};self.startWorker=instance=>{Module=instance;postMessage({"cmd":"loaded"})};self.onmessage=e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=function(){postMessage({cmd:"callHandler",handler:handler,args:[...arguments]})}}Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob=="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module)}else if(e.data.cmd==="run"){Module["__emscripten_thread_init"](e.data.pthread_ptr,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInitTLS();if(!initializedJS){pendingNotifiedProxyingQueues.forEach(queue=>{Module["executeNotifiedProxyingQueue"](queue)});pendingNotifiedProxyingQueues=[];initializedJS=true}try{Module["invokeEntryPoint"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processProxyingQueue"){if(initializedJS){Module["executeNotifiedProxyingQueue"](e.data.queue)}else{pendingNotifiedProxyingQueues.push(e.data.queue)}}else if(e.data.cmd){err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}};`}),Zq=en((e,t)=>{var n=(()=>{var r=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(r=r||__filename),function(a){a=a||{};var s=typeof a<"u"?a:{},i,o;s.ready=new Promise(function(ae,he){i=ae,o=he});var l;typeof process<"u"&&process.listeners&&(l={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var c=Object.assign({},s),u=typeof window=="object",h=typeof importScripts=="function",d=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",p="";function f(ae){return s.locateFile?s.locateFile(ae,p):p+ae}var m,y,g;if(d){var x=OS(),b=wD();h?p=b.dirname(p)+"/":p=__dirname+"/",m=(ae,he)=>(ae=tt(ae)?new URL(ae):b.normalize(ae),x.readFileSync(ae,he?void 0:"utf8")),g=ae=>{var he=m(ae,!0);return he.buffer||(he=new Uint8Array(he)),he},y=(ae,he,Ee)=>{ae=tt(ae)?new URL(ae):b.normalize(ae),x.readFile(ae,function(ye,St){ye?Ee(ye):he(St.buffer)})},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",function(ae){if(!(ae instanceof Lt))throw ae}),process.on("unhandledRejection",function(ae){throw ae}),s.inspect=function(){return"[Emscripten Module object]"}}else(u||h)&&(h?p=self.location.href:typeof document<"u"&&document.currentScript&&(p=document.currentScript.src),r&&(p=r),p.indexOf("blob:")!==0?p=p.substr(0,p.replace(/[?#].*/,"").lastIndexOf("/")+1):p="",m=ae=>{var he=new XMLHttpRequest;return he.open("GET",ae,!1),he.send(null),he.responseText},h&&(g=ae=>{var he=new XMLHttpRequest;return he.open("GET",ae,!1),he.responseType="arraybuffer",he.send(null),new Uint8Array(he.response)}),y=(ae,he,Ee)=>{var ye=new XMLHttpRequest;ye.open("GET",ae,!0),ye.responseType="arraybuffer",ye.onload=()=>{if(ye.status==200||ye.status==0&&ye.response){he(ye.response);return}Ee()},ye.onerror=Ee,ye.send(null)});var v=s.print||console.log.bind(console),w=s.printErr||console.warn.bind(console);Object.assign(s,c),c=null,s.arguments&&s.arguments,s.thisProgram&&s.thisProgram,s.quit&&s.quit;var I;s.wasmBinary&&(I=s.wasmBinary),s.noExitRuntime,typeof WebAssembly!="object"&&je("no native wasm support detected");var _,T=!1,A=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function M(ae,he,Ee){he>>>=0;for(var ye=he+Ee,St=he;ae[St]&&!(St>=ye);)++St;if(St-he>16&&ae.buffer&&A)return A.decode(ae.subarray(he,St));for(var Tt="";he<St;){var qe=ae[he++];if(!(qe&128)){Tt+=String.fromCharCode(qe);continue}var Le=ae[he++]&63;if((qe&224)==192){Tt+=String.fromCharCode((qe&31)<<6|Le);continue}var qt=ae[he++]&63;if((qe&240)==224?qe=(qe&15)<<12|Le<<6|qt:qe=(qe&7)<<18|Le<<12|qt<<6|ae[he++]&63,qe<65536)Tt+=String.fromCharCode(qe);else{var Xr=qe-65536;Tt+=String.fromCharCode(55296|Xr>>10,56320|Xr&1023)}}return Tt}function F(ae,he){return ae>>>=0,ae?M(q,ae,he):""}function C(ae,he,Ee,ye){if(Ee>>>=0,!(ye>0))return 0;for(var St=Ee,Tt=Ee+ye-1,qe=0;qe<ae.length;++qe){var Le=ae.charCodeAt(qe);if(Le>=55296&&Le<=57343){var qt=ae.charCodeAt(++qe);Le=65536+((Le&1023)<<10)|qt&1023}if(Le<=127){if(Ee>=Tt)break;he[Ee++>>>0]=Le}else if(Le<=2047){if(Ee+1>=Tt)break;he[Ee++>>>0]=192|Le>>6,he[Ee++>>>0]=128|Le&63}else if(Le<=65535){if(Ee+2>=Tt)break;he[Ee++>>>0]=224|Le>>12,he[Ee++>>>0]=128|Le>>6&63,he[Ee++>>>0]=128|Le&63}else{if(Ee+3>=Tt)break;he[Ee++>>>0]=240|Le>>18,he[Ee++>>>0]=128|Le>>12&63,he[Ee++>>>0]=128|Le>>6&63,he[Ee++>>>0]=128|Le&63}}return he[Ee>>>0]=0,Ee-St}function D(ae,he,Ee){return C(ae,q,he,Ee)}var L,O,q,H;function z(ae){L=ae,s.HEAP8=O=new Int8Array(ae),s.HEAP16=new Int16Array(ae),s.HEAP32=new Int32Array(ae),s.HEAPU8=q=new Uint8Array(ae),s.HEAPU16=new Uint16Array(ae),s.HEAPU32=H=new Uint32Array(ae),s.HEAPF32=new Float32Array(ae),s.HEAPF64=new Float64Array(ae)}s.INITIAL_MEMORY;var K=[],Z=[],J=[];function Q(){if(s.preRun)for(typeof s.preRun=="function"&&(s.preRun=[s.preRun]);s.preRun.length;)ue(s.preRun.shift());ur(K)}function ne(){ur(Z)}function oe(){if(s.postRun)for(typeof s.postRun=="function"&&(s.postRun=[s.postRun]);s.postRun.length;)we(s.postRun.shift());ur(J)}function ue(ae){K.unshift(ae)}function ve(ae){Z.unshift(ae)}function we(ae){J.unshift(ae)}var ge=0,Te=null;function $e(ae){ge++,s.monitorRunDependencies&&s.monitorRunDependencies(ge)}function Pe(ae){if(ge--,s.monitorRunDependencies&&s.monitorRunDependencies(ge),ge==0&&Te){var he=Te;Te=null,he()}}function je(ae){s.onAbort&&s.onAbort(ae),ae="Aborted("+ae+")",w(ae),T=!0,ae+=". Build with -sASSERTIONS for more info.";var he=new WebAssembly.RuntimeError(ae);throw o(he),he}var ft="data:application/octet-stream;base64,";function Xe(ae){return ae.startsWith(ft)}function tt(ae){return ae.startsWith("file://")}var De;De="tfjs-backend-wasm.wasm",Xe(De)||(De=f(De));function ot(ae){try{if(ae==De&&I)return new Uint8Array(I);if(g)return g(ae);throw"both async and sync fetching of the wasm failed"}catch(he){je(he)}}function kt(){if(!I&&(u||h)){if(typeof fetch=="function"&&!tt(De))return fetch(De,{credentials:"same-origin"}).then(function(ae){if(!ae.ok)throw"failed to load wasm binary file at '"+De+"'";return ae.arrayBuffer()}).catch(function(){return ot(De)});if(y)return new Promise(function(ae,he){y(De,function(Ee){ae(new Uint8Array(Ee))},he)})}return Promise.resolve().then(function(){return ot(De)})}function _r(){var ae={env:Wg,wasi_snapshot_preview1:Wg};function he(qe,Le){var qt=qe.exports;s.asm=qt,_=s.asm.memory,z(_.buffer),s.asm.__indirect_function_table,ve(s.asm.__wasm_call_ctors),Pe()}$e();function Ee(qe){he(qe.instance)}function ye(qe){return kt().then(function(Le){return WebAssembly.instantiate(Le,ae)}).then(function(Le){return Le}).then(qe,function(Le){w("failed to asynchronously prepare wasm: "+Le),je(Le)})}function St(){return!I&&typeof WebAssembly.instantiateStreaming=="function"&&!Xe(De)&&!tt(De)&&!d&&typeof fetch=="function"?fetch(De,{credentials:"same-origin"}).then(function(qe){var Le=WebAssembly.instantiateStreaming(qe,ae);return Le.then(Ee,function(qt){return w("wasm streaming compile failed: "+qt),w("falling back to ArrayBuffer instantiation"),ye(Ee)})}):ye(Ee)}if(s.instantiateWasm)try{var Tt=s.instantiateWasm(ae,he);return Tt}catch(qe){w("Module.instantiateWasm callback failed with error: "+qe),o(qe)}return St().catch(o),{}}function Lt(ae){this.name="ExitStatus",this.message="Program terminated with exit("+ae+")",this.status=ae}function ur(ae){for(;ae.length>0;)ae.shift()(s)}function In(){je("")}function cr(){return 4294901760}function ga(){return cr()}function Cr(ae,he,Ee){q.copyWithin(ae>>>0,he>>>0,he+Ee>>>0)}function hr(ae){try{return _.grow(ae-L.byteLength+65535>>>16),z(_.buffer),1}catch{}}function Nn(ae){var he=q.length;ae=ae>>>0;var Ee=cr();if(ae>Ee)return!1;let ye=(qt,Xr)=>qt+(Xr-qt%Xr)%Xr;for(var St=1;St<=4;St*=2){var Tt=he*(1+.2/St);Tt=Math.min(Tt,ae+100663296);var qe=Math.min(Ee,ye(Math.max(ae,Tt),65536)),Le=hr(qe);if(Le)return!0}return!1}function Kr(ae){return 52}function wi(ae,he,Ee,ye,St){return 70}var Lp=[null,[],[]];function Ds(ae,he){var Ee=Lp[ae];he===0||he===10?((ae===1?v:w)(M(Ee,0)),Ee.length=0):Ee.push(he)}function Bp(ae,he,Ee,ye){for(var St=0,Tt=0;Tt<Ee;Tt++){var qe=H[he>>>2],Le=H[he+4>>>2];he+=8;for(var qt=0;qt<Le;qt++)Ds(ae,q[qe+qt>>>0]);St+=Le}return H[ye>>>2]=St,0}function os(ae){var he=s["_"+ae];return he}function ki(ae,he){O.set(ae,he>>>0)}function _n(ae,he,Ee,ye,St){var Tt={string:Vn=>{var Si=0;if(Vn!=null&&Vn!==0){var Kg=(Vn.length<<2)+1;Si=Os(Kg),D(Vn,Si,Kg)}return Si},array:Vn=>{var Si=Os(Vn.length);return ki(Vn,Si),Si}};function qe(Vn){return he==="string"?F(Vn):he==="boolean"?!!Vn:Vn}var Le=os(ae),qt=[],Xr=0;if(ye)for(var zs=0;zs<ye.length;zs++){var Hg=Tt[Ee[zs]];Hg?(Xr===0&&(Xr=Ug()),qt[zs]=Hg(ye[zs])):qt[zs]=ye[zs]}var Wp=Le.apply(null,qt);function qg(Vn){return Xr!==0&&Vg(Xr),qe(Vn)}return Wp=qg(Wp),Wp}function Bg(ae,he,Ee,ye){Ee=Ee||[];var St=Ee.every(qe=>qe==="number"||qe==="boolean"),Tt=he!=="string";return Tt&&St&&!ye?os(ae):function(){return _n(ae,he,Ee,arguments)}}var Wg={abort:In,emscripten_get_heap_max:ga,emscripten_memcpy_big:Cr,emscripten_resize_heap:Nn,fd_close:Kr,fd_seek:wi,fd_write:Bp};_r(),s.___wasm_call_ctors=function(){return(s.___wasm_call_ctors=s.asm.__wasm_call_ctors).apply(null,arguments)},s._init=function(){return(s._init=s.asm.init).apply(null,arguments)},s._init_with_threads_count=function(){return(s._init_with_threads_count=s.asm.init_with_threads_count).apply(null,arguments)},s._get_threads_count=function(){return(s._get_threads_count=s.asm.get_threads_count).apply(null,arguments)},s._register_tensor=function(){return(s._register_tensor=s.asm.register_tensor).apply(null,arguments)},s._dispose_data=function(){return(s._dispose_data=s.asm.dispose_data).apply(null,arguments)},s._dispose=function(){return(s._dispose=s.asm.dispose).apply(null,arguments)},s._Abs=function(){return(s._Abs=s.asm.Abs).apply(null,arguments)},s._Acos=function(){return(s._Acos=s.asm.Acos).apply(null,arguments)},s._Acosh=function(){return(s._Acosh=s.asm.Acosh).apply(null,arguments)},s._Add=function(){return(s._Add=s.asm.Add).apply(null,arguments)},s._AddN=function(){return(s._AddN=s.asm.AddN).apply(null,arguments)},s._All=function(){return(s._All=s.asm.All).apply(null,arguments)},s._Any=function(){return(s._Any=s.asm.Any).apply(null,arguments)},s._ArgMax=function(){return(s._ArgMax=s.asm.ArgMax).apply(null,arguments)},s._ArgMin=function(){return(s._ArgMin=s.asm.ArgMin).apply(null,arguments)},s._Asin=function(){return(s._Asin=s.asm.Asin).apply(null,arguments)},s._Asinh=function(){return(s._Asinh=s.asm.Asinh).apply(null,arguments)},s._Atan=function(){return(s._Atan=s.asm.Atan).apply(null,arguments)},s._Atan2=function(){return(s._Atan2=s.asm.Atan2).apply(null,arguments)},s._Atanh=function(){return(s._Atanh=s.asm.Atanh).apply(null,arguments)},s._AvgPool=function(){return(s._AvgPool=s.asm.AvgPool).apply(null,arguments)},s._AvgPool3D=function(){return(s._AvgPool3D=s.asm.AvgPool3D).apply(null,arguments)},s._AvgPool3DGrad=function(){return(s._AvgPool3DGrad=s.asm.AvgPool3DGrad).apply(null,arguments)},s._AvgPoolGrad=function(){return(s._AvgPoolGrad=s.asm.AvgPoolGrad).apply(null,arguments)},s._BatchMatMul=function(){return(s._BatchMatMul=s.asm.BatchMatMul).apply(null,arguments)},s._Bincount=function(){return(s._Bincount=s.asm.Bincount).apply(null,arguments)},s._BitwiseAnd=function(){return(s._BitwiseAnd=s.asm.BitwiseAnd).apply(null,arguments)},s._Ceil=function(){return(s._Ceil=s.asm.Ceil).apply(null,arguments)},s._ClipByValue=function(){return(s._ClipByValue=s.asm.ClipByValue).apply(null,arguments)},s._Conv2D=function(){return(s._Conv2D=s.asm.Conv2D).apply(null,arguments)},s._Conv2DBackpropInput=function(){return(s._Conv2DBackpropInput=s.asm.Conv2DBackpropInput).apply(null,arguments)},s._Conv3D=function(){return(s._Conv3D=s.asm.Conv3D).apply(null,arguments)},s._Conv3DBackpropFilterV2=function(){return(s._Conv3DBackpropFilterV2=s.asm.Conv3DBackpropFilterV2).apply(null,arguments)},s._Conv3DBackpropInputV2=function(){return(s._Conv3DBackpropInputV2=s.asm.Conv3DBackpropInputV2).apply(null,arguments)},s._Cos=function(){return(s._Cos=s.asm.Cos).apply(null,arguments)},s._Cosh=function(){return(s._Cosh=s.asm.Cosh).apply(null,arguments)},s._CropAndResize=function(){return(s._CropAndResize=s.asm.CropAndResize).apply(null,arguments)},s._Cumprod=function(){return(s._Cumprod=s.asm.Cumprod).apply(null,arguments)},s._Cumsum=function(){return(s._Cumsum=s.asm.Cumsum).apply(null,arguments)},s._DenseBincount=function(){return(s._DenseBincount=s.asm.DenseBincount).apply(null,arguments)},s._DepthToSpace=function(){return(s._DepthToSpace=s.asm.DepthToSpace).apply(null,arguments)},s._DepthwiseConv2dNative=function(){return(s._DepthwiseConv2dNative=s.asm.DepthwiseConv2dNative).apply(null,arguments)},s._Diag=function(){return(s._Diag=s.asm.Diag).apply(null,arguments)},s._Dilation2D=function(){return(s._Dilation2D=s.asm.Dilation2D).apply(null,arguments)},s._Dilation2DBackpropFilter=function(){return(s._Dilation2DBackpropFilter=s.asm.Dilation2DBackpropFilter).apply(null,arguments)},s._Dilation2DBackpropInput=function(){return(s._Dilation2DBackpropInput=s.asm.Dilation2DBackpropInput).apply(null,arguments)},s._Elu=function(){return(s._Elu=s.asm.Elu).apply(null,arguments)},s._EluGrad=function(){return(s._EluGrad=s.asm.EluGrad).apply(null,arguments)},s._Equal=function(){return(s._Equal=s.asm.Equal).apply(null,arguments)},s._Erf=function(){return(s._Erf=s.asm.Erf).apply(null,arguments)},s._Exp=function(){return(s._Exp=s.asm.Exp).apply(null,arguments)},s._Expm1=function(){return(s._Expm1=s.asm.Expm1).apply(null,arguments)},s._FlipLeftRight=function(){return(s._FlipLeftRight=s.asm.FlipLeftRight).apply(null,arguments)},s._Floor=function(){return(s._Floor=s.asm.Floor).apply(null,arguments)},s._FloorDiv=function(){return(s._FloorDiv=s.asm.FloorDiv).apply(null,arguments)},s._FusedBatchNorm=function(){return(s._FusedBatchNorm=s.asm.FusedBatchNorm).apply(null,arguments)},s._FusedConv2D=function(){return(s._FusedConv2D=s.asm.FusedConv2D).apply(null,arguments)},s._FusedDepthwiseConv2D=function(){return(s._FusedDepthwiseConv2D=s.asm.FusedDepthwiseConv2D).apply(null,arguments)},s._Gather=function(){return(s._Gather=s.asm.Gather).apply(null,arguments)},s._GatherNd=function(){return(s._GatherNd=s.asm.GatherNd).apply(null,arguments)},s._Greater=function(){return(s._Greater=s.asm.Greater).apply(null,arguments)},s._GreaterEqual=function(){return(s._GreaterEqual=s.asm.GreaterEqual).apply(null,arguments)},s._IsFinite=function(){return(s._IsFinite=s.asm.IsFinite).apply(null,arguments)},s._IsInf=function(){return(s._IsInf=s.asm.IsInf).apply(null,arguments)},s._IsNan=function(){return(s._IsNan=s.asm.IsNan).apply(null,arguments)},s._LRN=function(){return(s._LRN=s.asm.LRN).apply(null,arguments)},s._LRNGrad=function(){return(s._LRNGrad=s.asm.LRNGrad).apply(null,arguments)},s._LeakyRelu=function(){return(s._LeakyRelu=s.asm.LeakyRelu).apply(null,arguments)},s._Less=function(){return(s._Less=s.asm.Less).apply(null,arguments)},s._LessEqual=function(){return(s._LessEqual=s.asm.LessEqual).apply(null,arguments)},s._LinSpace=function(){return(s._LinSpace=s.asm.LinSpace).apply(null,arguments)},s._Log=function(){return(s._Log=s.asm.Log).apply(null,arguments)},s._Log1p=function(){return(s._Log1p=s.asm.Log1p).apply(null,arguments)},s._LogicalAnd=function(){return(s._LogicalAnd=s.asm.LogicalAnd).apply(null,arguments)},s._LogicalNot=function(){return(s._LogicalNot=s.asm.LogicalNot).apply(null,arguments)},s._LogicalOr=function(){return(s._LogicalOr=s.asm.LogicalOr).apply(null,arguments)},s._LogicalXor=function(){return(s._LogicalXor=s.asm.LogicalXor).apply(null,arguments)},s._Max=function(){return(s._Max=s.asm.Max).apply(null,arguments)},s._MaxPool=function(){return(s._MaxPool=s.asm.MaxPool).apply(null,arguments)},s._MaxPool3D=function(){return(s._MaxPool3D=s.asm.MaxPool3D).apply(null,arguments)},s._MaxPool3DGrad=function(){return(s._MaxPool3DGrad=s.asm.MaxPool3DGrad).apply(null,arguments)},s._MaxPoolGrad=function(){return(s._MaxPoolGrad=s.asm.MaxPoolGrad).apply(null,arguments)},s._MaxPoolWithArgmax=function(){return(s._MaxPoolWithArgmax=s.asm.MaxPoolWithArgmax).apply(null,arguments)},s._Maximum=function(){return(s._Maximum=s.asm.Maximum).apply(null,arguments)},s._Mean=function(){return(s._Mean=s.asm.Mean).apply(null,arguments)},s._Min=function(){return(s._Min=s.asm.Min).apply(null,arguments)},s._Minimum=function(){return(s._Minimum=s.asm.Minimum).apply(null,arguments)},s._MirrorPad=function(){return(s._MirrorPad=s.asm.MirrorPad).apply(null,arguments)},s._Mod=function(){return(s._Mod=s.asm.Mod).apply(null,arguments)},s._Multinomial=function(){return(s._Multinomial=s.asm.Multinomial).apply(null,arguments)},s._Multiply=function(){return(s._Multiply=s.asm.Multiply).apply(null,arguments)},s._Neg=function(){return(s._Neg=s.asm.Neg).apply(null,arguments)},s._NonMaxSuppressionV3=function(){return(s._NonMaxSuppressionV3=s.asm.NonMaxSuppressionV3).apply(null,arguments)},s._NonMaxSuppressionV4=function(){return(s._NonMaxSuppressionV4=s.asm.NonMaxSuppressionV4).apply(null,arguments)},s._NonMaxSuppressionV5=function(){return(s._NonMaxSuppressionV5=s.asm.NonMaxSuppressionV5).apply(null,arguments)},s._NotEqual=function(){return(s._NotEqual=s.asm.NotEqual).apply(null,arguments)},s._OneHot=function(){return(s._OneHot=s.asm.OneHot).apply(null,arguments)},s._PadV2=function(){return(s._PadV2=s.asm.PadV2).apply(null,arguments)},s._Pow=function(){return(s._Pow=s.asm.Pow).apply(null,arguments)},s._Prelu=function(){return(s._Prelu=s.asm.Prelu).apply(null,arguments)},s._Prod=function(){return(s._Prod=s.asm.Prod).apply(null,arguments)},s._RealDiv=function(){return(s._RealDiv=s.asm.RealDiv).apply(null,arguments)},s._Reciprocal=function(){return(s._Reciprocal=s.asm.Reciprocal).apply(null,arguments)},s._Relu=function(){return(s._Relu=s.asm.Relu).apply(null,arguments)},s._Relu6=function(){return(s._Relu6=s.asm.Relu6).apply(null,arguments)},s._ResizeBilinear=function(){return(s._ResizeBilinear=s.asm.ResizeBilinear).apply(null,arguments)},s._ResizeBilinearGrad=function(){return(s._ResizeBilinearGrad=s.asm.ResizeBilinearGrad).apply(null,arguments)},s._ResizeNearestNeighbor=function(){return(s._ResizeNearestNeighbor=s.asm.ResizeNearestNeighbor).apply(null,arguments)},s._ResizeNearestNeighborGrad=function(){return(s._ResizeNearestNeighborGrad=s.asm.ResizeNearestNeighborGrad).apply(null,arguments)},s._Reverse=function(){return(s._Reverse=s.asm.Reverse).apply(null,arguments)},s._RotateWithOffset=function(){return(s._RotateWithOffset=s.asm.RotateWithOffset).apply(null,arguments)},s._Round=function(){return(s._Round=s.asm.Round).apply(null,arguments)},s._Rsqrt=function(){return(s._Rsqrt=s.asm.Rsqrt).apply(null,arguments)},s._ScatterNd=function(){return(s._ScatterNd=s.asm.ScatterNd).apply(null,arguments)},s._SearchSorted=function(){return(s._SearchSorted=s.asm.SearchSorted).apply(null,arguments)},s._SelectV2=function(){return(s._SelectV2=s.asm.SelectV2).apply(null,arguments)},s._Selu=function(){return(s._Selu=s.asm.Selu).apply(null,arguments)},s._Sigmoid=function(){return(s._Sigmoid=s.asm.Sigmoid).apply(null,arguments)},s._Sign=function(){return(s._Sign=s.asm.Sign).apply(null,arguments)},s._Sin=function(){return(s._Sin=s.asm.Sin).apply(null,arguments)},s._Sinh=function(){return(s._Sinh=s.asm.Sinh).apply(null,arguments)},s._Softmax=function(){return(s._Softmax=s.asm.Softmax).apply(null,arguments)},s._Softplus=function(){return(s._Softplus=s.asm.Softplus).apply(null,arguments)},s._SparseFillEmptyRows=function(){return(s._SparseFillEmptyRows=s.asm.SparseFillEmptyRows).apply(null,arguments)},s._SparseReshape=function(){return(s._SparseReshape=s.asm.SparseReshape).apply(null,arguments)},s._SparseSegmentReduction=function(){return(s._SparseSegmentReduction=s.asm.SparseSegmentReduction).apply(null,arguments)},s._SparseToDense=function(){return(s._SparseToDense=s.asm.SparseToDense).apply(null,arguments)},s._Sqrt=function(){return(s._Sqrt=s.asm.Sqrt).apply(null,arguments)},s._Square=function(){return(s._Square=s.asm.Square).apply(null,arguments)},s._SquaredDifference=function(){return(s._SquaredDifference=s.asm.SquaredDifference).apply(null,arguments)},s._Step=function(){return(s._Step=s.asm.Step).apply(null,arguments)},s._StridedSlice=function(){return(s._StridedSlice=s.asm.StridedSlice).apply(null,arguments)},s._Sub=function(){return(s._Sub=s.asm.Sub).apply(null,arguments)},s._Sum=function(){return(s._Sum=s.asm.Sum).apply(null,arguments)},s._Tan=function(){return(s._Tan=s.asm.Tan).apply(null,arguments)},s._Tanh=function(){return(s._Tanh=s.asm.Tanh).apply(null,arguments)},s._TensorScatterUpdate=function(){return(s._TensorScatterUpdate=s.asm.TensorScatterUpdate).apply(null,arguments)},s._Tile=function(){return(s._Tile=s.asm.Tile).apply(null,arguments)},s._TopK=function(){return(s._TopK=s.asm.TopK).apply(null,arguments)},s._Transform=function(){return(s._Transform=s.asm.Transform).apply(null,arguments)},s._Transpose=function(){return(s._Transpose=s.asm.Transpose).apply(null,arguments)},s.__FusedMatMul=function(){return(s.__FusedMatMul=s.asm._FusedMatMul).apply(null,arguments)},s._malloc=function(){return(s._malloc=s.asm.malloc).apply(null,arguments)},s._free=function(){return(s._free=s.asm.free).apply(null,arguments)},s.___errno_location=function(){return(s.___errno_location=s.asm.__errno_location).apply(null,arguments)};var Ug=s.stackSave=function(){return(Ug=s.stackSave=s.asm.stackSave).apply(null,arguments)},Vg=s.stackRestore=function(){return(Vg=s.stackRestore=s.asm.stackRestore).apply(null,arguments)},Os=s.stackAlloc=function(){return(Os=s.stackAlloc=s.asm.stackAlloc).apply(null,arguments)};s.dynCall_iijjiiii=function(){return(s.dynCall_iijjiiii=s.asm.dynCall_iijjiiii).apply(null,arguments)},s.dynCall_jiji=function(){return(s.dynCall_jiji=s.asm.dynCall_jiji).apply(null,arguments)},s.cwrap=Bg;var Pc;Te=function ae(){Pc||jg(),Pc||(Te=ae)};function jg(ae){if(ge>0||(Q(),ge>0))return;function he(){Pc||(Pc=!0,s.calledRun=!0,!T&&(ne(),i(s),s.onRuntimeInitialized&&s.onRuntimeInitialized(),oe()))}s.setStatus?(s.setStatus("Running..."),setTimeout(function(){setTimeout(function(){s.setStatus("")},1),he()},1)):he()}if(s.preInit)for(typeof s.preInit=="function"&&(s.preInit=[s.preInit]);s.preInit.length>0;)s.preInit.pop()();jg();var Yo;l&&(Yo={uncaughtException:process.listeners("uncaughtException").filter(function(ae){return!l.uncaughtException.indexOf(ae)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(ae){return!l.unhandledRejection.indexOf(ae)>-1})});var Jo;if(typeof a<"u")Jo=a;else if(typeof WasmBackendModuleThreadedSimd<"u")Jo=WasmBackendModuleThreadedSimd;else throw new Error("Could not find wasm module in post.js");if(Yo){var Gg=Jo._dispose;Jo._dispose=function(){Gg(),Yo.uncaughtException.forEach(function(ae){process.removeListener("uncaughtException",ae)}),Yo.unhandledRejection.forEach(function(ae){process.removeListener("unhandledRejection",ae)})}}return a.ready}})();typeof e=="object"&&typeof t=="object"?t.exports=n:typeof define=="function"&&define.amd?define([],function(){return n}):typeof e=="object"&&(e.WasmBackendModule=n)}),Qx=class{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}},Dm=class{refCount(e){return Tr("refCount")}incRef(e){return Tr("incRef")}timerAvailable(){return!0}time(e){return Tr("time")}read(e){return Tr("read")}readSync(e){return Tr("readSync")}readToGPU(e,t){return Tr("readToGPU")}numDataIds(){return Tr("numDataIds")}disposeData(e,t){return Tr("disposeData")}write(e,t,n){return Tr("write")}move(e,t,n,r,a){return Tr("move")}createTensorFromGPUData(e,t,n){return Tr("createTensorFromGPUData")}memory(){return Tr("memory")}floatPrecision(){return Tr("floatPrecision")}epsilon(){return this.floatPrecision()===32?1e-7:1e-4}dispose(){return Tr("dispose")}};function Tr(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function kD(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,Q0(e,t,n)}function Yq(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,r=0;for(;n>0;)r=Math.random()*n|0,n--,Q0(e,n,r),Q0(t,n,r)}function om(e,t,n){return Math.max(e,Math.min(t,n))}function Jq(e){return e%2===0?e:e+1}function Q0(e,t,n){let r=e[t];e[t]=e[n],e[n]=r}function Qq(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function e7(e,t){let n=Math.random();return t*n+(1-n)*e}function t7(e,t){let n=0;for(let r=0;r<e.length;r++){let a=Number(e[r])-Number(t[r]);n+=a*a}return n}function R(e,t){if(!e)throw new Error(typeof t=="string"?t:t())}function sr(e,t,n=""){R(pi(e,t),()=>n+` Shapes ${e} and ${t} must match`)}function ou(e){R(e!=null,()=>"The input to the tensor constructor must be a non-null value.")}function dt(e){if(e.length===0)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function n7(e){return e.length===0}function SD(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==null&&t[n]!==null&&e[n]!==t[n])return!1;return!0}function pi(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function jh(e){return e%1===0}function r7(e){if(Math.tanh!=null)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{let t=Math.exp(2*e);return(t-1)/(t+1)}}function a7(e){let t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function s7(e){let t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return kD(t),t}function Df(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function i7(e,t=a=>0,n,r){return new Promise((a,s)=>{let i=0,o=()=>{if(e()){a();return}i++;let l=t(i);if(n!=null&&i>=n){s();return}r!=null?r(o,l):setTimeout(o,l)};o()})}function o7(e,t){let n=1,r=-1;for(let s=0;s<e.length;++s)if(e[s]>=0)n*=e[s];else if(e[s]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${s}`);r=s}else if(e[s]<0)throw Error(`Shapes can not be < 0. Found ${e[s]} at dim ${s}`);if(r===-1){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(n===0)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);let a=e.slice();return a[r]=t/n,a}function $a(e,t){let n=t.length;return e=e==null?t.map((r,a)=>a):[].concat(e),R(e.every(r=>r>=-n&&r<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`),R(e.every(r=>jh(r)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(r=>r<0?n+r:r)}function ID(e,t){let n=[],r=[],a=t!=null&&Array.isArray(t)&&t.length===0,s=t==null||a?null:$a(t,e).sort(),i=0;for(let o=0;o<e.length;++o){if(s!=null){if(s[i]===o&&e[o]!==1)throw new Error(`Can't squeeze axis ${o} since its dim '${e[o]}' is not 1`);(s[i]==null||s[i]>o)&&e[o]===1&&(n.push(e[o]),r.push(o)),s[i]<=o&&i++}e[o]!==1&&(n.push(e[o]),r.push(o))}return{newShape:n,keptDims:r}}function ND(e,t){return zS(e,t)}function zS(e,t){let n=null;if(e==null||e==="float32")n=new Float32Array(t);else if(e==="int32")n=new Int32Array(t);else if(e==="bool")n=new Uint8Array(t);else if(e==="string")n=new Array(t);else throw new Error(`Unknown data type ${e}`);return n}function _D(e,t){for(let n=0;n<e.length;n++){let r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function CD(e){return e==="bool"||e==="complex64"||e==="float32"||e==="int32"||e==="string"}function l7(e,t){return!(t==="complex64"||t==="float32"&&e!=="complex64"||t==="int32"&&e!=="float32"&&e!=="complex64"||t==="bool"&&e==="bool")}function ex(e){if(e==="float32"||e==="int32")return 4;if(e==="complex64")return 8;if(e==="bool")return 1;throw new Error(`Unknown dtype ${e}`)}function TD(e){if(e==null)return 0;let t=0;return e.forEach(n=>t+=n.length),t}function Ki(e){return typeof e=="string"||e instanceof String}function ED(e){return typeof e=="boolean"}function AD(e){return typeof e=="number"}function Om(e){return Array.isArray(e)?Om(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":AD(e)?"float32":Ki(e)?"string":ED(e)?"bool":"float32"}function mo(e){return!!(e&&e.constructor&&e.call&&e.apply)}function tx(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function md(e){let t=e.length;if(t<2)return[];let n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function $D(e,t,n,r=!1){let a=new Array;if(t.length===1){let s=t[0]*(r?2:1);for(let i=0;i<s;i++)a[i]=n[e+i]}else{let s=t[0],i=t.slice(1),o=i.reduce((l,c)=>l*c)*(r?2:1);for(let l=0;l<s;l++)a[l]=$D(e+l*o,i,n,r)}return a}function $h(e,t,n=!1){if(e.length===0)return t[0];let r=e.reduce((a,s)=>a*s)*(n?2:1);if(r===0)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return $D(0,e,t,n)}function u7(e,t){if(Array.isArray(e))return e;if(t==="float32")return e instanceof Float32Array?e:new Float32Array(e);if(t==="int32")return e instanceof Int32Array?e:new Int32Array(e);if(t==="bool"||t==="string")return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function PS(e,t){let n=eb(e,t);for(let r=0;r<n.length;r++)n[r]=1;return n}function eb(e,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool")return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function c7(e,t){let n=e.reduce((r,a)=>r*a,1);if(t==null||t==="float32")return $h(e,new Float32Array(n));if(t==="int32")return $h(e,new Int32Array(n));if(t==="bool")return $h(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function qr(e){e.forEach(t=>{R(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function h7(e,t,n){if(t===0)return 0;if(t===1)return e[0];let r=e[e.length-1];for(let a=0;a<e.length-1;++a)r+=n[a]*e[a];return r}function d7(e,t,n){if(t===0)return[];if(t===1)return[e];let r=new Array(t);for(let a=0;a<r.length-1;++a)r[a]=Math.floor(e/n[a]),e-=r[a]*n[a];return r[r.length-1]=e,r}function tb(e){return e&&e.then&&typeof e.then=="function"}var CA="tfjsflags",MD=class{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=p7,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(X().getBool("IS_TEST")||X().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},this.urlFlags[e]!=null){let r=this.urlFlags[e];X().getBool("IS_TEST")||X().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${r}.`),this.set(e,r)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];let t=this.evaluateFlag(e);if(tb(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;let e=this.getQueryParams(this.global.location.search);CA in e&&e[CA].split(",").forEach(t=>{let[n,r]=t.split(":");this.urlFlags[n]=m7(n,r)})}};function p7(e){let t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...r)=>(f7(t,r[0],r[1]),r.join("="))),t}function f7(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}function m7(e,t){let n=t.toLowerCase();return n==="true"||n==="false"?n==="true":`${+n}`===n?+n:t}function X(){return LS}var LS=null;function g7(e){LS=e}var Ww;function FD(){if(Ww==null){let e;if(typeof window<"u")e=window;else if(typeof global<"u")e=global;else if(typeof process<"u")e=process;else if(typeof self<"u")e=self;else throw new Error("Could not find a global object");Ww=e}return Ww}function y7(){let e=FD();return e._tfGlobals==null&&(e._tfGlobals=new Map),e._tfGlobals}function BS(e,t){let n=y7();if(n.has(e))return n.get(e);{let r=t();return n.set(e,r),n.get(e)}}var gd="Abs",lu="Acos",uu="Acosh",Do="Add",cu="AddN",yd="All",xd="Any",bd="ArgMax",vd="ArgMin",hu="Asin",du="Asinh",pu="Atan",fu="Atanh",mu="Atan2",gu="AvgPool",zm="AvgPoolGrad",wd="AvgPool3D",Pm="AvgPool3DGrad",yu="BatchMatMul",kd="BatchToSpaceND",Sd="Bincount",Id="BitwiseAnd",RD="BroadcastTo",Lm="BroadcastArgs",xu="Cast",bu="Ceil",Oo="ClipByValue",nb="Complex",Bm="ComplexAbs",Nd="Concat",vu="Conv2D",rb="Conv2DBackpropFilter",wu="Conv2DBackpropInput",ku="Conv3D",_d="Conv3DBackpropFilterV2",Cd="Conv3DBackpropInputV2",Su="Cos",Iu="Cosh",Td="Cumprod",Nu="Cumsum",Ed="CropAndResize",Wm="DenseBincount",Ad="DepthToSpace",_u="DepthwiseConv2dNative",ab="DepthwiseConv2dNativeBackpropFilter",sb="DepthwiseConv2dNativeBackpropInput",Um="Diag",Cu="Dilation2D",Gh="Dilation2DBackpropInput",Hh="Dilation2DBackpropFilter",ib="Draw",Tu="RealDiv",ob="Einsum",Eu="Elu",$d="EluGrad",Au="Erf",Md="Equal",$u="Exp",Fd="ExpandDims",Mu="Expm1",lb="FFT",Vm="Fill",Rd="FlipLeftRight",Fu="Floor",Ru="FloorDiv",Du="FusedBatchNorm",Dd="GatherV2",Od="GatherNd",zd="Greater",Ou="GreaterEqual",zu="Identity",ub="IFFT",cb="Imag",Pu="IsFinite",Lu="IsInf",Bu="IsNan",Wu="LeakyRelu",Pd="Less",Ld="LessEqual",Bd="LinSpace",Uu="Log",Vu="Log1p",Wd="LogicalAnd",Ud="LogicalNot",Vd="LogicalOr",DD="LogicalXor",OD="LogSoftmax",x7="LowerBound",ju="LRN",jd="LRNGrad",b7="MatrixBandPart",Gu="Max",Hu="Maximum",qu="MaxPool",jm="MaxPoolGrad",Gd="MaxPool3D",Gm="MaxPool3DGrad",Hm="MaxPoolWithArgmax",Ku="Mean",Xu="Min",Zu="Minimum",Yu="MirrorPad",Ju="Mod",Hd="Multinomial",Qu="Multiply",qd="Neg",Kd="NotEqual",Xd="NonMaxSuppressionV3",Zd="NonMaxSuppressionV4",Yd="NonMaxSuppressionV5",Jd="OnesLike",ec="OneHot",Qd="Pack",tc="PadV2",v7="Pool",nc="Pow",rc="Prelu",ac="Prod",hb="RaggedGather",db="RaggedRange",pb="RaggedTensorToTensor",qm="Range",fb="Real",sc="Reciprocal",ic="Relu",ep="Reshape",oc="ResizeNearestNeighbor",tp="ResizeNearestNeighborGrad",lc="ResizeBilinear",np="ResizeBilinearGrad",uc="Relu6",cc="Reverse",hc="Round",dc="Rsqrt",rp="ScatterNd",ap="TensorScatterUpdate",sp="SearchSorted",ip="Select",pc="Selu",op="Slice",fc="Sin",mc="Sinh",gc="Sign",yc="Sigmoid",xc="Softplus",bc="Sqrt",vc="Sum",lp="SpaceToBatchND",up="SplitV",wc="Softmax",Km="SparseFillEmptyRows",cp="SparseReshape",Xm="SparseSegmentMean",Zm="SparseSegmentSum",hp="SparseToDense",kc="SquaredDifference",Ym="Square",Jm="StaticRegexReplace",dp="StridedSlice",Qm="StringNGrams",eg="StringSplit",tg="StringToHashBucketFast",Sc="Sub",Ic="Tan",Nc="Tanh",zo="Tile",pp="TopK",fp="Transform",ni="Transpose",ng="Unique",mp="Unpack",rg="UnsortedSegmentSum",w7="UpperBound",gp="ZerosLike",Po="Step",nx="FromPixels",yp="RotateWithOffset",zl="_FusedMatMul",Pl="FusedConv2D",Ll="FusedDepthwiseConv2D";function ji(...e){X().getBool("IS_TEST")||X().getBool("PROD")||console.warn(...e)}function k7(...e){X().getBool("IS_TEST")||X().getBool("PROD")||console.log(...e)}var qh=BS("kernelRegistry",()=>new Map),lm=BS("gradRegistry",()=>new Map);function um(e,t){let n=WS(e,t);return qh.get(n)}function dk(e){return lm.get(e)}function rx(e){let t=qh.entries(),n=[];for(;;){let{done:r,value:a}=t.next();if(r)break;let[s,i]=a,[o]=s.split("_");o===e&&n.push(i)}return n}function ag(e){let{kernelName:t,backendName:n}=e,r=WS(t,n);qh.has(r)&&ji(`The kernel '${t}' for backend '${n}' is already registered`),qh.set(r,e)}function zD(e){let{kernelName:t}=e;lm.has(t)&&X().getBool("DEBUG")&&ji(`Overriding the gradient for '${t}'`),lm.set(t,e)}function S7(e,t){let n=WS(e,t);if(!qh.has(n))throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);qh.delete(n)}function I7(e){if(!lm.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);lm.delete(e)}function N7(e,t){rx(e).forEach(n=>{let r=Object.assign({},n,{backendName:t});ag(r)})}function WS(e,t){return`${t}_${e}`}var k={};Re(k,{arraysEqual:()=>pi,arraysEqualWithNull:()=>SD,assert:()=>R,assertNonNegativeIntegerDimensions:()=>qr,assertNonNull:()=>ou,assertShapesMatch:()=>sr,bytesFromStringArray:()=>TD,bytesPerElement:()=>ex,checkConversionForErrors:()=>_D,clamp:()=>om,computeStrides:()=>md,convertBackendValuesAndArrayBuffer:()=>u7,createScalarValue:()=>$7,createShuffledIndices:()=>s7,decodeString:()=>ax,distSquared:()=>t7,encodeString:()=>ig,fetch:()=>F7,fingerPrint64:()=>A7,flatten:()=>go,getArrayFromDType:()=>zS,getTypedArrayFromDType:()=>ND,hasEncodingLoss:()=>l7,hexToLong:()=>sg,indexToLoc:()=>d7,inferDtype:()=>Om,inferFromImplicitShape:()=>o7,isBoolean:()=>ED,isFunction:()=>mo,isInt:()=>jh,isNumber:()=>AD,isPromise:()=>tb,isScalarShape:()=>n7,isString:()=>Ki,isTypedArray:()=>gn,isValidDtype:()=>CD,locToIndex:()=>h7,makeOnesTypedArray:()=>PS,makeZerosNestedTypedArray:()=>c7,makeZerosTypedArray:()=>eb,nearestDivisor:()=>tx,nearestLargerEven:()=>Jq,now:()=>cm,parseAxisParam:()=>$a,randUniform:()=>e7,repeatedTry:()=>i7,rightPad:()=>Df,shuffle:()=>kD,shuffleCombo:()=>Yq,sizeFromShape:()=>dt,sizeToSquarishShape:()=>a7,squeezeShape:()=>ID,sum:()=>Qq,swap:()=>Q0,tanh:()=>r7,toNestedArray:()=>$h,toTypedArray:()=>mb});function PD(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var TA=Ro(Rq()),dl=TA.default||TA;function sg(e){return dl.fromString(e,!0,16)}var LD=sg("c3a5c85c97cb3127"),ll=sg("b492b66fbe98f273"),Zn=sg("9ae16a3b2f90404f");function pk(e){return e.xor(e.shru(47))}function BD(e,t,n){let r=e.slice(t,t+n);return dl.fromBytes(Array.from(r),!0,!0)}function It(e,t){return BD(e,t,8)}function EA(e,t){return BD(e,t,4)}function mn(e,t){return t===0?e:e.shru(t).or(e.shl(64-t))}function oo(e,t,n=sg("9ddfea08eb382d69")){let r=e.xor(t).mul(n);r=r.xor(r.shru(47));let a=t.xor(r).mul(n);return a=a.xor(a.shru(47)),a=a.mul(n),a}function _7(e,t,n,r,a,s){a=a.add(e),s=mn(s.add(a).add(r),21);let i=a;return a=a.add(t),a=a.add(n),s=s.add(mn(a,44)),[a.add(r),s.add(i)]}function zy(e,t,n,r){return _7(It(e,t),It(e,t+8),It(e,t+16),It(e,t+24),n,r)}function C7(e,t=e.length){if(t>=8){let n=Zn.add(t*2),r=It(e,0).add(Zn),a=It(e,t-8),s=mn(a,37).mul(n).add(r),i=mn(r,25).add(a).mul(n);return oo(s,i,n)}if(t>=4){let n=Zn.add(t*2),r=EA(e,0);return oo(r.shl(3).add(t),EA(e,t-4),n)}if(t>0){let n=e[0],r=e[t>>1],a=e[t-1],s=n+(r<<8),i=t+(a<<2);return pk(Zn.mul(s).xor(LD.mul(i))).mul(Zn)}return Zn}function T7(e,t=e.length){let n=Zn.add(t*2),r=It(e,0).mul(ll),a=It(e,8),s=It(e,t-8).mul(n),i=It(e,t-16).mul(Zn);return oo(mn(r.add(a),43).add(mn(s,30)).add(i),r.add(mn(a.add(Zn),18)).add(s),n)}function E7(e,t=e.length){let n=Zn.add(t*2),r=It(e,0).mul(Zn),a=It(e,8),s=It(e,t-8).mul(n),i=It(e,t-16).mul(Zn),o=mn(r.add(a),43).add(mn(s,30)).add(i),l=oo(o,r.add(mn(a.add(Zn),18)).add(s),n),c=It(e,16).mul(n),u=It(e,24),h=o.add(It(e,t-32)).mul(n),d=l.add(It(e,t-24)).mul(n);return oo(mn(c.add(u),43).add(mn(h,30)).add(d),c.add(mn(u.add(r),18)).add(h),n)}function A7(e,t=e.length){let n=dl.fromNumber(81,!0);if(t<=32)return t<=16?C7(e,t):T7(e,t);if(t<=64)return E7(e,t);let r=n,a=n.mul(ll).add(113),s=pk(a.mul(Zn).add(113)).mul(Zn),i=[dl.UZERO,dl.UZERO],o=[dl.UZERO,dl.UZERO];r=r.mul(Zn).add(It(e,0));let l=0,c=(t-1>>6)*64,u=c+(t-1&63)-63;do r=mn(r.add(a).add(i[0]).add(It(e,l+8)),37).mul(ll),a=mn(a.add(i[1]).add(It(e,l+48)),42).mul(ll),r=r.xor(o[1]),a=a.add(i[0]).add(It(e,l+40)),s=mn(s.add(o[0]),33).mul(ll),i=zy(e,l,i[1].mul(ll),r.add(o[0])),o=zy(e,l+32,s.add(o[1]),a.add(It(e,l+16))),[s,r]=[r,s],l+=64;while(l!==c);let h=ll.add(s.and(255).shl(1));return l=u,o[0]=o[0].add(t-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),r=mn(r.add(a).add(i[0]).add(It(e,l+8)),37).mul(h),a=mn(a.add(i[1]).add(It(e,l+48)),42).mul(h),r=r.xor(o[1].mul(9)),a=a.add(i[0].mul(9).add(It(e,l+40))),s=mn(s.add(o[0]),33).mul(h),i=zy(e,l,i[1].mul(h),r.add(o[0])),o=zy(e,l+32,s.add(o[1]),a.add(It(e,l+16))),[s,r]=[r,s],oo(oo(i[0],o[0],h).add(pk(a).mul(LD)).add(s),oo(i[1],o[1],h).add(r),h)}function $7(e,t){return t==="string"?ig(e):mb([e],t)}function M7(e,t){return e instanceof Float32Array&&t==="float32"||e instanceof Int32Array&&t==="int32"||e instanceof Uint8Array&&t==="bool"}function mb(e,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=go(e)),X().getBool("DEBUG")&&_D(e,t),M7(e,t))return e;if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool"){let n=new Uint8Array(e.length);for(let r=0;r<n.length;++r)Math.round(e[r])!==0&&(n[r]=1);return n}else throw new Error(`Unknown data type ${t}`)}function cm(){return X().platform.now()}function F7(e,t){return X().platform.fetch(e,t)}function ig(e,t="utf-8"){return t=t||"utf-8",X().platform.encode(e,t)}function ax(e,t="utf-8"){return t=t||"utf-8",X().platform.decode(e,t)}function gn(e){return X().platform.isTypedArray!=null?X().platform.isTypedArray(e):PD(e)}function go(e,t=[],n=!1){if(t==null&&(t=[]),typeof e=="boolean"||typeof e=="number"||typeof e=="string"||tb(e)||e==null||gn(e)&&n)t.push(e);else if(Array.isArray(e)||gn(e))for(let r=0;r<e.length;++r)go(e[r],t,n);else{let r=-1;for(let a of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(a)&&(r=Math.max(r,Number(a)));for(let a=0;a<=r;a++)go(e[a],t,n)}return t}var R7=class{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new O7)}profileKernel(e,t,n){let r,a=()=>{r=n()},s,i=cm();if(this.backendTimer.timerAvailable())s=this.backendTimer.time(a);else{a();for(let o of r)o.dataSync();s=Promise.resolve({kernelMs:cm()-i})}if(X().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let o=0;o<r.length;o++){let l=r[o];l.data().then(c=>{D7(c,l.dtype,e)})}return{kernelName:e,outputs:r,inputs:t,timeMs:s.then(o=>o.kernelMs),extraInfo:s.then(o=>o.getExtraProfileInfo!=null?o.getExtraProfileInfo():"")}}logKernelProfile(e){let{kernelName:t,outputs:n,timeMs:r,inputs:a,extraInfo:s}=e;n.forEach(i=>{Promise.all([i.data(),r,s]).then(o=>{this.logger.logKernelProfile(t,i,o[0],o[1],a,o[2])})})}};function D7(e,t,n){if(t!=="float32")return!1;for(let r=0;r<e.length;r++){let a=e[r];if(isNaN(a)||!isFinite(a))return console.warn(`Found ${a} in the result of '${n}'`),!0}return!1}var O7=class{logKernelProfile(e,t,n,r,a,s){let i=typeof r=="number"?Df(`${r}ms`,9):r.error,o=Df(e,25),l=t.rank,c=t.size,u=Df(t.shape.toString(),14),h="";for(let d in a){let p=a[d];if(p!=null){let f=p.shape||t.shape,m=f.length;h+=`${d}: ${m}D ${m>0?f:""} `}}console.log(`%c${o}	%c${i}	%c${l}D ${u}	%c${c}	%c${h}	%c${s}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function z7(e,t,n){let r={},a={};for(let l=0;l<t.length;l++)r[t[l].id]=!0;for(let l=0;l<e.length;l++){let c=e[l],u=c.inputs;for(let h in u){let d=u[h],p=!1;for(let f=0;f<t.length;f++)if(r[d.id]){c.outputs.forEach(m=>r[m.id]=!0),p=!0,a[c.id]=!0;break}if(p)break}}let s={};s[n.id]=!0;let i={};for(let l=e.length-1;l>=0;l--){let c=e[l],u=c.inputs;for(let h=0;h<c.outputs.length;h++)if(s[c.outputs[h].id]){for(let d in u)s[u[d].id]=!0,i[c.id]=!0;break}}let o=[];for(let l=0;l<e.length;l++){let c=e[l];if(a[c.id]&&i[c.id]){let u={};for(let d in c.inputs){let p=c.inputs[d];r[p.id]&&(u[d]=p)}let h=Object.assign({},c);h.inputs=u,h.outputs=c.outputs,o.push(h)}}return o}function P7(e,t,n,r){for(let a=t.length-1;a>=0;a--){let s=t[a],i=[];if(s.outputs.forEach(l=>{let c=e[l.id];c!=null?i.push(c):i.push(null)}),s.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);let o=s.gradient(i);for(let l in s.inputs){if(!(l in o))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(o)}.`);let c=n(()=>o[l]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${c.dtype}'`);let u=s.inputs[l];if(!pi(c.shape,u.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${l}' has shape '${c.shape}', which does not match the shape of the input '${u.shape}'`);if(e[u.id]==null)e[u.id]=c;else{let h=e[u.id];e[u.id]=r(h,c),h.dispose()}}}}var AA=20,nf=3,Uw=7;function L7(e,t,n,r){let a=md(t),s=B7(e,t,n,a),i=t.length,o=f0(e,t,n,a,s),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${i}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(o.map(c=>"    "+c).join(`
`)),l.join(`
`)}function B7(e,t,n,r){let a=dt(t),s=r[r.length-1],i=new Array(s).fill(0),o=t.length,l=n==="complex64"?mf(e):e;if(o>1)for(let c=0;c<a/s;c++){let u=c*s;for(let h=0;h<s;h++)i[h]=Math.max(i[h],ff(l[u+h],0,n).length)}return i}function ff(e,t,n){let r;return Array.isArray(e)?r=`${parseFloat(e[0].toFixed(Uw))} + ${parseFloat(e[1].toFixed(Uw))}j`:Ki(e)?r=`'${e}'`:n==="bool"?r=WD(e):r=parseFloat(e.toFixed(Uw)).toString(),Df(r,t)}function WD(e){return e===0?"false":"true"}function f0(e,t,n,r,a,s=!0){let i=n==="complex64"?2:1,o=t[0],l=t.length;if(l===0){if(n==="complex64"){let m=mf(e);return[ff(m[0],0,n)]}return n==="bool"?[WD(e[0])]:[e[0].toString()]}if(l===1){if(o>AA){let m=nf*i,y=Array.from(e.slice(0,m)),g=Array.from(e.slice((o-nf)*i,o*i));return n==="complex64"&&(y=mf(y),g=mf(g)),["["+y.map((x,b)=>ff(x,a[b],n)).join(", ")+", ..., "+g.map((x,b)=>ff(x,a[o-nf+b],n)).join(", ")+"]"]}return["["+(n==="complex64"?mf(e):Array.from(e)).map((m,y)=>ff(m,a[y],n)).join(", ")+"]"]}let c=t.slice(1),u=r.slice(1),h=r[0]*i,d=[];if(o>AA){for(let m=0;m<nf;m++){let y=m*h,g=y+h;d.push(...f0(e.slice(y,g),c,n,u,a,!1))}d.push("...");for(let m=o-nf;m<o;m++){let y=m*h,g=y+h;d.push(...f0(e.slice(y,g),c,n,u,a,m===o-1))}}else for(let m=0;m<o;m++){let y=m*h,g=y+h;d.push(...f0(e.slice(y,g),c,n,u,a,m===o-1))}let p=l===2?",":"";d[0]="["+(o>0?d[0]+p:"");for(let m=1;m<d.length-1;m++)d[m]=" "+d[m]+p;let f=`,
`;for(let m=2;m<l;m++)f+=`
`;return d[d.length-1]=" "+d[d.length-1]+"]"+(s?"":f),d}function mf(e){let t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}var Yt=class{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=dt(e),n!=null){let r=n.length;R(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||zS(t,this.size),this.strides=md(e)}set(e,...t){t.length===0&&(t=[0]),R(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);let n=this.locToIndex(t);this.values[n]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(let r of e){if(r<0||r>=this.shape[t]){let a=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(a)}t++}let n=e[e.length-1];for(let r=0;r<e.length-1;++r)n+=this.strides[r]*e[r];return this.values[n]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];let t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Ha().makeTensor(this.values,this.shape,this.dtype)}},Ha=null,oh=null;function W7(e){Ha=e}function U7(e){oh=e}var ze=class{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=dt(e),this.strides=md(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let e=await this.data();return oh.buffer(this.shape,this.dtype,e)}bufferSync(){return oh.buffer(this.shape,this.dtype,this.dataSync())}async array(){let e=await this.data();return $h(this.shape,e,this.dtype==="complex64")}arraySync(){return $h(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();let e=Ha().read(this.dataId);if(this.dtype==="string"){let t=await e;try{return t.map(n=>ax(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Ha().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();let e=Ha().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>ax(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();let e=await Ha().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Ha().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return oh.print(this,e)}clone(){return this.throwIfDisposed(),oh.clone(this)}toString(e=!1){let t=this.dataSync();return L7(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),oh.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),Ha().makeVariable(this,e,t,n)}};Object.defineProperty(ze,Symbol.hasInstance,{value:e=>!!e&&e.data!=null&&e.dataSync!=null&&e.throwIfDisposed!=null});function re(){return BS("Tensor",()=>ze)}re();var Bl=class extends ze{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!pi(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Ha().disposeTensor(this),this.dataId=e.dataId,Ha().incRef(this,null)}dispose(){Ha().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(Bl,Symbol.hasInstance,{value:e=>e instanceof ze&&e.assign!=null&&e.assign instanceof Function});var Za={};Re(Za,{assertTypesMatch:()=>jD,getTensorsInContainer:()=>US,isTensorInList:()=>j7,makeTypesMatch:()=>Pt});var fk;(function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"})(fk||(fk={}));var mk;(function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"})(mk||(mk={}));var gk;(function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"})(gk||(gk={}));var yk;(function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"})(yk||(yk={}));var xk;(function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"})(xk||(xk={}));var V7={float32:yk,int32:mk,bool:gk,complex64:xk};function ca(e,t){if(e==="string"||t==="string"){if(e==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return V7[e][t]}function gb(e){return ca(e,"int32")}function UD(e){return e!=null&&typeof e=="object"&&"texture"in e&&e.texture instanceof WebGLTexture}function VD(e){return typeof GPUBuffer<"u"&&e!=null&&typeof e=="object"&&"buffer"in e&&e.buffer instanceof GPUBuffer}function Pt(e,t){if(e.dtype===t.dtype)return[e,t];let n=ca(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function jD(e,t){R(e.dtype===t.dtype,()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`)}function j7(e,t){return t.some(n=>n.id===e.id)}function US(e){let t=[];return GD(e,t,new Set),t}function GD(e,t,n){if(e==null)return;if(e instanceof ze){t.push(e);return}if(!G7(e))return;let r=e;for(let a in r){let s=r[a];n.has(s)||(n.add(s),GD(s,t,n))}}function G7(e){return Array.isArray(e)||typeof e=="object"}function Vw(e){return e.kernelName!=null}var $A=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(let e in this.registeredVariables)this.registeredVariables[e].dispose()}},VS=class bk{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new $A}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let t=this.getSortedBackends();for(let n=0;n<t.length;n++){let r=t[n];if(await this.initializeBackend(r).success){await this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:t,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){let{asyncInit:n}=this.initializeBackend(t);if(n)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,n,r=1){return t in this.registryFactory?(ji(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:n,priority:r},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;let{success:n,asyncInit:r}=this.initializeBackend(t);if(!(r?await n:n))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new R7(this.backendInstance),!0}setupRegisteredKernels(){rx(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){rx(t).forEach(n=>{n.disposeFunc!=null&&n.disposeFunc(this.registry[t])})}initializeBackend(t){let n=this.registryFactory[t];if(n==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{let r=n.factory();if(r&&!(r instanceof Dm)&&typeof r.then=="function"){let a=++this.pendingBackendInitId,s=r.then(i=>a<this.pendingBackendInitId?!1:(this.registry[t]=i,this.pendingBackendInit=null,!0)).catch(i=>(a<this.pendingBackendInitId||(this.pendingBackendInit=null,ji(`Initialization of backend ${t} failed`),ji(i.stack||i.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}else return this.registry[t]=r,{success:!0,asyncInit:!1}}catch(r){return ji(`Initialization of backend ${t} failed`),ji(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,n)=>this.registryFactory[n].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){let t=this.getSortedBackends();for(let n=0;n<t.length;n++){let r=t[n],{success:a,asyncInit:s}=this.initializeBackend(r);if(s||a)return{name:r,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,n){let r=this.state.tensorInfo.get(n),a=r.backend,s=this.readSync(n),i=a.refCount(n);a.disposeData(n,!0),r.backend=t,t.move(n,s,r.shape,r.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,n){let r=null;if(n==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");n=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof n!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=t}let a;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(a),()=>(a=n(),a instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),a))}scopedRun(t,n,r){t();try{let a=r();return n(),a}catch(a){throw n(),a}}nextTensorId(){return bk.nextTensorId++}nextVariableId(){return bk.nextVariableId++}clone(t){let n=B.runKernel(zu,{x:t}),r={x:t},a=i=>({x:()=>{let o="float32",l={x:i},c={dtype:o};return B.runKernel(xu,l,c)}}),s=[];return this.addTapeNode(this.state.activeScope.name,r,[n],a,s,{}),n}runKernel(t,n,r){if(this.backendName==null&&this.backend,um(t,this.backendName)==null)throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:n,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,n,r){let a=this.backend.numDataIds(),s=0;r.forEach(l=>{s+=l.dtype==="complex64"?3:1});let i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=a-n-s-i;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${t}'`)}runKernelFunc(t){let n,r=[],a=this.isTapeOn(),s=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let o;this.backendName==null&&this.backend;let l,c=Vw(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(Vw(t)){let{kernelName:f,inputs:m,attrs:y}=t;this.backendName==null&&this.backend;let g=um(f,this.backendName);R(g!=null,()=>`Cannot find registered kernel '${f}' for backend '${this.backendName}'`),o=()=>{let x=this.backend.numDataIds();l=g.kernelFunc({inputs:m,attrs:y,backend:this.backend});let b=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(f,x,b);let v=b.map(w=>w.rank!=null?w:this.makeTensorFromTensorInfo(w));if(a){let w=this.getTensorsForGradient(f,m,v);r=this.saveTensorsForBackwardMode(w)}return v}}else{let{forwardFunc:f}=t,m=y=>{a&&(r=y.map(g=>this.keep(this.clone(g))))};o=()=>{let y=this.backend.numDataIds();l=this.tidy(()=>f(this.backend,m));let g=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,y,g),g}}let{inputs:u,attrs:h}=t,d=Vw(t)?null:t.backwardsFunc,p;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?n=o():(p=this.profiler.profileKernel(c,u,()=>o()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),n=p.outputs)}),a&&this.addTapeNode(c,u,n,d,r,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map(f=>u[f]!=null?u[f].shape:null),outputShapes:n.map(f=>f.shape),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(l)?n:n[0]}saveTensorsForBackwardMode(t){return t.map(n=>this.keep(this.clone(n)))}getTensorsForGradient(t,n,r){let a=dk(t);if(a!=null){let s=a.inputsToSave||[],i=a.outputsToSave||[],o;a.saveAllInputs?(R(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),o=Object.keys(n).map(c=>n[c])):o=s.map(c=>n[c]);let l=r.filter((c,u)=>i[u]);return o.concat(l)}return[]}makeTensor(t,n,r,a){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",a=a||this.backend;let s=t;r==="string"&&Ki(t[0])&&(s=t.map(l=>ig(l)));let i=a.write(s,n,r),o=new ze(n,r,i,this.nextTensorId());if(this.trackTensor(o,a),r==="string"){let l=this.state.tensorInfo.get(i),c=TD(s);this.state.numBytes+=c-l.bytes,l.bytes=c}return o}makeTensorFromDataId(t,n,r,a){r=r||"float32";let s={dataId:t,shape:n,dtype:r};return this.makeTensorFromTensorInfo(s,a)}makeTensorFromTensorInfo(t,n){let{dataId:r,shape:a,dtype:s}=t,i=new ze(a,s,r,this.nextTensorId());return this.trackTensor(i,n),i}makeVariable(t,n=!0,r,a){r=r||this.nextVariableId().toString(),a!=null&&a!==t.dtype&&(t=t.cast(a));let s=new Bl(t,n,r,this.nextTensorId());if(this.state.registeredVariables[s.name]!=null)throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(t,n){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let r=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(r=t.size*ex(t.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:n||this.backend,dtype:t.dtype,shape:t.shape,bytes:r})),t instanceof Bl||this.track(t)}incRef(t,n){this.trackTensor(t,n),this.backend.incRef(t.dataId)}removeDataId(t,n){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===n&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;let n=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){let r=t.size*ex(t.dtype);this.state.numBytes-=r}n.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,n.backend)}disposeVariables(){for(let t in this.state.registeredVariables){let n=this.state.registeredVariables[t];this.disposeVariable(n)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){let t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;let n=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(a=>a.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-r;for(let a of this.state.activeProfile.kernels)a.kernelTimeMs=await a.kernelTimeMs,a.extraInfo=await a.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,n,r,a,s,i){let o={id:this.state.nextTapeNodeId++,kernelName:t,inputs:n,outputs:r,saved:s},l=dk(t);l!=null&&(a=l.gradFunc),a!=null&&(o.gradient=c=>(c=c.map((u,h)=>{if(u==null){let d=r[h],p=eb(d.size,d.dtype);return this.makeTensor(p,d.shape,d.dtype)}return u}),a(c.length>1?c:c[0],s,i))),this.state.activeTape.push(o)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){let n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(n.name=t),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(t){let n=US(t),r=new Set(n.map(s=>s.id));for(let s=0;s<this.state.activeScope.track.length;s++){let i=this.state.activeScope.track[s];!i.kept&&!r.has(i.id)&&i.dispose()}let a=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(s=>{!s.kept&&s.scopeId===a.id&&this.track(s)})}gradients(t,n,r,a=!1){if(R(n.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);let s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));R(s instanceof ze,()=>"The result y returned by f() must be a tensor.");let i=z7(this.state.activeTape,n,s);if(!a&&i.length===0&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let o={};o[s.id]=r??H7(s.shape),P7(o,i,c=>this.tidy(c),q7);let l=n.map(c=>o[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(let u of c.saved)u.dispose()}),this.state.activeTape=null),{value:s,grads:l}})}customGrad(t){return R(mo(t),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{R(n.every(o=>o instanceof ze),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r,a={};n.forEach((o,l)=>{a[l]=o});let s=(o,l)=>(r=t(...n,l),R(r.value instanceof ze,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),R(mo(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),i=(o,l)=>{let c=r.gradFunc(o,l),u=Array.isArray(c)?c:[c];R(u.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),R(u.every(d=>d instanceof ze),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let h={};return u.forEach((d,p)=>{h[p]=()=>d}),h};return this.runKernelFunc({forwardFunc:s,backwardsFunc:i,inputs:a})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,n){return this.state.tensorInfo.get(t).backend.readToGPU(t,n)}async time(t){let n=cm(),r=await this.backend.time(t);return r.wallMs=cm()-n,r}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new $A;for(let t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};VS.nextTensorId=0;VS.nextVariableId=0;function H7(e){let t=PS(dt(e),"float32");return B.makeTensor(t,e,"float32")}function HD(){let e=FD();if(e._tfengine==null){let t=new MD(e);e._tfengine=new VS(t)}return g7(e._tfengine.ENV),W7(()=>e._tfengine),e._tfengine}var B=HD();function q7(e,t){let n={a:e,b:t};return B.runKernel(Do,n)}var og={};Re(og,{isBrowser:()=>qD,isMobile:()=>Z7,mockIsMobile:()=>X7});function K7(){return typeof navigator<"u"&&navigator!=null}var vk;function X7(e){vk=e}function Z7(e){if(vk!==void 0)return vk;if(e||K7()){if(e||(e=navigator),e.product==="ReactNative")return!0;let t=e.userAgent||e.vendor||(typeof window<"u"?window.opera:"");if(!t){let n=e;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function qD(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}var vr=X();vr.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});vr.registerFlag("IS_BROWSER",()=>qD());vr.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");vr.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));vr.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));vr.registerFlag("PROD",()=>!1);vr.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>vr.getBool("DEBUG"));vr.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);vr.registerFlag("IS_TEST",()=>!1);vr.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>vr.getBool("DEBUG"));vr.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);vr.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);vr.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function Cs(e,t){let n=e;if(gn(e))return t==="string"?[]:[e.length];if(UD(e)){let a=e.channels||"RGBA";return[e.height,e.width*a.length]}else if(VD(e))return[e.buffer.size/(t==null?4:ex(t))];if(!Array.isArray(e))return[];let r=[];for(;Array.isArray(n)||gn(n)&&t!=="string";)r.push(n.length),n=n[0];return Array.isArray(e)&&X().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&KD(e,r,[]),r}function KD(e,t,n){if(n=n||[],!Array.isArray(e)&&!gn(e)){R(t.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}R(t.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`),R(e.length===t[0],()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`);let r=t.slice(1);for(let a=0;a<e.length;++a)KD(e[a],r,n.concat(a))}function MA(e,t,n,r){if(e!=="string_or_numeric"){if(e==null)throw new Error("Expected dtype cannot be null.");if(e!=="numeric"&&e!==t||e==="numeric"&&t==="string")throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function $(e,t,n,r="numeric"){if(e instanceof re())return MA(r,e.dtype,t,n),e;let a=Om(e);if(a!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(a=r),MA(r,a,t,n),e==null||!gn(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string"){let o=e==null?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${o}'`)}let s=Cs(e,a);!gn(e)&&!Array.isArray(e)&&(e=[e]);let i=a!=="string"?mb(e,a):go(e,[],!0);return B.makeTensor(i,s,a)}function hm(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((a,s)=>$(a,`${t}[${s}]`,n,r))}var jS="__op";function W(e){let t=Object.keys(e);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0],r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+jS;let a=(...s)=>{B.startScope(n);try{let i=r(...s);return tb(i)&&console.error("Cannot return a Promise inside of tidy."),B.endScope(i),i}catch(i){throw B.endScope(null),i}};return Object.defineProperty(a,"name",{value:n,configurable:!0}),a}function Y7(e,t){let n=$(e,"real","complex"),r=$(t,"imag","complex");sr(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);let a={real:n,imag:r};return B.runKernel(nb,a)}var ui=W({complex_:Y7});function Lo(e,t,n,r){if(r==null)r=Om(e);else if(r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(VD(e)||UD(e)){if(r!=="float32"&&r!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return B.backend.createTensorFromGPUData(e,t||n,r)}if(!gn(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){qr(t);let a=dt(t),s=dt(n);R(a===s,()=>`Based on the provided shape, [${t}], the tensor should have ${a} values but has ${s}`);for(let i=0;i<n.length;++i){let o=n[i],l=i===n.length-1?o!==dt(t.slice(i)):!0;R(n[i]===t[i]||!l,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return!gn(e)&&!Array.isArray(e)&&(e=[e]),t=t||n,e=r!=="string"?mb(e,r):go(e,[],!0),B.makeTensor(e,t,r)}function er(e,t,n){let r=Cs(e,n);return Lo(e,t,r,n)}var Wl={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},fi=class XD{static join(t){return new XD(t).slice()}constructor(t){if(this.shards=[],this.previousShardIndex=0,t==null||(t instanceof Array||(t=[t]),t=t.map(r=>gn(r)?r.buffer:r),t.length===0))return;this.bufferUniformSize=t[0].byteLength;let n=0;for(let r=0;r<t.length;r++){let a=t[r];r!==t.length-1&&a.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);let s=n+a.byteLength;this.shards.push({buffer:a,start:n,end:s}),n=s}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,n=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,n=isNaN(Number(n))?0:n,t=Math.max(0,t),n=Math.min(this.byteLength,n),n<=t)return new ArrayBuffer(0);let r=this.findShardForByte(t);if(r===-1)throw new Error(`Could not find start shard for byte ${t}`);let a=n-t,s=new ArrayBuffer(a),i=new Uint8Array(s),o=0;for(let l=r;l<this.shards.length;l++){let c=this.shards[l],u=t+o-c.start,h=o,d=Math.min(n,c.end)-c.start,p=new Uint8Array(c.buffer,u,d-u);if(i.set(p,h),o+=p.length,n<c.end)break}return s}findShardForByte(t){if(this.shards.length===0||t<0||t>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function n(a){return t<a.start?-1:t>=a.end?1:0}if(n(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;let r=J7(this.shards,n);return r===-1?-1:(this.previousShardIndex=r,this.previousShardIndex)}};function J7(e,t){let n=0,r=e.length;for(;n<=r;){let a=Math.floor((r-n)/2)+n,s=t(e[a]);if(s===0)return a;s<0?r=a:n=a+1}return-1}function Q7(){X().set("PROD",!0)}function e9(){X().set("DEBUG",!0)}function t9(){X().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function ZD(e){X().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function n9(){B.disposeVariables()}function wa(){return B}function wk(){return B.memory()}function r9(e){return B.profile(e)}function j(e,t){return B.tidy(e,t)}function Fe(e){US(e).forEach(t=>t.dispose())}function an(e){return B.keep(e)}function a9(e){return B.time(e)}function s9(e){return B.setBackend(e)}function i9(){return B.ready()}function YD(){return B.backendName}function o9(e){B.removeBackend(e)}function l9(e){return B.findBackend(e)}function u9(e){return B.findBackendFactory(e)}function yb(e,t,n=1){return B.registerBackend(e,t,n)}function GS(){return B.backend}function c9(e,t){X().setPlatform(e,t)}var yo=4;async function h9(e,t){let n=[],r=[],a=Array.isArray(e)?e.map(i=>i.name):Object.keys(e);for(let i=0;i<a.length;++i){let o=a[i],l=Array.isArray(e)?e[i].tensor:e[o];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${o}': ${l.dtype}`);let c={name:o,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){let u=new Promise(async h=>{let d=await l.bytes(),p=d.reduce((y,g)=>y+g.length,0)+yo*d.length,f=new Uint8Array(p),m=0;for(let y=0;y<d.length;y++){let g=d[y],x=new Uint8Array(new Uint32Array([g.length]).buffer);f.set(x,m),m+=yo,f.set(g,m),m+=g.length}h(f)});r.push(u)}else r.push(l.data());t!=null&&(c.group=t),n.push(c)}let s=await Promise.all(r);return{data:f9(s),specs:n}}function JD(e,t){let n=new fi(e),r={},a=0;for(let s of t){let i=d9(s,(o,l)=>n.slice(a+o,a+l));r[s.name]=QD(s,n.slice(a,a+i)),a+=i}return r}function d9(e,t){let n=dt(e.shape),r;if("quantization"in e){let a=e.quantization;r=Wl[a.dtype]}else if(e.dtype==="string"){let a=0;for(let s=0;s<n;s++)a+=yo+new Uint32Array(t(a,a+yo))[0];return a}else r=Wl[e.dtype];return n*r}async function p9(e,t){let n=dt(e.shape),r;if("quantization"in e){let a=e.quantization;r=Wl[a.dtype]}else if(e.dtype==="string"){let a=0;for(let s=0;s<n;s++)a+=yo+new Uint32Array(await t(a,a+yo))[0];return a}else r=Wl[e.dtype];return n*r}function QD(e,t){let n=e.name,r=e.dtype,a=e.shape,s=dt(a),i,o=0;if("quantization"in e){let l=e.quantization;if(l.dtype==="uint8"||l.dtype==="uint16"){if(!("min"in l&&"scale"in l))throw new Error(`Weight ${e.name} with quantization ${l.dtype} doesn't have corresponding metadata min and scale.`)}else if(l.dtype==="float16"){if(r!=="float32")throw new Error(`Weight ${e.name} is quantized with ${l.dtype} which only supports weights of type float32 not ${r}.`)}else throw new Error(`Weight ${e.name} has unknown quantization dtype ${l.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let c=Wl[l.dtype],u=l.dtype==="uint8"?new Uint8Array(t):new Uint16Array(t);if(r==="float32")if(l.dtype==="uint8"||l.dtype==="uint16"){i=new Float32Array(u.length);for(let h=0;h<u.length;h++){let d=u[h];i[h]=d*l.scale+l.min}}else if(l.dtype==="float16")i=w9()(u);else throw new Error(`Unsupported quantization type ${l.dtype} for weight type float32.`);else if(r==="int32"){if(l.dtype!=="uint8"&&l.dtype!=="uint16")throw new Error(`Unsupported quantization type ${l.dtype} for weight type int32.`);i=new Int32Array(u.length);for(let h=0;h<u.length;h++){let d=u[h];i[h]=Math.round(d*l.scale+l.min)}}else throw new Error(`Unsupported dtype in weight '${n}': ${r}`);o+=s*c}else if(r==="string"){let l=dt(e.shape);i=[];for(let c=0;c<l;c++){let u=new Uint32Array(t.slice(o,o+yo))[0];o+=yo;let h=new Uint8Array(t.slice(o,o+u));i.push(h),o+=u}}else{let l=Wl[r];if(r==="float32")i=new Float32Array(t);else if(r==="int32")i=new Int32Array(t);else if(r==="bool")i=new Uint8Array(t);else if(r==="complex64"){i=new Float32Array(t);let c=new Float32Array(i.length/2),u=new Float32Array(i.length/2);for(let f=0;f<c.length;f++)c[f]=i[f*2],u[f]=i[f*2+1];let h=er(c,a,"float32"),d=er(u,a,"float32"),p=ui(h,d);return h.dispose(),d.dispose(),p}else throw new Error(`Unsupported dtype in weight '${n}': ${r}`);o+=s*l}return er(i,a,r)}async function FA(e,t,n){let r=new Uint8Array(t);for(;r.byteLength<n;){let{done:a,value:s}=await e.read();if(a&&s==null){let o=n-r.byteLength;throw new Error(`Reader is done but ${o} bytes are still expected`)}let i=new Uint8Array(r.length+s.byteLength);i.set(r,0),i.set(new Uint8Array(s),r.length),r=i}return r.buffer}async function e3(e,t){let n={},r=e.getReader(),a=new ArrayBuffer(0);for(let s of t){let i=await p9(s,async(c,u)=>(a=await FA(r,a,u),a.slice(c,u)));a=await FA(r,a,i);let o=a.slice(0,i);a=a.slice(i);let l=QD(s,o);if(n[s.name]=l,YD()==="webgpu"){let c=GS();"uploadToGPU"in c&&dt(l.shape)>=X().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&c.uploadToGPU(l.dataId)}}return n}function f9(e){if(e===null)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0,n=[];e.forEach(s=>{if(t+=s.byteLength,n.push(s.byteLength===s.buffer.byteLength?s:new s.constructor(s)),!(s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`)});let r=new Uint8Array(t),a=0;return n.forEach(s=>{r.set(new Uint8Array(s.buffer),a),a+=s.byteLength}),r.buffer}var HS=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function RA(e){return HS?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function m9(e){if(HS)return Buffer.from(e).toString("base64");let t=new Uint8Array(e),n="";for(let r=0,a=t.length;r<a;r++)n+=String.fromCharCode(t[r]);return btoa(n)}function g9(e){if(HS){let r=Buffer.from(e,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}let t=atob(e),n=new Uint8Array(t.length);for(let r=0;r<t.length;++r)n.set([t.charCodeAt(r)],r);return n.buffer}function y9(e){return fi.join(e)}function DA(e){let t="/";for(e=e.trim();e.endsWith(t);)e=e.slice(0,e.length-1);let n=e.split(t);return n[n.length-1]}function t3(e,t){let n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return e.signature!=null&&(n.signature=e.signature),e.userDefinedMetadata!=null&&(n.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(n.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(n.initializerSignature=e.initializerSignature),e.trainingConfig!=null&&(n.trainingConfig=e.trainingConfig),n}function n3(e,t,n){let r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(e.trainingConfig!=null&&(r.trainingConfig=e.trainingConfig),e.weightsManifest!=null){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=n}return e.signature!=null&&(r.signature=e.signature),e.userDefinedMetadata!=null&&(r.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(r.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(r.initializerSignature=e.initializerSignature),r}async function qS(e,t){let n,r;return e.weightsManifest!=null&&([n,r]=await t(e.weightsManifest)),n3(e,n,r)}function lg(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:e.modelTopology==null?0:RA(JSON.stringify(e.modelTopology)),weightSpecsBytes:e.weightSpecs==null?0:RA(JSON.stringify(e.weightSpecs)),weightDataBytes:e.weightData==null?0:new fi(e.weightData).byteLength}}function kk(e){let t=[];for(let n of e)t.push(...n.weights);return t}function x9(){let e=n=>{let r=n<<13,a=0;for(;!(r&8388608);)a-=8388608,r<<=1;return r&=-8388609,a+=947912704,r|a},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}function b9(){let e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}function v9(){let e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}function w9(){let e=x9(),t=b9(),n=v9();return r=>{let a=new ArrayBuffer(4*r.length),s=new Uint32Array(a);for(let i=0;i<r.length;i++){let o=r[i],l=e[n[o>>10]+(o&1023)]+t[o>>10];s[i]=l}return new Float32Array(a)}}var ha=class Wa{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Wa.instance==null&&(Wa.instance=new Wa),Wa.instance}static registerSaveRouter(t){Wa.getInstance().saveRouters.push(t)}static registerLoadRouter(t){Wa.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return Wa.getHandlers(t,"save")}static getLoadHandlers(t,n){return Wa.getHandlers(t,"load",n)}static getHandlers(t,n,r){let a=[];return(n==="load"?Wa.getInstance().loadRouters:Wa.getInstance().saveRouters).forEach(s=>{let i=s(t,r);i!==null&&a.push(i)}),a}},k9=e=>ha.registerSaveRouter(e),S9=e=>ha.registerLoadRouter(e),I9=e=>ha.getSaveHandlers(e),N9=(e,t)=>ha.getLoadHandlers(e,t),Sk="tensorflowjs",Ik=1,Il="models_store",Xi="model_info_store";function r3(){if(!X().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let e=typeof window>"u"?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function Nk(e){let t=e.result;t.createObjectStore(Il,{keyPath:"modelPath"}),t.createObjectStore(Xi,{keyPath:"modelPath"})}var Ul=class{constructor(e){if(this.indexedDB=r3(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((n,r)=>{let a=this.indexedDB.open(Sk,Ik);a.onupgradeneeded=()=>Nk(a),a.onsuccess=()=>{let s=a.result;if(t==null){let i=s.transaction(Il,"readonly"),o=i.objectStore(Il).get(this.modelPath);o.onsuccess=()=>{if(o.result==null)return s.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));n(o.result.modelArtifacts)},o.onerror=l=>(s.close(),r(o.error)),i.oncomplete=()=>s.close()}else{t.weightData=fi.join(t.weightData);let i=lg(t),o=s.transaction(Xi,"readwrite"),l=o.objectStore(Xi),c;try{c=l.put({modelPath:this.modelPath,modelArtifactsInfo:i})}catch(h){return r(h)}let u;c.onsuccess=()=>{u=s.transaction(Il,"readwrite");let h=u.objectStore(Il),d;try{d=h.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:i})}catch(p){return r(p)}d.onsuccess=()=>n({modelArtifactsInfo:i}),d.onerror=p=>{l=o.objectStore(Xi);let f=l.delete(this.modelPath);f.onsuccess=()=>(s.close(),r(d.error)),f.onerror=m=>(s.close(),r(d.error))}},c.onerror=h=>(s.close(),r(c.error)),o.oncomplete=()=>{u==null?s.close():u.oncomplete=()=>s.close()}}},a.onerror=s=>r(a.error)})}};Ul.URL_SCHEME="indexeddb://";var a3=e=>X().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Ul.URL_SCHEME)?_9(e.slice(Ul.URL_SCHEME.length)):null;ha.registerSaveRouter(a3);ha.registerLoadRouter(a3);function _9(e){return new Ul(e)}function C9(e){return e.startsWith(Ul.URL_SCHEME)?e.slice(Ul.URL_SCHEME.length):e}var T9=class{constructor(){this.indexedDB=r3()}async listModels(){return new Promise((e,t)=>{let n=this.indexedDB.open(Sk,Ik);n.onupgradeneeded=()=>Nk(n),n.onsuccess=()=>{let r=n.result,a=r.transaction(Xi,"readonly"),s=a.objectStore(Xi).getAll();s.onsuccess=()=>{let i={};for(let o of s.result)i[o.modelPath]=o.modelArtifactsInfo;e(i)},s.onerror=i=>(r.close(),t(s.error)),a.oncomplete=()=>r.close()},n.onerror=r=>t(n.error)})}async removeModel(e){return e=C9(e),new Promise((t,n)=>{let r=this.indexedDB.open(Sk,Ik);r.onupgradeneeded=()=>Nk(r),r.onsuccess=()=>{let a=r.result,s=a.transaction(Xi,"readwrite"),i=s.objectStore(Xi),o=i.get(e),l;o.onsuccess=()=>{if(o.result==null)return a.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{let c=i.delete(e),u=()=>{l=a.transaction(Il,"readwrite");let h=l.objectStore(Il).delete(e);h.onsuccess=()=>t(o.result.modelArtifactsInfo),h.onerror=d=>n(o.error)};c.onsuccess=u,c.onerror=h=>(u(),a.close(),n(o.error))}},o.onerror=c=>(a.close(),n(o.error)),s.oncomplete=()=>{l==null?a.close():l.oncomplete=()=>a.close()}},r.onerror=a=>n(r.error)})}},Zs="/",lh="tensorflowjs_models",s3="info",E9="model_topology",A9="weight_specs",$9="weight_data",M9="model_metadata";function i3(e){return{info:[lh,e,s3].join(Zs),topology:[lh,e,E9].join(Zs),weightSpecs:[lh,e,A9].join(Zs),weightData:[lh,e,$9].join(Zs),modelMetadata:[lh,e,M9].join(Zs)}}function o3(e){for(let t of Object.values(e))window.localStorage.removeItem(t)}function F9(e){let t=e.split(Zs);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(Zs)}function R9(e){return e.startsWith(Vl.URL_SCHEME)?e.slice(Vl.URL_SCHEME.length):e}var Vl=class{constructor(e){if(!X().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=i3(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),r=lg(e),a=fi.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,m9(a));let s={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s)),{modelArtifactsInfo:r}}catch{throw o3(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(n==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;let r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;let a=this.LS.getItem(this.keys.modelMetadata);if(a!=null){let i=JSON.parse(a);t.format=i.format,t.generatedBy=i.generatedBy,t.convertedBy=i.convertedBy,i.signature!=null&&(t.signature=i.signature),i.userDefinedMetadata!=null&&(t.userDefinedMetadata=i.userDefinedMetadata),i.modelInitializer!=null&&(t.modelInitializer=i.modelInitializer),i.initializerSignature!=null&&(t.initializerSignature=i.initializerSignature),i.trainingConfig!=null&&(t.trainingConfig=i.trainingConfig)}let s=this.LS.getItem(this.keys.weightData);if(s==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=g9(s),t}};Vl.URL_SCHEME="localstorage://";var l3=e=>X().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Vl.URL_SCHEME)?D9(e.slice(Vl.URL_SCHEME.length)):null;ha.registerSaveRouter(l3);ha.registerLoadRouter(l3);function D9(e){return new Vl(e)}var O9=class{constructor(){R(X().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),R(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let e={},t=lh+Zs,n=Zs+s3;for(let r=0;r<this.LS.length;++r){let a=this.LS.key(r);if(a.startsWith(t)&&a.endsWith(n)){let s=F9(a);e[s]=JSON.parse(this.LS.getItem(a))}}return e}async removeModel(e){e=R9(e);let t=i3(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);let n=JSON.parse(this.LS.getItem(t.info));return o3(t),n}},Mh="://",xo=class Di{constructor(){this.managers={}}static getInstance(){return Di.instance==null&&(Di.instance=new Di),Di.instance}static registerManager(t,n){R(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(Mh)&&(t=t.slice(0,t.indexOf(Mh))),R(t.length>0,()=>"scheme must not be an empty string.");let r=Di.getInstance();R(r.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),r.managers[t]=n}static getManager(t){let n=Di.getInstance().managers[t];if(n==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return n}static getSchemes(){return Object.keys(Di.getInstance().managers)}};function m0(e){if(e.indexOf(Mh)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${xo.getSchemes().join(",")}`);return{scheme:e.split(Mh)[0],path:e.split(Mh)[1]}}async function u3(e,t,n=!1){R(e!==t,()=>`Old path and new path are the same: '${e}'`);let r=ha.getLoadHandlers(e);R(r.length>0,()=>`Copying failed because no load handler is found for source URL ${e}.`),R(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`);let a=r[0],s=ha.getSaveHandlers(t);R(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),R(s.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`);let i=s[0],o=m0(e).scheme,l=m0(e).path,c=o===m0(e).scheme,u=await a.load();n&&c&&await xo.getManager(o).removeModel(l);let h=await i.save(u);return n&&!c&&await xo.getManager(o).removeModel(l),h.modelArtifactsInfo}async function z9(){let e=xo.getSchemes(),t={};for(let n of e){let r=await xo.getManager(n).listModels();for(let a in r){let s=n+Mh+a;t[s]=r[a]}}return t}async function P9(e){let t=m0(e);return xo.getManager(t.scheme).removeModel(t.path)}async function L9(e,t){return u3(e,t,!1)}async function B9(e,t){return u3(e,t,!0)}var W9=class{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!X().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",n=>{if(n.source===window&&n.data.name===this.messageName){n.stopPropagation();let r=this.functionRefs[n.data.index];r(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return PD(e)}};if(X().get("IS_BROWSER")){X().setPlatform("browser",new W9);try{xo.registerManager(Vl.URL_SCHEME,new O9)}catch{}try{xo.registerManager(Ul.URL_SCHEME,new T9)}catch{}}var U9={importFetch:()=>Dq()},jw,V9=class{constructor(){this.util=Oq(),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return X().global.fetch!=null?X().global.fetch(e,t):(jw==null&&(jw=U9.importFetch()),jw(e,t))}now(){let e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}};X().get("IS_NODE")&&!X().get("IS_BROWSER")&&X().setPlatform("node",new V9);function Ve(e,t="float32",n){return t=t||"float32",qr(e),new Yt(e,t,n)}function j9(e,t){let n=$(e,"x","cast");if(!CD(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&n.dtype!=="string"||t!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");let r={x:n},a={dtype:t};return B.runKernel(xu,r,a)}var le=W({cast_:j9});function G9(e){let t={x:$(e,"x","clone","string_or_numeric")};return B.runKernel(zu,t)}var Is=W({clone_:G9});function KS(e,t=!1){console.log(e.toString(t))}HD();var H9={buffer:Ve,cast:le,clone:Is,print:KS};U7(H9);function q9(e,t){let n=$(e,"a","add"),r=$(t,"b","add");[n,r]=Pt(n,r);let a={a:n,b:r};return B.runKernel(Do,a)}var te=W({add_:q9});function K9(e,t){let n=$(e,"a","floorDiv"),r=$(t,"b","floorDiv");[n,r]=Pt(n,r);let a={a:n,b:r};return B.runKernel(Ru,a)}var xb=W({floorDiv_:K9});function X9(e,t){let n=$(e,"a","div"),r=$(t,"b","div");if([n,r]=Pt(n,r),n.dtype==="int32"&&r.dtype==="int32")return xb(n,r);let a={a:n,b:r},s={};return B.runKernel(Tu,a,s)}var xe=W({div_:X9});function Z9(e,t){let n=$(e,"a","mul"),r=$(t,"b","mul");[n,r]=Pt(n,r);let a={a:n,b:r};return B.runKernel(Qu,a)}var U=W({mul_:Z9});function Y9(e){let t=$(e,"x","abs");if(t.dtype==="complex64"){let n={x:t};return B.runKernel(Bm,n)}else{let n={x:t};return B.runKernel(gd,n)}}var Kt=W({abs_:Y9});function J9(e){let t={x:$(e,"x","acos")};return B.runKernel(lu,t)}var XS=W({acos_:J9});function Q9(e){let t={x:$(e,"x","acosh")};return B.runKernel(uu,t)}var ZS=W({acosh_:Q9});function eK(e){R(Array.isArray(e),()=>"The argument passed to tf.addN() must be a list of tensors"),R(e.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`);let t=e.map((a,s)=>$(a,`tensors${s}`,"addN")),n=t[0];t.forEach(a=>{if(a.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(a=>{if(!pi(a.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});let r=t;return B.runKernel(cu,r)}var c3=W({addN_:eK});function tK(e,t=null,n=!1){let r={x:$(e,"x","all","bool")},a={axis:t,keepDims:n};return B.runKernel(yd,r,a)}var bb=W({all_:tK});function nK(e,t=null,n=!1){let r={x:$(e,"x","any","bool")},a={axis:t,keepDims:n};return B.runKernel(xd,r,a)}var dm=W({any_:nK});function rK(e,t=0){let n={x:$(e,"x","argMax")},r={axis:t};return B.runKernel(bd,n,r)}var jl=W({argMax_:rK});function aK(e,t=0){let n={x:$(e,"x","argMin")},r={axis:t};return B.runKernel(vd,n,r)}var YS=W({argMin_:aK});function sK(e){let t={x:$(e,"x","asin")};return B.runKernel(hu,t)}var JS=W({asin_:sK});function iK(e){let t={x:$(e,"x","asinh")};return B.runKernel(du,t)}var QS=W({asinh_:iK});function oK(e){let t={x:$(e,"x","atan")};return B.runKernel(pu,t)}var eI=W({atan_:oK});function lK(e,t){let n=$(e,"a","atan2"),r=$(t,"b","atan2");[n,r]=Pt(n,r);let a={a:n,b:r};return B.runKernel(mu,a)}var tI=W({atan2_:lK});function uK(e){let t={x:$(e,"x","atanh")};return B.runKernel(fu,t)}var nI=W({atanh_:uK});function cK(e,t,n,r,a="NHWC",s){let i=e[3],o=[...t,i],l=p3(a);return ug(e,o,n,s,r,null,null,l)}function h3(e,t,n,r,a,s,i="channelsLast"){let[o,l]=pm(t),c;if(i==="channelsLast")c=[o,l,e[3],e[3]];else if(i==="channelsFirst")c=[o,l,e[1],e[1]];else throw new Error(`Unknown dataFormat ${i}`);return ug(e,c,n,r,a,s,!1,i)}function hK(e,t,n,r,a,s,i="NDHWC"){let[o,l,c]=_k(t),u,h;if(i==="NDHWC")h="channelsLast",u=[o,l,c,e[4],e[4]];else if(i==="NCDHW")h="channelsFirst",u=[o,l,c,e[1],e[1]];else throw new Error(`Unknown dataFormat ${i}`);return d3(e,u,n,r,a,!1,h,s)}function ug(e,t,n,r,a,s,i=!1,o="channelsLast"){let[l,c,u,h]=[-1,-1,-1,-1];if(o==="channelsLast")[l,c,u,h]=e;else if(o==="channelsFirst")[l,h,c,u]=e;else throw new Error(`Unknown dataFormat ${o}`);let[d,p,,f]=t,[m,y]=pm(n),[g,x]=pm(r),b=Fh(d,g),v=Fh(p,x),{padInfo:w,outHeight:I,outWidth:_}=fK(a,c,u,m,y,b,v,s,o),T=i?f*h:f,A;return o==="channelsFirst"?A=[l,T,I,_]:o==="channelsLast"&&(A=[l,I,_,T]),{batchSize:l,dataFormat:o,inHeight:c,inWidth:u,inChannels:h,outHeight:I,outWidth:_,outChannels:T,padInfo:w,strideHeight:m,strideWidth:y,filterHeight:d,filterWidth:p,effectiveFilterHeight:b,effectiveFilterWidth:v,dilationHeight:g,dilationWidth:x,inShape:e,outShape:A,filterShape:t}}function d3(e,t,n,r,a,s=!1,i="channelsLast",o){let[l,c,u,h,d]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[l,c,u,h,d]=e;else if(i==="channelsFirst")[l,d,c,u,h]=e;else throw new Error(`Unknown dataFormat ${i}`);let[p,f,m,,y]=t,[g,x,b]=_k(n),[v,w,I]=_k(r),_=Fh(p,v),T=Fh(f,w),A=Fh(m,I),{padInfo:M,outDepth:F,outHeight:C,outWidth:D}=mK(a,c,u,h,g,x,b,_,T,A,o),L=s?y*d:y,O;return i==="channelsFirst"?O=[l,L,F,C,D]:i==="channelsLast"&&(O=[l,F,C,D,L]),{batchSize:l,dataFormat:i,inDepth:c,inHeight:u,inWidth:h,inChannels:d,outDepth:F,outHeight:C,outWidth:D,outChannels:L,padInfo:M,strideDepth:g,strideHeight:x,strideWidth:b,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:_,effectiveFilterHeight:T,effectiveFilterWidth:A,dilationDepth:v,dilationHeight:w,dilationWidth:I,inShape:e,outShape:O,filterShape:t}}function dK(e,t,n,r,a){r==null&&(r=rI(e,t,n));let s=e[0],i=e[1],o=fm((s-t+2*r)/n+1,a),l=fm((i-t+2*r)/n+1,a);return[o,l]}function pK(e,t,n,r,a,s){a==null&&(a=rI(e,t[0],r[0]));let i=[0,0,0,n];for(let o=0;o<3;o++)e[o]+2*a>=t[o]&&(i[o]=fm((e[o]-t[o]+2*a)/r[o]+1,s));return i}function rI(e,t,n,r=1){let a=Fh(t,r);return Math.floor((e[0]*(n-1)-n+a)/2)}function pm(e){return typeof e=="number"?[e,e,e]:e.length===2?[e[0],e[1],1]:e}function _k(e){return typeof e=="number"?[e,e,e]:e}function Fh(e,t){return t<=1?e:e+(e-1)*(t-1)}function fK(e,t,n,r,a,s,i,o,l){let c,u,h;if(typeof e=="number"){c={top:e,bottom:e,left:e,right:e,type:e===0?"VALID":"NUMBER"};let d=dK([t,n],s,r,e,o);u=d[0],h=d[1]}else if(e==="same"){u=Math.ceil(t/r),h=Math.ceil(n/a);let d=Math.max(0,(u-1)*r+s-t),p=Math.max(0,(h-1)*a+i-n),f=Math.floor(d/2),m=d-f,y=Math.floor(p/2),g=p-y;c={top:f,bottom:m,left:y,right:g,type:"SAME"}}else if(e==="valid")c={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((t-s+1)/r),h=Math.ceil((n-i+1)/a);else if(typeof e=="object"){let d=l==="channelsLast"?e[1][0]:e[2][0],p=l==="channelsLast"?e[1][1]:e[2][1],f=l==="channelsLast"?e[2][0]:e[3][0],m=l==="channelsLast"?e[2][1]:e[3][1];c={top:d,bottom:p,left:f,right:m,type:d===0&&p===0&&f===0&&m===0?"VALID":"EXPLICIT"},u=fm((t-s+d+p)/r+1,o),h=fm((n-i+f+m)/a+1,o)}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:c,outHeight:u,outWidth:h}}function mK(e,t,n,r,a,s,i,o,l,c,u){let h,d,p,f;if(e==="valid"&&(e=0),typeof e=="number"){h={top:e,bottom:e,left:e,right:e,front:e,back:e,type:e===0?"VALID":"NUMBER"};let m=pK([t,n,r,1],[o,l,c],1,[a,s,i],e,u);d=m[0],p=m[1],f=m[2]}else if(e==="same"){d=Math.ceil(t/a),p=Math.ceil(n/s),f=Math.ceil(r/i);let m=(d-1)*a+o-t,y=(p-1)*s+l-n,g=(f-1)*i+c-r,x=Math.floor(m/2),b=m-x,v=Math.floor(y/2),w=y-v,I=Math.floor(g/2),_=g-I;h={top:v,bottom:w,left:I,right:_,front:x,back:b,type:"SAME"}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}function fm(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function bo(e){let[t,n,r]=pm(e);return t===1&&n===1&&r===1}function $s(e,t){return bo(e)||bo(t)}function Gl(e){return pm(e).every(t=>t>0)}function p3(e){if(e==="NHWC")return"channelsLast";if(e==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function ir(e,t,n){if(n!=null){if(typeof t=="string")throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if(typeof t=="number")R(jh(t),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);else if(typeof t=="object")t.forEach(r=>{r.forEach(a=>{R(jh(a),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${a}.`)})});else throw Error(`Error in ${e}: Unknown padding parameter: ${t}`)}}function gK(e,t){let n={x:$(e,"x","reshape","string_or_numeric")},r={shape:t};return B.runKernel(ep,n,r)}var V=W({reshape_:gK});function yK(e,t,n,r,a){let s=$(e,"x","avgPool","float32"),i=1;R($s(n,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`);let o=s,l=!1;s.rank===3&&(l=!0,o=V(s,[1,s.shape[0],s.shape[1],s.shape[2]])),R(o.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),ir("avgPool",r,a);let c={x:o},u={filterSize:t,strides:n,pad:r,dimRoundingMode:a},h=B.runKernel(gu,c,u);return h=le(h,s.dtype),l?V(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var mi=W({avgPool_:yK});function xK(e,t,n,r,a,s="NDHWC"){let i=$(e,"x","avgPool3d","float32"),o=i,l=!1;i.rank===4&&(l=!0,o=V(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),R(o.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),R(s==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),R(typeof n=="number"&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`),ir("avgPool3d",r,a);let c={x:o},u={filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:s},h=B.runKernel(wd,c,u);return h=le(h,o.dtype),l?V(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}var aI=W({avgPool3d_:xK});function bK(e,t=0){R(e.length>=1,()=>"Pass at least one tensor to concat");let n=hm(e,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(s=>{if(s.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${s.dtype}. `)}),n.length===1)return Is(n[0]);let r=n,a={axis:t};return B.runKernel(Nd,r,a)}var xt=W({concat_:bK});function vK(e,t,n=!1,r=!1){let a=$(e,"a","matMul"),s=$(t,"b","matMul");[a,s]=Pt(a,s);let i={a,b:s},o={transposeA:n,transposeB:r};return B.runKernel(yu,i,o)}var We=W({matMul_:vK});function wK(e){let t={x:$(e,"x","sigmoid","float32")};return B.runKernel(yc,t)}var Ca=W({sigmoid_:wK});function kK(e,t,n){let r=$(e,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");let a={x:r},s={begin:t,size:n};return B.runKernel(op,a,s)}var Ke=W({slice_:kK});function SK(e){let t={x:$(e,"x","tanh","float32")};return B.runKernel(Nc,t)}var vo=W({tanh_:SK});function IK(e,t,n,r,a,s){let i=$(e,"forgetBias","basicLSTMCell"),o=$(t,"lstmKernel","basicLSTMCell"),l=$(n,"lstmBias","basicLSTMCell"),c=$(r,"data","basicLSTMCell"),u=$(a,"c","basicLSTMCell"),h=$(s,"h","basicLSTMCell"),d=xt([c,h],1),p=We(d,o),f=te(p,l),m=f.shape[0],y=f.shape[1]/4,g=[m,y],x=Ke(f,[0,0],g),b=Ke(f,[0,y],g),v=Ke(f,[0,y*2],g),w=Ke(f,[0,y*3],g),I=te(U(Ca(x),vo(b)),U(u,Ca(te(i,v)))),_=U(vo(I),Ca(w));return[I,_]}var f3=W({basicLSTMCell_:IK});function NK(e,t,n){let r=$(e,"x","batchToSpaceND"),a=t.reduce((o,l)=>o*l);R(r.rank>=1+t.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`),R(n.length===t.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`),R(r.shape[0]%a===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${a}`);let s={x:r},i={blockShape:t,crops:n};return B.runKernel(kd,s,i)}var cg=W({batchToSpaceND_:NK});function _K(e){let t;return e.rank===0||e.rank===1?t=V(e,[1,1,1,e.size]):e.rank===2?t=V(e,[1,1,e.shape[0],e.shape[1]]):e.rank===3?t=V(e,[1,e.shape[0],e.shape[1],e.shape[2]]):t=e,t}function CK(e,t,n,r,a,s){s==null&&(s=.001);let i=$(e,"x","batchNorm"),o=$(t,"mean","batchNorm"),l=$(n,"variance","batchNorm"),c;a!=null&&(c=$(a,"scale","batchNorm"));let u;r!=null&&(u=$(r,"offset","batchNorm")),R(o.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),R(u==null||o.rank===u.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),R(c==null||o.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let h={x:_K(i),scale:c,offset:u,mean:o,variance:l},d={varianceEpsilon:s},p=B.runKernel(Du,h,d);return V(p,i.shape)}var _c=W({batchNorm_:CK});function TK(e,t,n,r,a,s){let i=$(e,"x","batchNorm"),o=$(t,"mean","batchNorm"),l=$(n,"variance","batchNorm"),c;a!=null&&(c=$(a,"scale","batchNorm"));let u;return r!=null&&(u=$(r,"offset","batchNorm")),R(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),R(o.rank===2||o.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),R(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),c!=null&&R(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),u!=null&&R(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${u.rank}.`),_c(i,o,l,u,c,s)}var sI=W({batchNorm2d_:TK});function EK(e,t,n,r,a,s){let i=$(e,"x","batchNorm"),o=$(t,"mean","batchNorm"),l=$(n,"variance","batchNorm"),c;a!=null&&(c=$(a,"scale","batchNorm"));let u;return r!=null&&(u=$(r,"offset","batchNorm")),R(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),R(o.rank===3||o.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),R(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),c!=null&&R(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),u!=null&&R(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${u.rank}.`),_c(i,o,l,u,c,s)}var iI=W({batchNorm3d_:EK});function AK(e,t,n,r,a,s){let i=$(e,"x","batchNorm"),o=$(t,"mean","batchNorm"),l=$(n,"variance","batchNorm"),c;a!=null&&(c=$(a,"scale","batchNorm"));let u;return r!=null&&(u=$(r,"offset","batchNorm")),R(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),R(o.rank===4||o.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),R(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),c!=null&&R(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),u!=null&&R(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${u.rank}.`),_c(i,o,l,u,c,s)}var oI=W({batchNorm4d_:AK});function $K(e,t,n){let r=$(e,"x","bincount"),a=$(t,"weights","bincount");R(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),R(n>=0,()=>`size must be non-negative, but got ${n}.`),R(a.size===r.size||a.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${a.shape}.`);let s={x:r,weights:a},i={size:n};return B.runKernel(Sd,s,i)}var lI=W({bincount_:$K});function MK(e,t){let n=$(e,"x","bitwiseAnd"),r=$(t,"y","bitwiseAnd");if(!pi(n.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${r.shape}`);if(n.dtype!=="int32"||r.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${r.dtype}`);let a={a:n,b:r};return B.runKernel(Id,a)}var m3=W({bitwiseAnd_:MK});function FK(e,t){let n=$(e,"s0","broadcastArgs","int32"),r=$(t,"s1","broadcastArgs","int32");if(n.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);let a={s0:n,s1:r};return B.runKernel(Lm,a)}var g3=W({broadcastArgs_:FK});function RK(e,t){let n=$(e,"broadcastTo","x"),r=n.shape;if(qr(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){let l=n.shape.slice();for(;l.length<t.length;)l.unshift(1);n=V(n,l)}let a=n.shape,s=Array.from(t);for(let l=t.length-1;l>=0;l--)if(a[l]===t[l])s[l]=1;else if(n.shape[l]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);if(s.map((l,c)=>l>1?c:-1).filter(l=>l>=0).length===0)return Is(n);let i={x:n},o={reps:s};return B.runKernel(zo,i,o)}var Tl=W({broadcastTo_:RK});function DK(e){let t={x:$(e,"x","ceil","float32")};return B.runKernel(bu,t)}var uI=W({ceil_:DK});function Wr(e,t,n){qr(e),n=n||Om(t);let r={shape:e,value:t,dtype:n};return B.runKernel(Vm,{},r)}function OK(e,t,n){let r=$(e,"x","clipByValue");if(R(t<=n,()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`),t===n)return Wr(r.shape,t,r.dtype);let a={x:r},s={clipValueMin:t,clipValueMax:n};return B.runKernel(Oo,a,s)}var Ln=W({clipByValue_:OK});function zK(e){return xt(e,0)}var cI=W({concat1d_:zK});function PK(e,t){return xt(e,t)}var hI=W({concat2d_:PK});function LK(e,t){return xt(e,t)}var dI=W({concat3d_:LK});function BK(e,t){return xt(e,t)}var pI=W({concat4d_:BK});function WK(e,t,n,r,a="NHWC",s=[1,1],i){let o=$(e,"x","conv2d","float32"),l=$(t,"filter","conv2d","float32"),c=o,u=!1;o.rank===3&&(u=!0,c=V(o,[1,o.shape[0],o.shape[1],o.shape[2]])),R(c.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),R(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),ir("conv2d",r,i);let h=a==="NHWC"?c.shape[3]:c.shape[1];R(h===l.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${l.shape[2]}.`),R($s(n,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),R(Gl(s),()=>"Error in conv2D: Dilated rates should be larger than 0."),R(Gl(n),()=>"Error in conv2D: Strides should be larger than 0.");let d={x:c,filter:l},p={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i},f=B.runKernel(vu,d,p);return u?V(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var nr=W({conv2d_:WK});function UK(e,t,n,r,a="NWC",s=1,i){let o=$(e,"x","conv1d"),l=$(t,"filter","conv1d"),c=o,u=!1;o.rank===2&&(u=!0,c=V(o,[1,o.shape[0],o.shape[1]])),R(c.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),R(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),ir("conv1d",r,i),R(c.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${l.shape[1]}.`),R($s(n,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${s}'`),R(Gl(s),()=>"Error in conv1D: Dilated rates should be larger than 0."),R(Gl(n),()=>"Error in conv1D: Stride should be larger than 0."),R(a==="NWC",()=>`Error in conv1d: got dataFormat of ${a} but only NWC is currently supported.`);let h=V(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=V(c,[c.shape[0],1,c.shape[1],c.shape[2]]),p=nr(d,h,[1,n],r,"NHWC",[1,s],i);return u?V(p,[p.shape[2],p.shape[3]]):V(p,[p.shape[0],p.shape[2],p.shape[3]])}var vb=W({conv1d_:UK});function VK(e,t,n,r,a,s="NHWC",i){R(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let o=e,l=t,c=!1;t.rank===3&&(c=!0,l=V(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),R(o.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),R(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),R(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);let u=s==="NHWC"?o[3]:o[1],h=s==="NHWC"?l.shape[3]:l.shape[1];R(u===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${u}) must match input depth for filter ${n.shape[2]}.`),R(h===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${n.shape[3]}.`),ir("conv2dDerInput",a,i);let d={dy:l,filter:n},p={strides:r,pad:a,dataFormat:s,dimRoundingMode:i,inputShape:o},f=B.runKernel(wu,d,p);return c?V(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var fI=W({conv2DBackpropInput_:VK});function jK(e,t,n,r,a,s){let i=$(e,"x","conv2dTranspose"),o=$(t,"filter","conv2dTranspose");return fI(n,i,o,r,a,"NHWC",s)}var wb=W({conv2dTranspose_:jK});function GK(e,t,n,r,a="NDHWC",s=[1,1,1]){let i=$(e,"x","conv3d"),o=$(t,"filter","conv3d"),l=i,c=!1;i.rank===4&&(c=!0,l=V(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),R(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),R(o.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),R(l.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`),R($s(n,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),R(a==="NDHWC",()=>`Error in conv3d: got dataFormat of ${a} but only NDHWC is currently supported.`),R(Gl(s),()=>"Error in conv3D: Dilated rates should be larger than 0."),R(Gl(n),()=>"Error in conv3D: Strides should be larger than 0.");let u={x:l,filter:o},h={strides:n,pad:r,dataFormat:a,dilations:s},d=B.runKernel(ku,u,h);return c?V(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var mI=W({conv3d_:GK});function HK(e,t,n,r,a){R(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let s=e,i=t,o=!1;t.rank===4&&(o=!0,i=V(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),s=[1,e[0],e[1],e[2],e[3]]);let l=s[4],c=i.shape[4];R(s.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),R(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),R(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),R(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),R(c===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${n.shape[4]}.`);let u={dy:i,filter:n},h={pad:a,strides:r,inputShape:s},d=B.runKernel(Cd,u,h);return o?V(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var y3=W({conv3DBackpropInput_:HK});function qK(e,t,n,r,a){let s=$(e,"x","conv3dTranspose"),i=$(t,"filter","conv3dTranspose");return y3(n,s,i,r,a)}var gI=W({conv3dTranspose_:qK});function KK(e){let t={x:$(e,"x","cos","float32")};return B.runKernel(Su,t)}var hg=W({cos_:KK});function XK(e){let t={x:$(e,"x","cosh","float32")};return B.runKernel(Iu,t)}var kb=W({cosh_:XK});function ZK(e,t=0,n=!1,r=!1){let a={x:$(e,"x","cumprod")},s={axis:t,exclusive:n,reverse:r};return B.runKernel(Td,a,s)}var mm=W({cumprod_:ZK});function YK(e,t=0,n=!1,r=!1){let a={x:$(e,"x","cumsum")},s={axis:t,exclusive:n,reverse:r};return B.runKernel(Nu,a,s)}var Sb=W({cumsum_:YK});function JK(e,t,n,r=!1){let a=$(e,"x","denseBincount"),s=$(t,"weights","denseBincount");R(a.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${a.dtype}`),R(a.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${a.rank}.`),R(n>=0,()=>`size must be non-negative, but got ${n}.`),R(s.size===a.size||s.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${a.shape}, weights shape: ${s.shape}.`);let i={x:a,weights:s},o={size:n,binaryOutput:r};return B.runKernel(Wm,i,o)}var sx=W({denseBincount_:JK});function QK(e,t,n="NHWC"){let r=$(e,"x","depthToSpace","float32"),a=n==="NHWC"?r.shape[1]:r.shape[2],s=n==="NHWC"?r.shape[2]:r.shape[3],i=n==="NHWC"?r.shape[3]:r.shape[1];R(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),R(a*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${a} and ${t}  for depthToSpace with input shape
    ${r.shape}`),R(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${t} for depthToSpace with input shape
        ${r.shape}`),R(i%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${r.shape}`);let o={x:r},l={blockSize:t,dataFormat:n};return B.runKernel(Ad,o,l)}var yI=W({depthToSpace_:QK});function eX(e,t,n,r,a="NHWC",s=[1,1],i){let o=$(e,"x","depthwiseConv2d","float32"),l=$(t,"filter","depthwiseConv2d","float32"),c=o,u=!1;o.rank===3&&(u=!0,c=V(o,[1,o.shape[0],o.shape[1],o.shape[2]])),R(c.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),R(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);let h=a==="NHWC"?c.shape[3]:c.shape[1];R(h===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${l.shape[2]}.`),ir("depthwiseConv2d",r,i);let d={x:c,filter:l},p={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i},f=B.runKernel(_u,d,p);return u?V(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var Cc=W({depthwiseConv2d_:eX});function tX(e){let t={x:$(e,"x","diag")};return B.runKernel(Um,t)}var x3=W({diag_:tX});function nX(e,t,n,r,a=[1,1],s="NHWC"){let i=$(e,"x","dilation2d"),o=$(t,"filter","dilation2d");R(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),R(o.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),R(s==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let l=i,c=!1;i.rank===3&&(l=V(i,[1,i.shape[0],i.shape[1],i.shape[2]]),c=!0),R(l.shape[3]===o.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`);let u={x:l,filter:o},h={strides:n,pad:r,dilations:a},d=B.runKernel(Cu,u,h);return c?V(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var xI=W({dilation2d_:nX}),xp={};Re(xp,{assertAndGetBroadcastShape:()=>bt,getBroadcastDims:()=>b3,getReductionAxes:()=>Qt});function b3(e,t){let n=e.length,r=[];for(let a=0;a<n;a++){let s=n-1-a,i=e[s]||1;(t[t.length-1-a]||1)>1&&i===1&&r.unshift(s)}return r}function Qt(e,t){let n=[];for(let r=0;r<t.length;r++){let a=e[e.length-r-1],s=t.length-r-1,i=t[s];(a==null||a===1&&i>1)&&n.unshift(s)}return n}function bt(e,t){let n=Math.max(e.length,t.length),r=new Array(n);for(let a=0;a<n;a++){let s=e[e.length-a-1];s==null&&(s=1);let i=t[t.length-a-1];if(i==null&&(i=1),s===1)r[n-a-1]=i;else if(i===1)r[n-a-1]=s;else if(s!==i){let o=`Operands could not be broadcast together with shapes ${e} and ${t}.`;throw Error(o)}else r[n-a-1]=s}return r}function rX(e,t){let n=$(e,"a","equal","string_or_numeric"),r=$(t,"b","equal","string_or_numeric");[n,r]=Pt(n,r),bt(n.shape,r.shape);let a={a:n,b:r};return B.runKernel(Md,a)}var Vr=W({equal_:rX});function aX(e,t,n){let r=$(t,"a","where"),a=$(n,"b","where"),s=$(e,"condition","where","bool"),i=bt(bt(s.shape,r.shape),a.shape),o=Tl(s,i),l=Tl(r,i),c=Tl(a,i),u={condition:o,t:l,e:c};return B.runKernel(ip,u)}var vn=W({where_:aX});function sX(e){let t={x:$(e,"x","zerosLike")};return B.runKernel(gp,t)}var Ye=W({zerosLike_:sX});function iX(e,t){let n=$(e,"a","div"),r=$(t,"b","div");[n,r]=Pt(n,r);let a=xe(n,r),s=Ye(a),i=Vr(r,s);return vn(i,s,a)}var bI=W({divNoNan_:iX});function oX(e,t){let n=$(e,"t1","dot"),r=$(t,"t2","dot");R((n.rank===1||n.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`);let a=n.rank===1?n.size:n.shape[1],s=r.rank===1?r.size:r.shape[0];if(R(a===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${a} and ${s}.`),n.rank===1&&r.rank===1){let i=V(n,[1,-1]),o=V(r,[-1,1]),l=We(i,o);return V(l,[])}else if(n.rank===1&&r.rank===2){let i=V(n,[1,-1]),o=V(r,[r.shape[0],r.shape[1]]),l=We(i,o);return V(l,[l.size])}else if(n.rank===2&&r.rank===1){let i=V(r,[-1,1]),o=We(n,i);return V(o,[o.size])}else{let i=V(r,[r.shape[0],r.shape[1]]);return We(n,i)}}var vI=W({dot_:oX});function lX(e,...t){let n=t.map((a,s)=>$(a,`tensors${s}`,"einsum")),r={equation:e};return B.runKernel(ob,n,r)}var pl=W({einsum_:lX});function uX(e){let t={x:$(e,"x","elu","float32")};return B.runKernel(Eu,t)}var bp=W({elu_:uX});function cX(e,t){let n=$(e,"x","ensureShape","string_or_numeric");if(!SD(n.shape,t))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${t}`);return e}var v3=W({ensureShape_:cX});function hX(e){let t=$(e,"x","erf");R(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=le(t,"float32"));let n={x:t};return B.runKernel(Au,n)}var Ib=W({erf_:hX});function wI(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function w3(e,t,n){let r=e.length+t.length,a=[],s=0,i=0;for(let o=0;o<r;o++)n.indexOf(o)===-1?a.push(e[s++]):a.push(t[i++]);return a}function k3(e,t){let n=[],r=e.length;for(let s=0;s<r;s++)t.indexOf(s)===-1&&n.push(e[s]);let a=t.map(s=>e[s]);return[n,a]}function Hl(e,t){let n=t.map(r=>1);return w3(e,n,t)}function dX(e,t,n){R(wI(t,n),()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`)}function S3(e,t){if(wI(e,t))return null;let n=[];for(let r=0;r<t;++r)e.indexOf(r)===-1&&n.push(r);return e.forEach(r=>n.push(r)),n}function kI(e){return e.map((t,n)=>[n,t]).sort((t,n)=>t[1]-n[1]).map(t=>t[0])}function pX(e,t){let n=[];for(let r=t-e;r<t;++r)n.push(r);return n}function fX(e,t=null,n=!1){let r={x:$(e,"x","max")},a={reductionIndices:t,keepDims:n};return B.runKernel(Gu,r,a)}var la=W({max_:fX});function mX(e,t=null,n=!1){let r={x:$(e,"x","min")},a={axis:t,keepDims:n};return B.runKernel(Xu,r,a)}var Kh=W({min_:mX});function gX(e,t){let n=$(e,"base","pow"),r=$(t,"exp","pow");[n,r]=Pt(n,r);let a={a:n,b:r};return B.runKernel(nc,a)}var Ts=W({pow_:gX});function _e(e,t){if((gn(e)&&t!=="string"||Array.isArray(e))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&gn(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Lo(e,[],[],t)}function yX(e){let t={x:$(e,"x","sqrt","float32")};return B.runKernel(bc,t)}var wn=W({sqrt_:yX});function xX(e){let t=$(e,"x","square"),n={};return B.runKernel("Square",{x:t},n)}var gt=W({square_:xX});function bX(e,t=null,n=!1){let r=$(e,"x","sum");r.dtype==="bool"&&(r=le(r,"int32"));let a={x:r},s={axis:t,keepDims:n};return B.runKernel(vc,a,s)}var ke=W({sum_:bX});function vX(e,t="euclidean",n=null,r=!1){e=$(e,"x","norm");let a=I3(e,t,n),s=a.shape;if(r){let i=$a(n,e.shape);s=Hl(a.shape,i)}return V(a,s)}function I3(e,t,n=null){if(e.rank===0)return Kt(e);if(e.rank!==1&&n===null)return I3(V(e,[-1]),t,n);if(e.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(t===1)return ke(Kt(e),n);if(t===1/0)return la(Kt(e),n);if(t===-1/0)return Kh(Kt(e),n);if(t==="euclidean"||t===2)return wn(ke(Ts(Kt(e),_e(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&n.length===2){if(t===1)return la(ke(Kt(e),n[0]),n[1]-1);if(t===1/0)return la(ke(Kt(e),n[1]),n[0]);if(t===-1/0)return Kh(ke(Kt(e),n[1]),n[0]);if(t==="fro"||t==="euclidean")return wn(ke(gt(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}var vp=W({norm_:vX});function wX(e,t=null,n=!1){return vp(e,"euclidean",t,n)}var SI=W({euclideanNorm_:wX});function kX(e){let t={x:$(e,"x","exp")};return B.runKernel($u,t)}var Bn=W({exp_:kX});function SX(e,t=0){let n=$(e,"x","expandDims","string_or_numeric");R(t<=n.rank,()=>"Axis must be <= rank of the tensor");let r={input:n},a={dim:t};return B.runKernel(Fd,r,a)}var yn=W({expandDims_:SX});function IX(e){let t={x:$(e,"x","expm1")};return B.runKernel(Mu,t)}var II=W({expm1_:IX});function NX(e,t){let n=$(e,"x","tile","string_or_numeric");R(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`);let r={x:n},a={reps:t};return B.runKernel(zo,r,a)}var Or=W({tile_:NX});function _X(e,t,n,r="float32"){t==null&&(t=e);let a=Ve([e,t],r),s=e<=t?e:t;for(let o=0;o<s;++o)a.set(1,o,o);let i=V(a.toTensor(),[e,t]);if(n==null)return i;if(n.length===1)return Or(yn(i,0),[n[0],1,1]);if(n.length===2)return Or(yn(yn(i,0),0),[n[0],n[1],1,1]);if(n.length===3)return Or(yn(yn(yn(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}var Nb=W({eye_:_X});function CX(e){let t={x:$(e,"x","floor","float32")};return B.runKernel(Fu,t)}var wp=W({floor_:CX});function TX(e,t,n=0,r=0){let a=$(e,"x","gather"),s=$(t,"indices","gather","int32"),i={x:a,indices:s},o={axis:n,batchDims:r};return B.runKernel(Dd,i,o)}var kp=W({gather_:TX});function EX(e,t){let n=$(e,"a","greater","string_or_numeric"),r=$(t,"b","greater","string_or_numeric");[n,r]=Pt(n,r),bt(n.shape,r.shape);let a={a:n,b:r};return B.runKernel(zd,a)}var or=W({greater_:EX});function AX(e,t){let n=$(e,"a","greaterEqual","string_or_numeric"),r=$(t,"b","greaterEqual","string_or_numeric");[n,r]=Pt(n,r),bt(n.shape,r.shape);let a={a:n,b:r};return B.runKernel(Ou,a)}var gi=W({greaterEqual_:AX});function $X(e){let t={input:$(e,"input","imag")};return B.runKernel(cb,t)}var dg=W({imag_:$X});function MX(e){let t={x:$(e,"x","isFinite")};return B.runKernel(Pu,t)}var NI=W({isFinite_:MX});function FX(e){let t={x:$(e,"x","isInf")};return B.runKernel(Lu,t)}var _I=W({isInf_:FX});function RX(e){let t={x:$(e,"x","isNaN")};return B.runKernel(Bu,t)}var CI=W({isNaN_:RX});function DX(e,t=.2){let n={x:$(e,"x","leakyRelu")},r={alpha:t};return B.runKernel(Wu,n,r)}var pg=W({leakyRelu_:DX});function OX(e,t){let n=$(e,"a","less","string_or_numeric"),r=$(t,"b","less","string_or_numeric");[n,r]=Pt(n,r),bt(n.shape,r.shape);let a={a:n,b:r};return B.runKernel(Pd,a)}var Xh=W({less_:OX});function zX(e,t){let n=$(e,"a","lessEqual","string_or_numeric"),r=$(t,"b","lessEqual","string_or_numeric");[n,r]=Pt(n,r),bt(n.shape,r.shape);let a={a:n,b:r};return B.runKernel(Ld,a)}var Bo=W({lessEqual_:zX});function N3(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");let r={start:e,stop:t,num:n};return B.runKernel(Bd,{},r)}function PX(e,t=5,n=1,r=1,a=.5){let s=$(e,"x","localResponseNormalization");R(s.rank===4||s.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`),R(jh(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let i=s,o=!1;s.rank===3&&(o=!0,i=V(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let l={x:i},c={depthRadius:t,bias:n,alpha:r,beta:a},u=B.runKernel(ju,l,c);return o?V(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var TI=W({localResponseNormalization_:PX});function LX(e){let t={x:$(e,"x","log","float32")};return B.runKernel(Uu,t)}var jr=W({log_:LX});function BX(e){let t={x:$(e,"x","log1p")};return B.runKernel(Vu,t)}var fg=W({log1p_:BX});function WX(e){return R(mo(e),()=>"The f passed in grad(f) must be a function"),(t,n)=>{let r=$(t,"x","tf.grad","string_or_numeric"),a=n!=null?$(n,"dy","tf.grad"):null;return B.tidy(()=>{let{value:s,grads:i}=B.gradients(()=>e(r),[r],a);return a!=null&&sr(s.shape,a.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),_b(i),i[0]})}}function UX(e){return R(mo(e),()=>"The f passed in grads(f) must be a function"),(t,n)=>{R(Array.isArray(t),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");let r=hm(t,"args","tf.grads","string_or_numeric"),a=n!=null?$(n,"dy","tf.grads"):null;return B.tidy(()=>{let{value:s,grads:i}=B.gradients(()=>e(...r),r,a);return a!=null&&sr(s.shape,a.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),_b(i),i})}}function VX(e){return R(mo(e),()=>"The f passed in valueAndGrad(f) must be a function"),(t,n)=>{R(t instanceof ze,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),R(n==null||n instanceof ze,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");let{grads:r,value:a}=B.gradients(()=>e(t),[t],n);return _b(r),{grad:r[0],value:a}}}function jX(e){return R(mo(e),()=>"The f passed in valueAndGrads(f) must be a function"),(t,n)=>{R(Array.isArray(t)&&t.every(a=>a instanceof ze),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),R(n==null||n instanceof ze,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");let r=B.gradients(()=>e(...t),t,n);return n!=null&&sr(r.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),_b(r.grads),r}}function _3(e,t){R(mo(e),()=>"The f passed in variableGrads(f) must be a function"),R(t==null||Array.isArray(t)&&t.every(c=>c instanceof Bl),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let n=t!=null;if(!n){t=[];for(let c in B.registeredVariables)t.push(B.registeredVariables[c])}let r=n?t.filter(c=>!c.trainable):null,a=t.length;t=t.filter(c=>c.trainable),R(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${a} variables is trainable.`);let s=!0,{value:i,grads:o}=B.gradients(e,t,null,s);R(o.some(c=>c!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),R(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);let l={};return t.forEach((c,u)=>{o[u]!=null&&(l[c.name]=o[u])}),r!=null&&r.forEach(c=>l[c.name]=null),{value:i,grads:l}}function Es(e){return B.customGrad(e)}function _b(e){if(e.filter(t=>t==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function GX(e){let t={x:$(e,"x","neg")};return B.runKernel(qd,t)}var Nt=W({neg_:GX});function HX(e){let t={x:$(e,"x","softplus")};return B.runKernel(xc,t)}var Tc=W({softplus_:HX});function qX(e){let t=$(e,"x","logSigmoid");return Es(n=>({value:Nt(Tc(Nt(n))),gradFunc:r=>U(r,Ca(Nt(n)))}))(t)}var EI=W({logSigmoid_:qX});function KX(e,t){let n=$(e,"a","sub"),r=$(t,"b","sub");[n,r]=Pt(n,r);let a={a:n,b:r};return B.runKernel(Sc,a)}var me=W({sub_:KX});function XX(e,t=-1){let n=$(e,"logits","logSoftmax");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return Es((r,a)=>{let s=la(r,t,!0),i=me(r,s),o=me(le(i,"float32"),jr(ke(Bn(i),t,!0)));return a([o]),{value:o,gradFunc:(l,c)=>{let[u]=c,h=!0,d=Bn(u);return me(l,U(ke(l,t,h),d))}}})(n)}var Cb=W({logSoftmax_:XX});function ZX(e,t=null,n=!1){let r=$(e,"x","logSumExp"),a=$a(t,r.shape),s=la(r,a,!0),i=me(r,s),o=Bn(i),l=ke(o,a),c=jr(l),u=te(V(s,c.shape),c);if(n){let h=Hl(u.shape,a);return V(u,h)}return u}var mg=W({logSumExp_:ZX});function YX(e,t){let n=$(e,"a","logicalAnd","bool"),r=$(t,"b","logicalAnd","bool");bt(n.shape,r.shape);let a={a:n,b:r};return B.runKernel(Wd,a)}var Aa=W({logicalAnd_:YX});function JX(e){let t={x:$(e,"x","logicalNot","bool")};return B.runKernel(Ud,t)}var gg=W({logicalNot_:JX});function QX(e,t){let n=$(e,"a","logicalOr","bool"),r=$(t,"b","logicalOr","bool");bt(n.shape,r.shape);let a={a:n,b:r};return B.runKernel(Vd,a)}var Tb=W({logicalOr_:QX});function eZ(e,t){let n=$(e,"a","logicalXor","bool"),r=$(t,"b","logicalXor","bool");return bt(n.shape,r.shape),Aa(Tb(e,t),gg(Aa(e,t)))}var AI=W({logicalXor_:eZ}),Py=2147483648;function tZ(e,t,n="left"){let r=$(e,"sortedSequence","searchSorted"),a=$(t,"values","searchSorted"),s=r.shape[r.shape.length-1],i=a.shape[a.shape.length-1],o=V(r,[-1,s]),l=V(a,[-1,i]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(dt(l.shape)>=Py)throw new Error(`values tensor size must less than ${Py}`);if(o.shape[1]>=Py)throw new Error(`trailing dim_size must less than ${Py} for int32 output type, was ${o.shape[1]}`);let c={sortedSequence:o,values:l},u={side:n};return B.runKernel(sp,c,u)}var Eb=W({searchSorted_:tZ});function C3(e,t){return Eb(e,t,"left")}function nZ(e,t,n,r,a){let s=$(e,"x","maxPool"),i=1,o=s,l=!1;s.rank===3&&(l=!0,o=V(s,[1,s.shape[0],s.shape[1],s.shape[2]])),R(o.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),R($s(n,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),ir("maxPool",r,a);let c={x:o},u={filterSize:t,strides:n,pad:r,dimRoundingMode:a},h=B.runKernel(qu,c,u);return l?V(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var pn=W({maxPool_:nZ});function rZ(e,t=[1,1,1],n,r,a,s="NDHWC"){let i=$(e,"x","maxPool3d"),o=i,l=!1;i.rank===4&&(l=!0,o=V(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),R(o.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),R(s==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),ir("maxPool3d",r,a);let c={x:o},u={filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:s},h=B.runKernel(Gd,c,u);return l?V(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}var $I=W({maxPool3d_:rZ});function aZ(e,t,n,r,a=!1){let s={x:$(e,"x","maxPoolWithArgmax")},i={filterSize:t,strides:n,pad:r,includeBatchInIndex:a},o=B.runKernel(Hm,s,i);return{result:o[0],indexes:o[1]}}var T3=W({maxPoolWithArgmax_:aZ});function sZ(e,t){let n=$(e,"a","maximum"),r=$(t,"b","maximum");[n,r]=Pt(n,r),n.dtype==="bool"&&(n=le(n,"int32"),r=le(r,"int32")),bt(n.shape,r.shape);let a={a:n,b:r};return B.runKernel(Hu,a)}var Ms=W({maximum_:sZ});function iZ(e,t=null,n=!1){let r={x:$(e,"x","mean")},a={axis:t,keepDims:n};return B.runKernel(Ku,r,a)}var Dt=W({mean_:iZ});function Ot(e,t="float32"){if(qr(e),t==="complex64"){let r=Ot(e,"float32"),a=Ot(e,"float32");return ui(r,a)}let n=eb(dt(e),t);return B.makeTensor(n,e,t)}function gr(e,t="float32"){if(qr(e),t==="complex64"){let r=gr(e,"float32"),a=Ot(e,"float32");return ui(r,a)}let n=PS(dt(e),t);return B.makeTensor(n,e,t)}function E3(e,t,{indexing:n="xy"}={}){if(n!=="xy"&&n!=="ij")throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(e===void 0)return[];let r=$(e,"x","meshgrid",e instanceof ze?e.dtype:"float32");if(t===void 0)return[r];let a=$(t,"y","meshgrid",t instanceof ze?t.dtype:"float32"),s=dt(r.shape),i=dt(a.shape);return n==="xy"?(r=V(r,[1,-1]),a=V(a,[-1,1]),[We(gr([i,1],r.dtype),r),We(a,gr([1,s],a.dtype))]):(r=V(r,[-1,1]),a=V(a,[1,-1]),[We(r,gr([1,i],r.dtype)),We(gr([s,1],a.dtype),a)])}function oZ(e,t){let n=$(e,"a","minimum"),r=$(t,"b","minimum");[n,r]=Pt(n,r),n.dtype==="bool"&&(n=le(n,"int32"),r=le(r,"int32")),bt(n.shape,r.shape);let a={a:n,b:r};return B.runKernel(Zu,a)}var wo=W({minimum_:oZ});function lZ(e,t,n){R(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);let r=$(e,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");R(t.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`);let a=n==="reflect"?1:0;for(let o=0;o<r.rank;o++)R(t[o].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),R(t[o][0]>=0&&t[o][0]<=r.shape[o]-a&&t[o][1]>=0&&t[o][1]<=r.shape[o]-a,()=>`Padding in dimension ${o} cannot be greater than or equal to ${r.shape[o]-a} or less than 0 for input of shape ${r.shape}`);let s={paddings:t,mode:n},i={x:r};return B.runKernel(Yu,i,s)}var MI=W({mirrorPad_:lZ});function uZ(e,t){let n=$(e,"a","mod"),r=$(t,"b","mod");[n,r]=Pt(n,r);let a={a:n,b:r};return B.runKernel(Ju,a)}var FI=W({mod_:uZ});function cZ(e,t=null,n=!1){e=$(e,"x","moments");let r=$a(t,e.shape),a=Dt(e,r,n),s=a.shape;n||(s=Hl(a.shape,r));let i=gt(me(le(e,"float32"),V(a,s))),o=Dt(i,r,n);return{mean:a,variance:o}}var yg=W({moments_:cZ});function hZ(e,t,n,r){let a=$(t,"data","multiRNNCell"),s=hm(n,"c","multiRNNCell"),i=hm(r,"h","multiRNNCell"),o=a,l=[];for(let h=0;h<e.length;h++){let d=e[h](o,s[h],i[h]);l.push(d[0]),l.push(d[1]),o=d[1]}let c=[],u=[];for(let h=0;h<l.length;h+=2)c.push(l[h]),u.push(l[h+1]);return[c,u]}var A3=W({multiRNNCell_:hZ});function dZ(e,t,n,r=!1){let a=$(e,"logits","multinomial"),s=a.size,i=a.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();let o={logits:i===1?V(a,[1,-1]):a},l={numSamples:t,seed:n,normalized:r},c=B.runKernel(Hd,o,l);return i===1?V(c,[c.size]):c}var $3=W({multinomial_:dZ});function pZ(e,t){let n=$(e,"a","notEqual","string_or_numeric"),r=$(t,"b","notEqual","string_or_numeric");[n,r]=Pt(n,r),bt(n.shape,r.shape);let a={a:n,b:r};return B.runKernel(Kd,a)}var ql=W({notEqual_:pZ});function fZ(e,t,n=1,r=0,a="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let s={indices:$(e,"indices","oneHot","int32")},i={dtype:a,depth:t,onValue:n,offValue:r};return B.runKernel(ec,s,i)}var Zh=W({oneHot_:fZ});function mZ(e){let t={x:$(e,"x","onesLike")};return B.runKernel(Jd,t)}var Gr=W({onesLike_:mZ});function gZ(e,t){let n=$(e,"v1","outerProduct"),r=$(t,"v2","outerProduct");R(n.rank===1&&r.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`);let a=V(n,[-1,1]),s=V(r,[1,-1]);return We(a,s)}var M3=W({outerProduct_:gZ});function yZ(e,t,n=0){let r=$(e,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let a={paddings:t,constantValue:n},s={x:r};return B.runKernel(tc,s,a)}var ss=W({pad_:yZ});function xZ(e,t,n=0){return R(t.length===2,()=>"Invalid number of paddings. Must be length of 2."),ss(e,[t],n)}var F3=W({pad1d_:xZ});function bZ(e,t,n=0){return R(t.length===2&&t[0].length===2&&t[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ss(e,t,n)}var R3=W({pad2d_:bZ});function vZ(e,t,n=0){return R(t.length===3&&t[0].length===2&&t[1].length===2&&t[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ss(e,t,n)}var D3=W({pad3d_:vZ});function wZ(e,t,n=0){return R(t.length===4&&t[0].length===2&&t[1].length===2&&t[2].length===2&&t[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ss(e,t,n)}var O3=W({pad4d_:wZ});function kZ(e,t,n){let r=$(e,"x","spaceToBatchND");R(r.rank>=1+t.length,()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`),R(n.length===t.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`),R(r.shape.reduce((i,o,l)=>l>0&&l<=t.length?i&&(o+n[l-1][0]+n[l-1][1])%t[l-1]===0:i,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`);let a={x:r},s={blockShape:t,paddings:n};return B.runKernel(lp,a,s)}var xg=W({spaceToBatchND_:kZ});function SZ(e,t,n,r,a,s,i){a==null&&(a=[1,1]),s==null&&(s=1),r===0&&(r="valid");let o=$(e,"x","maxPool"),l=o,c=!1;o.rank===3&&(c=!0,l=V(o,[1,o.shape[0],o.shape[1],o.shape[2]])),R($s(s,a),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${a}'`);let u=h3(l.shape,t,s,a,r),h=[u.dilationHeight,u.dilationWidth],d;r==="same"?d=NZ([u.filterHeight,u.filterWidth],h):d=[[0,0],[0,0]];let p=h[0]===1&&h[1]===1,[f,m]=IZ([u.inHeight,u.inWidth],h,d),y=p?r:"valid",g=p?l:xg(l,h,f),x=(n==="avg"?()=>mi(g,t,s,y,i):()=>pn(g,t,s,y,i))(),b=p?x:cg(x,h,m);return c?V(b,[b.shape[1],b.shape[2],b.shape[3]]):b}function IZ(e,t,n){let r=n.map(u=>u[0]),a=n.map(u=>u[1]),s=e.concat(r,a),i=t.map((u,h)=>(u-s[h]%u)%u),o=a.map((u,h)=>u+i[h]),l=t.map((u,h)=>[r[h],o[h]]),c=t.map((u,h)=>[0,i[h]]);return[l,c]}function NZ(e,t){let n=e.map((s,i)=>s+(s-1)*(t[i]-1)).map(s=>s-1),r=n.map(s=>Math.floor(s/2)),a=n.map((s,i)=>s-r[i]);return n.map((s,i)=>[r[i],a[i]])}var RI=W({pool_:SZ});function _Z(e,t){let n=$(e,"x","prelu"),r=$(t,"alpha","prelu"),a={x:n,alpha:r};return B.runKernel(rc,a)}var bg=W({prelu_:_Z});function CZ(e,t=null,n=!1){let r=$(e,"x","prod");r.dtype==="bool"&&(r=le(r,"int32"));let a={x:r},s={axis:t,keepDims:n};return B.runKernel(ac,a,s)}var DI=W({prod_:CZ});function TZ(e,t,n,r){let a=e.map((u,h)=>$(u,`tensors${h}`,"raggedGather","int32")),s=$(t,"paramsDenseValues","raggedGather"),i=$(n,"indices","raggedGather","int32"),o={paramsNestedSplits:a,paramsDenseValues:s,indices:i},l={outputRaggedRank:r},c=B.runKernel(hb,o,l);return{outputNestedSplits:c.slice(0,c.length-1),outputDenseValues:c[c.length-1]}}var z3=W({raggedGather_:TZ});function EZ(e,t,n){let r=$(e,"starts","raggedRange"),a=$(t,"limits","raggedRange",r.dtype),s=$(n,"deltas","raggedRange",r.dtype),i={starts:r,limits:a,deltas:s},o=B.runKernel(db,i);return{rtNestedSplits:o[0],rtDenseValues:o[1]}}var P3=W({raggedRange_:EZ});function AZ(e,t,n,r,a){let s=$(e,"shape","raggedTensorToTensor","int32"),i=$(t,"values","raggedTensorToTensor"),o=$(n,"defaultValue","raggedTensorToTensor",i.dtype),l=r.map((h,d)=>$(h,`tensors${d}`,"raggedTensorToTensor","int32")),c={shape:s,values:i,defaultValue:o,rowPartitionTensors:l},u={rowPartitionTypes:a};return B.runKernel(pb,c,u)}var L3=W({raggedTensorToTensor_:AZ});function $Z(e,t,n){qr(e);let r=dt(e),a=null;if(n==null||n==="float32")a=new Float32Array(r);else if(n==="int32")a=new Int32Array(r);else if(n==="bool")a=new Uint8Array(r);else throw new Error(`Unknown data type ${n}`);for(let s=0;s<r;s++)a[s]=t();return B.makeTensor(a,e,n)}var B3=W({rand_:$Z}),OI=Ro(Jx()),W3={};Re(W3,{TEST_EPSILON_FLOAT16:()=>U3,createVideoElement:()=>LZ,encodeStrings:()=>V3,expectArrayBuffersEqual:()=>PZ,expectArraysClose:()=>FZ,expectArraysEqual:()=>DZ,expectNumbersClose:()=>OZ,expectPromiseToFail:()=>RZ,expectValuesInRange:()=>zZ,play:()=>BZ,testEpsilon:()=>zI});var MZ=.001,U3=.1;function FZ(e,t,n){return n==null&&(n=zI()),Ck(e,t,(r,a)=>PI(r,a,n))}function zI(){return B.backend.floatPrecision()===32?MZ:U3}function Ck(e,t,n){let r=!0;if((gn(e)||gn(t))&&(r=!1),gn(e)&&gn(t)&&(r=!0),r){let i=e.constructor.name,o=t.constructor.name;if(i!==o)throw new Error(`Arrays are of different type. Actual: ${i}. Expected: ${o}`)}if(Array.isArray(e)&&Array.isArray(t)){let i=Cs(e),o=Cs(t);if(!pi(i,o))throw new Error(`Arrays have different shapes. Actual: [${i}]. Expected: [${o}]`)}let a=gn(e)?e:go(e),s=gn(t)?t:go(t);if(a.length!==s.length)throw new Error(`Arrays have different lengths actual: ${a.length} vs expected: ${s.length}.
Actual:   ${a}.
Expected: ${s}.`);for(let i=0;i<s.length;++i){let o=a[i],l=s[i];if(!n(o,l))throw new Error(`Arrays differ: actual[${i}] = ${o}, expected[${i}] = ${l}.
Actual:   ${a}.
Expected: ${s}.`)}typeof expect<"u"&&expect().nothing()}function RZ(e,t){e().then(()=>t.fail(),()=>t()),typeof expect<"u"&&expect().nothing()}function DZ(e,t){let n=typeof t=="string"||typeof t=="number"||typeof t=="boolean"?[t]:t;return Ki(e)||Ki(e[0])||Ki(t)||Ki(t[0])?Ck(e,n,(r,a)=>r==a):Ck(e,t,(r,a)=>PI(r,a,0))}function OZ(e,t,n){if(n==null&&(n=zI()),!PI(e,t,n))throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`);typeof expect<"u"&&expect().nothing()}function PI(e,t,n){return!isFinite(e)&&!isFinite(t)?!0:!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function zZ(e,t,n){for(let r=0;r<e.length;r++)if(e[r]<t||e[r]>n)throw new Error(`Value out of range:${e[r]} low: ${t}, high: ${n}`)}function PZ(e,t){let n=new Float32Array(e),r=new Float32Array(t);if(n.length!==r.length)throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${n.length}`);for(let a=0;a<r.length;a++)if(n[a]!==r[a])throw new Error(`Expected ArrayBuffer value at ${a} to be ${r[a]} but got ${n[a]} instead`)}function V3(e){for(let t=0;t<e.length;t++){let n=e[t];Array.isArray(n)?V3(n):e[t]=ig(n)}return e}function LZ(e){let t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(e),new Promise(n=>{t.addEventListener("loadeddata",r=>n(t)),t.load()})}async function BZ(e){await e.play(),"requestVideoFrameCallback"in e&&await new Promise(t=>{e.requestVideoFrameCallback(t)})}var LI=class{constructor(e,t,n,r,a){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let s=a||Math.random();this.random=OI.alea(s.toString())}nextValue(){if(!isNaN(this.nextVal)){let r=this.nextVal;return this.nextVal=NaN,r}let e,t,n=!1;for(;!n;){let r,a,s;do r=2*this.random()-1,a=2*this.random()-1,s=r*r+a*a;while(s>=1||s===0);let i=Math.sqrt(-2*Math.log(s)/s);e=this.mean+this.stdDev*r*i,t=this.mean+this.stdDev*a*i,(!this.truncated||this.isValidTruncated(e))&&(n=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}},WZ=class{constructor(e,t,n,r){this.alpha=e,this.beta=1/t,this.dtype=n;let a=r||Math.random();this.randu=OI.alea(a.toString()),this.randn=new LI(0,1,n,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,r,a,s;for(;;){do r=this.randn.nextValue(),s=1+this.c*r;while(s<=0);if(s*=s*s,e=r*r,t=1-.331*e*e,n=.5*e+this.d*(1-s+Math.log(s)),a=this.randu(),a<t||Math.log(a)<n)break}return s=1/this.beta*this.d*s,this.alpha<1&&(s*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(s)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}},UZ=class{constructor(e=0,t=1,n,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=n,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=OI.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function VZ(e,t,n=1,r="float32",a){if(qr(e),n==null&&(n=1),r==null&&(r="float32"),r!=="float32"&&r!=="int32")throw new Error(`Unsupported data type ${r}`);let s=new WZ(t,n,r,a),i=Ve(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}var j3=W({randomGamma_:VZ});function jZ(e,t=0,n=1,r,a){if(qr(e),r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);let s=new LI(t,n,r,!1,a),i=Ve(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}var Ab=W({randomNormal_:jZ});function GZ(e,t,n){if(t!=null&&t==="bool")throw new Error(`Unsupported data type ${t}`);return Ab(e,0,1,t,n)}var G3=W({randomStandardNormal_:GZ});function HZ(e,t=0,n=1,r="float32",a){qr(e);let s=Ve(e,r),i=new UZ(t,n,null,a);for(let o=0;o<s.values.length;o++)s.values[o]=i.nextValue();return s.toTensor()}var Wo=W({randomUniform_:HZ});function qZ(e,t,n,r){return Wo(e,t,n,"int32",r)}var H3=W({randomUniformInt_:qZ});function Kl(e,t,n=1,r="float32"){if(n===0)throw new Error("Cannot have a step of zero");let a={start:e,stop:t,step:n,dtype:r};return B.runKernel(qm,{},a)}function KZ(e){let t={input:$(e,"input","real")};return B.runKernel(fb,t)}var Yh=W({real_:KZ});function XZ(e){let t={x:$(e,"x","reciprocal")};return B.runKernel(sc,t)}var BI=W({reciprocal_:XZ});function ZZ(e){let t={x:$(e,"x","relu")};return B.runKernel(ic,t)}var ht=W({relu_:ZZ});function YZ(e){let t={x:$(e,"x","relu6")};return B.runKernel(uc,t)}var $b=W({relu6_:YZ});function JZ(e,t){let n={x:$(e,"x","reverse")},r={dims:t};return B.runKernel(cc,n,r)}var da=W({reverse_:JZ});function QZ(e){let t=$(e,"x","reverse");return R(t.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),da(t,0)}var q3=W({reverse1d_:QZ});function eY(e,t){let n=$(e,"x","reverse");return R(n.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),da(n,t)}var K3=W({reverse2d_:eY});function tY(e,t){let n=$(e,"x","reverse");return R(n.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),da(n,t)}var X3=W({reverse3d_:tY});function nY(e,t){let n=$(e,"x","reverse");return R(n.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),da(n,t)}var Z3=W({reverse4d_:nY});function rY(e){let t={x:$(e,"x","round")};return B.runKernel(hc,t)}var Mb=W({round_:rY});function aY(e){let t={x:$(e,"x","rsqrt","float32")};return B.runKernel(dc,t)}var Fb=W({rsqrt_:aY});function sY(e){let t={x:$(e,"x","selu")};return B.runKernel(pc,t)}var Rb=W({selu_:sY});function iY(e,t,n,r,a,s=[1,1],i="NHWC"){let o=$(e,"x","separableConv2d"),l=$(t,"depthwiseFilter","separableConv2d"),c=$(n,"pointwiseFilter","separableConv2d"),u=o,h=!1;if(o.rank===3&&(h=!0,u=V(o,[1,o.shape[0],o.shape[1],o.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");R(u.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${u.rank}.`),R(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),R(c.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),R(c.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),R(c.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);let d=l.shape[2],p=l.shape[3];R(c.shape[2]===d*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*p}, but got ${c.shape[2]}.`);let f=Cc(u,l,r,a,i,s),m=nr(f,c,1,"valid",i);return h?V(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var Sp=W({separableConv2d_:iY});async function oY(e,t){let n=$(e,"x","setdiff1d"),r=$(t,"y","setdiff1d");R(n.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`),R(n.rank===1,()=>`x should be 1D tensor, but got x (${n.shape}).`),R(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);let a=await n.data(),s=await r.data(),i=new Set(s),o=0;for(let u=0;u<a.length;u++)i.has(a[u])||o++;let l=new Yt([o],n.dtype),c=new Yt([o],"int32");for(let u=0,h=0;u<a.length;u++)i.has(a[u])||(l.values[h]=a[u],c.values[h]=u,h++);return[l.toTensor(),c.toTensor()]}var Y3=oY;function lY(e){let t={x:$(e,"x","sign")};return B.runKernel(gc,t)}var WI=W({sign_:lY});function uY(e){let t={x:$(e,"x","sin","float32")};return B.runKernel(fc,t)}var Db=W({sin_:uY});function cY(e){let t={x:$(e,"x","sinh")};return B.runKernel(mc,t)}var Ob=W({sinh_:cY});function hY(e,t,n){let r=$(e,"x","slice1d");return R(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),Ke(r,[t],[n])}var vg=W({slice1d_:hY});function dY(e,t,n){let r=$(e,"x","slice2d");return R(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),Ke(r,t,n)}var zb=W({slice2d_:dY});function pY(e,t,n){let r=$(e,"x","slice3d");return R(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),Ke(r,t,n)}var Ip=W({slice3d_:pY});function fY(e,t,n){let r=$(e,"x","slice4d");return R(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),Ke(r,t,n)}var Jh=W({slice4d_:fY});function mY(e,t=-1){let n=$(e,"logits","softmax","float32");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);let r={logits:n},a={dim:t};return B.runKernel(wc,r,a)}var Uo=W({softmax_:mY});function gY(e){R(e.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`);let t={input:e};return B.runKernel(lb,t)}var wg=W({fft_:gY});function yY(e){R(e.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`);let t={input:e};return B.runKernel(ub,t)}var Qh=W({ifft_:yY});function xY(e){let t=e.shape[e.shape.length-1],n=e.size/t,r;if(t<=2){let a=V(e,[n,t]);r=Qh(a)}else{let a=[n,2*(t-1)],s=V(Yh(e),[n,t]),i=V(dg(e),[n,t]),o=da(Ke(s,[0,1],[n,t-2]),1),l=U(da(Ke(i,[0,1],[n,t-2]),1),_e(-1)),c=xt([s,o],1),u=xt([i,l],1),h=V(ui(c,u),[a[0],a[1]]);r=Qh(h)}if(r=Yh(r),e.rank===3&&e.shape[0]!==0){let a=r,s=e.shape[0];r=V(r,[s,r.shape[0]/s,r.shape[1]]),a.dispose()}return r}var Pb=W({irfft_:xY});function bY(e,t,n=0){let r={x:$(e,"x","split")},a={numOrSizeSplits:t,axis:n};return B.runKernel(up,r,a)}var xr=W({split_:bY});function vY(e,t){R(e.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let n=e.shape[e.shape.length-1],r=e.size/n,a;if(t!=null&&t<n){let f=e.shape.map(y=>0),m=e.shape.map(y=>y);m[e.shape.length-1]=t,a=Ke(e,f,m),n=t}else if(t!=null&&t>n){let f=e.shape.map(m=>m);f[e.shape.length-1]=t-n,a=xt([e,Ot(f)],e.shape.length-1),n=t}else a=e;let s=Ye(a),i=V(ui(a,s),[r,n]),o=wg(i),l=Math.floor(n/2)+1,c=Yh(o),u=dg(o),h=xr(c,[l,n-l],c.shape.length-1),d=xr(u,[l,n-l],u.shape.length-1),p=a.shape.slice();return p[a.shape.length-1]=l,V(ui(h[0],d[0]),p)}var kg=W({rfft_:vY});function wY(e,t){let n=$(e,"a","squaredDifference"),r=$(t,"b","squaredDifference");[n,r]=Pt(n,r),bt(n.shape,r.shape);let a={a:n,b:r},s={};return B.runKernel(kc,a,s)}var Lb=W({squaredDifference_:wY});function kY(e,t){let n=$(e,"x","squeeze","string_or_numeric");return V(n,ID(n.shape,t).newShape)}var Vo=W({squeeze_:kY});function SY(e,t=0){let n=hm(e,"tensors","stack","string_or_numeric");R(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&R(t<=n[0].rank,()=>"Axis must be <= rank of the tensor");let r=n,a={axis:t};return B.runKernel(Qd,r,a)}var Jt=W({stack_:SY});function IY(e,t=0){let n={x:$(e,"x","step")},r={alpha:t};return B.runKernel(Po,n,r)}var Ec=W({step_:IY});function NY(e,t,n,r,a=0,s=0,i=0,o=0,l=0){let c={x:$(e,"x","stridedSlice","string_or_numeric")},u={begin:t,end:n,strides:r,beginMask:a,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};return B.runKernel(dp,c,u)}var UI=W({stridedSlice_:NY});function _Y(e){let t={x:$(e,"x","tan","float32")};return B.runKernel(Ic,t)}var VI=W({tan_:_Y});function ut(e,t){ou(e);let n=Cs(e,t);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Lo(e,null,n,t)}function Ns(e,t,n){if(ou(e),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");let r=Cs(e,n);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Lo(e,t,r,n)}function Bb(e,t,n){if(ou(e),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");let r=Cs(e,n);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Lo(e,t,r,n)}function ko(e,t,n){if(ou(e),t!=null&&t.length!==4)throw new Error("tensor4d() requires shape to have four numbers");let r=Cs(e,n);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Lo(e,t,r,n)}function J3(e,t,n){if(ou(e),t!=null&&t.length!==5)throw new Error("tensor5d() requires shape to have five numbers");let r=Cs(e,n);if(r.length!==5&&r.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Lo(e,t,r,n)}function Q3(e,t,n){if(ou(e),t!=null&&t.length!==6)throw new Error("tensor6d() requires shape to have six numbers");let r=Cs(e,n);if(r.length!==6&&r.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||r,Lo(e,t,r,n)}var Wb={};Re(Wb,{calculateShapes:()=>eO,validateInput:()=>Ub,validateUpdateShape:()=>jI});function jI(e,t,n){let r=t.rank>1?t.shape[t.rank-1]:1,a=t.rank>1?t.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${a}.`;if(n.rank<a)throw new Error(s+` update.rank < ${a}. `);if(e.length<r+(n.rank-a))throw new Error(s+` Output shape length < ${r+(n.rank-a)}`);if(n.rank!==a+e.length-r)throw new Error(s+` update.rank != ${a+e.length-r}`);for(let i=0;i<a;++i)if(n.shape[i]!==t.shape[i])throw new Error(s+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<n.rank-a;++i)if(n.shape[i+a]!==e[i+r])throw new Error(s+` updates.shape[${i+a}] (${n.shape[i+a]}) != shape[${i+a}] (${e[i+a]})`)}function Ub(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(e.size===0)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}jI(n,t,e)}function eO(e,t,n){let r=t.shape.length,a=r>1?t.shape[r-1]:1,s=n.length,i=1;for(let h=a;h<s;++h)i*=n[h];let o=a<1?1:a,l=dt(t.shape)/o,c=[...md(n.slice(0,a)),1],u=dt(n);return{sliceRank:a,numUpdates:l,sliceSize:i,strides:c,outputSize:u}}function CY(e,t,n){let r=$(e,"tensor","tensorScatterupdate"),a=$(t,"indices","tensorScatterupdate","int32"),s=$(n,"updates","tensorScatterupdate");if(Ub(s,a,r.shape),r.dtype!==s.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${s.dtype}.`);let i={tensor:r,indices:a,updates:s},o={};return B.runKernel(ap,i,o)}var tO=W({tensorScatterUpdate_:CY});function TY(e,t=1,n=!0){let r=$(e,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");let a=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>a)throw new Error(`'k' passed to topk() must be <= the last dimension (${a}) but got ${t}`);let s={x:r},i={k:t,sorted:n},[o,l]=B.runKernel(pp,s,i);return{values:o,indices:l}}var GI=W({topk_:TY});function EY(e,t=0,n=1,r,a){if(qr(e),r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");let s=new LI(t,n,r,!0,a),i=Ve(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}var Vb=W({truncatedNormal_:EY});function AY(e,t=0){let n=$(e,"x","unique","string_or_numeric");R(n.rank>0,()=>"The input tensor must be at least 1D");let r={x:n},a={axis:t},[s,i]=B.runKernel(ng,r,a);return{values:s,indices:i}}var HI=W({unique_:AY});function $Y(e,t,n){let r=$(e,"x","unsortedSegmentSum"),a=$(t,"segmentIds","unsortedSegmentSum","int32");R(jh(n),()=>"numSegments must be of dtype int");let s={x:r,segmentIds:a},i={numSegments:n};return B.runKernel(rg,s,i)}var jb=W({unsortedSegmentSum_:$Y});function MY(e,t=0){let n=$(e,"x","unstack","string_or_numeric");R(t>=-n.shape.length&&t<n.shape.length,()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`);let r={value:n},a={axis:t};return B.runKernel(mp,r,a)}var Vt=W({unstack_:MY});function nO(e,t){return Eb(e,t,"right")}function qI(e,t=!0,n,r){return B.makeVariable(e,t,n,r)}function rO(e,t){let n=[];for(let s=0;s<t.length;s++)t[s]&&n.push(s);let r=Ve(e,"int32"),a=Ve([n.length,e.length],"int32");for(let s=0;s<n.length;s++){let i=r.indexToLoc(n[s]),o=s*e.length;a.values.set(i,o)}return a.toTensor()}async function FY(e){let t=$(e,"condition","whereAsync","bool"),n=await t.data(),r=rO(t.shape,n);return e!==t&&t.dispose(),r}var KI=FY;async function RY(e,t,n){let r=$(e,"tensor","boolMask"),a=$(t,"mask","boolMask","bool"),s=n??0,i=a.rank,o=r.shape;R(i>0,()=>"mask cannot be scalar"),sr(o.slice(s,s+i),a.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let m=s;m<s+i;m++)l*=o[m];let c=o.slice(0,s).concat([l],o.slice(s+i)),u=V(r,c),h=V(a,[-1]),d=await KI(h),p=Vo(d,[1]),f=kp(u,p,s);return e!==r&&r.dispose(),t!==a&&a.dispose(),p.dispose(),u.dispose(),h.dispose(),d.dispose(),f}var aO=RY;function DY(e,t,n){let r=$(e,"x","transpose");if(t==null&&(t=r.shape.map((i,o)=>o).reverse()),R(r.rank===t.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`),t.forEach(i=>{R(i>=0&&i<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${t}`)}),r.rank<=1)return r.clone();let a={x:r},s={perm:t};return r.dtype==="complex64"?j(()=>{let i=Yh(r),o=dg(r);return i=B.runKernel(ni,{x:i},s),o=B.runKernel(ni,{x:o},s),n&&(o=Nt(o)),ui(i,o)}):B.runKernel(ni,a,s)}var Ue=W({transpose_:DY});function OY(e,t,n,r,a=!0){let s=$(e,"v","movingAverage"),i=$(t,"x","movingAverage"),o=$(n,"decay","movingAverage");jD(s,i),R(pi(s.shape,i.shape),()=>"Shape mismatch in v and x");let l=_e(1),c=me(l,o),u=U(me(i,s),c);if(a){R(r!=null,()=>"When using zeroDebias: true, step is required.");let h=$(r,"step","movingAverage");u=xe(u,me(l,Ts(o,h)))}return te(s,u)}var sO=W({movingAverage_:OY});function zY(e,t,n){qr(n);let r=$(e,"indices","scatterND","int32"),a=$(t,"updates","scatterND");Ub(a,r,n);let s={indices:r,updates:a},i={shape:n};return B.runKernel(rp,s,i)}var iO=W({scatterND_:zY});function PY(e,t,n,r){if(e.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);let a=e.rank>0?e.shape[0]:1,s=e.rank>1?e.shape[1]:1;if(n.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${s}.`);let i=t.size;if(!(t.rank===0||t.rank===1&&i===a))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${a}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function LY(e,t,n,r=0){qr(n);let a=$(e,"sparseIndices","sparseToDense","int32"),s=$(t,"sparseValues","sparseToDense","string_or_numeric"),i=$(r,"defaultValue","sparseToDense",s.dtype);PY(a,s,n,i);let o={sparseIndices:a,sparseValues:s,defaultValue:i},l={outputShape:n};return B.runKernel(hp,o,l)}var oO=W({sparseToDense_:LY});function BY(e,t){let n=$(t,"indices","gatherND","int32"),r={params:$(e,"x","gatherND","string_or_numeric"),indices:n};return B.runKernel(Od,r)}var lO=W({gatherND_:BY});function WY(e,t){if(t==null)return e.shape.slice();if(pi(e.shape,t))return t;if(e.shape.length===t.length){let n=[];for(let r=0;r<e.shape.length;r++)t[r]==null&&e.shape[r]!=null?n.push(e.shape[r]):n.push(t[r]);return n}return t}function UY(e,t,n,r){let a=$(e,"x","dropout");if(R(a.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${a.dtype} tensor instead.`),R(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return e instanceof ze?a.clone():a;let s=WY(a,n),i=1-t,o=xe(wp(te(Wo(s,0,1,"float32",r),i)),i);return U(a,o)}var XI=W({dropout_:UY});function ZI(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function Gb(e,t,n){let r=1-e%2,a=new Float32Array(e);for(let s=0;s<e;++s){let i=2*Math.PI*s/(e+r-1);a[s]=t-n*Math.cos(i)}return ut(a,"float32")}async function VY(e,t,n=1){let r=$(e,"predictions","inTopK"),a=$(t,"targets","inTopK");R(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),R(r.rank-1===a.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${a.rank}`),sr(r.shape.slice(0,r.shape.length-1),a.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let s=r.shape[r.shape.length-1];R(n>0&&n<=s,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${n}`);let i=await r.data(),o=await a.data(),[l,c]=[i.length/s,s],u=ND("bool",l);for(let h=0;h<l;h++){let d=h*c,p=i.subarray(d,d+c),f=[];for(let m=0;m<p.length;m++)f.push({value:p[m],index:m});f.sort((m,y)=>y.value-m.value),u[h]=0;for(let m=0;m<n;m++)if(f[m].index===o[h]){u[h]=1;break}}return e!==r&&r.dispose(),t!==a&&a.dispose(),er(u,a.shape,"bool")}var uO=VY,ed={};Re(ed,{conv2d:()=>HY,depthwiseConv2d:()=>ZY,matMul:()=>JY});function jY(e,t,n,r,a,s="NHWC",i){let o=e;e.rank===3&&(o=V(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;l.rank===3&&(l=V(t,[1,t.shape[0],t.shape[1],t.shape[2]])),R(o.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),R(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),R(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);let c=s==="NHWC"?o.shape[3]:o.shape[1],u=s==="NHWC"?l.shape[3]:l.shape[1];R(c===n[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${n[2]}.`),R(u===n[3],()=>`Error in conv2dDerFilter: depth of dy (${u}) must match output depth for filter (${n[3]}).`),ir("conv2dDerFilter",a,i);let h={x:o,dy:l},d={strides:r,pad:a,dataFormat:s,dimRoundingMode:i,filterShape:n};return B.runKernel(rb,h,d)}var YI=W({conv2DBackpropFilter_:jY});function Hb(e,t,n){if(n==null||n==="linear")return e;if(n==="relu")return U(e,Ec(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function qb(e,t){let n=t,r=Qt(e.shape,t.shape);return r.length>0&&(n=ke(n,r)),V(n,e.shape)}function Kb(e,t,n,r){if(t==="linear")return e;if(t==="relu")return ht(e);if(t==="elu")return bp(e);if(t==="relu6")return $b(e);if(t==="prelu")return bg(e,n);if(t==="leakyrelu")return pg(e,r);if(t==="sigmoid")return Ca(e);throw new Error(`Unknown fused activation ${t}.`)}var Xb=(e,t)=>!(e>0)||t==="linear";function GY({x:e,filter:t,strides:n,pad:r,dataFormat:a="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:u}){if(l=l||"linear",Xb(B.state.gradientDepth,l)===!1){R(a==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${a} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let I=nr(e,t,n,r,a,s,i);return o!=null&&(I=te(I,o)),Kb(I,l,c,u)}let h=$(e,"x","conv2d","float32"),d=$(t,"filter","conv2d","float32"),p=h,f=!1;h.rank===3&&(f=!0,p=V(h,[1,h.shape[0],h.shape[1],h.shape[2]])),R(p.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),R(d.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),ir("fused conv2d",r,i);let m=a==="NHWC"?p.shape[3]:p.shape[1];R(d.shape[2]===m,()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${d.shape[2]}.`),R($s(n,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`);let y=ug(p.shape,d.shape,n,s,r,i),g;o!=null&&(g=$(o,"bias","fused conv2d"),[g]=Pt(g,h),a==="NHWC"?bt(y.outShape,g.shape):(R(g.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${g.shape.length}.`),R(g.shape.length===0||g.shape[0]===y.outChannels||g.shape[0]===1,()=>`Error in fused conv2d: bias shape (${g.shape}) is not compatible with the number of output channels (${y.outChannels})`)));let x;if(c!=null){let I=c.shape;if(R(I.length<=1||I.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${I.length}.`),I.length===1)R(I[0]===1||I[0]===y.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${I}) is not compatible with the number of output channels (${y.outChannels}).`);else if(I.length===3)try{bt(I,y.outShape)}catch{let T=`Error in fused conv2d: PReLU activation weights (${I}) is not compatible with the output shape of the conv2d (${y.outShape}).`;throw Error(T)}x=$(c,"prelu weights","fused conv2d")}let b=(I,_)=>{R(a==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${a} but only NHWC is currently supported.`);let[T,A,M,F]=_,C=Hb(I,M,l);R(bo(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);let D=fI(A.shape,C,T,n,r),L=YI(A,C,T.shape,n,r),O=[D,L];if(F!=null){let q=qb(F,C);O.push(q)}return O},v={x:p,filter:d,bias:g,preluActivationWeights:x},w={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:u};return o==null?Es((I,_,T)=>{let A=B.runKernel(Pl,v,w);return T([_,I,A]),f&&(A=V(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:b}})(p,d):Es((I,_,T,A)=>{let M=B.runKernel(Pl,v,w);return A([_,I,M,T]),f&&(M=V(M,[M.shape[1],M.shape[2],M.shape[3]])),{value:M,gradFunc:b}})(p,d,g)}var HY=W({fusedConv2d_:GY});function qY(e,t,n,r,a,s=[1,1],i){let o=e;e.rank===3&&(o=V(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;l.rank===3&&(l=V(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let c={x:o,dy:l},u={strides:r,pad:a,dimRoundingMode:i,dilations:s,filterShape:n};return B.runKernel(ab,c,u)}var cO=W({depthwiseConv2dNativeBackpropFilter_:qY});function KY(e,t,n,r,a,s=[1,1],i){let o=t,l=!1;t.rank===3&&(l=!0,o=V(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let c={dy:o,filter:n},u={strides:r,pad:a,dimRoundingMode:i,dilations:s,inputShape:e},h=B.runKernel(sb,c,u);return l?V(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var hO=W({depthwiseConv2dNativeBackpropInput_:KY});function XY({x:e,filter:t,strides:n,pad:r,dataFormat:a="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:u}){if(Xb(B.state.gradientDepth,l)===!1){let w=Cc(e,t,n,r,a,s,i);return o!=null&&(w=te(w,o)),Kb(w,l,c,u)}let h=$(e,"x","depthwiseConv2d","float32"),d=$(t,"filter","depthwiseConv2d","float32"),p=h,f=!1;h.rank===3&&(f=!0,p=V(h,[1,h.shape[0],h.shape[1],h.shape[2]])),R(p.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),R(d.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),R(p.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),s==null&&(s=[1,1]),R($s(n,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),ir("fused depthwiseConv2d",r,i);let m=ug(p.shape,d.shape,n,s,r,i,!0),y;o!=null&&(y=$(o,"bias","fused conv2d"),[y]=Pt(y,h),bt(m.outShape,y.shape));let g;c!=null&&(g=$(c,"prelu weights","fused depthwiseConv2d"));let x=(w,I)=>{R(bo(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);let[_,T,A,M]=I,F=Hb(w,A,l),C=hO(T.shape,F,_,n,r,s,i),D=cO(T,F,_.shape,n,r,s,i);if(M!=null){let L=qb(y,F);return[C,D,L]}return[C,D]},b={x:p,filter:d,bias:y,preluActivationWeights:g},v={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:u};return o==null?Es((w,I,_)=>{let T=B.runKernel(Ll,b,v);return _([I,w,T]),f&&(T=V(T,[T.shape[1],T.shape[2],T.shape[3]])),{value:T,gradFunc:x}})(p,d):Es((w,I,_,T)=>{let A=B.runKernel(Ll,b,v);return T([I,w,A,_]),f&&(A=V(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:x}})(p,d,y)}var ZY=W({fusedDepthwiseConv2d_:XY});function YY({a:e,b:t,transposeA:n=!1,transposeB:r=!1,bias:a,activation:s="linear",preluActivationWeights:i,leakyreluAlpha:o=.2}){if(Xb(B.state.gradientDepth,s)===!1){let M=We(e,t,n,r);return a!=null&&(M=te(M,a)),Kb(M,s,i,o)}let l=$(e,"a","fused matMul"),c=$(t,"b","fused matMul");[l,c]=Pt(l,c);let u=n?l.shape[l.rank-2]:l.shape[l.rank-1],h=r?c.shape[c.rank-1]:c.shape[c.rank-2],d=n?l.shape[l.rank-1]:l.shape[l.rank-2],p=r?c.shape[c.rank-2]:c.shape[c.rank-1],f=l.shape.slice(0,-2),m=c.shape.slice(0,-2),y=dt(f),g=dt(m);R(u===h,()=>`Error in fused matMul: inner shapes (${u}) and (${h}) of Tensors with shapes ${l.shape} and ${c.shape} and transposeA=${n} and transposeB=${r} must match.`);let x=bt(l.shape.slice(0,-2),c.shape.slice(0,-2)).concat([d,p]),b=n?V(l,[y,u,d]):V(l,[y,d,u]),v=r?V(c,[g,p,h]):V(c,[g,h,p]),w;a!=null&&(w=$(a,"bias","fused matMul"),[w]=Pt(w,l),bt(x,w.shape));let I;i!=null&&(I=$(i,"prelu weights","fused matMul"));let _=(M,F)=>{let[C,D,L,O]=F,q=Hb(V(M,L.shape),L,s),H,z;if(!n&&!r?(H=We(q,D,!1,!0),z=We(C,q,!0,!1)):!n&&r?(H=We(q,D,!1,!1),z=We(q,C,!0,!1)):n&&!r?(H=We(D,q,!1,!0),z=We(C,q,!1,!1)):(H=We(D,q,!0,!0),z=We(q,C,!0,!0)),a!=null){let K=qb(O,q);return[H,z,K]}else return[H,z]},T={a:b,b:v,bias:w,preluActivationWeights:I},A={transposeA:n,transposeB:r,activation:s,leakyreluAlpha:o};return a==null?Es((M,F,C)=>{let D=B.runKernel(zl,T,A);return C([M,F,D]),{value:V(D,x),gradFunc:_}})(b,v):Es((M,F,C,D)=>{let L=B.runKernel(zl,T,A);return D([M,F,L,C]),{value:V(L,x),gradFunc:_}})(b,v,w)}var JY=W({fusedMatMul_:YY});function QY(e){return Gb(e,.54,.46)}var eJ=W({hammingWindow_:QY});function tJ(e){return Gb(e,.5,.5)}var dO=W({hannWindow_:tJ});function nJ(e,t,n,r=!1,a=0){let s=0,i=[];for(;s+t<=e.size;)i.push(Ke(e,s,t)),s+=n;if(r)for(;s<e.size;){let o=s+t-e.size,l=xt([Ke(e,s,t-o),Wr([o],a)]);i.push(l),s+=n}return i.length===0?Ns([],[0,t]):V(xt(i),[i.length,t])}var pO=W({frame_:nJ});function rJ(e,t,n,r,a=dO){r==null&&(r=ZI(t));let s=pO(e,t,n),i=U(s,a(t));return kg(i,r)}var aJ=W({stft_:rJ});function sJ(e,t,n,r,a="bilinear",s=0){let i=$(e,"image","cropAndResize"),o=$(t,"boxes","cropAndResize","float32"),l=$(n,"boxInd","cropAndResize","int32"),c=o.shape[0];R(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),R(o.rank===2&&o.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${o.shape}.`),R(l.rank===1&&l.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${o.shape}.`),R(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),R(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),R(a==="bilinear"||a==="nearest",()=>`method must be bilinear or nearest, but was ${a}`);let u={image:i,boxes:o,boxInd:l},h={method:a,extrapolationValue:s,cropSize:r};return B.runKernel(Ed,u,h)}var iJ=W({cropAndResize_:sJ});function oJ(e){let t=$(e,"image","flipLeftRight","float32");R(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);let n={image:t};return B.runKernel(Rd,n,{})}var lJ=W({flipLeftRight_:oJ});function uJ(e){let t=$(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];R(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),R(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);let a=new Array(t.rank);return a.fill(1,0,n),a[n]=3,Or(t,a)}var cJ=W({grayscaleToRGB_:uJ});function hJ(e){let t=$(e,"image","RGBToGrayscale"),n=t.rank-1,r=t.shape[n];R(t.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`),R(r===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`);let a=t.dtype,s=le(t,"float32"),i=ut([.2989,.587,.114]),o;switch(t.rank){case 2:o=pl("ij,j->i",s,i);break;case 3:o=pl("ijk,k->ij",s,i);break;case 4:o=pl("ijkl,l->ijk",s,i);break;case 5:o=pl("ijklm,m->ijkl",s,i);break;case 6:o=pl("ijklmn,n->ijklm",s,i);break;default:throw new Error("Not a valid tensor rank.")}return o=yn(o,-1),le(o,a)}var dJ=W({rgbToGrayscale_:hJ});function pJ(e,t,n=0,r=.5){let a=$(e,"image","rotateWithOffset","float32");R(a.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${a.rank}.`);let s={image:a},i={radians:t,fillValue:n,center:r};return B.runKernel(yp,s,i)}var fJ=W({rotateWithOffset_:pJ});function Np(e,t,n,r,a,s){r==null&&(r=.5),a==null&&(a=Number.NEGATIVE_INFINITY),s==null&&(s=0);let i=e.shape[0];return n=Math.min(n,i),R(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),R(e.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),R(e.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),R(t.rank===1,()=>"scores must be a 1D tensor"),R(t.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`),R(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s}}function mJ(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY){let s=$(e,"boxes","nonMaxSuppression","float32"),i=$(t,"scores","nonMaxSuppression","float32"),o=Np(s,i,n,r,a);n=o.maxOutputSize,r=o.iouThreshold,a=o.scoreThreshold;let l={maxOutputSize:n,iouThreshold:r,scoreThreshold:a};return B.runKernel(Xd,{boxes:s,scores:i},l)}var gJ=W({nonMaxSuppression_:mJ});function yJ(e,t,n){let r=xJ(e,t,n),a=r<0?-(r+1):r;e.splice(a,0,t)}function xJ(e,t,n){return vJ(e,t,n||bJ)}function bJ(e,t){return e>t?1:e<t?-1:0}function vJ(e,t,n){let r=0,a=e.length,s=0,i=!1;for(;r<a;){s=r+(a-r>>>1);let o=n(t,e[s]);o>0?r=s+1:(a=s,i=!o)}return i?r:-r-1}function fO(e,t,n,r,a){return JI(e,t,n,r,a,0)}function mO(e,t,n,r,a,s){return JI(e,t,n,r,a,0,!1,s,!0)}function gO(e,t,n,r,a,s){return JI(e,t,n,r,a,s,!0)}function JI(e,t,n,r,a,s,i=!1,o=!1,l=!1){let c=[];for(let y=0;y<t.length;y++)t[y]>a&&c.push({score:t[y],boxIndex:y,suppressBeginIndex:0});c.sort(OA);let u=s>0?-.5/s:0,h=[],d=[];for(;h.length<n&&c.length>0;){let y=c.pop(),{score:g,boxIndex:x,suppressBeginIndex:b}=y;if(g<a)break;let v=!1;for(let w=h.length-1;w>=b;--w){let I=wJ(e,x,h[w]);if(I>=r){v=!0;break}if(y.score=y.score*kJ(r,u,I),y.score<=a)break}y.suppressBeginIndex=h.length,v||(y.score===g?(h.push(x),d.push(y.score)):y.score>a&&yJ(c,y,OA))}let p=h.length,f=n-p;o&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));let m={selectedIndices:h};return i&&(m.selectedScores=d),l&&(m.validOutputs=p),m}function wJ(e,t,n){let r=e.subarray(t*4,t*4+4),a=e.subarray(n*4,n*4+4),s=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),c=Math.min(a[0],a[2]),u=Math.min(a[1],a[3]),h=Math.max(a[0],a[2]),d=Math.max(a[1],a[3]),p=(o-s)*(l-i),f=(h-c)*(d-u);if(p<=0||f<=0)return 0;let m=Math.max(s,c),y=Math.max(i,u),g=Math.min(o,h),x=Math.min(l,d),b=Math.max(g-m,0)*Math.max(x-y,0);return b/(p+f-b)}function kJ(e,t,n){let r=Math.exp(t*n*n);return n<=e?r:0}function OA(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}async function SJ(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY){let s=$(e,"boxes","nonMaxSuppressionAsync"),i=$(t,"scores","nonMaxSuppressionAsync"),o=Np(s,i,n,r,a);n=o.maxOutputSize,r=o.iouThreshold,a=o.scoreThreshold;let l=await Promise.all([s.data(),i.data()]),c=l[0],u=l[1],{selectedIndices:h}=fO(c,u,n,r,a);return s!==e&&s.dispose(),i!==t&&i.dispose(),ut(h,"int32")}var IJ=SJ;function NJ(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=0){let i=$(e,"boxes","nonMaxSuppression"),o=$(t,"scores","nonMaxSuppression"),l=Np(i,o,n,r,a,s);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,s=l.softNmsSigma;let c={boxes:i,scores:o},u={maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s},h=B.runKernel(Yd,c,u);return{selectedIndices:h[0],selectedScores:h[1]}}var _J=W({nonMaxSuppressionWithScore_:NJ});async function CJ(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=0){let i=$(e,"boxes","nonMaxSuppressionAsync"),o=$(t,"scores","nonMaxSuppressionAsync"),l=Np(i,o,n,r,a,s);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,s=l.softNmsSigma;let c=await Promise.all([i.data(),o.data()]),u=c[0],h=c[1],{selectedIndices:d,selectedScores:p}=gO(u,h,n,r,a,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:ut(d,"int32"),selectedScores:ut(p)}}var TJ=CJ;function EJ(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=!1){let i=$(e,"boxes","nonMaxSuppression"),o=$(t,"scores","nonMaxSuppression"),l=Np(i,o,n,r,a,null),c=l.maxOutputSize,u=l.iouThreshold,h=l.scoreThreshold,d={boxes:i,scores:o},p={maxOutputSize:c,iouThreshold:u,scoreThreshold:h,padToMaxOutputSize:s},f=B.runKernel(Zd,d,p);return{selectedIndices:f[0],validOutputs:f[1]}}var AJ=W({nonMaxSuppressionPadded_:EJ});async function $J(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=!1){let i=$(e,"boxes","nonMaxSuppressionAsync"),o=$(t,"scores","nonMaxSuppressionAsync"),l=Np(i,o,n,r,a,null),c=l.maxOutputSize,u=l.iouThreshold,h=l.scoreThreshold,[d,p]=await Promise.all([i.data(),o.data()]),{selectedIndices:f,validOutputs:m}=mO(d,p,c,u,h,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:ut(f,"int32"),validOutputs:_e(m,"int32")}}var MJ=$J;function FJ(e,t,n=!1,r=!1){let a=$(e,"images","resizeBilinear");R(a.rank===3||a.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${a.rank}.`),R(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),R(r===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=a,i=!1;a.rank===3&&(i=!0,s=V(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let o={images:s},l={alignCorners:n,halfPixelCenters:r,size:t},c=B.runKernel(lc,o,l);return i?V(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var yO=W({resizeBilinear_:FJ});function RJ(e,t,n=!1,r=!1){let a=$(e,"images","resizeNearestNeighbor");R(a.rank===3||a.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${a.rank}.`),R(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),R(a.dtype==="float32"||a.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),R(r===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=a,i=!1;a.rank===3&&(i=!0,s=V(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let o={images:s},l={alignCorners:n,halfPixelCenters:r,size:t},c=B.runKernel(oc,o,l);return i?V(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var xO=W({resizeNearestNeighbor_:RJ});function DJ(e,t="binary",n=!1,r=.5){let a=$(e,"image","threshold"),s=.2989,i=.587,o=.114,l=a.shape[0]*a.shape[1],c=U(ut([r]),255),u,h,d,p;if(R(a.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${a.rank}.`),R(a.shape[2]===3||a.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${a.shape[2]}.`),R(a.dtype==="int32"||a.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${a.dtype}.`),R(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),a.shape[2]===3){[u,h,d]=xr(a,[1,1,1],-1);let m=U(u,s),y=U(h,i),g=U(d,o);p=te(te(m,y),g)}else p=e;if(t==="otsu"){let m=lI(le(Mb(p),"int32"),er([]),256);c=OJ(m,l)}let f=n?Bo(p,c):or(p,c);return le(U(f,255),"int32")}function OJ(e,t){let n=ut([-1]),r=ut([0]),a=ut([0]),s,i,o,l,c,u;for(let h=0;h<e.size-1;h++){s=Ke(e,0,h+1),i=Ke(e,h+1),c=xe(ke(s),t),u=xe(ke(i),t);let d=ke(U(s,Kl(0,s.size)));o=xe(d,ke(s));let p=Wr(i.shape,s.size),f=te(Kl(0,i.size),p),m=U(i,f);l=xe(ke(m),ke(i));let y=me(o,l),g=me(o,l),x=U(c,u);a=U(U(x,y),g);let b=or(a,r);r=vn(b,a,r),n=vn(b,ut([h]),n)}return n}var zJ=W({threshold_:DJ});function PJ(e,t,n="nearest",r="constant",a=0,s){let i=$(e,"image","transform","float32"),o=$(t,"transforms","transform","float32");R(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),R(o.rank===2&&(o.shape[0]===i.shape[0]||o.shape[0]===1)&&o.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),R(s==null||s.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`);let l={image:i,transforms:o},c={interpolation:n,fillMode:r,fillValue:a,outputShape:s};return B.runKernel(fp,l,c)}var LJ=W({transform_:PJ});function BJ(e,t,n){let r=$(e,"a","bandPart");R(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);let a=r.shape,[s,i]=r.shape.slice(-2),o,l;typeof t=="number"?(R(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),R(t<=s,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${s}).`),o=$(t<0?s:t,"numLower","bandPart")):(R(t.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),o=vn(Xh(t,0),s,wo(t,s))),typeof n=="number"?(R(n%1===0,()=>`bandPart(): numUpper must be an integer, got ${n}.`),R(n<=i,()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`),l=$(n<0?i:n,"numUpper","bandPart")):(R(n.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=vn(Xh(n,0),i,wo(n,i)));let c=V(Kl(0,s,1,"int32"),[-1,1]),u=Kl(0,i,1,"int32"),h=me(c,u),d=Aa(Bo(h,o),gi(h,Nt(l))),p=Ot([s,i],r.dtype);return V(Jt(Vt(V(r,[-1,s,i])).map(f=>vn(d,f,p))),a)}var WJ=W({bandPart_:BJ});function UJ(e){let t;if(Array.isArray(e)){t=!1,R(e!=null&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let a=e[0].shape[0];for(let s=1;s<e.length;++s)R(e[s].shape[0]===a,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[s].shape[0]} vs. ${a})`)}else t=!0,e=xr(e,e.shape[0],0).map(a=>Vo(a,[0]));R(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);let n=[],r=e;for(let a=0;a<e.length;++a)n.push(B.tidy(()=>{let s=r[a];if(a>0)for(let i=0;i<a;++i){let o=U(ke(U(n[i],s)),n[i]);s=me(s,o)}return xe(s,vp(s,"euclidean"))}));return t?Jt(n,0):n}var VJ=W({gramSchmidt_:UJ});function jJ(e,t=!1){if(R(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),e.rank===2)return zA(e,t);{let n=e.shape.slice(0,e.shape.length-2).reduce((l,c)=>l*c),r=Vt(V(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),a=[],s=[];r.forEach(l=>{let[c,u]=zA(l,t);a.push(c),s.push(u)});let i=V(Jt(a,0),e.shape),o=V(Jt(s,0),e.shape);return[i,o]}}function zA(e,t=!1){return B.tidy(()=>{R(e.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);let n=e.shape[0],r=e.shape[1],a=Nb(n),s=Is(e),i=Ns([[1]],[1,1]),o=Is(i),l=n>=r?r:n;for(let c=0;c<l;++c){let u=s,h=o,d=a;[o,s,a]=B.tidy(()=>{let p=Ke(s,[c,c],[n-c,1]),f=vp(p),m=Ke(s,[c,c],[1,1]),y=vn(or(m,0),Ns([[-1]]),Ns([[1]])),g=me(m,U(y,f)),x=xe(p,g);x.shape[0]===1?o=Is(i):o=xt([i,Ke(x,[1,0],[x.shape[0]-1,x.shape[1]])],0);let b=Nt(xe(We(y,g),f)),v=Ke(s,[c,0],[n-c,r]),w=U(b,o),I=Ue(o);if(c===0)s=me(v,We(w,We(I,v)));else{let A=me(v,We(w,We(I,v)));s=xt([Ke(s,[0,0],[c,r]),A],0)}let _=Ue(w),T=Ke(a,[0,c],[n,a.shape[1]-c]);if(c===0)a=me(T,We(We(T,o),_));else{let A=me(T,We(We(T,o),_));a=xt([Ke(a,[0,0],[n,c]),A],1)}return[o,s,a]}),Fe([u,h,d])}return!t&&n>r&&(a=Ke(a,[0,0],[n,r]),s=Ke(s,[0,0],[r,r])),[a,s]})}var GJ=W({qr_:jJ}),Yn;(function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Yn||(Yn={}));function HJ(e,t,n=Yn.SUM_BY_NONZERO_WEIGHTS){let r=$(e,"losses","computeWeightedLoss"),a=null;t!=null&&(a=$(t,"weights","computeWeightedLoss"));let s=a==null?r:U(r,a);if(n===Yn.NONE)return s;if(n===Yn.SUM)return ke(s);if(n===Yn.MEAN){if(a==null)return Dt(s);{let i=r.size/a.size,o=xe(ke(s),ke(a));return i>1?xe(o,_e(i)):o}}if(n===Yn.SUM_BY_NONZERO_WEIGHTS){if(a==null)return xe(ke(s),_e(r.size));{let i=U(a,gr(r.shape)),o=le(ke(ql(i,_e(0))),"float32");return xe(ke(s),o)}}throw Error(`Unknown reduction: ${n}`)}var yi=W({computeWeightedLoss_:HJ});function qJ(e,t,n,r=Yn.SUM_BY_NONZERO_WEIGHTS){let a=$(e,"labels","absoluteDifference"),s=$(t,"predictions","absoluteDifference"),i=null;n!=null&&(i=$(n,"weights","absoluteDifference")),sr(a.shape,s.shape,"Error in absoluteDifference: ");let o=Kt(me(a,s));return yi(o,i,r)}var KJ=W({absoluteDifference_:qJ});function XJ(e,t,n,r,a=Yn.SUM_BY_NONZERO_WEIGHTS){let s=$(e,"labels","cosineDistance"),i=$(t,"predictions","cosineDistance"),o=null;r!=null&&(o=$(r,"weights","cosineDistance")),sr(s.shape,i.shape,"Error in cosineDistance: ");let l=_e(1),c=me(l,ke(U(s,i),n,!0));return yi(c,o,a)}var ZJ=W({cosineDistance_:XJ});function YJ(e,t,n,r=Yn.SUM_BY_NONZERO_WEIGHTS){let a=$(e,"labels","hingeLoss"),s=$(t,"predictions","hingeLoss"),i=null;n!=null&&(i=$(n,"weights","hingeLoss")),sr(a.shape,s.shape,"Error in hingeLoss: ");let o=_e(1);a=me(U(_e(2),a),o);let l=ht(me(o,U(a,s)));return yi(l,i,r)}var JJ=W({hingeLoss_:YJ});function QJ(e,t,n,r=1,a=Yn.SUM_BY_NONZERO_WEIGHTS){let s=$(e,"labels","huberLoss"),i=$(t,"predictions","huberLoss"),o=null;n!=null&&(o=$(n,"weights","huberLoss")),sr(s.shape,i.shape,"Error in huberLoss: ");let l=_e(r),c=Kt(me(i,s)),u=wo(c,l),h=me(c,u),d=te(U(_e(.5),gt(u)),U(l,h));return yi(d,o,a)}var eQ=W({huberLoss_:QJ});function tQ(e,t,n,r=1e-7,a=Yn.SUM_BY_NONZERO_WEIGHTS){let s=$(e,"labels","logLoss"),i=$(t,"predictions","logLoss"),o=null;n!=null&&(o=$(n,"weights","logLoss")),sr(s.shape,i.shape,"Error in logLoss: ");let l=_e(1),c=_e(r),u=Nt(U(s,jr(te(i,c)))),h=U(me(l,s),jr(te(me(l,i),c))),d=me(u,h);return yi(d,o,a)}var nQ=W({logLoss_:tQ});function rQ(e,t,n,r=Yn.SUM_BY_NONZERO_WEIGHTS){let a=$(e,"labels","meanSquaredError"),s=$(t,"predictions","meanSquaredError"),i=null;n!=null&&(i=$(n,"weights","meanSquaredError")),sr(a.shape,s.shape,"Error in meanSquaredError: ");let o=Lb(a,s);return yi(o,i,r)}var aQ=W({meanSquaredError_:rQ});function sQ(e,t){let n=$(e,"labels","sigmoidCrossEntropyWithLogits"),r=$(t,"logits","sigmoidCrossEntropyWithLogits");sr(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");let a=ht(r),s=U(r,n),i=fg(Bn(Nt(Kt(r))));return te(me(a,s),i)}function iQ(e,t,n,r=0,a=Yn.SUM_BY_NONZERO_WEIGHTS){let s=$(e,"multiClassLabels","sigmoidCrossEntropy"),i=$(t,"logits","sigmoidCrossEntropy"),o=null;if(n!=null&&(o=$(n,"weights","sigmoidCrossEntropy")),sr(s.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){let c=_e(r),u=_e(1),h=_e(.5);s=te(U(s,me(u,c)),U(h,c))}let l=sQ(s,i);return yi(l,o,a)}var oQ=W({sigmoidCrossEntropy_:iQ});function lQ(e,t,n=-1){if(n===-1&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return Es((r,a,s)=>{let i=mg(a,[n],!0),o=me(le(a,"float32"),i);s([r,o]);let l=Nt(U(o,r));return{value:ke(l,[n]),gradFunc:(c,u)=>{let[h,d]=u,p=Hl(c.shape,[n]);return[U(V(c,p),me(le(h,"float32"),Bn(d))),U(V(c,p),me(Bn(d),le(h,"float32")))]}}})(e,t)}function uQ(e,t,n,r=0,a=Yn.SUM_BY_NONZERO_WEIGHTS){let s=$(e,"onehotLabels","softmaxCrossEntropy"),i=$(t,"logits","softmaxCrossEntropy"),o=null;if(n!=null&&(o=$(n,"weights","softmaxCrossEntropy")),sr(s.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){let c=_e(r),u=_e(1),h=_e(s.shape[1]);s=te(U(s,me(u,c)),xe(c,h))}let l=lQ(s,i);return yi(l,o,a)}var cQ=W({softmaxCrossEntropy_:uQ});function hQ(e,t,n,r){let a=$(e,"indices","sparseFillEmptyRows","int32"),s=$(t,"values","sparseFillEmptyRows"),i=$(n,"denseShape","sparseFillEmptyRows","int32"),o=$(r,"defaultValue","sparseFillEmptyRows",s.dtype);if(a.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${a.shape}`);if(s.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(i.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(o.rank!==0)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);let l={indices:a,values:s,denseShape:i,defaultValue:o},c=B.runKernel(Km,l);return{outputIndices:c[0],outputValues:c[1],emptyRowIndicator:c[2],reverseIndexMap:c[3]}}var dQ=W({sparseFillEmptyRows_:hQ});function pQ(e,t,n){let r=$(e,"inputIndices","sparseReshape","int32"),a=$(t,"inputShape","sparseReshape","int32"),s=$(n,"newShape","sparseReshape","int32");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(a.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${a.shape}`);if(s.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);let i={inputIndices:r,inputShape:a,newShape:s},o=B.runKernel(cp,i);return{outputIndices:o[0],outputShape:o[1]}}var fQ=W({sparseReshape_:pQ});function mQ(e,t,n){let r=$(e,"data","sparseSegmentMean"),a=$(t,"indices","sparseSegmentMean","int32"),s=$(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(a.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${a.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${s.shape}`);let i={data:r,indices:a,segmentIds:s};return B.runKernel(Xm,i)}var gQ=W({sparseSegmentMean_:mQ});function yQ(e,t,n){let r=$(e,"data","sparseSegmentSum"),a=$(t,"indices","sparseSegmentSum","int32"),s=$(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(a.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${a.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${s.shape}`);let i={data:r,indices:a,segmentIds:s};return B.runKernel(Zm,i)}var xQ=W({sparseSegmentSum_:yQ});function bQ(e,t,n,r,a,s,i,o){let l=$(e,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);let c=$(t,"dataSplits","stringNGrams");if(c.dtype!=="int32")throw new Error("Data splits must be of datatype int32");let u={separator:n,nGramWidths:r,leftPad:a,rightPad:s,padWidth:i,preserveShortSequences:o},h={data:l,dataSplits:c},d=B.runKernel(Qm,h,u);return{nGrams:d[0],nGramsSplits:d[1]}}var vQ=W({stringNGrams_:bQ});function wQ(e,t,n=!0){let r=$(e,"input","stringSplit","string"),a=$(t,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(a.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${a.shape}`);let s={skipEmpty:n},i={input:r,delimiter:a},o=B.runKernel(eg,i,s);return{indices:o[0],values:o[1],shape:o[2]}}var kQ=W({stringSplit_:wQ});function SQ(e,t){let n=$(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");let a={input:n};return B.runKernel(tg,a,r)}var IQ=W({stringToHashBucketFast_:SQ});function NQ(e,t,n,r=!0){let a=$(e,"input","staticRegexReplace","string"),s={pattern:t,rewrite:n,replaceGlobal:r};return B.runKernel(Jm,{x:a},s)}var _Q=W({staticRegexReplace_:NQ}),bO={fft:wg,ifft:Qh,rfft:kg,irfft:Pb},vO={hammingWindow:eJ,hannWindow:dO,frame:pO,stft:aJ},ra={flipLeftRight:lJ,grayscaleToRGB:cJ,resizeNearestNeighbor:xO,resizeBilinear:yO,rgbToGrayscale:dJ,rotateWithOffset:fJ,cropAndResize:iJ,nonMaxSuppression:gJ,nonMaxSuppressionAsync:IJ,nonMaxSuppressionWithScore:_J,nonMaxSuppressionWithScoreAsync:TJ,nonMaxSuppressionPadded:AJ,nonMaxSuppressionPaddedAsync:MJ,threshold:zJ,transform:LJ},QI={bandPart:WJ,gramSchmidt:VJ,qr:GJ},wO={absoluteDifference:KJ,computeWeightedLoss:yi,cosineDistance:ZJ,hingeLoss:JJ,huberLoss:eQ,logLoss:nQ,meanSquaredError:aQ,sigmoidCrossEntropy:oQ,softmaxCrossEntropy:cQ},kO={sparseFillEmptyRows:dQ,sparseReshape:fQ,sparseSegmentMean:gQ,sparseSegmentSum:xQ},SO={stringNGrams:vQ,stringSplit:kQ,stringToHashBucketFast:IQ,staticRegexReplace:_Q},se={};Re(se,{Serializable:()=>IO,SerializationMap:()=>NO,getRegisteredName:()=>TQ,registerClass:()=>_O});var CQ=new Map,Tk=new Map,IO=class{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}},NO=class uh{constructor(){this.classNameMap={}}static getMap(){return uh.instance==null&&(uh.instance=new uh),uh.instance}static register(t){uh.getMap().classNameMap[t.className]=[t,t.fromConfig]}};function _O(e,t,n){R(e.className!=null,()=>"Class being registered does not have the static className property defined."),R(typeof e.className=="string",()=>"className is required to be a string, but got type "+typeof e.className),R(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof t>"u"&&(t="Custom"),typeof n>"u"&&(n=e.className);let r=n,a=t+">"+r;return NO.register(e),CQ.set(a,e),Tk.set(e,a),e}function TQ(e){return Tk.has(e)?Tk.get(e):e.className}var xi=class extends IO{minimize(e,t=!1,n){let{value:r,grads:a}=this.computeGradients(e,n);if(n!=null){let s=n.map(i=>({name:i.name,tensor:a[i.name]}));this.applyGradients(s)}else this.applyGradients(a);return Fe(a),t?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return _3(e,t)}dispose(){this.iterations_!=null&&Fe(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:_e(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}};Object.defineProperty(xi,Symbol.hasInstance,{value:e=>e.minimize!=null&&e.computeGradients!=null&&e.applyGradients!=null});var eN=class extends xi{static get className(){return"Adadelta"}constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],n==null&&(this.epsilon=B.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=B.registeredVariables[t],a=!1;this.accumulatedGrads[n]==null&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:j(()=>Ye(r).variable(a))}),this.accumulatedUpdates[n]==null&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:j(()=>Ye(r).variable(a))});let s=Array.isArray(e)?e[n].tensor:e[t];if(s==null)return;let i=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;j(()=>{let l=te(U(i,this.rho),U(gt(s),1-this.rho)),c=U(xe(wn(te(o,this.epsilon)),wn(te(i,this.epsilon))),s),u=te(U(o,this.rho),U(gt(c),1-this.rho));i.assign(l),o.assign(u);let h=te(U(c,-this.learningRate),r);r.assign(h)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Fe(this.accumulatedGrads.map(e=>e.variable)),Fe(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){let e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=e.length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.accumulatedUpdates=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}},tN=class extends xi{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=B.registeredVariables[t];this.accumulatedGrads[n]==null&&(this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:j(()=>Wr(r.shape,this.initialAccumulatorValue).variable(!1))});let a=Array.isArray(e)?e[n].tensor:e[t];if(a==null)return;let s=this.accumulatedGrads[n].variable;j(()=>{let i=te(s,gt(a));s.assign(i);let o=te(U(xe(a,wn(te(i,B.backend.epsilon()))),-this.learningRate),r);r.assign(o)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Fe(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulatedGrads=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}},nN=class extends xi{static get className(){return"Adam"}constructor(e,t,n,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],j(()=>{this.accBeta1=_e(t).variable(),this.accBeta2=_e(n).variable()}),r==null&&(this.epsilon=B.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);j(()=>{let n=me(1,this.accBeta1),r=me(1,this.accBeta2);t.forEach((a,s)=>{let i=B.registeredVariables[a],o=!1;this.accumulatedFirstMoment[s]==null&&(this.accumulatedFirstMoment[s]={originalName:`${a}/m`,variable:j(()=>Ye(i).variable(o))}),this.accumulatedSecondMoment[s]==null&&(this.accumulatedSecondMoment[s]={originalName:`${a}/v`,variable:j(()=>Ye(i).variable(o))});let l=Array.isArray(e)?e[s].tensor:e[a];if(l==null)return;let c=this.accumulatedFirstMoment[s].variable,u=this.accumulatedSecondMoment[s].variable,h=te(U(c,this.beta1),U(l,1-this.beta1)),d=te(U(u,this.beta2),U(gt(l),1-this.beta2)),p=xe(h,n),f=xe(d,r);c.assign(h),u.assign(d);let m=te(U(xe(p,te(wn(f),this.epsilon)),-this.learningRate),i);i.assign(m)}),this.accBeta1.assign(U(this.accBeta1,this.beta1)),this.accBeta2.assign(U(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Fe(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&Fe(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),j(()=>{this.accBeta1.assign(Ts(this.beta1,this.iterations_+1)),this.accBeta2.assign(Ts(this.beta2,this.iterations_+1))});let t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}},rN=class extends xi{static get className(){return"Adamax"}constructor(e,t,n,r=null,a=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],j(()=>{this.iteration=_e(0).variable(),this.accBeta1=_e(t).variable()}),r==null&&(this.epsilon=B.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);j(()=>{let n=me(1,this.accBeta1),r=xe(-this.learningRate,te(U(this.iteration,this.decay),1));t.forEach((a,s)=>{let i=B.registeredVariables[a],o=!1;this.accumulatedFirstMoment[s]==null&&(this.accumulatedFirstMoment[s]={originalName:`${a}/m`,variable:Ye(i).variable(o)}),this.accumulatedWeightedInfNorm[s]==null&&(this.accumulatedWeightedInfNorm[s]={originalName:`${a}/v`,variable:Ye(i).variable(o)});let l=Array.isArray(e)?e[s].tensor:e[a];if(l==null)return;let c=this.accumulatedFirstMoment[s].variable,u=this.accumulatedWeightedInfNorm[s].variable,h=te(U(c,this.beta1),U(l,1-this.beta1)),d=U(u,this.beta2),p=Kt(l),f=Ms(d,p);c.assign(h),u.assign(f);let m=te(U(xe(r,n),xe(h,te(f,this.epsilon))),i);i.assign(m)}),this.iteration.assign(te(this.iteration,1)),this.accBeta1.assign(U(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Fe(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&Fe(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}},Zb=class extends xi{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=Array.isArray(e)?e[n].tensor:e[t];if(r==null)return;let a=B.registeredVariables[t];j(()=>{let s=te(U(this.c,r),a);a.assign(s)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=an(_e(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}},aN=class extends Zb{static get className(){return"Momentum"}constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=_e(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=B.registeredVariables[t];this.accumulations[n]==null&&(this.accumulations[n]={originalName:`${t}/momentum`,variable:j(()=>Ye(r).variable(!1))});let a=this.accumulations[n].variable,s=Array.isArray(e)?e[n].tensor:e[t];s!=null&&j(()=>{let i,o=te(U(this.m,a),s);this.useNesterov?i=te(U(this.c,te(s,U(o,this.m))),r):i=te(U(this.c,o),r),a.assign(o),r.assign(i)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Fe(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulations=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}},sN=class extends xi{static get className(){return"RMSProp"}constructor(e,t=.9,n=0,r=null,a=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,r==null&&(this.epsilon=B.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=B.registeredVariables[t],a=!1;this.accumulatedMeanSquares[n]==null&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:j(()=>Ye(r).variable(a))}),this.accumulatedMoments[n]==null&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:j(()=>Ye(r).variable(a))}),this.accumulatedMeanGrads[n]==null&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:j(()=>Ye(r).variable(a))});let s=Array.isArray(e)?e[n].tensor:e[t];if(s==null)return;let i=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;j(()=>{let l=te(U(i,this.decay),U(gt(s),1-this.decay));if(this.centered){let c=this.accumulatedMeanGrads[n].variable,u=te(U(c,this.decay),U(s,1-this.decay)),h=xe(U(s,this.learningRate),wn(me(l,te(gt(u),this.epsilon)))),d=te(U(o,this.momentum),h);i.assign(l),c.assign(u),o.assign(d);let p=me(r,d);r.assign(p)}else{let c=te(U(i,this.decay),U(gt(s),1-this.decay)),u=te(U(o,this.momentum),xe(U(s,this.learningRate),wn(te(c,this.epsilon))));i.assign(c),o.assign(u);let h=me(r,u);r.assign(h)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Fe(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Fe(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&Fe(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.accumulatedMoments=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}},EQ=[eN,tN,nN,rN,aN,sN,Zb];function AQ(){for(let e of EQ)_O(e)}var Mn={};Re(Mn,{CompositeArrayBuffer:()=>fi,browserFiles:()=>zQ,browserHTTPRequest:()=>VQ,concatenateArrayBuffers:()=>y9,copyModel:()=>L9,decodeWeights:()=>JD,decodeWeightsStream:()=>e3,encodeWeights:()=>h9,fromMemory:()=>GQ,fromMemorySync:()=>$O,getLoadHandlers:()=>N9,getModelArtifactsForJSON:()=>qS,getModelArtifactsForJSONSync:()=>n3,getModelArtifactsInfoForJSON:()=>lg,getSaveHandlers:()=>I9,getWeightSpecs:()=>kk,http:()=>oN,isHTTPScheme:()=>Ak,listModels:()=>z9,loadWeights:()=>LQ,moveModel:()=>B9,registerLoadRouter:()=>S9,registerSaveRouter:()=>k9,removeModel:()=>P9,weightsLoaderFactory:()=>TO,withSaveHandler:()=>HQ,withSaveHandlerSync:()=>qQ});var $Q="model",MQ=".json",FQ=".weights.bin";function PA(e){return new Promise(t=>setTimeout(t)).then(e)}var ix=class Ek{constructor(t){if(!X().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(Ek.URL_SCHEME)&&(t=t.slice(Ek.URL_SCHEME.length)),(t==null||t.length===0)&&(t=$Q),this.modelJsonFileName=t+MQ,this.weightDataFileName=t+FQ}async save(t){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let n=fi.join(t.weightData),r=window.URL.createObjectURL(new Blob([n],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let a=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],s=t3(t,a),i=window.URL.createObjectURL(new Blob([JSON.stringify(s)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=i,await PA(()=>o.dispatchEvent(new MouseEvent("click"))),t.weightData!=null){let l=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;l.download=this.weightDataFileName,l.href=r,await PA(()=>l.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:lg(t)}}}};ix.URL_SCHEME="downloads://";var RQ=class{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{let n=new FileReader;n.onload=r=>{let a=JSON.parse(r.target.result),s=a.modelTopology;if(s==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(a.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:s});return}let i=qS(a,o=>this.loadWeights(o));e(i)},n.onerror=r=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)})}loadWeights(e){let t=[],n=[];for(let s of e)t.push(...s.weights),n.push(...s.paths);let r=this.checkManifestAndWeightFiles(e),a=n.map(s=>this.loadWeightsFile(s,r[s]));return Promise.all(a).then(s=>[t,s])}loadWeightsFile(e,t){return new Promise((n,r)=>{let a=new FileReader;a.onload=s=>{let i=s.target.result;n(i)},a.onerror=s=>r(`Failed to weights data from file of path '${e}'.`),a.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){let t=[],n=this.weightsFiles.map(a=>DA(a.name)),r={};for(let a of e)a.paths.forEach(s=>{let i=DA(s);if(t.indexOf(i)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${i}'`);if(t.push(i),n.indexOf(i)===-1)throw new Error(`Weight file with basename '${i}' is not provided.`);r[s]=this.weightsFiles[n.indexOf(i)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}},DQ=e=>X().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(ix.URL_SCHEME)?OQ(e.slice(ix.URL_SCHEME.length)):null;ha.registerSaveRouter(DQ);function OQ(e="model"){return new ix(e)}function zQ(e){return new RQ(e)}function LA(e,t,n,r){i(e),n=n??0,r=r??1,o(n,r);let a=0,s=l=>(l.then(c=>{let u=n+ ++a/e.length*(r-n);return t(u),c}),l);function i(l){R(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function o(l,c){R(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),R(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${c}`),R(c>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${c}`)}return Promise.all(e.map(s))}async function CO(e,t){t==null&&(t={});let n=t.fetchFunc==null?X().platform.fetch:t.fetchFunc,r=e.map(s=>n(s,t.requestInit,{isBinary:!0})),a=(t.onProgress==null?await Promise.all(r):await LA(r,t.onProgress,0,.5)).map(s=>s.arrayBuffer());return t.onProgress==null?await Promise.all(a):await LA(a,t.onProgress,.5,1)}function PQ(e,t){var n;let r=t.fetchFunc==null?X().platform.fetch:t.fetchFunc,a=0,s;return(n=t.onProgress)===null||n===void 0||n.call(t,0),new ReadableStream({pull:async i=>{for(var o;a<e.length;){s||(s=(await r(e[a],t.requestInit,{isBinary:!0})).body.getReader());let{done:l,value:c}=await s.read();if(l){a++,s=void 0,(o=t.onProgress)===null||o===void 0||o.call(t,a/e.length);continue}i.enqueue(c);return}i.close()}})}async function LQ(e,t="",n,r){return TO(a=>CO(a,{requestInit:r}))(e,t,n)}function TO(e){return async(t,n="",r)=>{let a=t.map(()=>!1),s={},i=r!=null?r.map(()=>!1):[],o=[];if(t.forEach((p,f)=>{let m=0;p.weights.forEach(y=>{let g="quantization"in y?y.quantization.dtype:y.dtype,x=Wl[g]*dt(y.shape),b=()=>{a[f]=!0,s[f]==null&&(s[f]=[]),s[f].push({manifestEntry:y,groupOffset:m,sizeBytes:x})};r!=null?r.forEach((v,w)=>{v===y.name&&(b(),i[w]=!0)}):b(),o.push(y.name),m+=x})}),!i.every(p=>p)){let p=r.filter((f,m)=>!i[m]);throw new Error(`Could not find weights in manifest with names: ${p.join(", ")}. 
Manifest JSON has weights with names: ${o.join(", ")}.`)}let l=a.reduce((p,f,m)=>(f&&p.push(m),p),[]),c=[];l.forEach(p=>{t[p].paths.forEach(f=>{let m=n+(n.endsWith("/")?"":"/")+f;c.push(m)})});let u=await e(c),h={},d=0;return l.forEach(p=>{let f=t[p].paths.length,m=new fi(u.slice(d,d+f));s[p].forEach(y=>{let g=m.slice(y.groupOffset,y.groupOffset+y.sizeBytes),x=JD(g,[y.manifestEntry]);for(let b in x)h[b]=x[b]}),d+=f}),h}}var BQ="application/octet-stream",WQ="application/json",iN=class{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(R(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=X().platform.fetch,R(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&R(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;let n=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=t3(e,n);if(t.body.append("model.json",new Blob([JSON.stringify(r)],{type:WQ}),"model.json"),e.weightData!=null){let s=fi.join(e.weightData);t.body.append("model.weights.bin",new Blob([s],{type:BQ}),"model.weights.bin")}let a=await this.fetch(this.path,t);if(a.ok)return{modelArtifactsInfo:lg(e),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)}async loadModelJSON(){let e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let s=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?s+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":s+=" Please make sure the server is serving valid JSON for this request.",new Error(s)}let n=t.modelTopology,r=t.weightsManifest;if(n==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();let e=await this.loadModelJSON();return qS(e,t=>this.loadWeights(t))}async loadStream(){let e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=kk(e.weightsManifest),r=()=>PQ(t,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:r})}async getWeightUrls(e){let t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=UQ(t),a=this.weightPathPrefix||n,s=[],i=[];for(let o of e)for(let l of o.paths)this.weightUrlConverter!=null?i.push(this.weightUrlConverter(l)):s.push(a+l+r);return this.weightUrlConverter&&s.push(...await Promise.all(i)),s}async loadWeights(e){let t=await this.getWeightUrls(e),n=kk(e),r=await CO(t,this.loadOptions);return[n,r]}};iN.URL_SCHEME_REGEX=/^https?:\/\//;function UQ(e){let t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),r=e.substring(0,t),a=n>t?e.substring(n):"";return[r+"/",a]}function Ak(e){return e.match(iN.URL_SCHEME_REGEX)!=null}var EO=(e,t)=>{if(typeof fetch>"u"&&(t==null||t.fetchFunc==null))return null;{let n=!0;if(Array.isArray(e)?n=e.every(r=>Ak(r)):n=Ak(e),n)return oN(e,t)}return null};ha.registerSaveRouter(EO);ha.registerLoadRouter(EO);function oN(e,t){return new iN(e,t)}function VQ(e,t){return oN(e,t)}var Gw=class{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}},AO=class{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}},jQ=class{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}};function GQ(e,t,n,r){let a=arguments;return new jQ($O(...a))}function $O(e,t,n,r){return arguments.length===1?e.modelTopology!=null||e.weightSpecs!=null?new Gw(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Gw({modelTopology:e})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Gw({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:r}))}function HQ(e){return new AO(e)}function qQ(e){return new AO(e)}var MO={};Re(MO,{confusionMatrix:()=>XQ});function KQ(e,t,n){let r=$(e,"labels","confusionMatrix"),a=$(t,"predictions","confusionMatrix");R(n==null||n>0&&Number.isInteger(n),()=>`If provided, numClasses must be a positive integer, but got ${n}`),R(r.rank===1,()=>`Expected the rank of labels to be 1, but got ${r.rank}`),R(a.rank===1,()=>`Expected the rank of predictions to be 1, but got ${a.rank}`),R(r.shape[0]===a.shape[0],()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${a.shape[0]}. Labels and predictions should have the same number of elements.`),R(n>0&&Number.isInteger(n),()=>`numClasses is required to be a positive integer, but got ${n}`);let s=Zh(le(r,"int32"),n),i=Zh(le(a,"int32"),n),o=Ue(s),l=We(o,i);return le(l,"int32")}var XQ=W({confusionMatrix_:KQ}),Sg={};Re(Sg,{draw:()=>ree,fromPixels:()=>aee,fromPixelsAsync:()=>eee,toPixels:()=>nee});var rl,BA=!1;function FO(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(e==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,a=!1,s=!1,i=!1,o=!1;if(e.data instanceof Uint8Array)n=!0;else if(typeof ImageData<"u"&&e instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&e instanceof HTMLVideoElement)a=!0;else if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement)s=!0;else if(e.getContext!=null)i=!0;else if(typeof ImageBitmap<"u"&&e instanceof ImageBitmap)o=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);if(um(nx,B.backendName)!=null){let d={pixels:e},p={numChannels:t};return B.runKernel(nx,d,p)}let[l,c]=a?[e.videoWidth,e.videoHeight]:[e.width,e.height],u;if(i)u=e.getContext("2d").getImageData(0,0,l,c).data;else if(r||n)u=e.data;else if(s||a||o){if(rl==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")rl=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else rl=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});rl.canvas.width=l,rl.canvas.height=c,rl.drawImage(e,0,0,l,c),u=rl.getImageData(0,0,l,c).data}let h;if(t===4)h=new Int32Array(u);else{let d=l*c;h=new Int32Array(d*t);for(let p=0;p<d;p++)for(let f=0;f<t;++f)h[p*t+f]=u[p*4+f]}return Bb(h,[c,l,t],"int32")}function ZQ(e){return e!=null&&e.data instanceof Uint8Array}function YQ(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function JQ(e){return e!=null&&e.width!==0&&e.height!==0}function QQ(e){return YQ()&&!(e instanceof ImageBitmap)&&JQ(e)&&!ZQ(e)}async function eee(e,t=3){let n=null;if(X().getBool("WRAP_TO_IMAGEBITMAP")&&QQ(e)){let r;try{r=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch{r=null}r!=null&&r.width===e.width&&r.height===e.height?n=r:n=e}else n=e;return FO(n,t)}function RO(e){if(e.rank!==2&&e.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);let t=e.rank===2?1:e.shape[2];if(t>4||t===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);if(e.dtype!=="float32"&&e.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`)}function tee(e){let t=(e==null?void 0:e.alpha)||1;if(t>1||t<0)throw new Error(`Alpha value ${t} is suppoed to be in range [0 - 1].`)}async function nee(e,t){let n=$(e,"img","toPixels");if(!(e instanceof ze)){let c=n;n=le(c,"int32"),c.dispose()}RO(n);let[r,a]=n.shape.slice(0,2),s=n.rank===2?1:n.shape[2],i=await n.data(),o=n.dtype==="float32"?255:1,l=new Uint8ClampedArray(a*r*4);for(let c=0;c<r*a;++c){let u=[0,0,0,255];for(let d=0;d<s;d++){let p=i[c*s+d];if(n.dtype==="float32"){if(p<0||p>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${p}.`)}else if(n.dtype==="int32"&&(p<0||p>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${p}.`);s===1?(u[0]=p*o,u[1]=p*o,u[2]=p*o):u[d]=p*o}let h=c*4;l[h+0]=Math.round(u[0]),l[h+1]=Math.round(u[1]),l[h+2]=Math.round(u[2]),l[h+3]=Math.round(u[3])}if(t!=null){BA||um(ib,B.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),BA=!0),t.width=a,t.height=r;let c=t.getContext("2d"),u=new ImageData(l,a,r);c.putImageData(u,0,0)}return n!==e&&n.dispose(),l}function ree(e,t,n){let r=$(e,"img","draw");if(!(e instanceof ze)){let i=r;r=le(i,"int32"),i.dispose()}RO(r),tee(n==null?void 0:n.imageOptions);let a={image:r},s={canvas:t,options:n};B.runKernel(ib,a,s)}var aee=W({fromPixels_:FO}),lN={};Re(lN,{prepareAndValidate:()=>DO});function DO(e,t){let n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(dt(e.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);let a=t.shape,s=a[a.length-1],i=1;for(let h=0;h<a.length-1;++h)i*=a[h];let o=e.shape,l=a.slice();l.pop();let c=1;for(let h=s;h<n;++h)c*=o[h],l.push(o[h]);let u=[...md(e.shape).map(h=>h/c),1].slice(0,s);return[l,i,c,u]}var ln={};Re(ln,{assertParamsValid:()=>iee,computeFlatOffset:()=>hee,computeOutShape:()=>lee,getNormalizedAxes:()=>uee,isSliceContinous:()=>cee,maskToAxes:()=>oee,parseSliceParams:()=>jO,sliceInfo:()=>dee,startForAxis:()=>UO,startIndicesWithElidedDims:()=>LO,stopForAxis:()=>VO,stopIndicesWithElidedDims:()=>BO,stridesForAxis:()=>WO,stridesWithElidedDims:()=>OO});var $k=-2,see=-1;function iee(e,t,n){let r=e.shape.length;R(r===t.length,()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`),R(r===n.length,()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`);for(let a=0;a<r;++a)R(t[a]+n[a]<=e.shape[a],()=>`Error in slice${r}D: begin[${a}] + size[${a}] (${t[a]+n[a]}) would overflow input.shape[${a}] (${e.shape[a]})`)}function oee(e){let t=[],n=0;for(;e>0;)e&1&&t.push(n),e/=2,n++;return t}function lee(e,t,n){let r=[];for(let a=0;a<e.length;a++)r[a]=Math.ceil((t[a]-e[a])/n[a]);return r}function OO(e,t,n,r){let a=[...e];for(let s=a.length;s<r.length;s++)a.push(1);for(let s=0;s<n;s++)s===0?a[t]=1:(a.splice(t,0,1),a.pop());return a}function zO(e,t,n){return n<=e?n:n-(t-1)}function PO(e,t){let n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function uee(e,t,n,r,a,s,i,o,l){let c=e.length,u=new Array(c),h=new Array(c),d=new Array(c);if(t.length&&n>0){let p=t[0],f=n+1;u=LO(i,p,f,r,e),h=BO(o,p,f,a,e),d=OO(s,p,f,e)}else for(let p=0;p<c;p++)u[p]=UO(i,r,s,e,p,l),h[p]=VO(o,a,s,e,p,l),d[p]=WO(s,p,l);return{begin:u,end:h,strides:d}}function LO(e,t,n,r,a){let s=[...a],i=PO(n,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=0;else{let l=zO(t,n,o),c=r[l];e&1<<l&&(c=0),s[o]=c}return s}function BO(e,t,n,r,a){let s=[...a],i=PO(n,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=Number.MAX_SAFE_INTEGER;else{let l=zO(t,n,o),c=r[l];e&1<<l&&(c=Number.MAX_SAFE_INTEGER),s[o]=c}for(let o=0;o<s.length;o++){let l=a[o];s[o]<0&&(s[o]+=l),s[o]=om(0,s[o],a[o])}return s}function WO(e,t,n){let r=e[t];return(n&1<<t||r==null)&&(r=1),r}function UO(e,t,n,r,a,s){let i=t[a],o=n[a]||1;(e&1<<a||s&1<<a||i==null)&&(o>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);let l=r[a];return i<0&&(i+=l),i=om(0,i,l-1),i}function VO(e,t,n,r,a,s){let i=t[a],o=n[a]||1;(e&1<<a||s&1<<a||i==null)&&(o>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);let l=r[a];return i<0&&(i+=l),o>0?i=om(0,i,l):i=om(-1,i,l-1),i}function cee(e,t,n){let r=n.length;for(let a=0;a<n.length;a++)if(n[a]>1){r=a;break}for(let a=r+1;a<n.length;a++)if(t[a]>0||n[a]!==e[a])return!1;return!0}function hee(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function jO(e,t,n){let r,a=e.shape.length;typeof t=="number"?r=[t,...new Array(a-1).fill(0)]:t.length<a?r=t.concat(new Array(a-t.length).fill(0)):r=t.slice(),r.forEach(i=>{R(i!==-1,()=>"slice() does not support negative begin indexing.")});let s;return n==null?s=new Array(a).fill(-1):typeof n=="number"?s=[n,...new Array(a-1).fill(-1)]:n.length<a?s=n.concat(new Array(a-n.length).fill(-1)):s=n,s=s.map((i,o)=>i>=0?i:(R(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${o}.`),e.shape[o]-r[o])),[r,s]}function dee(e,t,n,r,a,s,i,o,l){let c;if(r==null?(c=new Array(t.length),c.fill(1)):c=r,i!=null&&i&i-1)throw new Error("Multiple ellipses in slice is not allowed.");let u=!1,h={dims:c.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:c.slice(),beginMask:a,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};for(let x=0;x<h.dims;x++)u&&1<<x&o&&h.numAddAxisAfterEllipsis++,1<<x&i&&(u=!0);u||(h.ellipsisMask|=1<<h.dims,h.dims++);let d={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};pee(h,d);let p=!0,f=!0,m=!0,y=[],g=[];for(let x=0;x<e.length;++x){if(d.strides[x]===0)throw Error(`strides[${x}] must be non-zero`);let b=!!(d.shrinkAxisMask&1<<x),v=e[x];if(v===-1){y.push(b?1:-1);continue}let w=[d.beginMask&1<<x,d.endMask&1<<x],I=[d.strides[x]>0?0:-1,d.strides[x]>0?v:v-1];if(b&&d.strides[x]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&d.strides[x]===1;let _=!!(d.beginMask&1<<x&&d.endMask&1<<x);if(d.beginValid&&d.endValid){if(b){let F=d.begin[x]<0?v+d.begin[x]:d.begin[x];if(d.begin[x]=F,d.end[x]=d.begin[x]+1,F<0||F>=v)throw Error(`slice index ${d.begin[x]} of dimension ${x} out of bounds.`)}else d.begin[x]=WA(d.begin[x],0,d.strides[x],v,w,I),d.end[x]=WA(d.end[x],1,d.strides[x],v,w,I);let M=d.strides[x]===1&&d.begin[x]===0&&d.end[x]===v;p=p&&M,f=f&&(x===0&&d.strides[x]===1||M)}else p=p&&d.strides[x]===1&&_,f=f&&(x===0&&d.strides[x]===1||_);let T,A=!1;if(d.beginValid&&d.endValid?(T=d.end[x]-d.begin[x],A=!0):b?(T=1,A=!0):_&&v>=0&&(d.strides[x]<0?T=-v:T=v,A=!0),A){let M;T===0||T<0!=d.strides[x]<0?M=0:M=Math.trunc(T/d.strides[x])+(T%d.strides[x]!==0?1:0),y.push(M)}else y.push(-1)}for(let x=0;x<d.finalShapeGatherIndices.length;++x){let b=d.finalShapeGatherIndices[x];b>=0?g.push(y[b]):b===$k&&g.push(1)}return{finalShapeSparse:g.filter((x,b)=>d.finalShapeGatherIndices[b]!==$k),finalShape:g,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:d.begin,end:d.end,strides:d.strides}}function pee(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=e.begin!=null,t.endValid=e.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){let a=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<a;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push($k),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);e.begin!=null&&(t.begin[n]=e.begin[r]),e.end!=null&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(see),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}function WA(e,t,n,r,a,s){if(a[t])return n>0?s[t]:s[t+1&1];{let i=e<0?r+e:e;return i<s[0]?s[0]:i>s[1]?s[1]:i}}var fee="4.22.0",GO=class{static sgd(e){return new Zb(e)}static momentum(e,t,n=!1){return new aN(e,t,n)}static rmsprop(e,t=.9,n=0,r=null,a=!1){return new sN(e,t,n,r,a)}static adam(e=.001,t=.9,n=.999,r=null){return new nN(e,t,n,r)}static adadelta(e=.001,t=.95,n=null){return new eN(e,t,n)}static adamax(e=.002,t=.9,n=.999,r=null,a=0){return new rN(e,t,n,r,a)}static adagrad(e,t=.1){return new tN(e,t)}},ul=GO,mee=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:e=>e();function uN(){return new Promise(e=>mee(()=>e()))}var E={};Re(E,{ERF_A1:()=>Aee,ERF_A2:()=>$ee,ERF_A3:()=>Mee,ERF_A4:()=>Fee,ERF_A5:()=>Ree,ERF_P:()=>Eee,PARALLELIZE_THRESHOLD:()=>cN,RowPartitionType:()=>ms,SELU_SCALE:()=>qO,SELU_SCALEALPHA:()=>HO,applyActivation:()=>Kb,assertAndGetBroadcastShape:()=>bt,assertAxesAreInnerMostDims:()=>dX,assertParamsConsistent:()=>gee,assignToTypedArray:()=>Bee,axesAreInnerMostDims:()=>wI,calculateShapes:()=>eO,checkEinsumDimSizes:()=>Hee,checkPadOnDimRoundingMode:()=>ir,combineLocations:()=>w3,combineRaggedTensorToTensorShapes:()=>xee,complexWithEvenIndex:()=>zee,complexWithOddIndex:()=>Pee,computeConv2DInfo:()=>ug,computeConv3DInfo:()=>d3,computeDefaultPad:()=>rI,computeDilation2DInfo:()=>cK,computeOptimalWindowSize:()=>kee,computeOutAndReduceShapes:()=>k3,computeOutShape:()=>yee,computePool2DInfo:()=>h3,computePool3DInfo:()=>hK,convertConv2DDataFormat:()=>p3,decodeEinsumEquation:()=>jee,eitherStridesOrDilationsAreOne:()=>$s,expandShapeToKeepDim:()=>Hl,exponent:()=>Uee,exponents:()=>Wee,fromStringArrayToUint8:()=>pte,fromUint8ToStringArray:()=>dte,getAxesPermutation:()=>S3,getBroadcastDims:()=>b3,getComplexWithIndex:()=>Lee,getEinsumComputePath:()=>qee,getEinsumPermutation:()=>Gee,getFusedBiasGradient:()=>qb,getFusedDyActivation:()=>Hb,getImageCenter:()=>See,getInnerMostAxes:()=>pX,getPermuted:()=>Nee,getRaggedRank:()=>vee,getReductionAxes:()=>Qt,getReshaped:()=>Iee,getReshapedPermuted:()=>_ee,getRowPartitionTypesHelper:()=>bee,getSliceBeginCoords:()=>Cee,getSliceSize:()=>Tee,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>Yee,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>Jee,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>Qee,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>nte,getSparseReshapeInputOutputMismatchErrorMessage:()=>ate,getSparseReshapeInputOutputMultipleErrorMessage:()=>rte,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>ete,getSparseReshapeNegativeOutputDimErrorMessage:()=>tte,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>lte,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>ste,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>ite,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>ote,getUndoAxesPermutation:()=>kI,isIdentityPermutation:()=>Kee,log:()=>k7,mergeRealAndImagArrays:()=>Dee,prepareAndValidate:()=>DO,prepareSplitSize:()=>Zee,segment_util:()=>KO,shouldFuse:()=>Xb,slice_util:()=>ln,splitRealAndImagArrays:()=>Oee,stridesOrDilationsArePositive:()=>Gl,tupleValuesAreOne:()=>bo,upcastType:()=>ca,validateDefaultValueShape:()=>wee,validateInput:()=>Ub,validateUpdateShape:()=>jI,warn:()=>ji});function gee(e,t){let n=e[0].length;e.forEach((a,s)=>{R(a.length===n,()=>`Error in concat${n}D: rank of tensors[${s}] must be the same as the rank of the rest (${n})`)}),R(t>=0&&t<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);let r=e[0];e.forEach((a,s)=>{for(let i=0;i<n;i++)R(i===t||a[i]===r[i],()=>`Error in concat${n}D: Shape of tensors[${s}] (${a}) does not match the shape of the rest (${r}) along the non-concatenated axis ${s}.`)})}function yee(e,t){let n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}var ms;(function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"})(ms||(ms={}));function xee(e,t,n){let r=new Array;if(n==null&&t==null)return r;if(t==null)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(n==null)return r;if(e+n.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let a=1;a<n.length;++a){let s=n[a],i=r[r.length-n.length+a],o=r[i];if(s>=0)if(o>=0){if(o!==s)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${a+e}] = ${s} but shape[${a+e}] = ${o}`)}else r[i]=s}return r}function bee(e){let t={FIRST_DIM_SIZE:ms.FIRST_DIM_SIZE,VALUE_ROWIDS:ms.VALUE_ROWIDS,ROW_LENGTHS:ms.ROW_LENGTHS,ROW_SPLITS:ms.ROW_SPLITS,ROW_LIMITS:ms.ROW_LIMITS,ROW_STARTS:ms.ROW_STARTS},n=[];for(let r of e)if(r in t)n.push(t[r]);else break;return n}function vee(e){return e.length===0?0:e[0]===ms.FIRST_DIM_SIZE?e.length-1:e.length}function wee(e,t){if(e==null||t==null)return;let n=e.length,r=t.length;if(n>=r)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let a=0;a<Math.min(n,r-1);++a){let s=e[a],i=t[a+1];if(s>=0&&i>=0&&s!==1&&s!==i)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${a-e.length}] = ${s} but ragged tensor input.flatValues.shape[${a-e.length}] = ${i}`)}}var cN=30;function kee(e){return e<=cN?e:tx(e,Math.floor(Math.sqrt(e)))}function See(e,t,n){let r=n*(typeof e=="number"?e:e[0]),a=t*(typeof e=="number"?e:e[1]);return[r,a]}function Iee(e,t,n,r=!0){let a=[];if(r)a=a.concat(t.slice(0)),a.push(e[0]/n),a=a.concat(e.slice(1));else{a=a.concat(e[0]);let s=t.length;for(let i=0;i<s;++i)a=a.concat([e[i+1]/t[i],t[i]]);a=a.concat(e.slice(s+1))}return a}function Nee(e,t,n=!0){let r=[];if(n){r.push(t);for(let a=t+1;a<e;++a)a<=2*t?(r.push(a),r.push(a-(t+1))):r.push(a)}else{let a=[],s=[];for(let i=1;i<e;++i)i>=t*2+1||i%2===1?s.push(i):a.push(i);r.push(...a),r.push(0),r.push(...s)}return r}function _ee(e,t,n,r=!0){let a=[];r?a.push(e[0]/n):a.push(e[0]*n);for(let s=1;s<e.length;++s)s<=t.length?r?a.push(t[s-1]*e[s]):a.push(e[s]/t[s-1]):a.push(e[s]);return a}function Cee(e,t){let n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function Tee(e,t,n){let r=e.slice(0,1);for(let a=0;a<n;++a)r.push(e[a+1]-t[a][0]-t[a][1]);return r}var HO=1.7580993408473768,qO=1.0507009873554805,Eee=.3275911,Aee=.254829592,$ee=-.284496736,Mee=1.421413741,Fee=-1.453152027,Ree=1.061405429;function Dee(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);let n=new Float32Array(e.length*2);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function Oee(e){let t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function zee(e){let t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let a=0;a<e.length;a+=4)n[Math.floor(a/4)]=e[a],r[Math.floor(a/4)]=e[a+1];return{real:n,imag:r}}function Pee(e){let t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let a=2;a<e.length;a+=4)n[Math.floor(a/4)]=e[a],r[Math.floor(a/4)]=e[a+1];return{real:n,imag:r}}function Lee(e,t){let n=e[t*2],r=e[t*2+1];return{real:n,imag:r}}function Bee(e,t,n,r){e[r*2]=t,e[r*2+1]=n}function Wee(e,t){let n=new Float32Array(e/2),r=new Float32Array(e/2);for(let a=0;a<Math.ceil(e/2);a++){let s=(t?2:-2)*Math.PI*(a/e);n[a]=Math.cos(s),r[a]=Math.sin(s)}return{real:n,imag:r}}function Uee(e,t,n){let r=(n?2:-2)*Math.PI*(e/t),a=Math.cos(r),s=Math.sin(r);return{real:a,imag:s}}var Hw="->",Vee=/->/g,UA=",",VA="...";function jee(e,t){e=e.replace(/\s/g,"");let n=(e.length-e.replace(Vee,"").length)/Hw.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${Hw}").`);let[r,a]=e.split(Hw);R(r.indexOf(VA)===-1,()=>`The ellipsis notation ("${VA}") is not supported yet.`);let s=r.split(UA),i=s.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let o=[];for(let d=0;d<a.length;++d){let p=a[d];if(!s.some(f=>f.indexOf(p)!==-1))throw new Error(`Output subscripts contain the label ${p} not present in the input subscripts.`);o.indexOf(p)===-1&&o.push(p)}for(let d=0;d<r.length;++d){let p=r[d];o.indexOf(p)===-1&&p!==UA&&o.push(p)}let l=new Array(s.length);for(let d=0;d<i;++d){if(new Set(s[d].split("")).size!==s[d].length)throw new Error(`Found duplicate axes in input component ${s[d]}. Support for duplicate axes in input is not implemented yet.`);l[d]=[];for(let p=0;p<s[d].length;++p)l[d].push(o.indexOf(s[d][p]))}let c=o.length,u=a.length,h=[];for(let d=u;d<c;++d)h.push(d);return{allDims:o,summedDims:h,idDims:l}}function Gee(e,t){let n=new Array(e);n.fill(-1);for(let a=0;a<t.length;++a)n[t[a]]=a;let r=[];for(let a=0;a<e;++a)n[a]===-1&&r.push(a);return n=n.filter(a=>a!==-1),{permutationIndices:n,expandDims:r}}function Hee(e,t,n){let r=new Array(e);for(let a=0;a<n.length;++a){let s=n[a].shape;for(let i=0;i<t[a].length;++i)r[t[a][i]]===void 0?r[t[a][i]]=s[i]:R(r[t[a][i]]===s[i],()=>`Expected dimension ${r[t[a][i]]} at axis ${i} of input shaped ${JSON.stringify(s)}, but got dimension ${s[i]}`)}}function qee(e,t){let n=e,r=[],a=0;e.length===0&&n.push(-1),a=e.length+1;for(let i=0;i<a;++i)r.push([]);let s=[];for(let i=0;i<n.length;++i){let o=n[i],l=Xee(t,o);for(let c of l)s.indexOf(c)===-1&&(r[i].push(c),s.push(c))}return{path:n,steps:r}}function Kee(e){return e.every((t,n)=>t===n)}function Xee(e,t){let n=[];for(let r=0;r<e.length;++r)(e[r].length===0||e[r].indexOf(t)!==-1||t===-1)&&n.push(r);return n}function Zee(e,t,n=0){let r=[];if(typeof t=="number")R(e.shape[n]%t===0,()=>"Number of splits must evenly divide the axis."),r=new Array(t).fill(e.shape[n]/t);else{let a=t.reduce((i,o)=>(o===-1&&(i+=1),i),0);R(a<=1,()=>"There should be only one negative value in split array.");let s=t.indexOf(-1);if(s!==-1){let i=t.reduce((o,l)=>l>0?o+l:o);t[s]=e.shape[n]-i}R(e.shape[n]===t.reduce((i,o)=>i+o),()=>"The sum of sizes must match the size of the axis dimension."),r=t}return r}function Yee(e){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${e}`}function Jee(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function Qee(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function ete(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function tte(e,t){return`size ${e} must be non-negative, not ${t}`}function nte(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function rte(e,t){let n=dt(e),r=dt(t);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${e} outputShape= ${t}`}function ate(e,t){let n=dt(e),r=dt(t);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${r}. inputShape=${e} outputShape=${t}`}function ste(){return"segment ids must be >= 0"}function ite(){return"segment ids are not increasing"}function ote(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function lte(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}var KO={};Re(KO,{collectGatherOpShapeInfo:()=>hte,computeOutShape:()=>cte,segOpComputeOptimalWindowSize:()=>ute});function ute(e,t){let n=!1,r;for(e<=cN?(r=e,n=!0):r=tx(e,Math.floor(Math.sqrt(e)));!n;)r>t||r===e?n=!0:r=tx(e,r+1);return r}function cte(e,t,n){let r=[],a=e.length;for(let s=0;s<a;s++)s!==t?r.push(e[s]):r.push(n);return r}function hte(e,t,n,r){let a=t.shape.length,s=e.shape.length;if(r!==0&&(r<-a||r>a))throw new Error(`Expect batchDims in the range of [-${a}, ${a}], but got ${r}`);if(r<0&&(r+=a),r>s)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${s}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let h=0;h<r;++h)if(e.shape[h]!==t.shape[h])throw new Error(`x.shape[${h}]: ${e.shape[h]} should be equal to indices.shape[${h}]: ${t.shape[h]}.`);let i=e.shape[n],o=[],l=1,c=1,u=1;for(let h=0;h<r;++h)o.push(e.shape[h]),l*=e.shape[h];for(let h=r;h<n;h++)o.push(e.shape[h]),c*=e.shape[h];for(let h=r;h<a;h++)o.push(t.shape[h]);for(let h=n+1;h<s;h++)o.push(e.shape[h]),u*=e.shape[h];return{batchSize:l,sliceSize:u,outerSize:c,dimSize:i,outputShape:o}}function dte(e){try{return e.map(t=>ax(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function pte(e){return e.map(t=>ig(t))}var Fs={};Re(Fs,{nonMaxSuppressionV3Impl:()=>fO,nonMaxSuppressionV4Impl:()=>mO,nonMaxSuppressionV5Impl:()=>gO,whereImpl:()=>rO});AQ();var XO={kernelName:gd,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>U(e,Ec(le(n,"float32"),-1))}}},fte={kernelName:lu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=gt(le(n,"float32")),a=wn(me(_e(1),r));return Nt(xe(e,a))}}}},mte={kernelName:uu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=wn(me(gt(le(n,"float32")),1));return xe(e,r)}}}},gte={kernelName:Do,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=bt(n.shape,r.shape);return{a:()=>{let s=e,i=Qt(n.shape,a);return i.length>0&&(s=ke(s,i)),V(s,n.shape)},b:()=>{let s=e,i=Qt(r.shape,a);return i.length>0&&(s=ke(s,i)),V(s,r.shape)}}}},yte={kernelName:cu,saveAllInputs:!0,gradFunc:(e,t)=>{let n={};return t.forEach((r,a)=>{n[a]=()=>e.clone()}),n}},xte={kernelName:bd,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Ye(n)}}},bte={kernelName:vd,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Ye(n)}}},vte={kernelName:hu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>xe(e,wn(me(_e(1),gt(le(n,"float32")))))}}},wte={kernelName:du,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=wn(te(_e(1),gt(le(n,"float32"))));return xe(e,r)}}}},kte={kernelName:mu,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=bt(n.shape,r.shape);return{a:()=>{let s=te(gt(n),gt(r)),i=U(e,xe(r,s)),o=Qt(n.shape,a);return o.length>0&&(i=ke(i,o)),V(i,n.shape)},b:()=>{let s=te(gt(n),gt(r)),i=Nt(U(e,xe(n,s))),o=Qt(r.shape,a);return o.length>0&&(i=ke(i,o)),V(i,r.shape)}}}},Ste={kernelName:pu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>xe(e,te(gt(le(n,"float32")),1))}}},Ite={kernelName:fu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>xe(e,me(_e(1),gt(le(n,"float32"))))}}};function Nte(e,t,n,r,a,s){let i=$(e,"dy","avgPool3dGrad"),o=$(t,"input","avgPool3dGrad"),l=i,c=o,u=!1;o.rank===4&&(u=!0,l=V(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),c=V(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),R(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),R(c.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${c.rank}.`),ir("avgPool3dGrad",a,s);let h={dy:l,input:c},d={filterSize:n,strides:r,pad:a,dimRoundingMode:s},p=B.runKernel(Pm,h,d);return u?V(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var _te=W({avgPool3dGrad_:Nte}),Cte={kernelName:wd,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:a,strides:s,pad:i,dimRoundingMode:o}=n;return{x:()=>_te(e,r,a,s,i,o)}}};function Tte(e,t,n,r,a){let s=$(e,"dy","avgPoolGrad"),i=$(t,"input","avgPoolGrad");R(i.rank===s.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${s.rank})`);let o=i,l=s,c=!1;i.rank===3&&(c=!0,o=V(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=V(s,[1,s.shape[0],s.shape[1],s.shape[2]])),R(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),R(o.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);let u={dy:l,input:o},h={filterSize:n,strides:r,pad:a},d=B.runKernel(zm,u,h);return c?V(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var Ete=W({avgPoolGrad_:Tte}),Ate={kernelName:gu,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:a,strides:s,pad:i}=n;return{x:()=>Ete(e,r,a,s,i)}}},$te={kernelName:yu,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{let[r,a]=t,{transposeA:s,transposeB:i}=n;return!s&&!i?{a:()=>We(e,a,!1,!0),b:()=>We(r,e,!0,!1)}:!s&&i?{a:()=>We(e,a,!1,!1),b:()=>We(e,r,!0,!1)}:s&&!i?{a:()=>We(a,e,!1,!0),b:()=>We(r,e,!1,!1)}:{a:()=>We(a,e,!0,!0),b:()=>We(e,r,!0,!0)}}},Mte={kernelName:kd,gradFunc:(e,t,n)=>{let{blockShape:r,crops:a}=n;return{x:()=>xg(e,r,a)}}},Fte={kernelName:RD,gradFunc:(e,t,n)=>{let r=n,a=r.inputShape,s=r.shape,i=Array.from(s);for(let l=a.length-1;l>=0;l--)if(a[l]===s[l])i[l]=1;else if(a[l]!==1)throw new Error(`broadcastTo(): [${a}] cannot be broadcast to [${s}].`);let o=[];for(let l=0;l<i.length;l++)i[l]>1&&o.push(l);return{x:()=>ke(e,o,!0)}}},Rte={kernelName:xu,gradFunc:e=>({x:()=>e.clone()})},Dte={kernelName:bu,gradFunc:e=>({x:()=>Ye(e)})},Ote={kernelName:Oo,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{clipValueMin:a,clipValueMax:s}=n;return{x:()=>vn(Aa(gi(r,a),Bo(r,s)),e,Ye(e))}}},zte={kernelName:Bm,inputsToSave:["x"],gradFunc:XO.gradFunc},Pte={kernelName:Nd,saveAllInputs:!0,gradFunc:(e,t,n)=>{let r=t.map(o=>o.shape),{axis:a}=n,s=$a(a,t[0].shape)[0],i=r.map(o=>o[s]);return xr(e,i,s).map(o=>()=>o)}},Lte={kernelName:vu,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,{dilations:s,strides:i,pad:o,dataFormat:l}=n;return R(bo(s),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`),{x:()=>fI(r.shape,e,a,i,o,l),filter:()=>YI(r,e,a.shape,i,o,l)}}},Bte={kernelName:wu,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,{strides:s,pad:i,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>nr(e,a,s,i,o,1,l),filter:()=>YI(e,r,a.shape,s,i,o,l)}}};function Wte(e,t,n,r,a){let s=e;e.rank===4&&(s=V(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;i.rank===4&&(i=V(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),R(s.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`),R(i.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),R(n.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),R(s.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${n[3]}.`),R(i.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`);let o={x:s,dy:i},l={strides:r,pad:a,filterShape:n};return B.runKernel(_d,o,l)}var Ute=W({conv3DBackpropFilter_:Wte}),Vte={kernelName:ku,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:a,pad:s}=n;R(bo(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);let[i,o]=t;return{x:()=>y3(i.shape,e,o,a,s),filter:()=>Ute(i,e,o.shape,a,s)}}},jte={kernelName:Su,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>U(Nt(Db(le(n,"float32"))),e)}}},Gte={kernelName:Iu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>U(Ob(le(n,"float32")),e)}}},Hte={kernelName:Nu,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a,exclusive:s,reverse:i}=n;return{x:()=>{let o=S3([a],r.rank),l=Sb(e,a,s,!i);return o!=null&&(l=Ue(l,o)),l}}}},qte={kernelName:_u,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:a,pad:s,dimRoundingMode:i}=n,o=r??[1,1];R(bo(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);let[l,c]=t;return R(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),R(c.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${c.rank}.`),R(l.shape[3]===c.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`),R($s(a,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${a} and dilations '${o}'.`),ir("depthwiseConv2d",s,i),{x:()=>hO(l.shape,e,c,a,s,o,i),filter:()=>cO(l,e,c.shape,a,s,o,i)}}},Kte={kernelName:Cu,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,s={x:r,filter:a,dy:e},i={x:r,filter:a,dy:e};return{x:()=>B.runKernel(Gh,s,n),filter:()=>B.runKernel(Hh,i,n)}}},Xte={kernelName:Eu,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t,r={dy:e,y:n};return{x:()=>B.runKernel($d,r)}}},Zte={kernelName:Au,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=U(Bn(Nt(gt(n))),2/Math.sqrt(Math.PI));return{x:()=>U(e,r)}}},Yte={kernelName:$u,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>U(e,n)}}},Jte={kernelName:Fd,inputsToSave:["input"],gradFunc:(e,t)=>{let[n]=t;return{input:()=>V(e,n.shape)}}},Qte={kernelName:Mu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>U(e,Bn(n))}}},ene={kernelName:Fu,gradFunc:e=>({x:()=>Ye(e)})},tne={kernelName:Ru,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=bt(n.shape,r.shape);return{a:()=>{let s=xe(e,le(r,"float32")),i=Qt(n.shape,a);return i.length>0?V(ke(s,i),n.shape):s},b:()=>{let s=U(e,le(n,"float32")),i=Qt(r.shape,a);i.length>0&&(s=V(ke(s,i),r.shape));let o=gt(r);return Nt(xe(s,le(o,"float32")))}}}},nne={kernelName:Du,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{let{varianceEpsilon:r}=n,[a,s,i,o]=t,l=o??_e(1),c=Qt(s.shape,a.shape),u=[];if(s.rank===1){for(let m=0;m<a.shape.length-1;++m)u.push(a.shape[m]);u.push(1)}let h=me(a,s),d=U(e,l),p=Fb(te(i,_e(r))),f=U(U(U(p,p),p),_e(-.5));return{x:()=>s.rank===1?V(U(U(e,Or(V(p,[1,1,1,s.shape[0]]),u)),l),a.shape):V(U(U(e,p),l),a.shape),mean:()=>{let m=U(U(p,_e(-1)),d);return s.rank===1&&(m=ke(m,c)),V(m,s.shape)},variance:()=>{let m=U(U(f,h),d);return s.rank===1&&(m=ke(m,c)),V(m,s.shape)},scale:()=>{let m=U(h,p),y=U(e,m);return s.rank===1&&(y=ke(y,c)),V(y,s.shape)},offset:()=>{let m=e;return s.rank===1&&(m=ke(m,c)),V(m,s.shape)}}}},rne={kernelName:Dd,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{let[r,a]=t,{axis:s,batchDims:i}=n,o=$a(s,r.shape)[0],l=(c,u,h)=>()=>{let d=c.shape,p=u.size,f=d.slice(0,o),m=f.length,y=d.slice(s,d.length).slice(1),g=y.length,x=jA(0,m),b=jA(m+1,m+1+g),v=GA([f,[p],y]),w=V(h,v),I=V(u,[p]),_=GA([[m],x,b]),T=Ue(w,_),A=jb(T,I,c.shape[o]),M=kI(_);return A=Ue(A,M),A};if(i===1){let c=r.shape[0],u=r.split(c,0);return{x:()=>Jt(u.map((h,d)=>l(h,a.slice(d,1),e.slice(d,1))())).reshape(r.shape),indices:()=>a}}else return{x:l(r,a,e),indices:()=>a}}};function jA(e,t){let n=[];for(let r=e;r<t;++r)n.push(r);return n}function GA(e){let t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}var ane={kernelName:Ou,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>Ye(n),b:()=>Ye(r)}}},sne={kernelName:zu,gradFunc:e=>({x:()=>le(e,"float32")})},ine={kernelName:Pu,gradFunc:e=>({x:()=>Ye(e)})},one={kernelName:Lu,gradFunc:e=>({x:()=>Ye(e)})},lne={kernelName:Bu,gradFunc:e=>({x:()=>Ye(e)})},une={kernelName:Wu,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{alpha:a}=n,s=or(r,0);return{x:()=>vn(s,e,U(e,a))}}},cne={kernelName:Vu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>xe(e,te(n,1))}}},hne={kernelName:Uu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>xe(e,le(n,"float32"))}}},dne={kernelName:OD,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n;return{logits:()=>{let s=Bn(r);return me(e,U(ke(e,a,!0),s))}}}};function pne(e,t,n,r=5,a=1,s=1,i=.5){let o={x:e,y:t,dy:n},l={depthRadius:r,bias:a,alpha:s,beta:i};return B.runKernel(jd,o,l)}var fne=W({localResponseNormalizationBackprop_:pne}),mne={kernelName:ju,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{depthRadius:s,bias:i,alpha:o,beta:l}=n;return{x:()=>fne(r,a,e,s,i,o,l)}}};function ZO(e,t,n,r){return t.rank<n.rank&&(t=V(t,Hl(t.shape,r))),e.rank<n.rank&&(e=V(e,Hl(e.shape,r))),{x:()=>U(e,le(Vr(n,t),e.dtype))}}var HA={kernelName:Gu,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{reductionIndices:a}=r,s=t[0],i=t[1],o=$a(a,s.shape),l=ZO(e,i,s,o);return{x:()=>l.x()}}},gne={kernelName:Hu,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>U(e,le(gi(n,r),"float32")),b:()=>U(e,le(Xh(n,r),"float32"))}}};function yne(e,t,n,r,a,s,i){let o=$(e,"dy","maxPool3dGrad"),l=$(t,"input","maxPool3dGrad"),c=$(n,"output","maxPool3dGrad"),u=o,h=l,d=c,p=!1;l.rank===4&&(p=!0,u=V(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),h=V(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=V(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),R(u.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),R(h.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),R(d.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`),ir("maxPool3dGrad",s,i);let f={dy:u,input:h,output:d},m={filterSize:r,strides:a,pad:s,dimRoundingMode:i},y=B.runKernel(Gm,f,m);return p?V(y,[y.shape[1],y.shape[2],y.shape[3],y.shape[4]]):y}var xne=W({maxPool3dGrad_:yne}),bne={kernelName:Gd,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=n;return{x:()=>xne(e,r,a,s,i,o,l)}}};function vne(e,t,n,r,a,s,i){let o=$(e,"dy","maxPoolGrad"),l=$(t,"input","maxPoolGrad"),c=$(n,"output","maxPoolGrad");R(l.rank===o.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`),R(o.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),R(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),ir("maxPoolGrad",s,i);let u={dy:o,input:l,output:c},h={filterSize:r,strides:a,pad:s,dimRoundingMode:i};return B.runKernel(jm,u,h)}var wne=W({maxPoolGrad_:vne}),kne={kernelName:qu,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{filterSize:s,strides:i,pad:o}=n;return{x:()=>wne(e,r,a,s,i,o)}}},Sne={kernelName:Ku,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n,s=$a(a,r.shape),i=k3(r.shape,s)[1],o=dt(i);return{x:()=>{let l=r.shape.slice();s.forEach(u=>{l[u]=1});let c=V(e,l);return xe(U(c,gr(r.shape,"float32")),o)}}}},Ine={kernelName:Xu,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{axis:a}=r,[s,i]=t,o=$a(a,s.shape),l=ZO(e,i,s,o);return{x:()=>l.x()}}},Nne={kernelName:Zu,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>U(e,le(Bo(n,r),"float32")),b:()=>U(e,le(or(n,r),"float32"))}}},_ne={kernelName:Yu,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:a}=n,s=a.map(i=>i[0]);return{x:()=>Ke(e,s,r.shape)}}},Cne={kernelName:Ju,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=bt(n.shape,r.shape);return{a:()=>{let s=Qt(n.shape,a);return s.length>0?V(ke(e,s),n.shape):e},b:()=>{let s=U(e,Nt(wp(xe(n,r)))),i=Qt(r.shape,a);return i.length>0?V(ke(s,i),r.shape):s}}}},Tne={kernelName:Qu,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=bt(n.shape,r.shape);return{a:()=>{let s=U(e,le(r,"float32")),i=Qt(n.shape,a);return i.length>0?V(ke(s,i),n.shape):s},b:()=>{let s=U(e,le(n,"float32")),i=Qt(r.shape,a);return i.length>0?V(ke(s,i),r.shape):s}}}},Ene={kernelName:qd,gradFunc:e=>({x:()=>Nt(e)})},Ane={kernelName:ec,inputsToSave:["indices"],gradFunc:(e,t)=>{let n=t[0];return{indices:()=>Ot(n.shape,"float32")}}},$ne={kernelName:Jd,gradFunc:e=>({x:()=>Ye(e)})},Mne={kernelName:Qd,saveAllInputs:!0,gradFunc:(e,t,n)=>{let{axis:r}=n;return Vt(e,r).map(a=>()=>a)}},qA={kernelName:tc,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:a}=n,s=a.map(i=>i[0]);return{x:()=>Ke(e,s,r.shape)}}},Fne={kernelName:nc,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{let[n,r,a]=t,s=n,i=r,o=bt(s.shape,i.shape);return{a:()=>{let l=le(i,"float32"),c=U(e,U(l,Ts(s,me(l,_e(1))))),u=Qt(s.shape,o);return u.length>0&&(c=ke(c,u)),V(c,s.shape)},b:()=>{let l=or(s,0),c=vn(l,jr(s),Ye(s)),u=U(e,U(a,c)),h=Qt(i.shape,o);return h.length>0&&(u=ke(u,h)),V(u,i.shape)}}}},Rne={kernelName:rc,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{let[n,r]=t,a=or(n,0);return{x:()=>vn(a,e,U(e,r)),alpha:()=>{let s=vn(a,Ye(e),U(e,n)),i=Qt(r.shape,e.shape);return i.length>0&&(s=ke(s,i)),V(s,r.shape)}}}};function Dne(e,t,n){let r=e.shape.slice();r[n]=1;let a=V(t,r),s=mm(e,n,!0,!1),i=mm(e,n,!0,!0),o=U(s,i);return U(a,o)}function One(e,t,n){let r=e.shape.length,a=r-n.length,s=E.getAxesPermutation(n,r),i=e;s!=null&&(i=Ue(e,s));let o=i.shape.slice(),l=o.splice(r-n.length,n.length).reduce((h,d)=>h*d,1);o.push(l);let c=i.reshape(o),u=Dne(c,t,a);if(u=u.reshape(i.shape),s!=null){let h=E.getUndoAxesPermutation(s);u=Ue(u,h)}return u}var zne={kernelName:ac,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n,s=[];return a==null?s=r.shape.map((i,o)=>o):typeof a=="number"?s=[a]:s=a,{x:()=>One(r,e,s)}}},Pne={kernelName:Tu,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=bt(n.shape,r.shape);return{a:()=>{let s=xe(e,le(r,"float32")),i=Qt(n.shape,a);return i.length>0?V(ke(s,i),n.shape):s},b:()=>{let s=U(e,le(n,"float32")),i=Qt(r.shape,a);i.length>0&&(s=V(ke(s,i),r.shape));let o=gt(r);return Nt(xe(s,le(o,"float32")))}}}},Lne={kernelName:sc,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>xe(e,Nt(gt(n)))}}},Bne={kernelName:uc,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=U(Bo(n,6),Ec(n));return{x:()=>U(e,le(r,"float32"))}}},Wne={kernelName:ic,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>U(e,le(Ec(n),"float32"))}}},Une={kernelName:ep,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>V(e,n.shape)}}},Vne={kernelName:lc,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,a={dy:e,images:r};return{images:()=>B.runKernel(np,a,n)}}},jne={kernelName:oc,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,a={dy:e,images:r};return{images:()=>B.runKernel(tp,a,n)}}},Gne={kernelName:cc,gradFunc:(e,t,n)=>{let{dims:r}=n,a=$a(r,e.shape);return{x:()=>da(e,a)}}},Hne={kernelName:hc,gradFunc:e=>({x:()=>Ye(e)})},qne={kernelName:dc,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Nt(xe(e,U(Ts(n,1.5),2)))}}},Kne={kernelName:ip,inputsToSave:["condition"],gradFunc:(e,t)=>{let[n]=t;return{condition:()=>le(Ye(n),"float32"),t:()=>U(e,le(n,e.dtype)),e:()=>U(e,le(gg(n),e.dtype))}}},Xne={kernelName:pc,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=or(n,_e(0)),a=_e(HO),s=_e(qO),i=U(e,s),o=U(U(e,a),Bn(le(n,"float32")));return vn(r,i,o)}}}},Zne={kernelName:yc,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>U(e,U(n,me(_e(1),n)))}}},Yne={kernelName:gc,gradFunc:e=>({x:()=>Ye(e)})},Jne={kernelName:fc,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>U(hg(le(n,"float32")),e)}}},Qne={kernelName:mc,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>U(kb(le(n,"float32")),e)}}},ere={kernelName:op,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{begin:a,size:s}=n,i=r.shape,[o,l]=jO(r,a,s),c=[];for(let u=0;u<e.rank;u++)c.push([o[u],i[u]-o[u]-l[u]]);return{x:()=>ss(e,c)}}},tre={kernelName:wc,outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{dim:a}=n,s=!0,i=U(e,r);return{logits:()=>me(i,U(ke(i,[a],s),r))}}},nre={kernelName:xc,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>U(e,Ca(n))}}},KA={kernelName:lp,gradFunc:(e,t,n)=>{let{blockShape:r,paddings:a}=n;return{x:()=>cg(e,r,a)}}},XA={kernelName:up,gradFunc:(e,t,n)=>{let{axis:r}=n;return{x:()=>xt(e,r)}}},rre={kernelName:bc,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>xe(e,U(wn(le(n,"float32")),2))}}},are={kernelName:Ym,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>U(e,U(le(n,"float32"),2))}}},sre={kernelName:kc,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=_e(2);return{a:()=>U(e,U(a,me(n,r))),b:()=>U(e,U(a,me(r,n)))}}},ire={kernelName:Po,gradFunc:e=>({x:()=>Ye(e)})},ore={kernelName:Sc,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=bt(n.shape,r.shape);return{a:()=>{let s=e,i=Qt(n.shape,a);return i.length>0&&(s=ke(s,i)),V(s,n.shape)},b:()=>{let s=e,i=Qt(r.shape,a);return i.length>0&&(s=ke(s,i)),V(Nt(s),r.shape)}}}},lre={kernelName:vc,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,a=r.shape.slice(),{axis:s}=n;$a(s,r.shape).forEach(l=>{a[l]=1});let i=V(e,a),o=U(i,gr(r.shape,"float32"));return{x:()=>o}}},ure={kernelName:Ic,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>xe(e,gt(hg(n)))}}},cre={kernelName:Nc,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>U(me(_e(1),gt(n)),e)}}},hre={kernelName:zo,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{reps:a}=n;return{x:()=>{let s=Ye(r);if(r.rank===1)for(let i=0;i<a[0];++i)s=te(s,Ke(e,[i*r.shape[0]],[r.shape[0]]));else if(r.rank===2)for(let i=0;i<a[0];++i)for(let o=0;o<a[1];++o)s=te(s,Ke(e,[i*r.shape[0],o*r.shape[1]],[r.shape[0],r.shape[1]]));else if(r.rank===3)for(let i=0;i<a[0];++i)for(let o=0;o<a[1];++o)for(let l=0;l<a[2];++l)s=te(s,Ke(e,[i*r.shape[0],o*r.shape[1],l*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else if(r.rank===4)for(let i=0;i<a[0];++i)for(let o=0;o<a[1];++o)for(let l=0;l<a[2];++l)for(let c=0;c<a[3];++c)s=te(s,Ke(e,[i*r.shape[0],o*r.shape[1],l*r.shape[2],c*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);return s}}}},dre={kernelName:ni,gradFunc:(e,t,n)=>{let r=n,{perm:a}=r,s=kI(a);return{x:()=>Ue(e,s)}}},pre={kernelName:mp,gradFunc:(e,t,n)=>{let r=n,{axis:a}=r;return{value:()=>Jt(e,a)}}},fre={kernelName:rg,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>mre(e,n)}}};function mre(e,t){let n=Ms(t,Ye(t)),r=kp(e,n),a=gi(t,_e(0,"int32")),s=r.rank-a.rank;for(let o=0;o<s;++o)a=yn(a,o+1);a=Aa(a,gr(r.shape,"bool"));let i=Ye(r);return vn(a,r,i)}var gre={kernelName:gp,gradFunc:e=>({x:()=>Ye(e)})},yre=[XO,fte,mte,gte,yte,xte,bte,vte,wte,kte,Ste,Ite,Cte,Ate,$te,Mte,Fte,Rte,Dte,Ote,zte,Pte,Bte,Lte,Vte,jte,Gte,Hte,qte,Kte,Pne,Xte,Zte,Yte,Jte,Qte,tne,ene,nne,rne,ane,sne,ine,one,lne,une,cne,hne,dne,mne,HA,HA,gne,bne,kne,Sne,Ine,Nne,_ne,Cne,Tne,Ene,Ane,$ne,Mne,qA,qA,Fne,Rne,zne,Lne,Bne,Wne,Une,Vne,jne,Gne,Hne,qne,Kne,Xne,Zne,Yne,Jne,Qne,ere,tre,nre,KA,KA,XA,XA,rre,sre,are,ire,ore,lre,ure,cre,hre,dre,pre,fre,gre];for(let e of yre)zD(e);re().prototype.abs=function(){return this.throwIfDisposed(),Kt(this)};re().prototype.acos=function(){return this.throwIfDisposed(),XS(this)};re().prototype.acosh=function(){return this.throwIfDisposed(),ZS(this)};re().prototype.add=function(e){return this.throwIfDisposed(),te(this,e)};re().prototype.all=function(e,t){return this.throwIfDisposed(),bb(this,e,t)};re().prototype.any=function(e,t){return this.throwIfDisposed(),dm(this,e,t)};re().prototype.argMax=function(e){return this.throwIfDisposed(),jl(this,e)};re().prototype.argMin=function(e){return this.throwIfDisposed(),YS(this,e)};re().prototype.asScalar=function(){return this.throwIfDisposed(),R(this.size===1,()=>"The array must have only 1 element."),V(this,[])};re().prototype.asType=function(e){return this.throwIfDisposed(),le(this,e)};re().prototype.as1D=function(){return this.throwIfDisposed(),V(this,[this.size])};re().prototype.as2D=function(e,t){return this.throwIfDisposed(),V(this,[e,t])};re().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),V(this,[e,t,n])};re().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),V(this,[e,t,n,r])};re().prototype.as5D=function(e,t,n,r,a){return this.throwIfDisposed(),V(this,[e,t,n,r,a])};re().prototype.asin=function(){return this.throwIfDisposed(),JS(this)};re().prototype.asinh=function(){return this.throwIfDisposed(),QS(this)};re().prototype.atan=function(){return this.throwIfDisposed(),eI(this)};re().prototype.atan2=function(e){return this.throwIfDisposed(),tI(this,e)};re().prototype.atanh=function(){return this.throwIfDisposed(),nI(this)};re().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),mi(this,e,t,n,r)};re().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),cg(this,e,t)};re().prototype.batchNorm=function(e,t,n,r,a){return this.throwIfDisposed(),_c(this,e,t,n,r,a)};re().prototype.broadcastTo=function(e){return this.throwIfDisposed(),Tl(this,e)};re().prototype.cast=function(e){return this.throwIfDisposed(),le(this,e)};re().prototype.ceil=function(){return this.throwIfDisposed(),uI(this)};re().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),Ln(this,e,t)};re().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof ze&&(e=[e]),xt([this,...e],t)};re().prototype.conv1d=function(e,t,n,r,a,s){return this.throwIfDisposed(),vb(this,e,t,n,r,a,s)};re().prototype.conv2dTranspose=function(e,t,n,r,a){return this.throwIfDisposed(),wb(this,e,t,n,r,a)};re().prototype.conv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),nr(this,e,t,n,r,a,s)};re().prototype.cos=function(){return this.throwIfDisposed(),hg(this)};re().prototype.cosh=function(){return this.throwIfDisposed(),kb(this)};re().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),mm(this,e,t,n)};re().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),Sb(this,e,t,n)};re().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),yI(this,e,t)};re().prototype.depthwiseConv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),Cc(this,e,t,n,r,a,s)};re().prototype.dilation2d=function(e,t,n,r,a){return this.throwIfDisposed(),xI(this,e,t,n,r,a)};re().prototype.divNoNan=function(e){return this.throwIfDisposed(),bI(this,e)};re().prototype.div=function(e){return this.throwIfDisposed(),xe(this,e)};re().prototype.dot=function(e){return this.throwIfDisposed(),vI(this,e)};re().prototype.elu=function(){return this.throwIfDisposed(),bp(this)};re().prototype.equal=function(e){return this.throwIfDisposed(),Vr(this,e)};re().prototype.erf=function(){return this.throwIfDisposed(),Ib(this)};re().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),SI(this,e,t)};re().prototype.exp=function(){return this.throwIfDisposed(),Bn(this)};re().prototype.expandDims=function(e){return this.throwIfDisposed(),yn(this,e)};re().prototype.expm1=function(){return this.throwIfDisposed(),II(this)};re().prototype.fft=function(){return this.throwIfDisposed(),wg(this)};re().prototype.flatten=function(){return this.throwIfDisposed(),V(this,[this.size])};re().prototype.floor=function(){return this.throwIfDisposed(),wp(this)};re().prototype.floorDiv=function(e){return this.throwIfDisposed(),xb(this,e)};re().prototype.gather=function(e,t,n){return this.throwIfDisposed(),kp(this,e,t,n)};re().prototype.greaterEqual=function(e){return this.throwIfDisposed(),gi(this,e)};re().prototype.greater=function(e){return this.throwIfDisposed(),or(this,e)};re().prototype.ifft=function(){return this.throwIfDisposed(),Qh(this)};re().prototype.irfft=function(){return this.throwIfDisposed(),Pb(this)};re().prototype.isFinite=function(){return this.throwIfDisposed(),NI(this)};re().prototype.isInf=function(){return this.throwIfDisposed(),_I(this)};re().prototype.isNaN=function(){return this.throwIfDisposed(),CI(this)};re().prototype.leakyRelu=function(e){return this.throwIfDisposed(),pg(this,e)};re().prototype.lessEqual=function(e){return this.throwIfDisposed(),Bo(this,e)};re().prototype.less=function(e){return this.throwIfDisposed(),Xh(this,e)};re().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),TI(this,e,t,n,r)};re().prototype.logSigmoid=function(){return this.throwIfDisposed(),EI(this)};re().prototype.logSoftmax=function(e){return this.throwIfDisposed(),Cb(this,e)};re().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),mg(this,e,t)};re().prototype.log=function(){return this.throwIfDisposed(),jr(this)};re().prototype.log1p=function(){return this.throwIfDisposed(),fg(this)};re().prototype.logicalAnd=function(e){return this.throwIfDisposed(),Aa(this,e)};re().prototype.logicalNot=function(){return this.throwIfDisposed(),gg(this)};re().prototype.logicalOr=function(e){return this.throwIfDisposed(),Tb(this,e)};re().prototype.logicalXor=function(e){return this.throwIfDisposed(),AI(this,e)};re().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),We(this,e,t,n)};re().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),pn(this,e,t,n,r)};re().prototype.max=function(e,t){return this.throwIfDisposed(),la(this,e,t)};re().prototype.maximum=function(e){return this.throwIfDisposed(),Ms(this,e)};re().prototype.mean=function(e,t){return this.throwIfDisposed(),Dt(this,e,t)};re().prototype.min=function(e,t){return this.throwIfDisposed(),Kh(this,e,t)};re().prototype.minimum=function(e){return this.throwIfDisposed(),wo(this,e)};re().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),MI(this,e,t)};re().prototype.mod=function(e){return this.throwIfDisposed(),FI(this,e)};re().prototype.mul=function(e){return this.throwIfDisposed(),U(this,e)};re().prototype.neg=function(){return this.throwIfDisposed(),Nt(this)};re().prototype.norm=function(e,t,n){return this.throwIfDisposed(),vp(this,e,t,n)};re().prototype.notEqual=function(e){return this.throwIfDisposed(),ql(this,e)};re().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),Zh(this,e,t,n)};re().prototype.onesLike=function(){return this.throwIfDisposed(),Gr(this)};re().prototype.pad=function(e,t){return this.throwIfDisposed(),ss(this,e,t)};re().prototype.pool=function(e,t,n,r,a,s){return this.throwIfDisposed(),RI(this,e,t,n,r,a,s)};re().prototype.pow=function(e){return this.throwIfDisposed(),Ts(this,e)};re().prototype.prelu=function(e){return this.throwIfDisposed(),bg(this,e)};re().prototype.prod=function(e,t){return this.throwIfDisposed(),DI(this,e,t)};re().prototype.reciprocal=function(){return this.throwIfDisposed(),BI(this)};re().prototype.relu=function(){return this.throwIfDisposed(),ht(this)};re().prototype.relu6=function(){return this.throwIfDisposed(),$b(this)};re().prototype.reshapeAs=function(e){return this.throwIfDisposed(),V(this,e.shape)};re().prototype.reshape=function(e){return this.throwIfDisposed(),V(this,e)};re().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),yO(this,e,t,n)};re().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),xO(this,e,t,n)};re().prototype.reverse=function(e){return this.throwIfDisposed(),da(this,e)};re().prototype.rfft=function(){return this.throwIfDisposed(),kg(this)};re().prototype.round=function(){return this.throwIfDisposed(),Mb(this)};re().prototype.rsqrt=function(){return this.throwIfDisposed(),Fb(this)};re().prototype.selu=function(){return this.throwIfDisposed(),Rb(this)};re().prototype.separableConv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),Sp(this,e,t,n,r,a,s)};re().prototype.sigmoid=function(){return this.throwIfDisposed(),Ca(this)};re().prototype.sign=function(){return this.throwIfDisposed(),WI(this)};re().prototype.sin=function(){return this.throwIfDisposed(),Db(this)};re().prototype.sinh=function(){return this.throwIfDisposed(),Ob(this)};re().prototype.slice=function(e,t){return this.throwIfDisposed(),Ke(this,e,t)};re().prototype.softmax=function(e){return this.throwIfDisposed(),Uo(this,e)};re().prototype.softplus=function(){return this.throwIfDisposed(),Tc(this)};re().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),xg(this,e,t)};re().prototype.split=function(e,t){return this.throwIfDisposed(),xr(this,e,t)};re().prototype.sqrt=function(){return this.throwIfDisposed(),wn(this)};re().prototype.square=function(){return this.throwIfDisposed(),gt(this)};re().prototype.squaredDifference=function(e){return this.throwIfDisposed(),Lb(this,e)};re().prototype.squeeze=function(e){return this.throwIfDisposed(),Vo(this,e)};re().prototype.stack=function(e,t){this.throwIfDisposed();let n=e instanceof ze?[this,e]:[this,...e];return Jt(n,t)};re().prototype.step=function(e){return this.throwIfDisposed(),Ec(this,e)};re().prototype.stridedSlice=function(e,t,n,r,a,s,i,o){return this.throwIfDisposed(),UI(this,e,t,n,r,a,s,i,o)};re().prototype.sub=function(e){return this.throwIfDisposed(),me(this,e)};re().prototype.sum=function(e,t){return this.throwIfDisposed(),ke(this,e,t)};re().prototype.tan=function(){return this.throwIfDisposed(),VI(this)};re().prototype.tanh=function(){return this.throwIfDisposed(),vo(this)};re().prototype.tile=function(e){return this.throwIfDisposed(),Or(this,e)};re().prototype.toBool=function(){return this.throwIfDisposed(),le(this,"bool")};re().prototype.toFloat=function(){return this.throwIfDisposed(),le(this,"float32")};re().prototype.toInt=function(){return this.throwIfDisposed(),le(this,"int32")};re().prototype.topk=function(e,t){return this.throwIfDisposed(),GI(this,e,t)};re().prototype.transpose=function(e){return this.throwIfDisposed(),Ue(this,e)};re().prototype.unique=function(e){return this.throwIfDisposed(),HI(this,e)};re().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),jb(this,e,t)};re().prototype.unstack=function(e){return this.throwIfDisposed(),Vt(this,e)};re().prototype.where=function(e,t){return this.throwIfDisposed(),vn(e,this,t)};re().prototype.zerosLike=function(){return this.throwIfDisposed(),Ye(this)};var Bi=class YO extends Error{constructor(t){super(t),Object.setPrototypeOf(this,YO.prototype)}},vs=class JO extends Error{constructor(t){super(t),Object.setPrototypeOf(this,JO.prototype)}},G=class QO extends Error{constructor(t){super(t),Object.setPrototypeOf(this,QO.prototype)}},Ge=class ez extends Error{constructor(t){super(t),Object.setPrototypeOf(this,ez.prototype)}},xre=class tz extends Error{constructor(t){super(t),Object.setPrototypeOf(this,tz.prototype)}},nz=class{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){let n=this.cache.keys().next().value;this.cache.delete(n)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){let n=this.cache.keys().next().value;this.cache.delete(n)}this.maxEntries=e}};function Xl(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}else{let n=new Array(t);return n.fill(e),n}}function gs(e,t){if(!e)throw new xre(t)}function ZA(e,t){let n=0;for(let r of e)r===t&&n++;return n}function mr(e){return e.length===1?e[0]:e}function ct(e){return Array.isArray(e)?e:[e]}function qs(e){let t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function fl(e){return e.length<=1||e.indexOf("_")===-1?e:e.replace(/[_]+(\w|$)/g,(t,n)=>n.toUpperCase())}var xa={};function hN(e){if(e==null)return null;let t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function Mk(e){if(!(e==null||typeof e!="object"))if(Array.isArray(e))e.forEach(t=>Mk(t));else{let t=Object.keys(e);for(let n of t){let r=e[n];r!=null&&typeof r=="object"&&(!Array.isArray(r)&&r.type==="ndarray"&&typeof r.value=="number"?e[n]=r.value:Mk(r))}}}function Ig(e,t={},n={},r="object",a=!1){if(typeof e=="string"){let s=e,i;if(s in n)i=n[s];else if(s in xa)i=xa[s];else if(i=t[s],i==null)throw new G(`Unknown ${r}: ${e}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}else{let s=e;if(s.className==null||s.config==null)throw new G(`${r}: Improper config format: ${JSON.stringify(s)}.
'className' and 'config' must set.`);let i=s.className,o,l;if(i in n?[o,l]=n[i]:i in xa?[o,l]=xa.className:i in t&&([o,l]=t[i]),o==null)throw new G(`Unknown ${r}: ${i}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){let c={};for(let p of Object.keys(xa))c[p]=xa[p];for(let p of Object.keys(n))c[p]=n[p];let u=s.config;u.customObjects=c;let h=Object.assign({},xa);for(let p of Object.keys(n))xa[p]=n[p];Mk(s.config);let d=l(o,s.config,n,a);return xa=Object.assign({},h),d}else{let c=Object.assign({},xa);for(let h of Object.keys(n))xa[h]=n[h];let u=new o(s.config);return xa=Object.assign({},c),u}}}function bre(e,t){return e<t?-1:e>t?1:0}function Ly(e,t){return-1*bre(e,t)}function lo(e){if(e==null)return e;let t=[];for(let n of e)t.indexOf(n)===-1&&t.push(n);return t}function vre(e){if(e==null)throw new G(`Invalid value in obj: ${JSON.stringify(e)}`);for(let t in e)if(e.hasOwnProperty(t))return!1;return!0}function Ac(e,t,n){if(n!=null&&e.indexOf(n)<0)throw new G(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function dN(e,t,n=0,r=1/0){return gs(n>=0),gs(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every(a=>typeof a===t)}function bn(e,t){Array.isArray(e)?(k.assert(e.length>0,()=>`${t} is unexpectedly an empty array.`),e.forEach((n,r)=>bn(n,`element ${r+1} of ${t}`))):k.assert(Number.isInteger(e)&&e>0,()=>`Expected ${t} to be a positive integer, but got ${rz(e)}.`)}function rz(e){return e===null?"null":Array.isArray(e)?"["+e.map(t=>rz(t)).join(",")+"]":typeof e=="string"?`"${e}"`:`${e}`}function wre(e,t,n){let r=n!=null?n():k.now(),a;return(...s)=>{let i=n!=null?n():k.now();return i-r<t||(r=i,a=e(...s)),a}}function az(e){return e==="relu"?"relu":e==="linear"?"linear":e==="elu"?"elu":null}var kre=0;function sz(){return kre++}var By={};function Yb(e=""){return e in By||(By[e]=0),By[e]+=1,e+By[e].toString()}var Sre=["channelsFirst","channelsLast"],Ire=["nearest","bilinear"],Nre=["valid","same","causal"],_re=["max","avg"],Cre=["sum","mul","concat","ave"],nh=new Map;function Gt(e){Ac(Sre,"DataFormat",e)}function Tre(e){Ac(Ire,"InterpolationFormat",e)}function ma(e){Ac(Nre,"PaddingMode",e)}function iz(e){Ac(_re,"PoolMode",e)}var Of=[],YA="/";function El(e,t){Of.push(e);try{let n=t();return Of.pop(),n}catch(n){throw Of.pop(),n}}function Ere(){return Of.length===0?"":Of.join(YA)+YA}function oz(e){if(!uz(e))throw new Error("Not a valid tensor name: '"+e+"'");return Ere()+e}function lz(e){if(!uz(e))throw new Error("Not a valid tensor name: '"+e+"'");nh.has(e)||nh.set(e,0);let t=nh.get(e);if(nh.set(e,nh.get(e)+1),t>0){let n=`${e}_${t}`;return nh.set(n,1),n}else return e}var Are=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function uz(e){return!!e.match(Are)}function $re(e){return e===parseInt(e.toString(),10)}function uo(e,t,n){t==null&&(t=0),n==null&&(n=e.length);let r=1;for(let a=t;a<n;++a)r*=e[a];return r}function td(e){if(e.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r<t&&(t=r)}return t}function So(e){if(e.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r>t&&(t=r)}return t}function es(e,t){if(t<e)throw new G(`end (${t}) < begin (${e}) is forbidden.`);let n=[];for(let r=e;r<t;++r)n.push(r);return n}var qw;function sn(){return qw==null&&(qw=GS().epsilon()),qw}function ts(){return"channelsLast"}function ci(e,t){return le(e,t)}function Ng(e,t=-1){let n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),V(e,n)}function Mre(e,t){return j(()=>{if(e.shape.length!==2)throw new G(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);let n=Ng(e,1);return Fk(n,[1,t,1])})}function Fre(e){let t=[uo(e.shape)];return V(e,t)}function Rre(e){if(e.rank<=1)throw new G(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);let t=[e.shape[0],uo(e.shape,1)];return V(e,t)}function Al(e,t,n){return j(()=>{switch(e.rank){case 1:return vg(e,t,n);case 2:return zb(e,[t,0],[n,e.shape[1]]);case 3:return Ip(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return Jh(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return Ke(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return Ke(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new G(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}})}function Kw(e,t,n){return j(()=>{switch(e.rank){case 1:return vg(e,t,n);case 2:return zb(e,[0,t],[e.shape[0],n]);case 3:return Ip(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return Jh(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new G(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function Wy(e,t,n,r){return j(()=>{switch(e.rank){case 1:return vg(e,t,n);case 2:switch(r){case 1:return Al(e,t,n);case 2:return Kw(e,t,n);default:throw new G(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return Al(e,t,n);case 2:return Ip(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return Kw(e,t,n);default:throw new G(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return Al(e,t,n);case 2:return Jh(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return Jh(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return Kw(e,t,n);default:throw new G(`The axis is not within the rank of the tensor ${r}`)}default:throw new G(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function pN(e,t=-1){let n;return t<0&&(n=e[0].rank,n!==0?t=n:t=0),t===e[0].rank&&(t=-1),xt(e,t)}function JA(e,t){switch(e.rank){case 1:return cI([e,t]);case 2:return hI([e,t],0);case 3:return dI([e,t],0);case 4:return pI([e,t],0);default:throw new G(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function Fk(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new G(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return Or(e,t)}function Jb(e,t=0,n=1,r,a){return Ab(e,t,n,r,a)}function _s(e,t,n,r){if(e.rank<2||t.rank<2)throw new Ge(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){let a=e.shape.slice(-1)[0],s=t.shape.slice(-2)[0];if(a!==s)throw new Ge(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(e.rank===2&&t.rank===2)return ed.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?Rk(e.rank,r,ts()):null,activation:n});{let a=e.shape.slice(),s=a.pop();e=V(e,[-1,s]);let i=t.shape.slice(),o=i.pop(),l=i.pop(),c=[...i,o],u=Array.from({length:t.rank},(d,p)=>p===0?t.rank-2:p<=t.rank-2?p-1:p);t=V(Ue(t,u),[l,-1]);let h=[...a,...c];return V(ed.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?Rk(e.rank,r,ts()):null,activation:n}),h)}}function cz(e,t,n){return j(()=>(Array.isArray(t)?t=ut(t,"int32"):t=le(t,"int32"),kp(e,t,n)))}function _g(e){return U(e,e)}function Rk(e,t,n){let r=t.shape;if(t.rank!==1&&t.rank!==e)throw new G(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(e===5){if(n==="channelsFirst")return r.length===1?V(t,[1,r[0],1,1,1]):V(t,[1,r[3],r[0],r[1],r[2]]);if(n==="channelsLast")return r.length===1?V(t,[1,1,1,1,r[0]]):V(t,[1].concat(r))}else if(e===4){if(n==="channelsFirst")return r.length===1?V(t,[1,r[0],1,1]):V(t,[1,r[2],r[0],r[1]]);if(n==="channelsLast")return r.length===1?V(t,[1,1,1,r[0]]):V(t,[1].concat(r))}else if(e===3){if(n==="channelsFirst")return r.length===1?V(t,[1,r[0],1]):V(t,[1,r[1],r[0]]);if(n==="channelsLast")return r.length===1?V(t,[1,1,r[0]]):V(t,[1].concat(r))}else if(e<3)return t;throw new G(`Unsupported input rank by biasAdd: ${t.rank}`)}function is(e,t,n){return j(()=>(n==null&&(n=ts()),Gt(n),te(e,Rk(e.rank,t,n))))}function Dre(e,t=1){if(t!==1)throw new Ge(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return bp(e)}function Ore(e){return j(()=>xe(e,te(Kt(e),1)))}function hz(e,t,n,r){return j(()=>XI(e,t,n,r))}function zre(e){return j(()=>{let t=te(.5,U(.2,e));return Ln(t,0,1)})}function Cg(e,t,n=!1){return n?e():t()}var Pre=["fanIn","fanOut","fanAvg"],Lre=["normal","uniform","truncatedNormal"];function Bre(e){Ac(Pre,"FanMode",e)}function Wre(e){Ac(Lre,"Distribution",e)}var Ma=class extends se.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},fN=class extends Ma{apply(e,t){return Ot(e,t)}};fN.className="Zeros";se.registerClass(fN);var Qb=class extends Ma{apply(e,t){return gr(e,t)}};Qb.className="Ones";se.registerClass(Qb);var mN=class extends Ma{constructor(e){if(super(),typeof e!="object")throw new G(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new G(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return j(()=>U(_e(this.value),gr(e,t)))}getConfig(){return{value:this.value}}};mN.className="Constant";se.registerClass(mN);var gN=class extends Ma{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return Wo(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};gN.className="RandomUniform";se.registerClass(gN);var yN=class extends Ma{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Ge(`randomNormal does not support dType ${t}.`);return Jb(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};yN.className="RandomNormal";se.registerClass(yN);var xN=class extends Ma{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Ge(`truncatedNormal does not support dType ${t}.`);return Vb(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};xN.className="TruncatedNormal";se.registerClass(xN);var bN=class extends Ma{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return j(()=>{if(e.length!==2||e[0]!==e[1])throw new G("Identity matrix initializer can only be used for 2D square matrices.");return U(this.gain,Nb(e[0]))})}getConfig(){return{gain:this.gain}}};bN.className="Identity";se.registerClass(bN);function Ure(e,t="channelsLast"){let n,r;if(Gt(t),e.length===2)n=e[0],r=e[1];else if([3,4,5].indexOf(e.length)!==-1){if(t==="channelsFirst"){let a=uo(e,2);n=e[1]*a,r=e[0]*a}else if(t==="channelsLast"){let a=uo(e,0,e.length-2);n=e[e.length-2]*a,r=e[e.length-1]*a}}else{let a=uo(e);n=Math.sqrt(a),r=Math.sqrt(a)}return[n,r]}var wr=class extends Ma{constructor(e){if(super(),e.scale<0)throw new G(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,Bre(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,Wre(this.distribution),this.seed=e.seed}apply(e,t){let n=Ure(e),r=n[0],a=n[1],s=this.scale;if(this.mode==="fanIn"?s/=Math.max(1,r):this.mode==="fanOut"?s/=Math.max(1,a):s/=Math.max(1,(r+a)/2),this.distribution==="normal"){let i=Math.sqrt(s);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Ge(`${this.getClassName()} does not support dType ${t}.`);return Vb(e,0,i,t,this.seed)}else{let i=Math.sqrt(3*s);return Wo(e,-i,i,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};wr.className="VarianceScaling";se.registerClass(wr);var ev=class extends wr{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return wr.className}};ev.className="GlorotUniform";se.registerClass(ev);var tv=class extends wr{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return wr.className}};tv.className="GlorotNormal";se.registerClass(tv);var nv=class extends wr{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return wr.className}};nv.className="HeNormal";se.registerClass(nv);var rv=class extends wr{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return wr.className}};rv.className="HeUniform";se.registerClass(rv);var av=class extends wr{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return wr.className}};av.className="LeCunNormal";se.registerClass(av);var sv=class extends wr{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return wr.className}};sv.className="LeCunUniform";se.registerClass(sv);var vN=class extends Ma{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return j(()=>{if(e.length<2)throw new Ge("Shape must be at least 2D.");if(t!=="int32"&&t!=="float32"&&t!==void 0)throw new TypeError(`Unsupported data type ${t}.`);t=t;let n=k.sizeFromShape(e.slice(0,-1)),r=e[e.length-1],a=n*r;a>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${a}) elements: Slowness may result.`);let s=[Math.max(r,n),Math.min(r,n)],i=Jb(s,0,1,t,this.seed),o=QI.qr(i,!1),l=o[0],c=o[1].flatten().stridedSlice([0],[Math.min(r,n)*Math.min(r,n)],[Math.min(r,n)+1]);return l=U(l,c.sign()),n<r&&(l=l.transpose()),U(_e(this.gain),l.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}};vN.className="Orthogonal";se.registerClass(vN);var QA={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function e$(e,t={}){return Ig(e,se.SerializationMap.getMap().classNameMap,t,"initializer")}function zt(e){return hN(e)}function $t(e){if(typeof e=="string"){let t=e in QA?QA[e]:e;if(t==="GlorotNormal")return new tv;if(t==="GlorotUniform")return new ev;if(t==="HeNormal")return new nv;if(t==="HeUniform")return new rv;if(t==="LeCunNormal")return new av;if(t==="LeCunUniform")return new sv;{let n={};return n.className=t,n.config={},e$(n)}}else return e instanceof Ma?e:e$(e)}function Dk(e){return Array.isArray(e)&&Array.isArray(e[0])}function ox(e){return e.length===0?[]:Array.isArray(e[0])?e:[e]}function Me(e){let t;if(Array.isArray(e)){if(e.length!==1)throw new G(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function rt(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(e.length===1)return e=e,e[0];throw new G(`Expected exactly 1 Shape; got ${e.length}`)}else return e}function lx(e){let t=0;for(let n of e)n.shape.length===0?t+=1:t+=n.shape.reduce((r,a)=>r*a);return t}var t$="Variable",dz=class{constructor(e,t="float32",n=t$,r=!0,a=null){this.dtype=t??"float32",this.shape=e.shape,this.id=sz(),n=n??t$,this.originalName=oz(n),this.name=lz(this.originalName),this.trainable_=r,this.constraint=a,this.val=qI(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),Vre(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}};function Vre(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}function Ok(e){return e.map(t=>t.read())}function wN(e){e.forEach(t=>{t[0].write(t[1])})}var Zt=class{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}},ns=class{constructor(e,t,n,r,a,s,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=a,this.outputTensorIndex=i,this.id=sz(),s!=null&&(this.originalName=oz(s),this.name=lz(this.originalName)),this.rank=t.length}},jre=0,iv=class{constructor(e,t){this.callArgs=t,this.id=jre++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(let n of e.inboundLayers)n!=null&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){let e=[];for(let t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},Gre=0,He=class extends se.Serializable{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=Gre++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){let n=this.getClassName();t=qs(n)+"_"+Yb(n)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let n;if(e.batchInputShape!=null)n=e.batchInputShape;else if(e.inputShape!=null){let a=null;e.batchSize!=null&&(a=e.batchSize),n=[a].concat(e.inputShape)}this.batchInputShape=n;let r=e.dtype;r==null&&(r=e.inputDType),r==null&&(r="float32"),this.dtype=r}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new vs(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new G(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return mr(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return mr(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Bi(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new Bi(`Layer ${this.name} is not connected, no input to return.`);return mr(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new Bi(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Bi(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return mr(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){let t=ct(e);if(this.inputSpec==null||this.inputSpec.length===0)return;let n=ct(this.inputSpec);if(t.length!==n.length)throw new G(`Layer ${this.name} expects ${n.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let r=0;r<t.length;r++){let a=t[r],s=n[r];if(s==null)continue;let i=a.rank;if(s.ndim!=null&&i!==s.ndim)throw new G(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${i}`);if(s.maxNDim!=null&&i>s.maxNDim)throw new G(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${i}`);if(s.minNDim!=null&&i<s.minNDim)throw new G(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${i}.`);if(s.dtype!=null&&a.dtype!==s.dtype)throw new G(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${a.dtype}.`);if(s.axes){let o=a.shape;for(let l in s.axes){let c=Number(l),u=s.axes[l],h=c>=0?o[c]:o[o.length+c];if(u!=null&&[u,null].indexOf(h)===-1)throw new G(`Input ${r} is incompatible with layer ${this.name}: expected axis ${c} of input shape to have value ${u} but got shape ${o}.`)}}if(s.shape!=null)for(let o=0;o<s.shape.length;++o){let l=s.shape[o],c=a.shape[o];if(l!=null&&c!=null&&l!==c)throw new G(`Input ${r} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${a.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();let n=ct(e),r=Kre(e),a=Xre(e);if(r===a)throw new G("Arguments to apply() must be all SymbolicTensors or all Tensors");return El(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);let s=[];for(let i of ct(e))s.push(i.shape);this.build(mr(s)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&a&&(this._refCount=1)}if(this.assertInputCompatibility(e),a){let s=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,s);let i=ct(s),o=[];for(let l of i)n.indexOf(l)!==-1&&(l=l.clone()),o.push(l);if(s=mr(o),this.activityRegularizer!=null)throw new Ge("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return s}else{let s=Hre(e),i=this.computeOutputShape(s),o,l=qre(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?s[0]:s),i!=null&&i.length>0&&Array.isArray(i[0])?o=i.map((c,u)=>new ns(l,c,this,ct(e),t,this.name,u)):o=new ns(l,i,this,ct(e),t,this.name),this.addInboundNode(e,o,null,null,s,i,t),this._refCount++,this.activityRegularizer!=null)throw new Ge("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((n,r)=>{n!=null&&e[r]!=null&&e[r]!==n&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new Bi(`The layer ${this.name} has never been called and thus has no defined output shape.`);let e=[];for(let t of this.inboundNodes){let n=JSON.stringify(t.outputShapes);e.indexOf(n)===-1&&e.push(n)}if(e.length===1){let t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new Bi(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new vs(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return lx(this.weights)}build(e){this.built=!0}getWeights(e=!1){return Ok(e?this.trainableWeights:this.weights)}setWeights(e){j(()=>{let t=this.weights;if(t.length!==e.length)throw new G(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;let n=[],r=Ok(t);for(let a=0;a<r.length;++a){let s=r[a],i=t[a],o=e[a];if(!k.arraysEqual(s.shape,o.shape))throw new G(`Layer weight shape ${s.shape} not compatible with provided weight shape ${o.shape}`);n.push([i,o])}wN(n)})}addWeight(e,t,n,r,a,s,i,o){if(this._addedWeightNames.indexOf(e)!==-1)throw new G(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),n==null&&(n="float32"),this.fastWeightInitDuringBuild&&(r=o!=null?o():$t("zeros"));let l=r.apply(t,n),c=new dz(l,n,e,s,i);return l.dispose(),a!=null&&this.addLoss(()=>a.apply(c.read())),s==null&&(s=!0),s?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=ct(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(n=>{if(n!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}setMaskMetadata(e,t,n){if(!this.supportsMasking)return;let r=this.computeMask(e,n),a=ct(t),s=ct(r);if(a.length!==s.length)throw new Error(`${this.name} outputs ${a.length} tensors but ${a.length} masks for those tensors`);for(let i=0;i<a.length;i++)a[i].kerasMask=s[i]}addInboundNode(e,t,n,r,a,s,i=null){let o=ct(e);t=ct(t),n=ct(n),r=ct(r),a=ox(a),s=ox(s);let l=[],c=[],u=[];for(let h of o)l.push(h.sourceLayer),c.push(h.nodeIndex),u.push(h.tensorIndex);new iv({outboundLayer:this,inboundLayers:l,nodeIndices:c,tensorIndices:u,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:a,outputShapes:s},i);for(let h=0;h<t.length;h++)t[h].sourceLayer=this,t[h].nodeIndex=this.inboundNodes.length-1,t[h].tensorIndex=h}getConfig(){let e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}};function Hre(e){e=ct(e);let t=[];for(let n of e)t.push(n.shape);return mr(t)}function qre(e){return"float32"}function pz(e,t,n){if((t==null||n!=null&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),t.inboundNodes.length===0)return[e];{let r=t.inboundNodes[n];if(r.inboundLayers.length===0)return r.inputTensors;{let a=[];for(let s=0;s<r.inboundLayers.length;s++){let i=r.inputTensors[s],o=r.inboundLayers[s],l=r.nodeIndices[s],c=pz(i,o,l);for(let u of c)a.indexOf(u)===-1&&a.push(u)}return a}}}function Kre(e){let t=!0;for(let n of ct(e))if(!(n instanceof ns)){t=!1;break}return t}function Xre(e){let t=!0;for(let n of ct(e))if(n instanceof ns){t=!1;break}return t}var _p=class extends He{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:Yb("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new G("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new G("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new G("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];let r=new ns(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new iv({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new G(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};_p.className="InputLayer";se.registerClass(_p);function fz(e){if(e.batchShape==null&&e.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(e.batchShape!=null&&e.shape!=null)throw new G("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;e.shape!=null&&t==null&&(t=[null].concat(e.shape));let n=e.dtype;return n==null&&(n="float32"),new _p({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}function Zre(e,t){if(e.dtype==null||e.dtype===t.dtype)return t;try{return le(t,e.dtype)}catch{throw new G(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}var kh=class mz{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof mz)for(let n in t.id2Value)this.id2Value[n]=t.id2Value[n],n in t.id2Mask&&(this.id2Mask[n]=t.id2Mask[n]);else{if(t==null)return;for(let n of t)this.add(n.key,n.value)}}add(t,n,r){if(this.id2Value[t.id]==null)this.id2Value[t.id]=Zre(t,n),this.name2Id[t.name]=t.id,r!=null&&(this.id2Mask[t.id]=r);else throw new G(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof ns){if(this.id2Value[t.id]==null)throw new G(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{let n=this.name2Id[t];if(n==null)throw new G(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[n]}}getMask(t){if(t instanceof ns){if(this.id2Value[t.id]==null)throw new G(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{let n=this.name2Id[t];if(n==null)throw new G(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[n]}}disposeMasks(){this.id2Mask!=null&&Fe(this.id2Mask)}},ux=new nz,cx=new nz;function Yre(e){ux!=null&&ux.setMaxEntries(e),cx!=null&&cx.setMaxEntries(e)}function gf(e,t,n,r){let a=n==null?!1:n.training,s=Array.isArray(e),i=s?e:[e],o=i.map(f=>f.name),l=[],c=t.names();for(let f of o)c.indexOf(f)!==-1?l.push(t.getValue(f)):l.push(null);let u=o.join(",")+"|"+t.names().sort().join(","),h=ux.get(u),d;if(h==null){let f=Jre(i,t);h=f.sorted,d=f.recipientCounts,ux.put(u,h),cx.put(u,d)}d={},a||Object.assign(d,cx.get(u));let p=new kh(t);for(let f=0;f<h.length;++f){let m=h[f],y=m.sourceLayer;if(y instanceof _p)continue;let g=[],x=[],b=[],v=!1;for(let A of m.inputs){let M=p.getValue(A),F=p.getMask(A);g.push(M),x.push(F),F!=null&&(v=!0),a||(d[A.name]--,d[A.name]===0&&!t.hasKey(A)&&o.indexOf(A.name)===-1&&!M.isDisposed&&A.sourceLayer.stateful!==!0&&b.push(M))}v&&(n=n||{},n.mask=x[0]);let w=ct(y.apply(g,n)),I=null;y.supportsMasking&&(I=y.computeMask(g,x));let _=eae(m),T=Array.isArray(_)?_:[_];for(let A=0;A<T.length;++A){p.hasKey(T[A])||p.add(T[A],w[A],Array.isArray(I)?I[0]:I);let M=o.indexOf(T[A].name);M!==-1&&(l[M]=w[A])}a||Fe(b)}return p.disposeMasks(),s?l:l[0]}function Jre(e,t){k.assert(e!=null&&e.length>0,()=>"Expected at least one fetch, got none");let n=[],r={};if(e.length===1){let a=n$(e[0],t);n=a.sorted,r=a.recipientMap}else{let a=new Set;for(let s of e){let{sorted:i,recipientMap:o}=n$(s,t);for(let l of i)a.has(l.name)||(n.push(l),a.add(l.name));for(let l in o)r[l]==null&&(r[l]=new Set),o[l].forEach(c=>r[l].add(c))}}return{sorted:n,recipientCounts:Qre(r)}}function Qre(e){let t={};for(let n in e)t[n]=e[n].size;return t}function n$(e,t){let n=new Set,r=[],a={};for(let o of t.names())n.add(o);let s=[],i=[];for(s.push(e);s.length>0;){let o=s[s.length-1];if(n.has(o.name)){s.pop();continue}let l=i[i.length-1]===s.length-1;if(o.inputs.length===0||l)s.pop(),r.push(o),n.add(o.name),l&&i.pop();else{i.push(s.length-1);for(let c of o.inputs)a[c.name]==null&&(a[c.name]=new Set),a[c.name].add(o.name),!n.has(c.name)&&s.push(c)}}return{sorted:r,recipientMap:a}}function eae(e){let t;if(e.sourceLayer.inboundNodes.length===1)t=e.sourceLayer.output;else{let n=null;for(let r=0;r<e.sourceLayer.inboundNodes.length;++r)for(let a of e.sourceLayer.inboundNodes[r].outputTensors)if(a.id===e.id){n=r;break}t=e.sourceLayer.getOutputAt(n)}return t}var tae=X();tae.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,Yre);var gz={};Re(gz,{maxNorm:()=>nae,minMaxNorm:()=>sae,nonNeg:()=>aae,unitNorm:()=>rae});function kN(e,t){return j(()=>wn(ke(U(e,e),t,!0)))}var Tg=class extends se.Serializable{getConfig(){return{}}},SN=class extends Tg{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return j(()=>{let t=kN(e,this.axis),n=Ln(t,0,this.maxValue);return U(e,xe(n,te(sn(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};SN.className="MaxNorm";se.registerClass(SN);var IN=class extends Tg{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return j(()=>xe(e,te(sn(),kN(e,this.axis))))}getConfig(){return{axis:this.axis}}};IN.className="UnitNorm";se.registerClass(IN);var NN=class extends Tg{apply(e){return ht(e)}};NN.className="NonNeg";se.registerClass(NN);var _N=class extends Tg{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return j(()=>{let t=kN(e,this.axis),n=te(U(this.rate,Ln(t,this.minValue,this.maxValue)),U(1-this.rate,t));return U(e,xe(n,te(sn(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};_N.className="MinMaxNorm";se.registerClass(_N);var r$={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function un(e){return hN(e)}function a$(e,t={}){return Ig(e,se.SerializationMap.getMap().classNameMap,t,"constraint")}function cn(e){if(e==null)return null;if(typeof e=="string"){let t={className:e in r$?r$[e]:e,config:{}};return a$(t)}else return e instanceof Tg?e:a$(e)}function nae(e){return new SN(e)}function rae(e){return new IN(e)}function aae(){return new NN}function sae(e){return new _N(e)}var yz={};Re(yz,{constant:()=>lae,glorotNormal:()=>mae,glorotUniform:()=>fae,heNormal:()=>gae,heUniform:()=>yae,identity:()=>dae,leCunNormal:()=>xae,leCunUniform:()=>bae,ones:()=>oae,orthogonal:()=>vae,randomNormal:()=>cae,randomUniform:()=>uae,truncatedNormal:()=>hae,varianceScaling:()=>pae,zeros:()=>iae});function iae(){return new fN}function oae(){return new Qb}function lae(e){return new mN(e)}function uae(e){return new gN(e)}function cae(e){return new yN(e)}function hae(e){return new xN(e)}function dae(e){return new bN(e)}function pae(e){return new wr(e)}function fae(e){return new ev(e)}function mae(e){return new tv(e)}function gae(e){return new nv(e)}function yae(e){return new rv(e)}function xae(e){return new av(e)}function bae(e){return new sv(e)}function vae(e){return new vN(e)}var xz={};Re(xz,{Layer:()=>He,RNN:()=>bi,RNNCell:()=>Ag,activation:()=>Yse,add:()=>iie,alphaDropout:()=>Vie,average:()=>oie,averagePooling1d:()=>P_,averagePooling2d:()=>L_,averagePooling3d:()=>B_,avgPool1d:()=>gie,avgPool2d:()=>xie,avgPool3d:()=>vie,avgPooling1d:()=>yie,avgPooling2d:()=>bie,avgPooling3d:()=>wie,batchNormalization:()=>pie,bidirectional:()=>Die,categoryEncoding:()=>Kie,centerCrop:()=>Hie,concatenate:()=>lie,conv1d:()=>Use,conv2d:()=>Vse,conv2dTranspose:()=>jse,conv3d:()=>Gse,conv3dTranspose:()=>Hse,convLstm2d:()=>$ie,convLstm2dCell:()=>Mie,cropping2D:()=>Kse,dense:()=>Jse,depthwiseConv2d:()=>Zse,dot:()=>die,dropout:()=>Qse,elu:()=>Ose,embedding:()=>sie,flatten:()=>tie,gaussianDropout:()=>Uie,gaussianNoise:()=>Wie,globalAveragePooling1d:()=>kie,globalAveragePooling2d:()=>Sie,globalMaxPool1d:()=>zie,globalMaxPool2d:()=>Pie,globalMaxPooling1d:()=>vP,globalMaxPooling2d:()=>wP,gru:()=>Nie,gruCell:()=>_ie,input:()=>Oz,inputLayer:()=>Dse,layerNormalization:()=>fie,leakyReLU:()=>Pse,lstm:()=>Cie,lstmCell:()=>Tie,masking:()=>jie,maxPool1d:()=>Lie,maxPool2d:()=>Bie,maxPooling1d:()=>kP,maxPooling2d:()=>SP,maxPooling3d:()=>Iie,maximum:()=>uie,minimum:()=>cie,multiply:()=>hie,permute:()=>aie,prelu:()=>Lse,randomWidth:()=>Xie,reLU:()=>zse,repeatVector:()=>nie,rescaling:()=>Gie,reshape:()=>rie,resizing:()=>qie,rnn:()=>Fie,separableConv2d:()=>qse,simpleRNN:()=>Eie,simpleRNNCell:()=>Aie,softmax:()=>Bse,spatialDropout1d:()=>eie,stackedRNNCells:()=>Rie,thresholdedReLU:()=>Wse,timeDistributed:()=>Oie,upSampling2d:()=>Xse,zeroPadding2d:()=>mie});async function Oi(e){if(e==null)return;let t=[],n=[],r=[];for(let a in e){let s=e[a];if(typeof s!="number"){let i=s;t.push(i.data()),n.push(a),r.push(i)}}if(t.length>0){let a=await Promise.all(t);for(let s=0;s<a.length;++s)e[n[s]]=a[s][0];Fe(r)}}function bz(e){if(e!=null)for(let t in e){let n=e[t];typeof n!="number"&&n.dispose()}}var s$;(function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"})(s$||(s$={}));var wae=125,nd=class{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}},vz=class{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(let t of this.callbacks)t.setParams(e)}setModel(e){for(let t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainEnd(e)}},kae=class extends nd{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});let n=t.size==null?0:t.size;this.seen+=n;for(let r in t){let a=t[r];if(typeof a=="number")this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+a*n;else{let s;r in this.totals?s=this.totals[r]:this.totals[r]=0;let i=j(()=>te(this.totals[r],U(a,n)));this.totals[r]=i,s!=null&&s.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(let n of this.params.metrics)this.totals[n]!=null&&(typeof this.totals[n]=="number"?t[n]=this.totals[n]/this.seen:j(()=>{let r=U(xe(1,this.seen),this.totals[n]);t[n]=r,this.totals[n].dispose(),an(t[n])}))}},wz=class extends nd{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(let n in t)this.history[n]==null&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){let e=[],t=[],n=[];for(let a in this.history){let s=this.history[a];for(let i=0;i<s.length;++i)if(typeof s[i]!="number"){let o=s[i];e.push(o.data()),t.push(a),n.push(i)}}let r=await Promise.all(e);for(let a=0;a<r.length;++a)this.history[t[a]][n[a]].dispose(),this.history[t[a]][n[a]]=r[a][0]}},kz=class extends nd{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||uN,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=wae),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");k.isNumber(this.yieldEvery)&&(this.maybeWait=wre(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){let r=[];this.yield!=null&&(await Oi(n),r.push(this.yield(e,t,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await Oi(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){let n=[];this.epochEnd!=null&&(await Oi(t),n.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){this.batchBegin!=null&&(await Oi(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){let n=[];this.batchEnd!=null&&(await Oi(t),n.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?n.push(this.nextFrameFunc()):k.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){this.trainBegin!=null&&(await Oi(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await Oi(e),await this.trainEnd(e))}};function Sz(e,t){return e==null&&(e={}),e instanceof nd?[e]:Array.isArray(e)&&e[0]instanceof nd?e:ct(e).map(n=>new kz(n,t))}var CN=class cs{constructor(){}static registerCallbackConstructor(t,n){k.assert(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),cs.checkForDuplicate(n),cs.constructors[t]==null&&(cs.constructors[t]=[]),cs.constructors[t].push(n)}static checkForDuplicate(t){for(let n in cs.constructors)cs.constructors[+n].forEach(r=>{if(r===t)throw new G("Duplicate callback constructor.")})}static clear(){cs.constructors={}}static createCallbacks(t){let n=[];for(let r in cs.constructors){let a=+r;t>=a&&n.push(...cs.constructors[a])}return n.map(r=>new r)}};CN.constructors={};function Iz(e,t,n,r,a,s,i,o,l){let c=new wz,u=[new kae,...CN.createCallbacks(t)];e!=null&&u.push(...e),u.push(c);let h=new vz(u);return h.setParams({epochs:n,initialEpoch:r,samples:a,steps:s,batchSize:i,verbose:t,doValidation:o,metrics:l}),{callbackList:h,history:c}}function Ya(e,t={},n=!1){return Ig(e,se.SerializationMap.getMap().classNameMap,t,"layer",n)}function hx(e,t){return j(()=>{e.dtype!=="float32"&&(e=le(e,"float32"));let n=ke(_g(e),t,!0),r=Wr(n.shape,sn()),a=wn(Ms(n,r));return xe(e,a)})}function $c(e,t){return j(()=>Dt(_g(me(t,e)),-1))}function ov(e,t){return j(()=>Dt(Kt(me(t,e)),-1))}function Cp(e,t){return j(()=>{let n=me(e,t),r=Ln(Kt(e),sn(),Number.MAX_VALUE),a=Kt(xe(n,r));return U(100,Dt(a,-1))})}function Sae(e,t){return j(()=>{let n=Ln(t,sn(),Number.MAX_VALUE),r=jr(te(1,n)),a=Ln(e,sn(),Number.MAX_VALUE),s=jr(te(1,a));return Dt(_g(me(r,s)),-1)})}function Iae(e,t){return j(()=>{let n=Ms(0,me(1,U(e,t)));return Dt(_g(n),-1)})}function Nae(e,t){return j(()=>{let n=Ms(0,me(1,U(e,t)));return Dt(n,-1)})}function _ae(e,t){return j(()=>{let n=ke(U(e,t),-1),r=la(U(me(1,e),t),-1);return Ms(0,te(1,me(r,n)))})}function Cae(e,t){return j(()=>{let n=Math.log(2),r=me(t,e),a=me(te(r,Tc(U(-2,r))),n);return Dt(a,-1)})}function gm(e,t,n=!1){return j(()=>{if(n)t=Uo(t);else{let r=ke(t,t.shape.length-1,!0);t=xe(t,r)}return t=Ln(t,sn(),1-sn()),Nt(ke(U(le(e,"float32"),jr(t)),t.shape.length-1))})}function dx(e,t,n=!1){return j(()=>{let r=le(wp(Fre(e)),"int32");t=Ln(t,sn(),1-sn());let a=t.shape,s=V(Zh(r,a[a.length-1]),a);return gm(s,t,n)})}function Tae(e,t){if(!k.arraysEqual(e.shape,t.shape))throw new G(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return j(()=>{let n=ht(t),r=Nt(Kt(t));return te(me(n,U(t,e)),fg(Bn(r)))})}function lv(e,t){return j(()=>{let n;return n=Ln(t,sn(),1-sn()),n=jr(xe(n,me(1,n))),Dt(Tae(e,n),-1)})}function Eae(e,t){return j(()=>{let n=Ln(e,sn(),1),r=Ln(t,sn(),1);return ke(U(e,jr(xe(n,r))),-1)})}function Aae(e,t){return j(()=>{let n=jr(te(sn(),t));return Dt(me(t,U(e,n)),-1)})}function TN(e,t){return j(()=>{let n=hx(e,-1),r=hx(t,-1),a=U(n,r);return Nt(ke(a,-1))})}var px={meanSquaredError:$c,meanAbsoluteError:ov,meanAbsolutePercentageError:Cp,meanSquaredLogarithmicError:Sae,squaredHinge:Iae,hinge:Nae,categoricalHinge:_ae,logcosh:Cae,categoricalCrossentropy:gm,sparseCategoricalCrossentropy:dx,binaryCrossentropy:lv,kullbackLeiblerDivergence:Eae,poisson:Aae,cosineProximity:TN};function Xw(e){if(typeof e=="string"){if(e in px)return px[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new G(t)}else return e}function EN(e,t){return j(()=>{let n=U(.5,Gr(t)),r=ci(or(t,n),e.dtype);return Dt(Vr(e,r),-1)})}function AN(e,t){return j(()=>ci(Vr(jl(e,-1),jl(t,-1)),"float32"))}function Nz(e,t){return j(()=>le(ke(Aa(Vr(e,1),Vr(t,1))),"float32"))}function $ae(e,t){return j(()=>le(ke(Aa(Vr(e,1),Vr(t,0))),"float32"))}function Mae(e,t){return j(()=>le(ke(Aa(Vr(e,0),Vr(t,1))),"float32"))}function _z(e,t){return j(()=>{let n=Nz(e,t),r=Mae(e,t),a=te(n,r);return le(vn(or(a,0),xe(n,a),0),"float32")})}function Fae(e,t){return j(()=>{let n=Nz(e,t),r=$ae(e,t),a=te(n,r);return le(vn(or(a,0),xe(n,a),0),"float32")})}function Cz(e,t){return lv(e,t)}function Tz(e,t){return e.rank===t.rank&&(e=Vo(e,[e.rank-1])),t=jl(t,-1),t.dtype!==e.dtype&&(t=le(t,e.dtype)),le(Vr(e,t),"float32")}function Rae(e,t){return j(()=>{let n=e.sub(t).square().sum(),r=e.sub(e.mean()).square().sum();return _e(1).sub(n.div(r))})}var Dae=$c,Oae=$c,zae=ov,Pae=ov,Lae=Cp,Bae=Cp,$N=gm,Wae=TN,Ez=dx,fx={binaryAccuracy:EN,categoricalAccuracy:AN,precision:_z,categoricalCrossentropy:$N,sparseCategoricalCrossentropy:Ez,mse:Dae,MSE:Oae,mae:zae,MAE:Pae,mape:Lae,MAPE:Bae,cosine:Wae};function Uae(e){if(typeof e=="string"&&e in fx)return fx[e];if(typeof e!="string"&&e!=null)return e;throw new G(`Unknown metric ${e}`)}function Uy(e){if(gs(e!==null,`Unknown LossOrMetricFn ${e}`),typeof e=="string")return e;{let t;for(let n of Object.keys(px))if(px[n]===e){t=n;break}if(t!==void 0)return t;for(let n of Object.keys(fx))if(fx[n]===e){t=n;break}return t!==void 0?t:e.name}}function Vae(e){let t={Adagrad:()=>ul.adagrad(.01),Adadelta:()=>ul.adadelta(1,.95,sn()),Adam:()=>ul.adam(.001,.9,.999,sn()),Adamax:()=>ul.adamax(.002,.9,.999,sn(),0),RMSProp:()=>ul.rmsprop(.001,.9,0,sn()),SGD:()=>ul.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new G(`Unknown Optimizer ${e}`)}function i$(e,t,n=!1){if(e==null||typeof e!="object"||Object.getPrototypeOf(e)!==Object.prototype||!zk(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){let r=JSON.stringify(e);r.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function zk(e){if(e===null)return!0;if(typeof e=="object")if(Object.getPrototypeOf(e)===Object.prototype){let t=Object.keys(e);for(let n of t)if(typeof n!="string"||!zk(e[n]))return!1;return!0}else if(Array.isArray(e)){for(let t of e)if(!zk(t))return!1;return!0}else return!1;else{let t=typeof e;return t==="string"||t==="number"||t==="boolean"}}function jae(e,t,n,r=console.log){let a=Hae(e),s=["Layer (type)","Input Shape","Output shape","Param #"];a?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map(u=>Math.floor(t*u)));let i;if(!a){s.push("Receives inputs"),i=[];for(let u in e.nodesByDepth)i.push(...e.nodesByDepth[u])}r("_".repeat(t)),mx(s,n,r),r("=".repeat(t));let o=e.layers;for(let u=0;u<o.length;++u)a?qae(o[u],n,r):Kae(o[u],n,i,r),r((u===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();let l=Gae(e),c=lx(e.nonTrainableWeights);r(`Total params: ${l+c}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${c}`),r("_".repeat(t))}function Gae(e){let t;return e.collectedTrainableWeights!=null?t=lx(e.collectedTrainableWeights):t=lx(e.trainableWeights),t}function Hae(e){let t=!0,n=[],r=[];for(let a in e.nodesByDepth)n.push(e.nodesByDepth[a]);for(let a of n){if(a.length>1||a.length===1&&a[0].inboundLayers.length>1){t=!1;break}r.push(...a)}if(t)for(let a of e.layers){let s=!1;for(let i of a.inboundNodes)if(r.indexOf(i)!==-1)if(s){t=!1;break}else s=!0;if(!t)break}return t}function mx(e,t,n=console.log){let r="";for(let a=0;a<e.length;++a)a>0&&(r=r.slice(0,r.length-1)+" "),r+=e[a],r=r.slice(0,t[a]),r+=" ".repeat(t[a]-r.length);n(r)}function qae(e,t,n){let r,a;try{a=e.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{a="multiple"}try{r=JSON.stringify(e.outputShape)}catch{r="multiple"}let s=e.name,i=e.getClassName(),o=[`${s} (${i})`,a,r,e.countParams().toString()];mx(o,t,n)}function Kae(e,t,n,r){let a,s;try{s=e.inboundNodes.map(h=>JSON.stringify(h.inputShapes)).join(",")}catch{s="multiple"}try{a=JSON.stringify(e.outputShape)}catch{a="multiple"}let i=[];for(let h of e.inboundNodes)if(!(n!=null&&n.length>0&&n.indexOf(h)===-1))for(let d=0;d<h.inboundLayers.length;++d){let p=h.inboundLayers[d].name,f=h.nodeIndices[d],m=h.tensorIndices[d];i.push(`${p}[${f}][${m}]`)}let o=e.name,l=e.getClassName(),c=i.length===0?"":i[0],u=[`${o} (${l})`,s,a,e.countParams().toString(),c];mx(u,t,r);for(let h=1;h<i.length;++h)mx(["","","","",i[h]],t,r)}function Az(e,t,n){return(e==="inboundNodes"||e==="outputLayers"||e==="inputLayers")&&t===0&&typeof n=="string"}function ym(e,t){if(e===null)return null;if(typeof e=="string")return fl(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){let n=[],r=e.length;for(let a=0;a<r;++a){let s=e[a];Az(t,a,s)?n.push(s):n.push(ym(s,t))}return n}else{let n={};for(let r of Object.keys(e)){let a=e[r];if(r==="name"&&typeof a=="string")n[r]=a;else{let s=fl(r);n[s]=ym(a,s)}}return n}}function Pk(e,t){if(e==null)return null;if(typeof e=="string")return qs(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){let n=[],r=e.length;for(let a=0;a<r;++a){let s=e[a];Az(t,a,s)?n.push(s):n.push(Pk(s,t))}return n}else{let n={};for(let r of Object.keys(e)){let a=e[r],s=qs(r);(r==="name"||r==="className")&&typeof a=="string"?n[s]=a:n[s]=Pk(a,r)}return n}}var MN="4.22.0",Xae=e=>{let t=Object.keys(e);if(t.length===0)return!1;let n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))},Zae=class hs extends He{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,this.name==null){let x=this.getClassName().toLowerCase();this.name=Yb(x)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],lo(this.inputs).length!==this.inputs.length)throw new G(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(x=>x.name)}`);lo(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(x=>x.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let x of this.outputs){let b=x.sourceLayer,v=x.nodeIndex,w=x.tensorIndex;this.outputLayers.push(b),this.outputLayersNodeIndices.push(v),this.outputLayersTensorIndices.push(w)}for(let x of this.inputs){let b=x.sourceLayer,v=x.nodeIndex,w=x.tensorIndex;gs(v===0,"input layer has >1 nodes"),gs(w===0,"input layer has >1 tensors"),this.inputLayers.push(b),this.inputLayersNodeIndices.push(v),this.inputLayersTensorIndices.push(w)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let x=0;x<this.inputLayers.length;x++){let b=this.inputLayers[x];if(!(b instanceof _p))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${x} (0-based) originates from layer type ${b.getClassName()}.`);this.inputNames.push(b.name),this.feedInputShapes.push(b.batchInputShape),this.feedInputNames.push(b.name)}for(let x of this.outputLayers)this.outputNames.push(x.name);this.internalInputShapes=this.inputs.map(x=>x.shape),this.internalOutputShapes=this.outputs.map(x=>x.shape);let n={},r={},a={},s={},i={},o=[],l=(x,b,v,w,I,_)=>{(w==null||I==null||_==null)&&(w=x.sourceLayer,I=x.nodeIndex,_=x.tensorIndex);let T=w.inboundNodes[I];if(v.indexOf(T)!==-1)throw new vs(`The tensor ${x.name} at layer "${w.name}" is part of a cycle.`);if(b.indexOf(T)!==-1)return;this.containerNodes.add(hs.nodeKey(w,I)),w.id in i||(i[w.id]=Object.keys(i).length),v.indexOf(T)===-1&&v.push(T);let A=T.inboundLayers.length;for(let M=0;M<A;M++){let F=T.inputTensors[M],C=T.inboundLayers[M],D=T.nodeIndices[M],L=T.tensorIndices[M];l(F,b,v,C,D,L)}for(b.push(T);v.indexOf(T)>=0;)v.splice(v.indexOf(T),1);o.push(T)},c=[],u=[];for(let x of this.outputs)l(x,c,u);let h=o.slice().reverse();for(let x of h){r[x.id]=x,x.id in n||(n[x.id]=0);let b=n[x.id],v=a[x.outboundLayer.id]==null?0:a[x.outboundLayer.id];b=Math.max(b,v),a[x.outboundLayer.id]=b,s[x.outboundLayer.id]=x.outboundLayer,n[x.id]=b;for(let w=0;w<x.inboundLayers.length;w++){let I=x.inboundLayers[w],_=x.nodeIndices[w],T=I.inboundNodes[_],A=n[T.id]==null?0:n[T.id];n[T.id]=Math.max(b+1,A),r[T.id]=T}}let d={};for(let x in n){let b=n[x];b in d||(d[b]=[]),d[b].push(r[x])}let p={};for(let x in a){let b=a[x];b in p||(p[b]=[]),p[b].push(s[x])}let f=Object.keys(p).map(x=>parseInt(x,10)).sort(Ly);this.layers=[];for(let x of f){let b=p[x];b.sort((v,w)=>{let I=i[v.id],_=i[w.id];return I<_?-1:I>_?1:0});for(let v of b)v instanceof hs&&this.internalContainerRefs.push(v),this.layers.push(v)}this.layersByDepth=p,f=Object.keys(d).map(x=>parseInt(x,10)).sort(Ly);let m=this.inputs.slice(),y=[];for(let x of f)for(let b of d[x]){let v=b.outboundLayer;if(v!=null){for(let w of b.inputTensors)if(m.indexOf(w)===-1)throw new vs(`Graph disconnected: cannot obtain value for tensor ${w} at layer "${v.name}". The following previous layers were accessed without issue: ${y}`);for(let w of b.outputTensors)m.push(w);y.push(v.name)}}this.nodesByDepth=d;let g=this.layers.map(x=>x.name);for(let x of g){let b=g.filter(v=>v===x).length;if(b!==1)throw new vs(`The name "${x}" is used ${b} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new iv({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(x=>null),outputMasks:this.outputs.map(x=>null),inputShapes:this.inputs.map(x=>x.shape),outputShapes:this.outputs.map(x=>x.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(let n of this.layers)t.numDisposedVariables+=n.dispose().numDisposedVariables;for(let n of this.internalContainerRefs)t.numDisposedVariables+=n.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(n=>{n._trainableWeights.forEach(r=>r.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new G("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(let n of this.layers)t=t.concat(n.trainableWeights);return t}get nonTrainableWeights(){let t=[];for(let n of this.layers)t.push(...n.nonTrainableWeights);if(!this.trainable){let n=[];for(let r of this.layers)n.push(...r.trainableWeights);return n.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,n=!0){let r={},a=0,s=Xae(t);s&&this.parseWeights(t);for(let o of this.layers)for(let[l,c]of o.weights.entries()){let u=s?`${c.name.split("/").slice(0,-1).join("/")+"/"}${l}`:c.originalName;if(r[u]!=null)throw new G(`Duplicate weight name: ${u}`);r[u]=c,a++}let i=[];for(let o in t){let l=o;if(r[o]==null){let c=o.split("/");l=c.slice(0,-2).concat([c[c.length-1]]).join("/")}if(r[l]!=null)i.push([r[l],t[o]]);else if(n)throw new G(`Provided weight data has no target variable: ${o}`);delete r[l]}if(n){let o=[];for(let l in r)o.push(l);if(o.length>0)throw new G(`${o.length} of ${a} weights are not set: ${o}`)}wN(i)}parseWeights(t){for(let n in Object.keys(t)){let r=n.split("/"),a=["vars","layer_checkpoint_dependencies"],s=r.map(i=>i.startsWith("_")?i.slice(1):i).filter(i=>!a.includes(i)).join("/");s!==n&&(t[s]=t[n],delete t[n])}}updatedConfig(){let t=this.getConfig(),n={};return n.className=this.getClassName(),n.config=t,n.kerasVersion=`tfjs-layers ${MN}`,n.backend="TensorFlow.js",n}toJSON(t,n=!0){let r=Pk(this.updatedConfig());return n?JSON.stringify(r):r}call(t,n){return j(()=>{t=ct(t);let r=new kh;for(let a=0;a<this.inputs.length;++a)r.add(this.inputs[a],t[a]);return gf(this.outputs,r,n)})}computeMask(t,n){return j(()=>{t=ct(t);let r;return n==null?r=Xl(null,t.length):r=ct(n),this.runInternalGraph(t,r)[1]})}computeOutputShape(t){let n=ox(t);if(n.length!==this.inputLayers.length)throw new G(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);let r={};for(let o=0;o<n.length;o++){let l=this.inputLayers[o],c=n[o],u=l.name+"_0_0";r[u]=c}let a=Object.keys(this.nodesByDepth).map(o=>parseInt(o,10)).sort(Ly);if(a.length>1)for(let o of a){let l=this.nodesByDepth[o];for(let c of l){let u=c.outboundLayer;if(this.inputLayers.map(m=>m.id).indexOf(u.id)!==-1)continue;let h=[];for(let m=0;m<c.inboundLayers.length;m++){let y=c.inboundLayers[m],g=c.nodeIndices[m],x=c.tensorIndices[m],b=`${y.name}_${g}_${x}`,v=r[b];h.push(v)}let d=u.computeOutputShape(mr(h)),p=ox(d),f=u.inboundNodes.indexOf(c);for(let m=0;m<p.length;m++){let y=`${u.name}_${f}_${m}`;r[y]=p[m]}}}let s=[],i=[];for(let o=0;o<this.outputLayers.length;o++){let l=this.outputLayers[o],c=this.outputLayersNodeIndices[o],u=this.outputLayersTensorIndices[o],h=`${l.name}_${c}_${u}`;i.push(h)}for(let o=0;o<i.length;o++){let l=i[o];gs(l in r),s.push(r[l])}return mr(s)}runInternalGraph(t,n){n==null&&(n=Xl(null,t.length));let r={};for(let l=0;l<this.inputs.length;++l){let c=this.inputs[l],u=t[l],h=n[l];r[c.id]=[u,h]}let a=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(Ly);for(let l of a){let c=this.nodesByDepth[l];for(let u of c){let h=u.outboundLayer,d=u.inputTensors,p=u.outputTensors,f=new Array;for(let m of d)m.id in r&&f.push(r[m.id]);if(f.length===d.length){let m={},y,g,x,b;if(u.callArgs!=null&&(m=u.callArgs),f.length===1){let[v,w]=f[0];m.mask==null&&(m.mask=w),x=ct(h.call(v,m)),b=ct(h.computeMask(v,w)),y=[v],g=[w]}else y=f.map(v=>v[0]),g=f.map(v=>v[1]),m.mask==null&&(m.mask=g),x=ct(h.call(y,m)),b=ct(h.computeMask(y,g));if(h.activityRegularizer)throw new Ge("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let v=0;v<p.length;++v){let w=p[v],I=x[v],_=b[v];r[w.id]=[I,_]}}}}let s=[],i=[],o=[];for(let l of this.outputs){gs(l.id in r,`Could not compute output ${l.name} : ${l.id}`);let[c,u]=r[l.id];o.push(c.shape),s.push(c),i.push(u)}return[s,i,o]}buildNodeConversionMap(t){let n={},r;for(let a of this.layers){r=a instanceof hs?1:0;for(let s=0;s<a.inboundNodes.length;s++){let i=hs.nodeKey(a,s);this.containerNodes.has(i)&&(n[i]=r,r+=1)}}return n}getLayer(t,n){if(n!=null)return this.findLayer(n);if(t==null)throw new G("Provide either a layer name or layer index");if(typeof t=="number")return this.findLayer(t);for(let r of this.layers)if(r.name===t)return r;throw new G(`No such layer: ${t}`)}findLayer(t){if(this.layers.length<=t)throw new G(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}calculateLosses(){return j(()=>{let t=[];for(let n of this.layers)for(let r=0;r<n.inboundNodes.length;++r){let a=hs.nodeKey(n,r);this.containerNodes.has(a)&&t.push(...n.calculateLosses())}return t})}getConfig(){let t={name:this.name},n=this.buildNodeConversionMap(this.layers),r=[];for(let i of this.layers){let o=i.getClassName(),l=i.getConfig(),c=[];for(let h=0;h<i.inboundNodes.length;h++){let d=i.inboundNodes[h],p=hs.nodeKey(i,h),f={};if(this.containerNodes.has(p)){if(d.callArgs)try{JSON.stringify(d.callArgs),f=d.callArgs}catch{console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${d.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),f={}}if(d.inboundLayers.length>0){let m=[];for(let y=0;y<d.inboundLayers.length;y++){let g=d.inboundLayers[y],x=d.nodeIndices[y],b=d.tensorIndices[y],v=hs.nodeKey(g,x),w=n[v];w==null&&(w=0),m.push([g.name,w,b,f])}c.push(m)}}}let u={};u.name=i.name,u.className=o,u.config=l,u.inboundNodes=c,r.push(u)}t.layers=r;let a=[];for(let i=0;i<this.inputLayers.length;i++){let o=this.inputLayers[i],l=this.inputLayersNodeIndices[i],c=hs.nodeKey(o,l);if(!this.containerNodes.has(c))continue;let u=n[c];u==null&&(u=0);let h=this.inputLayersTensorIndices[i];a.push([o.name,u,h])}t.inputLayers=a;let s=[];for(let i=0;i<this.outputLayers.length;i++){let o=this.outputLayers[i],l=this.outputLayersNodeIndices[i],c=hs.nodeKey(o,l);if(!this.containerNodes.has(c))continue;let u=n[c];u==null&&(u=0);let h=this.outputLayersTensorIndices[i];s.push([o.name,u,h])}return t.outputLayers=s,t}static fromConfig(t,n,r={},a=!1){let s={},i={};function o(y,g){y.name in i?i[y.name].push(g):i[y.name]=[g]}function l(y,g){let x=[],b;for(let v of g){let w=v[0],I=v[1],_=v[2];if(b=v[3]==null?{}:v[3],!(w in s)){o(y,g);return}let T=s[w];if(T.inboundNodes.length<=I){o(y,g);return}let A=T.inboundNodes[I];x.push(A.outputTensors[_])}x.length>0&&y.apply(mr(x),b)}function c(y){let g=y.name,x=Ya(y,n.customObjects!=null?n.customObjects:{});x.setFastWeightInitDuringBuild(a),s[g]=x,y.inboundNodes.forEach(b=>{if(!(b instanceof Array))throw new G(`Corrupted configuration, expected array for nodeData: ${b}`);o(x,b)})}let u=n.name,h=n.layers;for(let y of h)c(y);for(;!vre(i);)for(let y of h){let g=s[y.name];if(g.name in i){let x=i[g.name];delete i[g.name];for(let b of x)l(g,b)}}let d=[],p=[],f=n.inputLayers;for(let y of f){let g=y[0],x=y[1],b=y[2];gs(g in s);let v=s[g].inboundNodes[x].outputTensors;d.push(v[b])}let m=n.outputLayers;for(let y of m){let g=y[0],x=y[1],b=y[2];gs(g in s);let v=s[g].inboundNodes[x].outputTensors;p.push(v[b])}return new t({inputs:d,outputs:p,name:u})}get stateful(){if(this._stateful)throw new G("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let t of this.layers)if(t.stateful)return!0;return!1}resetStates(){j(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}};function Yae(e,t,n){let r=t.length;if(e==null||Array.isArray(e)&&e.length===0)return t.map(a=>null);if(r===1)return Array.isArray(e)&&e.length===1?e:typeof e=="object"&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}else if(typeof e=="object"&&Object.keys(e).length>0&&typeof e[Object.keys(e)[0]]=="object"){let a=[];return t.forEach(s=>{s in e?a.push(e[s]):a.push(null)}),a}else throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}function $z(e,t){return Yae(e,t,"classWeight")}async function Mz(e,t,n,r){if(n!=null){let a=j(()=>{if(e.shape.length===1)return Is(e);if(e.shape.length===2){if(e.shape[1]>1)return jl(e,1);if(e.shape[1]===1)return V(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),s=Array.from(await a.data());Fe(a);let i=[];return s.forEach(o=>{if(n[o]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${o} exists in the data but not in classWeight`);i.push(n[o])}),ut(i,"float32")}else return null}function Jae(e,t){return U(e,t)}var Qae=32;function Fz(e,t){let n,r,a=t;n=a.xs,r=a.ys,k.assert(n!=null&&r!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);let s=o$("input",e.inputNames,n),i=o$("output",e.outputNames,r),o=s[0].shape[0];k.assert(s.length===e.inputs.length,()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`),k.assert(i.length===e.outputs.length,()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`);for(let l=0;l<s.length;l++)k.assert(s[l].shape[0]===o,()=>`Batch size mismatch: input ${e.inputNames[l]} has ${s[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);for(let l=0;l<i.length;l++)k.assert(i[l].shape[0]===o,()=>`Batch size mismatch: output ${e.outputNames[l]} has ${i[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);return{xs:s,ys:i}}function o$(e,t,n){if(n instanceof ze)return[n];if(Array.isArray(n))return k.assert(n.length===t.length,()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`),n;{let r=[];for(let a of t){if(n[a]==null)throw new G(`The feature data generated by the dataset lacks the required ${e} key '${a}'.`);r.push(n[a])}return r}}function ese(e){if(e.length===3)throw new Ge("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}async function tse(e,t,n){let r=n.batchesPerEpoch!=null;if(k.assert(e.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),k.assert(n!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),k.assert(n.epochs!=null&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),k.assert(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),k.assert(n.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{let a=n.validationData!=null,s,i;if(a)if(l$(n.validationData))k.assert(n.validationBatches==null||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{let y=ese(n.validationData);s=y.xs,i=y.ys}let o=e.makeTrainFunction(),l=e.getDedupedMetricsNames(),c;a?c=l.slice().concat(l.map(y=>"val_"+y)):c=l.slice();let u=Sz(n.callbacks,n.yieldEvery),h=n.verbose==null?1:n.verbose,{callbackList:d,history:p}=Iz(u,h,n.epochs,null,null,nse(t,n),null,a,c);d.setModel(e),e.history=p,await d.onTrainBegin(),e.stopTraining_=!1;let f=n.initialEpoch==null?0:n.initialEpoch,m=await t.iterator();for(;f<n.epochs;){let y={};await d.onEpochBegin(f);let g=0,x=0;for(r||(m=await t.iterator());!r||g<n.batchesPerEpoch;){let b=await m.next();if(r&&b.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${g} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(b.value!=null){let{xs:v,ys:w}=Fz(e,b.value),I={};I.batch=x,I.size=v[0].shape[0],await d.onBatchBegin(x,I);let _=[];if(n.classWeight!=null){let M=$z(n.classWeight,e.outputNames);for(let F=0;F<M.length;++F)_.push(await Mz(w[F],null,M[F]))}let T=v.concat(w).concat(_),A=o(T);Fe(T);for(let M=0;M<l.length;++M){let F=l[M],C=A[M];I[F]=C,an(C)}await d.onBatchEnd(x,I),bz(I),x++,g++}if(r?g>=n.batchesPerEpoch:b.done){if(a){let v;l$(n.validationData)?v=ct(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):v=ct(e.evaluate(s,i,{batchSize:n.validationBatchSize==null?Qae:n.validationBatchSize,verbose:0}));for(let w=0;w<e.metricsNames.length;++w)y[`val_${e.metricsNames[w]}`]=v[w]}break}if(e.stopTraining_)break}if(await d.onEpochEnd(f,y),f++,e.stopTraining_)break}return await d.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function nse(e,t){let n=null;return t.batchesPerEpoch!=null?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}function l$(e){return typeof e.iterator=="function"}function rse(e){return typeof e.next=="function"}async function ase(e,t,n){n=n||{};let r=n.batches!=null,a=e.testFunction,s=[];if(n.verbose>0)throw new Ge("Verbose mode is not implemented yet.");k.assert(!r||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);let i=rse(t)?t:await t.iterator(),o=0,l=0;for(;!r||l<n.batches;){let c=await i.next();if(s=j(()=>{if(c.value){let{xs:u,ys:h}=Fz(e,c.value),d=u.concat(h),p=j(()=>a(d));if(Fe(d),l===0)for(let m=0;m<p.length;++m)s.push(_e(0));let f=d[0].shape[0];for(let m=0;m<p.length;++m){let y=p[m],g=s[m];s[m]=j(()=>te(s[m],U(f,y))),l>0&&Fe(g)}Fe(p),o+=f,++l}return s}),c.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let c=0;c<s.length;++c){let u=s[c];s[c]=xe(s[c],o),Fe(u)}return mr(s)}function Zw(e){k.assert(e>0&&Number.isInteger(e),()=>`batchSize is required to be a positive integer, but got ${e}`)}function rf(e,t,n){return e==null?[null]:Array.isArray(e)?e.map(r=>Al(r,t,n-t)):Al(e,t,n-t)}function Lk(e,t){return j(()=>e==null?null:Array.isArray(e)?e.map(n=>Lk(n,t)):cz(e,t.dtype==="int32"?t:le(t,"int32")))}function Yw(e,t){let n=[],r=0,a=null;for(;r<e;)a=r+t,a>=e&&(a=e),n.push([r,a]),r=a;return n}function Rz(e){let t=[];e instanceof ze&&(e=[e]);for(let n=0;n<e.length;++n){let r=e[n];if(r.rank===1)t.push(Ng(r,1));else{if(r.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function Ba(e,t){if(e==null)return;let n=[];if(t instanceof ze)n.push(t.id);else if(Array.isArray(t))t.forEach(a=>n.push(a.id));else if(t!=null)for(let a in t){let s=t[a];n.push(s.id)}let r=[];if(e instanceof ze)n.indexOf(e.id)===-1&&r.push(e);else if(Array.isArray(e))e.forEach(a=>{n.indexOf(a.id)===-1&&r.push(a)});else if(e!=null)for(let a in e){let s=e[a];n.indexOf(s.id)===-1&&r.push(s)}r.forEach(a=>{a.isDisposed||a.dispose()})}function sse(e){return e instanceof ze}function Bk(e){return Array.isArray(e)}function u$(e){return!sse(e)&&!Bk(e)}function c$(e,t,n,r=!0,a=""){if(t==null||t.length===0){if(e!=null){let i=!1;if(Bk(e)&&e.length>0)i=!0;else if(u$(e)){for(let o in e)if(e.hasOwnProperty(o)){i=!0;break}}else i=!0;if(i)throw new G(`Error when checking model ${a} expected no data, but got ${e}`)}return[]}if(e==null)return t.map(i=>null);let s;if(u$(e)){e=e,s=[];for(let i of t){if(e[i]==null)throw new G(`No data provided for "${i}". Need data for each key in: ${t}`);s.push(e[i])}}else if(Bk(e)){if(e=e,e.length!==t.length)throw new G(`Error when checking model ${a}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);s=e}else{if(e=e,t.length>1)throw new G(`The model ${a} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);s=[e]}if(s=Rz(s),n!=null)for(let i=0;i<t.length;++i){if(n[i]==null)continue;let o=s[i];if(o.shape.length!==n[i].length)throw new G(`Error when checking ${a}: expected ${t[i]} to have ${n[i].length} dimension(s). but got array with shape ${o.shape}`);for(let l=0;l<n[i].length;++l){if(l===0&&!r)continue;let c=o.shape[l],u=n[i][l];if(u!=null&&u>=0&&c!==u)throw new G(`${a} expected a batch of elements where each example has shape [${n[i].slice(1,n[i].length)}] (i.e.,tensor shape [*,${n[i].slice(1,n[i].length)}]) but the ${a} received an input with ${o.shape[0]} examples, each with shape [${o.shape.slice(1,o.shape.length)}] (tensor shape [${o.shape}])`)}}return s}function ise(e,t,n){let r=lo(e.map(s=>s.shape[0]));r.sort();let a=lo(t.map(s=>s.shape[0]));if(a.sort(),r.length>1)throw new G(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(s=>s.shape))}`);if(a.length>1)throw new G(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(s=>s.shape))}`);if(r.length>0&&a.length>0&&!k.arraysEqual(r,a))throw new G(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${a[0]} target sample(s).`)}function ose(e,t,n){let r=[$c,lv,gm];for(let a=0;a<e.length;++a){let s=e[a],i=t[a],o=n[a];if(i!=null){if(i===gm&&s.shape[s.shape.length-1]===1)throw new G(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(r.indexOf(i)!==-1){let l=s.shape.slice(1),c=o.slice(1);for(let u=0;u<l.length;++u){let h=l[u],d=c[u];if(d!=null&&h!==d)throw new G(`A target Tensor with shape ${s.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function h$(e,t,n,r=!0,a=""){let s;if(Array.isArray(e)){if(e.length!==t.length)throw new G(`Error when checking model ${a}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);s=e}else{if(t.length>1)throw new G(`The model expects ${t.length} ${a} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);s=[e]}if(n!=null)for(let i=0;i<t.length;++i){if(n[i]==null)continue;let o=s[i];if(o.shape.length!==n[i].length)throw new G(`Error when checking ${a}: expected ${t[i]} to have ${n[i].length} dimension(s), but got array with shape ${JSON.stringify(o.shape)}`);for(let l=0;l<n[i].length;++l){if(l===0&&!r)continue;let c=o.shape[l],u=n[i][l];if(u!=null&&u!==c)throw new G(`Error when checking ${a}: expected ${t[i]} to have shape ${JSON.stringify(n[i])} but got array with shape ${JSON.stringify(o.shape)}.`)}}}function lse(e,t){if(e==null||Array.isArray(e)&&e.length===0)return t.map(r=>[]);let n;if(typeof e=="string"||typeof e=="function")n=[e];else if(Array.isArray(e)||typeof e=="object")n=e;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);if(Array.isArray(n))return t.map(r=>n);{let r=[];for(let a of t){let s=n.hasOwnProperty(a)?n[a]:[];Array.isArray(s)||(s=[s]),r.push(s)}return r}}var use="layers-model",ri=class extends Zae{constructor(e){super(e),this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new G("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");jae(this,e,t,n)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=Vae(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof xi))throw new G("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(let s in e.loss)if(this.outputNames.indexOf(s)===-1)throw new G(`Unknown entry in loss dictionary: "${s}". Only expected the following keys: ${this.outputNames}`);for(let s of this.outputNames)e.loss[s]==null&&console.warn(`Output "${s}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${s} during training`),t.push(Xw(e.loss[s]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new G(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(s=>Xw(s))}else{let s=Xw(e.loss);this.outputs.forEach(i=>{t.push(s)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let s=0;s<this.outputs.length;++s){let i=this.internalOutputShapes[s],o=this.outputNames[s];this.feedOutputNames.push(o),this.feedOutputShapes.push(i),this.feedLossFns.push(this.lossFunctions[s])}let n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],El("loss",()=>{for(let s=0;s<this.outputs.length;++s){if(n.indexOf(s)!==-1)continue;let i=this.lossFunctions[s];this.outputs.length>1&&(this.metricsTensors.push([i,s]),this.metricsNames.push(this.outputNames[s]+"_loss"))}});let r=lse(e.metrics,this.outputNames),a=(s,i,o)=>{this.outputNames.length>1&&(i=this.outputNames[s]+"_"+i),this.metricsNames.push(i),this.metricsTensors.push([o,s])};El("metric",()=>{for(let s=0;s<this.outputs.length;++s){if(n.indexOf(s)!==-1)continue;let i=r[s];(o=>{let l="",c,u,h;for(let d of o){if(typeof d=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(d)!==-1){let f=this.internalOutputShapes[s];f[f.length-1]===1||this.lossFunctions[s]===lv?["accuracy","acc"].indexOf(d)!==-1?u=EN:["crossentropy","ce"].indexOf(d)!==-1&&(u=Cz):this.lossFunctions[s]===dx?["accuracy","acc"].indexOf(d)!==-1?u=Tz:["crossentropy","ce"].indexOf(d)!==-1&&(u=Ez):["accuracy","acc"].indexOf(d)!==-1?u=AN:["crossentropy","ce"].indexOf(d)!==-1&&(u=$N);let m;["accuracy","acc"].indexOf(d)!==-1?m="acc":["crossentropy","ce"].indexOf(d)!==-1&&(m="ce"),h=u,c=l+m}else h=Uae(d),c=l+Uy(d);let p;El(c,()=>{p=h}),a(s,c,p)}})(i)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){let r=n.batchSize==null?32:n.batchSize;Zw(r);let a=this.standardizeUserDataXY(e,t,!0,r);try{let s=a[0].concat(a[1]);this.makeTestFunction();let i=this.testFunction,o=this.testLoop(i,s,r,n.verbose,n.steps);return mr(o)}finally{Ba(a[0],e),Ba(a[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),ase(this,e,t)}checkNumSamples(e,t,n,r="steps"){let a;if(n!=null){if(a=null,t!=null)throw new G(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?a=e[0].shape[0]:a=e.shape[0];else throw new G(`Either the input data should have a defined shape, or ${r} shoud be specified.`);return a}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new G("`outputs` is an empty Array, which is not allowed.");let n=Array.isArray(t),r=n?t:[t],a=this.retrieveSymbolicTensors(r),s=new kh;if(e instanceof ze&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new G(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let o=0;o<this.inputs.length;++o)s.add(this.inputs[o],e[o])}else for(let o of this.inputs){let l=e[o.name];if(l==null)throw new G(`No value is provided for the model's input ${o.name}`);s.add(o,l)}let i=gf(a,s);return n?i:i[0]}retrieveSymbolicTensors(e){let t=Xl(null,e.length),n=e.length;for(let r of this.layers){let a=Array.isArray(r.output)?r.output:[r.output],s=a.map(i=>i.name);for(let i=0;i<e.length;++i){let o=s.indexOf(e[i]);if(o!==-1&&(t[i]=a[o],n--),n===0)break}if(n===0)break}if(n>0){let r=[];throw t.forEach((a,s)=>{a==null&&r.push(e[s])}),new G(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(r)}`)}return t}predictLoop(e,t=32,n=!1){return j(()=>{let r=this.checkNumSamples(e);if(n)throw new Ge("Verbose predictLoop() is not implemented yet.");let a=Yw(r,t),s=this.outputs.map(i=>[]);for(let i=0;i<a.length;++i)j(()=>{let o=a[i][0],l=a[i][1],c=rf(e,o,l),u=[];if(Array.isArray(c))for(let d=0;d<c.length;++d)u.push({key:this.inputs[d],value:c[d]});else u.push({key:this.inputs[0],value:c});let h=new kh(u);return gf(this.outputs,h)}).forEach((o,l)=>s[l].push(o));return mr(s.map(i=>xt(i,0)))})}predict(e,t={}){let n=Rz(e);h$(n,this.inputNames,this.feedInputShapes,!1);try{let r=t.batchSize==null?32:t.batchSize;return Zw(r),this.predictLoop(n,r)}finally{Ba(n,e)}}predictOnBatch(e){h$(e,this.inputNames,this.feedInputShapes,!0);let t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,r){if(this.optimizer_==null)throw new vs("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let a=[];for(let s=0;s<this.feedOutputShapes.length;++s){let i=this.feedOutputShapes[s];this.feedLossFns[s]===dx?a.push(i.slice(0,i.length-1).concat([1])):a.push(i)}if(e=c$(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=c$(t,this.feedOutputNames,a,!1,"target"),ise(e,t),ose(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&r!=null&&r>0&&e[0].shape[0]%r!==0)throw new G(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,r,a=!0,s){let[i,o]=this.standardizeUserDataXY(e,t,a,s);if(n!=null)throw new Error("sample weight is not supported yet.");let l=null;if(r!=null){let c=$z(r,this.outputNames);l=[];for(let u=0;u<c.length;++u)l.push(await Mz(o[u],null,c[u]))}return[i,o,l]}testLoop(e,t,n,r=0,a){return j(()=>{let s=this.checkNumSamples(t,n,a,"steps"),i=[];if(r>0)throw new Ge("Verbose mode is not implemented yet.");if(a!=null)throw new Ge("steps mode in testLoop() is not implemented yet");{let o=Yw(s,n),l=ut(es(0,s));for(let c=0;c<o.length;++c){let u=o[c][0],h=o[c][1],d=Al(l,u,h-u),p=Lk(t,d),f=e(p);if(c===0)for(let m=0;m<f.length;++m)i.push(_e(0));for(let m=0;m<f.length;++m){let y=f[m];i[m]=te(i[m],U(h-u,y))}}for(let c=0;c<i.length;++c)i[c]=xe(i[c],s)}return i})}getDedupedMetricsNames(){let e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){let r=e[n],a=r;if(ZA(e,r)>1){let s=ZA(e.slice(0,n),r);a+=`_${s}`}t.push(a)}return t}makeTrainFunction(){return e=>{let t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),s=[],i=()=>{let l=[];for(let d=0;d<this.inputs.length;++d)l.push({key:this.inputs[d],value:n[d]});let c=new kh(l),u=gf(this.outputs,c,{training:!0}),h;for(let d=0;d<this.lossFunctions.length;++d){let p=this.lossFunctions[d],f=p(r[d],u[d]);a[d]!=null&&(f=Jae(f,a[d]));let m=Dt(f);t.push(m),d===0?h=f:h=te(h,f)}for(let d=0;d<this.metricsTensors.length;++d){let p;if(this.outputs.length>1&&d<this.outputs.length)p=t[d];else{let f=this.metricsTensors[d][0],m=this.metricsTensors[d][1];p=Dt(f(r[m],u[m]))}an(p),s.push(p)}return h=Dt(h),this.calculateLosses().forEach(d=>{h=te(h,d)}),h},o=this.collectedTrainableWeights.map(l=>l.read());return[this.optimizer_.minimize(i,!0,o)].concat(s)}}makeTestFunction(){this.testFunction=e=>j(()=>{let t=[],n,r=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=[];for(let l=0;l<this.inputs.length;++l)s.push({key:this.inputs[l],value:r[l]});let i=new kh(s),o=gf(this.outputs,i);for(let l=0;l<this.lossFunctions.length;++l){let c=this.lossFunctions[l],u=Dt(c(a[l],o[l]));l===0?n=u:n=te(n,u),t.push(n)}for(let l=0;l<this.metricsTensors.length;++l){let c=this.metricsTensors[l][0],u=this.metricsTensors[l][1],h=Dt(c(a[u],o[u]));t.push(h)}return t})}async fit(e,t,n={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let r,a,s,i,o,l,c,u,h;try{let d=n.batchSize==null?32:n.batchSize;Zw(d);let p=await this.standardizeUserData(e,t,n.sampleWeight,n.classWeight,!1,d);r=p[0],a=p[1],h=p[2];let f=!1,m;if(n.validationData!=null&&n.validationData.length>0){if(f=!0,n.validationData.length===2)o=n.validationData[0],l=n.validationData[1];else throw n.validationData.length===3?new Ge("validationData including sample weights is not supported yet."):new G(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);let I=await this.standardizeUserData(o,l,null,null,!0,d);c=I[0],u=I[1],m=c.concat(u)}else if(n.validationSplit!=null&&n.validationSplit>0&&n.validationSplit<1){f=!0;let I=Math.floor(r[0].shape[0]*(1-n.validationSplit)),_=r[0].shape[0];c=rf(r,I,_),s=r,r=rf(r,0,I),u=rf(a,I,_),i=a,a=rf(a,0,I),m=c.concat(u)}else n.validationSteps!=null&&(f=!0);let y=r.concat(a).concat(h);this.checkTrainableWeightsConsistency();let g=this.makeTrainFunction(),x=this.getDedupedMetricsNames(),b,v;f?(this.makeTestFunction(),b=this.testFunction,v=x.slice().concat(x.map(I=>"val_"+I))):(b=null,m=[],v=x.slice());let w=Sz(n.callbacks,n.yieldEvery);return await this.fitLoop(g,y,x,d,n.epochs,n.verbose,w,b,m,n.shuffle,v,n.initialEpoch,null,null)}finally{this.isTraining=!1,Ba(r,e),Ba(a,t),Ba(s,e),Ba(i,t),Ba(c,o),Ba(u,l),h!=null&&Fe(h)}}async fitLoop(e,t,n,r,a,s,i,o,l,c,u,h,d,p){r==null&&(r=32),a==null&&(a=1),c==null&&(c=!0),h==null&&(h=0);let f=!1;if(o!=null&&l!=null&&(f=!0),p!=null&&(f=!0,d==null))throw new G("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let m=this.checkNumSamples(t,r,d,"steps_per_epoch"),y;m!=null&&(y=es(0,m)),s==null&&(s=1);let{callbackList:g,history:x}=Iz(i,s,a,h,m,d,r,f,u);g.setModel(this),this.history=x,await g.onTrainBegin(),this.stopTraining_=!1;for(let b=h;b<a;++b){await g.onEpochBegin(b);let v={};if(d!=null)throw new Ge("stepsPerEpoch mode is not implemented yet.");{if(c==="batch")throw new Ge("batch shuffling is not implemneted yet");c&&k.shuffle(y);let w=ut(y),I=Yw(m,r);for(let _=0;_<I.length;++_){let T={};if(await g.onBatchBegin(_,T),j(()=>{let A=I[_][0],M=I[_][1],F=Al(w,A,M-A);T.batch=_,T.size=M-A;let C=Lk(t,F),D=e(C);for(let L=0;L<n.length;++L){let O=n[L],q=D[L];T[O]=q,an(q)}if(_===I.length-1&&f){let L=this.testLoop(o,l,r);for(let O=0;O<n.length;++O){let q=n[O],H=L[O];an(H),v["val_"+q]=H}}}),await g.onBatchEnd(_,T),bz(T),this.stopTraining_)break}w.dispose()}if(await g.onEpochEnd(b,v),this.stopTraining_)break}return await g.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return tse(this,e,t)}async trainOnBatch(e,t){let n=await this.standardizeUserData(e,t),r=n[0],a=n[1],s=this.makeTrainFunction()(r.concat(a)),i=[];for(let o of s){let l=await o.data();i.push(l[0])}return Fe(s),Ba(n[0],e),Ba(n[1],t),mr(i)}getNamedWeights(e){let t=[],n=e!=null&&e.trainableOnly,r=n?this.trainableWeights:this.weights,a=this.getWeights(n);for(let s=0;s<r.length;++s)n&&!r[s].trainable||t.push({name:r[s].originalName,tensor:a[s]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){let e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){let t=wk().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-wk().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=qs(this.loss);else if(Array.isArray(this.loss)){for(let t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>qs(t))}else{let t=Object.keys(this.loss);e={};let n=this.loss;for(let r of t)if(typeof n[r]=="string")e[r]=qs(n[r]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[qs(Uy(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>qs(Uy(e)));{let e={};for(let t in this.metrics)e[t]=qs(Uy(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");let t=ym(e.optimizer_config),n=Ya(t),r;if(typeof e.loss=="string")r=fl(e.loss);else if(Array.isArray(e.loss))r=e.loss.map(s=>fl(s));else if(e.loss!=null){r={};for(let s in e.loss)r[s]=fl(e.loss[s])}let a;if(Array.isArray(e.metrics))a=e.metrics.map(s=>fl(s));else if(e.metrics!=null){a={};for(let s in e.metrics)a[s]=fl(e.metrics[s])}this.compile({loss:r,metrics:a,optimizer:n})}async save(e,t){if(typeof e=="string"){let a=Mn.getSaveHandlers(e);if(a.length===0)throw new G(`Cannot find any save handlers for URL '${e}'`);if(a.length>1)throw new G(`Found more than one (${a.length}) save handlers for URL '${e}'`);e=a[0]}if(e.save==null)throw new G("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let n=await Mn.encodeWeights(this.getNamedWeights(t)),r={modelTopology:this.toJSON(null,!1),format:use,generatedBy:`TensorFlow.js tfjs-layers v${MN}`,convertedBy:null};if(t!=null&&t.includeOptimizer&&this.optimizer!=null){r.trainingConfig=this.getTrainingConfig();let a="optimizer",{data:s,specs:i}=await Mn.encodeWeights(await this.optimizer.getWeights(),a);n.specs.push(...i),n.data=Mn.concatenateArrayBuffers([n.data,s])}return this.userDefinedMetadata!=null&&(i$(this.userDefinedMetadata,this.name,!0),r.userDefinedMetadata=this.userDefinedMetadata),r.weightData=n.data,r.weightSpecs=n.specs,e.save(r)}setUserDefinedMetadata(e){i$(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}};ri.className="Model";se.registerClass(ri);var Dz=class extends ri{};Dz.className="Functional";se.registerClass(Dz);async function cse(e,t){"modelTopology"in e||(e={modelTopology:e}),e=e;let n=e.modelTopology;n.model_config!=null&&(n=n.model_config);let r=ym(n),a=Ya(r,t);if(e.weightsManifest!=null){let s=await Mn.loadWeights(e.weightsManifest,e.pathPrefix,a.weights.map(o=>o.originalName)),i={};for(let o of a.weights)i[o.originalName]=s[o.originalName];a.loadWeights(i),Fe(s)}return a}async function hse(e,t){if(t==null&&(t={}),typeof e=="string"){let n=Mn.getLoadHandlers(e,t);if(n.length===0)n.push(Mn.browserHTTPRequest(e,t));else if(n.length>1)throw new G(`Found more than one (${n.length}) load handlers for URL '${e}'`);e=n[0]}return dse(e,void 0,t)}async function dse(e,t,n){if(n==null&&(n={}),e.load==null)throw new G("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let r=await e.load(),a=r.modelTopology;a.model_config!=null&&(a=a.model_config);let s=n.strict==null?!0:n.strict,i=r.weightData!=null&&r.weightSpecs!=null&&s,o=Ya(ym(a),t,i),l=r.trainingConfig;if(l!=null&&o.loadTrainingConfig(l),r.userDefinedMetadata!=null&&o.setUserDefinedMetadata(r.userDefinedMetadata),r.weightData!=null){if(r.weightSpecs==null)throw new G("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");let{modelWeights:c,optimizerWeights:u}=pse(r.weightData,r.weightSpecs);o.loadWeights(c,s),o.optimizer!=null&&u.length>0&&await o.optimizer.setWeights(u),Fe(c),Fe(u.map(h=>h.tensor))}return o}function pse(e,t){let n=Mn.decodeWeights(e,t),r={},a=[];return t.forEach(s=>{s.group==="optimizer"?a.push({name:s.name,tensor:n[s.name]}):r[s.name]=n[s.name]}),{modelWeights:r,optimizerWeights:a}}var uv=class Wk extends ri{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=t.name!=null?t.name:Yb("sequential_"),t.layers!=null)for(let n of t.layers)this.add(n)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(n=>n<0))throw new G(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){let n=t instanceof Wk||t instanceof ri,r;if(n){if(r=t,r.outputs.length!==1)throw new G("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(r.inputs.length!==1)throw new G("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null)throw new G("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let a=fz({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(a)}if(n)this.outputs=r.outputs,this.inputs=r.inputs;else{if(t.inboundNodes.length!==1)throw new G(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(t.inboundNodes[0].outputTensors.length!==1)throw new G("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=pz(this.outputs[0])}this.inboundNodes=[],new iv({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Xl(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(a=>a.shape),outputShapes:this.outputs[0].shape})}else{let a=t.apply(this.outputs[0]);if(Array.isArray(a))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[a],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,n){return this.model==null&&this.build(),this.model.call(t,n)}build(t){if(rt(t),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new ri({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,n,r=console.log){this.built||this.build(),super.summary(t,n,r)}setWeights(t){this.model==null&&this.build(),this.model.setWeights(t)}evaluate(t,n,r={}){if(!this.built)throw new vs("The model needs to be compiled before being used.");return this.model.evaluate(t,n,r)}async evaluateDataset(t,n){if(!this.built)throw new vs("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,n)}predict(t,n={}){return this.model==null&&this.build(),this.model.predict(t,n)}predictOnBatch(t){return this.model==null&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,n,r={}){if(!this.built)throw new vs("The model needs to be compiled before being used.");return this.model.fit(t,n,r)}async fitDataset(t,n){if(!this.built)throw new vs("The model needs to be compiled before being used.");return this.model.fitDataset(t,n)}async trainOnBatch(t,n){return this.model.trainOnBatch(t,n)}static fromConfig(t,n,r={},a=!1){let s,i={};if(n instanceof Array){if(n[0].className==null||n[0].className==="Merge")throw new G("Legacy serialization format not supported yet.");s=n}else k.assert(n.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),s=n.layers,delete n.layers,i=n;let o=new t(i);if(!(o instanceof Wk))throw new Ge(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(let l of s){let c=Ya(l,void 0,a);a&&c.setFastWeightInitDuringBuild(!0),o.add(c)}return o}set stopTraining(t){if(this.model==null)throw new G("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(this.model==null)throw new G("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let t=[];for(let n of this.layers){let r={};r.className=n.getClassName(),r.config=n.getConfig(),t.push(r)}return{name:this.name,layers:t}}};uv.className="Sequential";se.registerClass(uv);function fse(e){return new ri(e)}function mse(e){return new uv(e)}function Oz(e){return fz(e)}function gse(e,t){CN.registerCallbackConstructor(e,t)}var Wn=class extends se.Serializable{getConfig(){return{}}},zz=class extends Wn{apply(e,t=1){return Dre(e,t)}};zz.className="elu";se.registerClass(zz);var Pz=class extends Wn{apply(e){return Rb(e)}};Pz.className="selu";se.registerClass(Pz);var Lz=class extends Wn{apply(e){return ht(e)}};Lz.className="relu";se.registerClass(Lz);var Bz=class extends Wn{apply(e){return j(()=>wo(6,ht(e)))}};Bz.className="relu6";se.registerClass(Bz);var Wz=class extends Wn{apply(e){return e}};Wz.className="linear";se.registerClass(Wz);var Uz=class extends Wn{apply(e){return Ca(e)}};Uz.className="sigmoid";se.registerClass(Uz);var Vz=class extends Wn{apply(e){return zre(e)}};Vz.className="hardSigmoid";se.registerClass(Vz);var jz=class extends Wn{apply(e){return Tc(e)}};jz.className="softplus";se.registerClass(jz);var Gz=class extends Wn{apply(e){return Ore(e)}};Gz.className="softsign";se.registerClass(Gz);var Hz=class extends Wn{apply(e){return vo(e)}};Hz.className="tanh";se.registerClass(Hz);var FN=class extends Wn{apply(e,t=-1){return Uo(e,t)}};FN.className="softmax";se.registerClass(FN);var qz=class extends Wn{apply(e,t=-1){return Cb(e,t)}};qz.className="logSoftmax";se.registerClass(qz);var Kz=class extends Wn{apply(e){return j(()=>j(()=>{let t=Math.sqrt(2),n=U(.5,te(1,Ib(xe(e,t))));return U(e,n)}))}};Kz.className="gelu";se.registerClass(Kz);var Xz=class extends Wn{apply(e){return j(()=>U(.5,U(e,te(1,vo(U(wn(xe(2,Math.PI)),te(e,U(.044715,Ts(e,3)))))))))}};Xz.className="gelu_new";se.registerClass(Xz);var Zz=class extends Wn{apply(e){return j(()=>U(e,vo(Tc(e))))}};Zz.className="mish";se.registerClass(Zz);var Yz=class extends Wn{apply(e,t=1){return j(()=>U(Ca(U(e,t)),e))}};Yz.className="swish";se.registerClass(Yz);function Io(e){return e.getClassName()}function Jw(e,t={}){return Ig(e,se.SerializationMap.getMap().classNameMap,t,"activation")}function No(e){if(e==null){let t={};return t.className="linear",t.config={},Jw(t)}if(typeof e=="string"){let t={};return t.className=e,t.config={},Jw(t)}else return e instanceof Wn?e:Jw(e)}function RN(e){if(e!=null&&typeof e!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}var Jz=class extends se.Serializable{},Eg=class extends Jz{constructor(e){super(),RN(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return j(()=>{let t=Ot([1]);return this.hasL1&&(t=te(t,ke(U(this.l1,Kt(e))))),this.hasL2&&(t=te(t,ke(U(this.l2,_g(e))))),V(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}};Eg.className="L1L2";se.registerClass(Eg);function yse(e){return RN(e),new Eg({l1:e!=null?e.l1:null,l2:0})}function xse(e){return RN(e),new Eg({l2:e!=null?e.l2:null,l1:0})}var d$={l1l2:"L1L2"};function wt(e){return hN(e)}function p$(e,t={}){return Ig(e,se.SerializationMap.getMap().classNameMap,t,"regularizer")}function Mt(e){if(e==null)return null;if(typeof e=="string"){let t={className:e in d$?d$[e]:e,config:{}};return p$(t)}else return e instanceof Jz?e:p$(e)}var DN=class extends He{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=Me(e);let n=ht(e);return this.maxValue!=null&&(n=Ln(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){let e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}};DN.className="ReLU";se.registerClass(DN);var ON=class extends He{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=Me(e);return pg(n,this.alpha)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};ON.className="LeakyReLU";se.registerClass(ON);var zN=class extends He{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=$t(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Mt(e.alphaRegularizer),this.alphaConstraint=cn(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new G(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=rt(e);let t=e.slice(1);if(this.sharedAxes!=null)for(let r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let n={};if(this.sharedAxes!=null)for(let r=1;r<e.length;++r)n[r]=e[r];this.inputSpec=[new Zt({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=Me(e),bg(e,this.alpha.read())}getConfig(){let e={alphaInitializer:zt(this.alphaInitializer),alphaRegularizer:wt(this.alphaRegularizer),alphaConstraint:un(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}};zN.className="PReLU";se.registerClass(zN);var PN=class extends He{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new Ge(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=Me(e);return bp(n)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};PN.className="ELU";se.registerClass(PN);var LN=class extends He{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){let n=Me(e);return U(n,le(or(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){let e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}};LN.className="ThresholdedReLU";se.registerClass(LN);var BN=class extends He{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new FN().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){return j(()=>{let n=Me(e),r=t.mask;if(r!=null){let a=U(me(gr(n.shape),le(r,n.dtype)),_e(-1e9));n=te(n,a)}return this.axis instanceof Array?this.axis.length>1?Bn(me(n,mg(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)})}computeOutputShape(e){return e}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};BN.className="Softmax";se.registerClass(BN);function Rh(e,t,n){if(typeof e=="number")return Xl(e,t);if(e.length!==t)throw new G(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let r=0;r<t;++r){let a=e[r];if(!$re(a))throw new G(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${a}`)}return e}function Ja(e,t,n,r,a=1){if(e==null)return e;let s=t+(t-1)*(a-1),i;return n==="same"?i=e:i=e-s+1,Math.floor((i+r-1)/r)}function ys(e,t,n,r){if(e==null)return null;if(r==="valid")e=e*t+So([n-t,0]);else if(r==="same")e=e*t;else throw new G(`Unsupport padding mode: ${r}.`);return e}function WN(e,t){return j(()=>(Gt(t),t==="channelsFirst"?Ue(e,[0,2,3,1]):e))}function Qz(e,t){return j(()=>(Gt(t),t==="channelsFirst"?Ue(e,[0,2,3,4,1]):e))}function bse(e,t,n,r=1,a="valid",s,i=1){return j(()=>{if(s==null&&(s=ts()),Gt(s),e.shape.length!==3)throw new G(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(t.shape.length!==3)throw new G(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(n!=null&&n.shape.length!==1)throw new G(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);if(s==="channelsFirst"&&(e=Ue(e,[0,2,1])),a==="causal")throw new Ge("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=vb(e,t,r,a==="same"?"same":"valid","NWC",i);return n!=null&&(o=is(o,n)),o})}function f$(e,t,n,r=[1,1],a="valid",s,i,o=null){return j(()=>{if(s==null&&(s=ts()),Gt(s),e.rank!==3&&e.rank!==4)throw new G(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(t.rank!==3&&t.rank!==4)throw new G(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=WN(e,s);if(a==="causal")throw new Ge("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=ed.conv2d({x:l,filter:t,strides:r,pad:a==="same"?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),s==="channelsFirst"&&(l=Ue(l,[0,3,1,2])),l})}function vse(e,t,n,r=[1,1,1],a="valid",s,i){return j(()=>{if(s==null&&(s=ts()),Gt(s),e.rank!==4&&e.rank!==5)throw new G(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(t.rank!==4&&t.rank!==5)throw new G(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=Qz(e,s);if(a==="causal")throw new Ge("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=mI(o,t,r,a==="same"?"same":"valid","NDHWC",i),n!=null&&(o=is(o,n)),s==="channelsFirst"&&(o=Ue(o,[0,4,1,2,3])),o})}var eP=class tP extends He{constructor(t,n){if(super(n),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",tP.verifyArgs(n),this.rank=t,bn(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Ge(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Rh(n.kernelSize,t,"kernelSize"),this.strides=Rh(n.strides==null?1:n.strides,t,"strides"),this.padding=n.padding==null?"valid":n.padding,ma(this.padding),this.dataFormat=n.dataFormat==null?"channelsLast":n.dataFormat,Gt(this.dataFormat),this.activation=No(n.activation),this.useBias=n.useBias==null?!0:n.useBias,this.biasInitializer=$t(n.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=cn(n.biasConstraint),this.biasRegularizer=Mt(n.biasRegularizer),this.activityRegularizer=Mt(n.activityRegularizer),this.dilationRate=Rh(n.dilationRate==null?1:n.dilationRate,t,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new G(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new G(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new G(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(t){if(gs("kernelSize"in t,"required key 'kernelSize' not in config"),typeof t.kernelSize!="number"&&!dN(t.kernelSize,"number",1,3))throw new G(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){let t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Io(this.activation),useBias:this.useBias,biasInitializer:zt(this.biasInitializer),biasRegularizer:wt(this.biasRegularizer),activityRegularizer:wt(this.activityRegularizer),biasConstraint:un(this.biasConstraint)},n=super.getConfig();return Object.assign(t,n),t}},cv=class nP extends eP{constructor(t,n){super(t,n),this.kernel=null,nP.verifyArgs(n),this.filters=n.filters,bn(this.filters,"filters"),this.kernelInitializer=$t(n.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=cn(n.kernelConstraint),this.kernelRegularizer=Mt(n.kernelRegularizer)}build(t){t=rt(t);let n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null)throw new G(`The channel dimension of the input should be defined. Found ${t[n]}`);let r=t[n],a=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[n]:r}}],this.built=!0}call(t,n){return j(()=>{t=Me(t);let r,a=this.bias==null?null:this.bias.read(),s=az(this.activation.getClassName());if(s!=null&&this.rank===2)r=f$(t,this.kernel.read(),a,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(this.rank===1)r=bse(t,this.kernel.read(),a,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)r=f$(t,this.kernel.read(),a,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)r=vse(t,this.kernel.read(),a,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Ge("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(r=this.activation.apply(r))}return r})}computeOutputShape(t){t=rt(t);let n=[],r=this.dataFormat==="channelsLast"?t.slice(1,t.length-1):t.slice(2);for(let s=0;s<r.length;++s){let i=Ja(r[s],this.kernelSize[s],this.padding,this.strides[s],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[s]);n.push(i)}let a=[t[0]];return this.dataFormat==="channelsLast"?(a=a.concat(n),a.push(this.filters)):(a.push(this.filters),a=a.concat(n)),a}getConfig(){let t={filters:this.filters,kernelInitializer:zt(this.kernelInitializer),kernelRegularizer:wt(this.kernelRegularizer),kernelConstraint:un(this.kernelConstraint)},n=super.getConfig();return Object.assign(t,n),t}static verifyArgs(t){if(!("filters"in t)||typeof t.filters!="number"||t.filters<1)throw new G(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}},hv=class rP extends cv{constructor(t){super(2,t),rP.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!dN(t.kernelSize,"number",1,2))throw new G(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}};hv.className="Conv2D";se.registerClass(hv);var dv=class aP extends cv{constructor(t){super(3,t),aP.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3)))throw new G(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}};dv.className="Conv3D";se.registerClass(dv);var UN=class extends hv{constructor(e){if(super(e),this.inputSpec=[new Zt({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new G(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=rt(e),e.length!==4)throw new G("Input should have rank 4; Received input shape: "+JSON.stringify(e));let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new G("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Zt({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return j(()=>{let n=Me(e);if(n.shape.length!==4)throw new G(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let r=n.shape,a=r[0],s,i;this.dataFormat==="channelsFirst"?(s=2,i=3):(s=1,i=2);let o=r[s],l=r[i],c=this.kernelSize[0],u=this.kernelSize[1],h=this.strides[0],d=this.strides[1],p=ys(o,h,c,this.padding),f=ys(l,d,u,this.padding),m=[a,p,f,this.filters];this.dataFormat!=="channelsLast"&&(n=Ue(n,[0,2,3,1]));let y=wb(n,this.kernel.read(),m,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(y=Ue(y,[0,3,1,2])),this.bias!=null&&(y=is(y,this.bias.read(),this.dataFormat)),this.activation!=null&&(y=this.activation.apply(y)),y})}computeOutputShape(e){e=rt(e);let t=e.slice(),n,r,a;this.dataFormat==="channelsFirst"?(n=1,r=2,a=3):(n=3,r=1,a=2);let s=this.kernelSize[0],i=this.kernelSize[1],o=this.strides[0],l=this.strides[1];return t[n]=this.filters,t[r]=ys(t[r],o,s,this.padding),t[a]=ys(t[a],l,i,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};UN.className="Conv2DTranspose";se.registerClass(UN);var VN=class extends dv{constructor(e){if(super(e),this.inputSpec=[new Zt({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new G(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=rt(e),e.length!==5)throw new G("Input should have rank 5; Received input shape: "+JSON.stringify(e));let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new G("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Zt({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return j(()=>{let n=Me(e);if(n.shape.length!==5)throw new G(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let r=n.shape,a=r[0],s,i,o;this.dataFormat==="channelsFirst"?(o=2,s=3,i=4):(o=1,s=2,i=3);let l=r[o],c=r[s],u=r[i],h=this.kernelSize[0],d=this.kernelSize[1],p=this.kernelSize[2],f=this.strides[0],m=this.strides[1],y=this.strides[2],g=ys(l,f,h,this.padding),x=ys(c,m,d,this.padding),b=ys(u,y,p,this.padding),v=[a,g,x,b,this.filters];this.dataFormat!=="channelsLast"&&(n=Ue(n,[0,2,3,4,1]));let w=gI(n,this.kernel.read(),v,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(w=Ue(w,[0,4,1,2,3])),this.bias!==null&&(w=is(w,this.bias.read(),this.dataFormat)),this.activation!==null&&(w=this.activation.apply(w)),w})}computeOutputShape(e){e=rt(e);let t=e.slice(),n,r,a,s;this.dataFormat==="channelsFirst"?(n=1,r=2,a=3,s=4):(n=4,r=1,a=2,s=3);let i=this.kernelSize[0],o=this.kernelSize[1],l=this.kernelSize[2],c=this.strides[0],u=this.strides[1],h=this.strides[2];return t[n]=this.filters,t[r]=ys(t[r],c,i,this.padding),t[a]=ys(t[a],u,o,this.padding),t[s]=ys(t[s],h,l,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};VN.className="Conv3DTranspose";se.registerClass(VN);var sP=class extends cv{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new G("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new G("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new G(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=$t(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Mt(t.depthwiseRegularizer),this.depthwiseConstraint=cn(t.depthwiseConstraint),this.pointwiseInitializer=$t(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Mt(t.pointwiseRegularizer),this.pointwiseConstraint=cn(t.pointwiseConstraint)}build(e){if(e=rt(e),e.length<this.rank+2)throw new G(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new G(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);let n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),a=[];for(let i=0;i<this.rank;++i)a.push(1);a.push(n*this.depthMultiplier,this.filters);let s=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,s,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,s,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,s,this.biasConstraint):this.bias=null,this.inputSpec=[new Zt({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return j(()=>{e=Me(e);let n;if(this.rank===1)throw new Ge("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=Ue(e,[0,2,3,1])),n=Sp(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(n=is(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),this.dataFormat==="channelsFirst"&&(n=Ue(n,[0,3,1,2])),n})}getConfig(){let e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=zt(this.depthwiseInitializer),e.pointwiseInitializer=zt(this.pointwiseInitializer),e.depthwiseRegularizer=wt(this.depthwiseRegularizer),e.pointwiseRegularizer=wt(this.pointwiseRegularizer),e.depthwiseConstraint=un(this.depthwiseConstraint),e.pointwiseConstraint=un(this.pointwiseConstraint),e}};sP.className="SeparableConv";var jN=class extends sP{constructor(e){super(2,e)}};jN.className="SeparableConv2D";se.registerClass(jN);var GN=class iP extends cv{constructor(t){super(1,t),iP.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){let t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!dN(t.kernelSize,"number",1,1))throw new G(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}};GN.className="Conv1D";se.registerClass(GN);var HN=class extends He{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return j(()=>{if(e=Me(e),this.dataFormat==="channelsLast"){let n=Wy(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Wy(n,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{let n=Wy(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Wy(n,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};HN.className="Cropping2D";se.registerClass(HN);var qN=class extends He{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Gt(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,Tre(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){let t=e[2]==null?null:this.size[0]*e[2],n=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,n]}else{let t=e[1]==null?null:this.size[0]*e[1],n=e[2]==null?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return j(()=>{let n=Me(e),r=n.shape;if(this.dataFormat==="channelsFirst"){n=Ue(n,[0,2,3,1]);let a=this.size[0]*r[2],s=this.size[1]*r[3],i=this.interpolation==="nearest"?ra.resizeNearestNeighbor(n,[a,s]):ra.resizeBilinear(n,[a,s]);return Ue(i,[0,3,1,2])}else{let a=this.size[0]*r[1],s=this.size[1]*r[2];return this.interpolation==="nearest"?ra.resizeNearestNeighbor(n,[a,s]):ra.resizeBilinear(n,[a,s])}})}getConfig(){let e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}};qN.className="UpSampling2D";se.registerClass(qN);function wse(e,t,n=[1,1],r="valid",a,s){return j(()=>{a==null&&(a=ts()),Gt(a);let i=WN(e,a);if(e.rank!==4)throw new G(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(t.rank!==4)throw new G(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=Cc(i,t,n,r==="same"?"same":"valid","NHWC",s),a==="channelsFirst"&&(i=Ue(i,[0,3,1,2])),i})}var KN=class extends eP{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=$t(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=cn(e.depthwiseConstraint),this.depthwiseRegularizer=Mt(e.depthwiseRegularizer)}build(e){if(e=rt(e),e.length<4)throw new G(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);let t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new G(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);let n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return j(()=>{e=Me(e);let n=wse(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(n=is(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),n})}computeOutputShape(e){e=rt(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,a=Ja(t,this.kernelSize[0],this.padding,this.strides[0]),s=Ja(n,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],r,a,s]:[e[0],a,s,r]}getConfig(){let e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=zt(this.depthwiseInitializer),e.depthwiseRegularizer=wt(this.depthwiseRegularizer),e.depthwiseConstraint=un(this.depthwiseRegularizer),e}};KN.className="DepthwiseConv2D";se.registerClass(KN);function oP(e,t,n,r){if(Array.isArray(e)){if(t!=null||n!=null)throw new G("When inputs is an array, neither initialState or constants should be provided");r!=null&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function a(s){return s==null||Array.isArray(s)?s:[s]}return t=a(t),n=a(n),{inputs:e,initialState:t,constants:n}}function lP(e,t,n,r=!1,a,s,i=!1,o=!1){return j(()=>{let l=t.shape.length;if(l<3)throw new G(`Input should be at least 3D, but is ${l}D.`);let c=[1,0].concat(es(2,l));t=Ue(t,c),s!=null,i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),a!=null&&(a=le(le(a,"bool"),"float32"),a.rank===l-1&&(a=yn(a,-1)),a=Ue(a,c)),r&&(t=da(t,0),a!=null&&(a=da(a,0)));let u=[],h,d=n,p=t.shape[0],f=Vt(t),m;a!=null&&(m=Vt(a));for(let g=0;g<p;++g){let x=f[g],b=j(()=>e(x,d));if(a==null)h=b[0],d=b[1];else{let v=j(()=>{let w=m[g],I=me(Gr(w),w),_=te(U(b[0],w),U(d[0],I)),T=d.map((A,M)=>te(U(b[1][M],w),U(A,I)));return{output:_,newStates:T}});h=v.output,d=v.newStates}o&&u.push(h)}let y;return o&&(y=Jt(u,1)),[h,y,d]})}var bi=class uP extends He{constructor(t){super(t);let n;if(t.cell==null)throw new G("cell property is missing for the constructor of RNN.");if(Array.isArray(t.cell)?n=new mv({cells:t.cell}):n=t.cell,n.stateSize==null)throw new G("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=n,this.returnSequences=t.returnSequences==null?!1:t.returnSequences,this.returnState=t.returnState==null?!1:t.returnState,this.goBackwards=t.goBackwards==null?!1:t.goBackwards,this._stateful=t.stateful==null?!1:t.stateful,this.unroll=t.unroll==null?!1:t.unroll,this.supportsMasking=!0,this.inputSpec=[new Zt({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return es(0,t).map(n=>null)}else return this.states_}setStates(t){this.states_=t}computeOutputShape(t){Dk(t)&&(t=t[0]),t=t;let n=this.cell.stateSize;Array.isArray(n)||(n=[n]);let r=n[0],a;if(this.returnSequences?a=[t[0],t[1],r]:a=[t[0],r],this.returnState){let s=[];for(let i of n)s.push([t[0],i]);return[a].concat(s)}else return a}computeMask(t,n){return j(()=>{Array.isArray(n)&&(n=n[0]);let r=this.returnSequences?n:null;if(this.returnState){let a=this.states.map(s=>null);return[r].concat(a)}else return r})}get states(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,n=[];for(let r=0;r<t;++r)n.push(null);return n}else return this.states_}set states(t){this.states_=t}build(t){if(this.numConstants!=null)throw new Ge("Constants support is not implemented in RNN yet.");Dk(t)&&(t=t[0]),t=t;let n=this.stateful?t[0]:null,r=t.slice(2);this.inputSpec[0]=new Zt({shape:[n,null,...r]});let a=[t[0]].concat(t.slice(2));this.cell.build(a);let s;if(Array.isArray(this.cell.stateSize)?s=this.cell.stateSize:s=[this.cell.stateSize],this.stateSpec!=null){if(!k.arraysEqual(this.stateSpec.map(i=>i.shape[i.shape.length-1]),s))throw new G(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=s.map(i=>new Zt({shape:[null,i]}));this.stateful&&this.resetStates()}resetStates(t,n=!1){j(()=>{if(!this.stateful)throw new Bi("Cannot call resetStates() on an RNN Layer that is not stateful.");let r=this.inputSpec[0].shape[0];if(r==null)throw new G("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(a=>Ot([r,a])):this.states_=[Ot([r,this.cell.stateSize])];else if(t==null)Fe(this.states_),this.keptStates!=null&&(Fe(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(a=>Ot([r,a])):this.states_[0]=Ot([r,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new G(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);n===!0?this.keptStates.push(this.states_.slice()):Fe(this.states_);for(let a=0;a<this.states_.length;++a){let s=t[a],i=Array.isArray(this.cell.stateSize)?this.cell.stateSize[a]:this.cell.stateSize,o=[r,i];if(!k.arraysEqual(s.shape,o))throw new G(`State ${a} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${s.shape}`);this.states_[a]=s}}this.states_=this.states_.map(a=>an(a.clone()))})}apply(t,n){let r=n==null?null:n.initialState,a=n==null?null:n.constants;n==null&&(n={});let s=oP(t,r,a,this.numConstants);t=s.inputs,r=s.initialState,a=s.constants;let i=[],o=[];if(r!=null){n.initialState=r,i=i.concat(r),this.stateSpec=[];for(let l of r)this.stateSpec.push(new Zt({shape:l.shape}));o=o.concat(this.stateSpec)}if(a!=null&&(n.constants=a,i=i.concat(a),this.numConstants=a.length),i[0]instanceof ns){let l=[t].concat(i),c=this.inputSpec.concat(o),u=this.inputSpec;this.inputSpec=c;let h=super.apply(l,n);return this.inputSpec=u,h}else return super.apply(t,n)}call(t,n){return j(()=>{let r=n==null?null:n.mask,a=n==null?null:n.training,s=n==null?null:n.initialState;t=Me(t),s==null&&(this.stateful?s=this.states_:s=this.getInitialState(t));let i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==i)throw new G(`RNN Layer has ${i} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let o={training:a},l=lP((p,f)=>{let m=this.cell.call([p].concat(f),o);return[m[0],m.slice(1)]},t,s,this.goBackwards,r,null,this.unroll,this.returnSequences),c=l[0],u=l[1],h=l[2];this.stateful&&this.resetStates(h,a);let d=this.returnSequences?u:c;return this.returnState?[d].concat(h):d})}getInitialState(t){return j(()=>{let n=Ot(t.shape);return n=ke(n,[1,2]),n=Ng(n),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(r=>r>1?Fk(n,[1,r]):n):this.cell.stateSize>1?[Fk(n,[1,this.cell.stateSize])]:[n]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){let t=super.getConfig(),n={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(n.numConstants=this.numConstants);let r=this.cell.getConfig();return this.getClassName()===uP.className&&(n.cell={className:this.cell.getClassName(),config:r}),Object.assign(Object.assign(Object.assign({},r),t),n)}static fromConfig(t,n,r={}){let a=n.cell,s=Ya(a,r);return new t(Object.assign(n,{cell:s}))}};bi.className="RNN";se.registerClass(bi);var Ag=class extends He{},pv=class extends Ag{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,bn(this.units,"units"),this.activation=No(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=$t(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=$t(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=$t(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Mt(e.kernelRegularizer),this.recurrentRegularizer=Mt(e.recurrentRegularizer),this.biasRegularizer=Mt(e.biasRegularizer),this.kernelConstraint=cn(e.kernelConstraint),this.recurrentConstraint=cn(e.recurrentConstraint),this.biasConstraint=cn(e.biasConstraint),this.dropout=td([1,So([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=td([1,So([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=rt(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return j(()=>{if(e=e,e.length!==2)throw new G(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];let r=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=_o({ones:()=>Gr(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=_o({ones:()=>Gr(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let a,s=this.dropoutMask,i=this.recurrentDropoutMask;s!=null?a=_s(U(e,s),this.kernel.read()):a=_s(e,this.kernel.read()),this.bias!=null&&(a=is(a,this.bias.read())),i!=null&&(n=U(n,i));let o=te(a,_s(n,this.recurrentKernel.read()));return this.activation!=null&&(o=this.activation.apply(o)),[o,o]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:Io(this.activation),useBias:this.useBias,kernelInitializer:zt(this.kernelInitializer),recurrentInitializer:zt(this.recurrentInitializer),biasInitializer:zt(this.biasInitializer),kernelRegularizer:wt(this.kernelRegularizer),recurrentRegularizer:wt(this.recurrentRegularizer),biasRegularizer:wt(this.biasRegularizer),activityRegularizer:wt(this.activityRegularizer),kernelConstraint:un(this.kernelConstraint),recurrentConstraint:un(this.recurrentConstraint),biasConstraint:un(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}};pv.className="SimpleRNNCell";se.registerClass(pv);var XN=class extends bi{constructor(e){e.cell=new pv(e),super(e)}call(e,t){return j(()=>{this.cell.dropoutMask!=null&&(Fe(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Fe(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,r=t==null?null:t.training,a=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})})}static fromConfig(e,t){return new e(t)}};XN.className="SimpleRNN";se.registerClass(XN);var fv=class extends Ag{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new G("GRUCell does not support reset_after parameter set to true.");this.units=e.units,bn(this.units,"units"),this.activation=No(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=No(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=$t(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=$t(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=$t(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Mt(e.kernelRegularizer),this.recurrentRegularizer=Mt(e.recurrentRegularizer),this.biasRegularizer=Mt(e.biasRegularizer),this.kernelConstraint=cn(e.kernelConstraint),this.recurrentConstraint=cn(e.recurrentConstraint),this.biasConstraint=cn(e.biasConstraint),this.dropout=td([1,So([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=td([1,So([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=rt(e);let t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return j(()=>{if(e=e,e.length!==2)throw new G(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training==null?!1:t.training,r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=_o({ones:()=>Gr(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=_o({ones:()=>Gr(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));let a=this.dropoutMask,s=this.recurrentDropoutMask,i,o,l;0<this.dropout&&this.dropout<1&&(e=U(e,a[0]));let c=_s(e,this.kernel.read());this.useBias&&(c=is(c,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=U(r,s[0]));let u=this.recurrentKernel.read(),[h,d]=xr(u,[2*this.units,this.units],u.rank-1),p=_s(r,h),[f,m,y]=xr(c,3,c.rank-1),[g,x]=xr(p,2,p.rank-1);i=this.recurrentActivation.apply(te(f,g)),o=this.recurrentActivation.apply(te(m,x));let b=_s(U(o,r),d);l=this.activation.apply(te(y,b));let v=te(U(i,r),U(te(1,Nt(i)),l));return[v,v]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:Io(this.activation),recurrentActivation:Io(this.recurrentActivation),useBias:this.useBias,kernelInitializer:zt(this.kernelInitializer),recurrentInitializer:zt(this.recurrentInitializer),biasInitializer:zt(this.biasInitializer),kernelRegularizer:wt(this.kernelRegularizer),recurrentRegularizer:wt(this.recurrentRegularizer),biasRegularizer:wt(this.biasRegularizer),activityRegularizer:wt(this.activityRegularizer),kernelConstraint:un(this.kernelConstraint),recurrentConstraint:un(this.recurrentConstraint),biasConstraint:un(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}};fv.className="GRUCell";se.registerClass(fv);var ZN=class extends bi{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new fv(e),super(e)}call(e,t){return j(()=>{this.cell.dropoutMask!=null&&(Fe(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Fe(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,r=t==null?null:t.training,a=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};ZN.className="GRU";se.registerClass(ZN);var $g=class extends Ag{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,bn(this.units,"units"),this.activation=No(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=No(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=$t(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=$t(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=$t(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=Mt(e.kernelRegularizer),this.recurrentRegularizer=Mt(e.recurrentRegularizer),this.biasRegularizer=Mt(e.biasRegularizer),this.kernelConstraint=cn(e.kernelConstraint),this.recurrentConstraint=cn(e.recurrentConstraint),this.biasConstraint=cn(e.biasConstraint),this.dropout=td([1,So([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=td([1,So([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=rt(e);let n=e[e.length-1];this.kernel=this.addWeight("kernel",[n,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let r;if(this.useBias){if(this.unitForgetBias){let a=this.biasInitializer,s=this.units;r=new(t=class extends Ma{apply(i,o){let l=a.apply([s]),c=new Qb().apply([s]),u=a.apply([s*2]);return JA(JA(l,c),u)}},t.className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return j(()=>{let n=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new G(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1],a=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=_o({ones:()=>Gr(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=_o({ones:()=>Gr(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let s=this.dropoutMask,i=this.recurrentDropoutMask,o,l,c,u;0<this.dropout&&this.dropout<1&&(e=U(e,s[0]));let h=_s(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=U(r,i[0])),h=te(h,_s(r,this.recurrentKernel.read())),this.useBias&&(h=is(h,this.bias.read()));let[d,p,f,m]=xr(h,4,h.rank-1);o=this.recurrentActivation.apply(d),l=this.recurrentActivation.apply(p),c=te(U(l,a),U(o,this.activation.apply(f))),u=this.recurrentActivation.apply(m);let y=U(u,this.activation.apply(c));return[y,y,c]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:Io(this.activation),recurrentActivation:Io(this.recurrentActivation),useBias:this.useBias,kernelInitializer:zt(this.kernelInitializer),recurrentInitializer:zt(this.recurrentInitializer),biasInitializer:zt(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:wt(this.kernelRegularizer),recurrentRegularizer:wt(this.recurrentRegularizer),biasRegularizer:wt(this.biasRegularizer),activityRegularizer:wt(this.activityRegularizer),kernelConstraint:un(this.kernelConstraint),recurrentConstraint:un(this.recurrentConstraint),biasConstraint:un(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}};$g.className="LSTMCell";se.registerClass($g);var YN=class extends bi{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new $g(e),super(e)}call(e,t){return j(()=>{this.cell.dropoutMask!=null&&(Fe(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Fe(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,r=t==null?null:t.training,a=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};YN.className="LSTM";se.registerClass(YN);var mv=class extends Ag{constructor(e){super(e),this.cells=e.cells}get stateSize(){let e=[];for(let t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return j(()=>{e=e;let n=e.slice(1),r=[];for(let i of this.cells.slice().reverse())Array.isArray(i.stateSize)?r.push(n.splice(0,i.stateSize.length)):r.push(n.splice(0,1));r.reverse();let a=[],s;for(let i=0;i<this.cells.length;++i){let o=this.cells[i];n=r[i],i===0?s=[e[0]].concat(n):s=[s[0]].concat(n),s=o.call(s,t),a.push(s.slice(1))}n=[];for(let i of a.slice().reverse())n.push(...i);return[s[0]].concat(n)})}build(e){Dk(e)&&(e=e[0]),e=e;let t;this.cells.forEach((n,r)=>{El(`RNNCell_${r}`,()=>{n.build(e),Array.isArray(n.stateSize)?t=n.stateSize[0]:t=n.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){let e=super.getConfig(),t=r=>({className:r.getClassName(),config:r.getConfig()}),n={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),n)}static fromConfig(e,t,n={}){let r=[];for(let a of t.cells)r.push(Ya(a,n));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];let e=[];for(let t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let n of this.cells)t.push(...n.trainableWeights);return t.concat(e)}return e}getWeights(){let e=[];for(let t of this.cells)e.push(...t.weights);return Ok(e)}setWeights(e){let t=[];for(let n of this.cells){let r=n.weights.length,a=e.splice(r);for(let s=0;s<n.weights.length;++s)t.push([n.weights[s],a[s]])}wN(t)}};mv.className="StackedRNNCells";se.registerClass(mv);function _o(e){let{ones:t,rate:n,training:r=!1,count:a=1,dropoutFunc:s}=e,i=()=>s!=null?s(t(),n):hz(t(),n),o=()=>Cg(i,t,r);return!a||a<=1?an(o().clone()):Array(a).fill(void 0).map(o).map(l=>an(l.clone()))}var kse=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(e!=null&&typeof Object.getOwnPropertySymbols=="function")for(var a=0,r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]]);return n},cP=class extends bi{constructor(e){if(e.unroll)throw new Ge("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Ge("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new Zt({ndim:5})]}call(e,t){return j(()=>{if(this.cell.dropoutMask!=null&&(Fe(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Fe(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new G("ConvRNN2D cell does not support constants");let n=t==null?null:t.mask,r=t==null?null:t.training,a=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return j(()=>{let{stateSize:t}=this.cell,n=e.shape,r=this.computeSingleOutputShape(n),a=[r[0],...r.slice(2)],s=Ot(a);return Array.isArray(t)?Array(t.length).fill(s):[s]})}resetStates(e,t=!1){j(()=>{if(!this.stateful)throw new Bi("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),a=[r[0],...r.slice(2)];if(n[0]==null)throw new G("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Ot(a)):this.states_=[Ot(a)];else if(e==null)Fe(this.states_),this.keptStates!=null&&(Fe(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Ot(a)):this.states_[0]=Ot(a);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new G(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):Fe(this.states_);for(let s=0;s<this.states_.length;++s){let i=e[s],o=a;if(!k.arraysEqual(i.shape,o))throw new G(`State ${s} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${i.shape}`);this.states_[s]=i}}this.states_=this.states_.map(s=>an(s.clone()))})}computeSingleOutputShape(e){let{dataFormat:t,filters:n,kernelSize:r,padding:a,strides:s,dilationRate:i}=this.cell,o=t==="channelsFirst",l=e[o?3:2],c=e[o?4:3],u=Ja(l,r[0],a,s[0],i[0]),h=Ja(c,r[1],a,s[1],i[1]);return[...e.slice(0,2),...o?[n,u,h]:[u,h,n]]}};cP.className="ConvRNN2D";var gv=class extends $g{constructor(e){let{filters:t,kernelSize:n,strides:r,padding:a,dataFormat:s,dilationRate:i}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,bn(this.filters,"filters"),this.kernelSize=Rh(n,2,"kernelSize"),this.kernelSize.forEach(o=>bn(o,"kernelSize")),this.strides=Rh(r||1,2,"strides"),this.strides.forEach(o=>bn(o,"strides")),this.padding=a||"valid",ma(this.padding),this.dataFormat=s||"channelsLast",Gt(this.dataFormat),this.dilationRate=Rh(i||1,2,"dilationRate"),this.dilationRate.forEach(o=>bn(o,"dilationRate"))}build(e){var t;e=rt(e);let n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new G(`The channel dimension of the input should be defined. Found ${e[n]}`);let r=e[n],a=4,s=this.kernelSize.concat([r,this.filters*a]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let i=this.kernelSize.concat([this.filters,this.filters*a]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",i,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let o;if(this.unitForgetBias){let l=this.biasInitializer,c=this.filters;o=new(t=class extends Ma{apply(u,h){let d=l.apply([c]),p=gr([c]),f=l.apply([c*2]);return pN([d,p,f])}},t.className="CustomInit",t)}else o=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*a],null,o,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return j(()=>{if(e.length!==3)throw new G(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training||!1,r=e[0],a=e[1],s=e[2],i=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=_o({ones:()=>Gr(r),rate:this.dropout,training:n,count:i,dropoutFunc:this.dropoutFunc}));let o=this.dropoutMask,l=(K,Z,J)=>!Z||!Z[J]?K:U(Z[J],K),c=l(r,o,0),u=l(r,o,1),h=l(r,o,2),d=l(r,o,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=_o({ones:()=>Gr(a),rate:this.recurrentDropout,training:n,count:i,dropoutFunc:this.dropoutFunc}));let p=this.recurrentDropoutMask,f=l(a,p,0),m=l(a,p,1),y=l(a,p,2),g=l(a,p,3),x=3,[b,v,w,I]=xr(this.kernel.read(),i,x),[_,T,A,M]=this.useBias?xr(this.bias.read(),i):[null,null,null,null];c=this.inputConv(c,b,_,this.padding),u=this.inputConv(u,v,T,this.padding),h=this.inputConv(h,w,A,this.padding),d=this.inputConv(d,I,M,this.padding);let[F,C,D,L]=xr(this.recurrentKernel.read(),i,x);f=this.recurrentConv(f,F),m=this.recurrentConv(m,C),y=this.recurrentConv(y,D),g=this.recurrentConv(g,L);let O=this.recurrentActivation.apply(te(c,f)),q=this.recurrentActivation.apply(te(u,m)),H=te(U(q,s),U(O,this.activation.apply(te(h,y)))),z=U(this.recurrentActivation.apply(te(d,g)),this.activation.apply(H));return[z,z,H]})}getConfig(){let e=super.getConfig(),t=kse(e,["units"]),n={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},t),n)}inputConv(e,t,n,r){let a=nr(e,t,this.strides,r||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return n?is(a,n,this.dataFormat):a}recurrentConv(e,t){return nr(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}};gv.className="ConvLSTM2DCell";se.registerClass(gv);var JN=class extends cP{constructor(e){let t=new gv(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}};JN.className="ConvLSTM2D";se.registerClass(JN);var yv=class extends He{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;let t=e.shape,n=[];for(let r=0;r<this.noiseShape.length;++r)n.push(this.noiseShape[r]==null?t[r]:this.noiseShape[r]);return n}call(e,t){return j(()=>{this.invokeCallHook(e,t);let n=Me(e);if(0<this.rate&&this.rate<1){let r=t.training==null?!1:t.training,a=this.getNoiseShape(n);return Cg(()=>hz(n,this.rate,a,this.seed),()=>n,r)}return e})}getConfig(){let e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}};yv.className="Dropout";se.registerClass(yv);var QN=class extends yv{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){let t=e.shape;return[t[0],1,t[2]]}};QN.className="SpatialDropout1D";se.registerClass(QN);var e_=class extends He{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,bn(this.units,"units"),this.activation=No(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=$t(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=$t(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=cn(e.kernelConstraint),this.biasConstraint=cn(e.biasConstraint),this.kernelRegularizer=Mt(e.kernelRegularizer),this.biasRegularizer=Mt(e.biasRegularizer),this.activityRegularizer=Mt(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=rt(e);let t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=rt(e);let t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return j(()=>{this.invokeCallHook(e,t);let n=Me(e),r=az(this.activation.getClassName()),a;return r!=null?a=_s(n,this.kernel.read(),r,this.bias?this.bias.read():null):(a=_s(n,this.kernel.read()),this.bias!=null&&(a=is(a,this.bias.read())),this.activation!=null&&(a=this.activation.apply(a))),a})}getConfig(){let e={units:this.units,activation:Io(this.activation),useBias:this.useBias,kernelInitializer:zt(this.kernelInitializer),biasInitializer:zt(this.biasInitializer),kernelRegularizer:wt(this.kernelRegularizer),biasRegularizer:wt(this.biasRegularizer),activityRegularizer:wt(this.activityRegularizer),kernelConstraint:un(this.kernelConstraint),biasConstraint:un(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}};e_.className="Dense";se.registerClass(e_);var t_=class extends He{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=rt(e);for(let t of e.slice(1))if(t==null)throw new G(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],uo(e,1)]}call(e,t){return j(()=>{this.invokeCallHook(e,t);let n=Me(e);if(this.dataFormat==="channelsFirst"&&n.rank>1){let r=[0];for(let a=2;a<n.rank;++a)r.push(a);r.push(1),n=Ue(n,r)}return Rre(n)})}getConfig(){let e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);let t=super.getConfig();return Object.assign(e,t),e}};t_.className="Flatten";se.registerClass(t_);var n_=class extends He{constructor(e){super(e),this.supportsMasking=!0,this.activation=No(e.activation)}call(e,t){return j(()=>{this.invokeCallHook(e,t);let n=Me(e);return this.activation.apply(n)})}getConfig(){let e={activation:Io(this.activation)},t=super.getConfig();return Object.assign(e,t),e}};n_.className="Activation";se.registerClass(n_);var r_=class extends He{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return j(()=>(e=Me(e),Mre(e,this.n)))}getConfig(){let e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}};r_.className="RepeatVector";se.registerClass(r_);var a_=class extends He{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){let n="Total size of new array must be unchanged.",r=t.slice(),a=1,s=null;for(let o=0;o<r.length;++o){let l=r[o];if(this.isUnknown(l))if(s===null)s=o;else throw new G("Can only specifiy one unknown dimension.");else a*=l}let i=uo(e);if(s!==null){if(a===0||i%a!==0)throw new G(n);r[s]=i/a}else if(i!==a)throw new G(n);return r}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return j(()=>{this.invokeCallHook(e,t);let n=Me(e),r=n.shape,a=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return V(n,a)})}getConfig(){let e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}};a_.className="Reshape";se.registerClass(a_);var s_=class extends He{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);let t=es(1,e.dims.length+1);if(!k.arraysEqual(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Zt({ndim:this.dims.length+1})]}computeOutputShape(e){e=rt(e);let t=e.slice();return this.dims.forEach((n,r)=>{t[r+1]=e[n]}),t}call(e,t){return Ue(Me(e),this.dimsIncludingBatch)}getConfig(){let e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}};s_.className="Permute";se.registerClass(s_);var i_=class extends He{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){let n=Me(e);return dm(ql(n,this.maskValue),-1)}call(e,t){return j(()=>{this.invokeCallHook(e,t);let n=Me(e),r=dm(ql(n,this.maskValue),-1,!0);return U(n,le(r,n.dtype))})}};i_.className="Masking";se.registerClass(i_);var o_=class extends He{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(ct(e.inputLength))}this.inputDim=e.inputDim,bn(this.inputDim,"inputDim"),this.outputDim=e.outputDim,bn(this.outputDim,"outputDim"),this.embeddingsInitializer=$t(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Mt(e.embeddingsRegularizer),this.activityRegularizer=Mt(e.activityRegularizer),this.embeddingsConstraint=cn(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return j(()=>this.maskZero?(e=Me(e),ql(e,Ye(e))):null)}computeOutputShape(e){if(e=rt(e),this.inputLength==null)return[...e,this.outputDim];let t=ct(this.inputLength);if(t.length!==e.length-1)throw new G(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let r=0;r<t.length;++r){let a=t[r],s=e[r+1];if(a!=null&&s!=null&&a!==s)throw new G(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);a==null&&(t[n]=s),n++}}return[e[0],...t,this.outputDim]}call(e,t){return j(()=>{this.invokeCallHook(e,t);let n=Me(e);n.dtype!=="int32"&&(n=ci(n,"int32"));let r=cz(this.embeddings.read(),V(n,[n.size]));return V(r,rt(this.computeOutputShape(n.shape)))})}getConfig(){let e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:zt(this.embeddingsInitializer),embeddingsRegularizer:wt(this.embeddingsRegularizer),activityRegularizer:wt(this.activityRegularizer),embeddingsConstraint:un(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}};o_.className="Embedding";se.registerClass(o_);var Mc=class extends He{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new Ge}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;let n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){let a=e[e.length-t.length+r],s=t[r];if(a==null||s==null||a<0||s<0)n.push(null);else if(a===1)n.push(s);else if(s===1)n.push(a);else{if(a!==s)throw new G("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(a)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[rt(e)]),e=e,e.length<2)throw new G(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(let a of e)a!=null&&a[0]!==null&&t.push(a[0]);if(t=lo(t),t.length>1)throw new G(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=e[0]==null?null:e[0].slice(1);for(let a=1;a<e.length;++a){let s=e[a]==null?null:e[a].slice(1);n=this.computeElementwiseOpOutputShape(n,s)}let r=e.map(a=>a.length);e.indexOf(null)===-1&&lo(r).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return j(()=>{if(e=e,this.reshapeRequired){let n=[],r=e.map(a=>a.rank);if(r.indexOf(null)===-1){let a=So(r);for(let s of e){let i=s.rank;for(let o=0;o<a-i;++o)s=Ng(s,1);n.push(s)}return this.mergeFunction(n)}else{let a=!1;for(let o of e){let l=o.rank;if(l==null){let c=o.shape,u=c[0],h=c.slice(1).concat([u]),d=V(o,[u].concat(uo(c.slice(1))));d=Ue(d,[1,0]),d=V(d,h),n.push(d),a=!0}else if(l>1){let c=es(1,l).concat([0]);n.push(Ue(o,c)),a=!0}else n.push(o)}let s=this.mergeFunction(n),i=s.rank;if(a){if(i==null){let o=s.shape,l=o.length,c=o[l-1],u=[c].concat(o.slice(0,o.length-1));s=V(Ue(V(s,[-1,c]),[1,0]),u)}else if(i>1){let o=[i-1].concat(es(0,i-1));s=Ue(s,o)}}return s}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let r=1;r<e.length;++r){let a=e[r]==null?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,a)}let n=[];for(let r of e)r!=null&&r[0]!==null&&n.push(r[0]);return n=lo(n),n.length===1?t=n.concat(t):t=[null].concat(t),t}computeMask(e,t){return j(()=>{if(t==null)return null;if(!Array.isArray(t))throw new G("`mask` should be an Array");if(!Array.isArray(e))throw new G("`inputs` should be an Array");if(t.length!==e.length)throw new G(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(r=>r==null))return null;t=t.map(r=>r==null?r:yn(r,0));let n=t[0];for(let r=1;r<t.length-1;++r)n=Aa(n,t[r]);return n})}},l_=class extends Mc{constructor(e){super(e)}mergeFunction(e){return j(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=te(t,e[n]);return t})}};l_.className="Add";se.registerClass(l_);var u_=class extends Mc{constructor(e){super(e)}mergeFunction(e){return j(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=U(t,e[n]);return t})}};u_.className="Multiply";se.registerClass(u_);var c_=class extends Mc{constructor(e){super(e)}mergeFunction(e){return j(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=te(t,e[n]);return U(1/e.length,t)})}};c_.className="Average";se.registerClass(c_);var h_=class extends Mc{constructor(e){super(e)}mergeFunction(e){return j(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Ms(t,e[n]);return t})}};h_.className="Maximum";se.registerClass(h_);var d_=class extends Mc{constructor(e){super(e)}mergeFunction(e){return j(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=wo(t,e[n]);return t})}};d_.className="Minimum";se.registerClass(d_);var p_=class extends Mc{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new G("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(let r of e)if(r!=null){t=!1;break}if(t)return;let n=[];for(let r=0;r<e.length;++r){let a=e[r].slice();a.splice(this.axis,1);let s=!1;for(let i of n)if(k.arraysEqual(i,a)){s=!0;break}s||n.push(a)}if(n.length>1)throw new G("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return j(()=>pN(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new G("A `Concatenate` layer should be called on a list of inputs.");let t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(let a of t.slice(1)){if(n[r]==null||a[r]==null){n[r]=null;break}n[r]+=a[r]}return n}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new G("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new G("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new G(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return j(()=>{let n=!0;if(t.forEach(s=>{if(s!=null){n=!1;return}}),n)return null;let r=[];for(let s=0;s<e.length;++s)t[s]==null?r.push(le(Gr(e[s]),"bool")):t[s].rank<e[s].rank?r.push(yn(t[s],-1)):r.push(t[s]);let a=xt(r,this.axis);return bb(a,-1,!1)})}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};p_.className="Concatenate";se.registerClass(p_);function af(e,t){for(;e<0;)e+=t;return e}function Sse(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new Ge("batchDot is not implemented for tensors of 4D or higher rank yet");if(k.assert(e.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`),k.assert(e.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof n=="number"&&(n=[n,n]),e.dtype==="complex64"||t.dtype==="complex64")throw new Ge("batchDot is not implemented for complex64-type Tensors yet.");let r=e.shape.length,a=t.shape.length;n==null&&(n=[r-1,a-2]);let s=n;return j(()=>{let i;if(r>a){i=r-a;let l=[];for(let c=0;c<i;++c)l.push(1);t=V(t,t.shape.concat(l))}else if(a>r){i=a-r;let l=[];for(let c=0;c<i;++c)l.push(1);e=V(e,e.shape.concat(l))}else i=0;let o;if(e.shape.length===2&&t.shape.length===2)s[0]===s[1]?o=ke(U(e,t),s[0]):o=ke(U(Ue(e,[1,0]),t),s[1]);else{let l=s[0]!==e.shape.length-1,c=s[1]===t.shape.length-1;o=We(e,t,l,c)}if(i>0){let l;r>a?l=r+a-3:l=r-1;let c=[];for(let u=l;u<l+i;++u)c.push(u);o=Vo(o,c)}return o.shape.length===1&&(o=yn(o,1)),o})}var f_=class extends Mc{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){k.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0],n=e[1];if(t.length>3||n.length>3)throw new Ge("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new G(`Dimension incompatibility: ${t[r[0]]} !== ${n[r[1]]}`)}mergeFunction(e){if(e.length!==2)throw new G(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],n=e[1],r;return Array.isArray(this.axes)?r=this.axes.map((a,s)=>af(a,e[s].shape.length)):r=[af(this.axes,t.shape.length),af(this.axes,n.shape.length)],this.normalize&&(t=hx(t,r[0]),n=hx(n,r[1])),Sse(t,n,r)}interpretAxes(e,t){let n;return Array.isArray(this.axes)?n=this.axes:n=[af(this.axes,e.length),af(this.axes,t.length)],n}computeOutputShape(e){k.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new Ge("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);let a=t.concat(n);return a.length===1&&a.push(1),a}computeMask(e,t){return null}getConfig(){let e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}};f_.className="Dot";se.registerClass(f_);var m_=class extends He{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return j(()=>{this.invokeCallHook(e,t);let n=Me(e);return Cg(()=>te(Jb(n.shape,0,this.stddev),n),()=>n,t.training||!1)})}};m_.className="GaussianNoise";se.registerClass(m_);var g_=class extends He{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return j(()=>{this.invokeCallHook(e,t);let n=Me(e);return this.rate>0&&this.rate<1?Cg(()=>{let r=Math.sqrt(this.rate/(1-this.rate));return U(n,Jb(n.shape,1,r))},()=>n,t.training||!1):n})}};g_.className="GaussianDropout";se.registerClass(g_);var y_=class extends He{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Me(e).shape}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return j(()=>{if(this.rate<1&&this.rate>0){let n=this._getNoiseShape(e);return Cg(()=>{let r=Me(e),a=-1.6732632423543772*1.0507009873554805,s=gi(Wo(n),this.rate);s=ci(s,"float32");let i=((1-this.rate)*(1+this.rate*a**2))**-.5,o=-i*a*this.rate,l=te(U(r,s),U(te(s,-1),a));return te(U(l,i),o)},()=>Me(e),t.training||!1)}return e})}};y_.className="AlphaDropout";se.registerClass(y_);function xm(e,t,n,r,a,s=.001){let i;if(e.rank===2)i=sI(e,t,n,r,a,s);else if(e.rank===3)i=iI(e,t,n,r,a,s);else if(e.rank===4)i=oI(e,t,n,r,a,s);else throw new Ge(`batchNormalization is not implemented for array of rank ${e.rank} yet`);return i}function Ise(e,t,n,r,a=.001){return j(()=>{let s=yg(e,r),i=s.mean,o=s.variance;return[xm(e,i,o,n,t,a),i,o]})}function Nse(e,t,n,r,a=.001){return j(()=>{let s=yg(e,r),i=s.mean,o=s.variance,l=[];for(let p of es(0,e.rank))r.indexOf(p)!==-1?l.push(1):l.push(e.shape[p]);let c=V(i,l),u=V(o,l),h=t==null?null:V(t,l),d=n==null?null:V(n,l);return[xm(e,c,u,d,h,a),i,o]})}function _se(e,t,n,r,a=.001){return k.arraysEqual(r.slice().sort(),es(0,e.rank-1))?Ise(e,t,n,r,a):Nse(e,t,n,r,a)}var x_=class extends He{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=$t(e.betaInitializer||"zeros"),this.gammaInitializer=$t(e.gammaInitializer||"ones"),this.movingMeanInitializer=$t(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=$t(e.movingVarianceInitializer||"ones"),this.betaConstraint=cn(e.betaConstraint),this.gammaConstraint=cn(e.gammaConstraint),this.betaRegularizer=Mt(e.betaRegularizer),this.gammaRegularizer=Mt(e.gammaRegularizer)}build(e){e=rt(e);let t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(n==null)throw new G(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Zt({ndim:e.length,axes:{[t]:n}})];let r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return j(()=>{let n=t.training==null?!1:t.training,r=Me(e),a=r.shape,s=a.length,i=es(0,s),o=this.axis>=0?this.axis:this.axis+s;i.splice(o,1);let l=Xl(1,s);l[o]=a[o];let c=i.slice();c.sort();let u=!k.arraysEqual(c,es(0,s).slice(0,s-1)),h=()=>{if(u){let y=V(this.movingMean.read(),l),g=V(this.movingVariance.read(),l),x=this.center?V(this.beta.read(),l):null,b=this.scale?V(this.gamma.read(),l):null;return xm(r,y,g,x,b,this.epsilon)}else return xm(r,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!n)return h();let[d,p,f]=_se(r,this.gamma.read(),this.beta.read(),i,this.epsilon),m=(y,g,x)=>{j(()=>{let b=1-x,v=y.read(),w=U(me(v,g),b);y.write(me(v,w))})};return m(this.movingMean,p,this.momentum),m(this.movingVariance,f,this.momentum),d})}getConfig(){let e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:zt(this.betaInitializer),gammaInitializer:zt(this.gammaInitializer),movingMeanInitializer:zt(this.movingMeanInitializer),movingVarianceInitializer:zt(this.movingVarianceInitializer),betaRegularizer:wt(this.betaRegularizer),gammaRegularizer:wt(this.gammaRegularizer),betaConstraint:un(this.betaConstraint),gammaConstraint:un(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}};x_.className="BatchNormalization";se.registerClass(x_);var b_=class extends He{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(let t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=$t(e.betaInitializer||"zeros"),this.gammaInitializer=$t(e.gammaInitializer||"ones"),this.betaRegularizer=Mt(e.betaRegularizer),this.gammaRegularizer=Mt(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=rt(e);let t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let a=0;a<this.axis.length;++a)this.axis[a]<0&&(this.axis[a]+=t);for(let a of this.axis)if(a<0||a>=t)throw new Error(`Invalid axis: ${a}`);if(this.axis.length!==lo(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let n=this.axis.map(a=>e[a]),r=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){let n=Me(e),r=n.shape,a=r.length;return j(()=>{let{mean:s,variance:i}=yg(n,this.axis,!0),o=Xl(1,a);for(let p of this.axis)o[p]=r[p];let l=p=>p!=null&&p.shape.length!==a?V(p,o):p,c=this.scale?l(this.gamma.read()):null,u=this.center?l(this.beta.read()):null,h=[],d=[];for(let p=0;p<a;++p)this.axis.indexOf(p)!==-1?(h.push(r[p]),d.push(1)):(h.push(1),d.push(r[p]));return s=Or(s,h),i=Or(i,h),c!=null&&(c=Or(c,d)),u!=null&&(u=Or(u,d)),xm(n,s,i,u,c,this.epsilon)})}getConfig(){let e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:zt(this.betaInitializer),gammaInitializer:zt(this.gammaInitializer),betaRegularizer:wt(this.betaRegularizer),gammaRegularizer:wt(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}};b_.className="LayerNormalization";se.registerClass(b_);function Cse(e,t,n){return j(()=>{if(e.rank!==4)throw new G(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new G("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(n==null&&(n=ts()),n!=="channelsLast"&&n!=="channelsFirst")throw new G(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return n==="channelsFirst"?r=[[0,0],[0,0],t[0],t[1]]:r=[[0,0],t[0],t[1],[0,0]],ss(e,r)})}var v_=class extends He{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?ts():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new G(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new G(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new G(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new Zt({ndim:4})]}computeOutputShape(e){e=rt(e);let t,n;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?n=e[3]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],e[1],t,n]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?n=e[2]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],t,n,e[3]])}call(e,t){return j(()=>Cse(Me(e),this.padding,this.dataFormat))}getConfig(){let e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};v_.className="ZeroPadding2D";se.registerClass(v_);function xv(e,t,n,r,a,s){return j(()=>{Gt(a),iz(s),ma(r),n==null&&(n=[1,1]),r==null&&(r="valid"),a==null&&(a=ts()),s==null&&(s="max"),e=WN(e,a);let i,o=r==="same"?"same":"valid";return s==="max"?i=pn(e,t,n,o):i=mi(e,t,n,o),a==="channelsFirst"&&(i=Ue(i,[0,3,1,2])),i})}function hP(e,t,n,r,a,s){return j(()=>{Gt(a),iz(s),ma(r),n==null&&(n=[1,1,1]),r==null&&(r="valid"),a==null&&(a=ts()),s==null&&(s="max"),e=Qz(e,a);let i,o=r==="same"?"same":"valid";return s==="max"?i=$I(e,t,n,o):i=aI(e,t,n,o),a==="channelsFirst"&&(i=Ue(i,[0,4,1,2,3])),i})}var dP=class extends He{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new G(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(bn(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new G(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);bn(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,ma(this.padding),this.inputSpec=[new Zt({ndim:3})]}computeOutputShape(e){e=rt(e);let t=Ja(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return j(()=>{this.invokeCallHook(e,t),e=Ng(Me(e),2);let n=this.poolingFunction(Me(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Vo(n,[2])})}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}},w_=class extends dP{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Gt(a),ma(r),xv(e,t,n,r,a,"max")}};w_.className="MaxPooling1D";se.registerClass(w_);var k_=class extends dP{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Gt(a),ma(r),xv(e,t,n,r,a,"avg")}};k_.className="AveragePooling1D";se.registerClass(k_);var pP=class extends He{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new G(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];bn(this.poolSize,"poolSize"),bn(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Gt(this.dataFormat),ma(this.padding),this.inputSpec=[new Zt({ndim:4})]}computeOutputShape(e){e=rt(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=Ja(t,this.poolSize[0],this.padding,this.strides[0]),n=Ja(n,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return j(()=>(this.invokeCallHook(e,t),this.poolingFunction(Me(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},S_=class extends pP{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Gt(a),ma(r),xv(e,t,n,r,a,"max")}};S_.className="MaxPooling2D";se.registerClass(S_);var I_=class extends pP{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Gt(a),ma(r),xv(e,t,n,r,a,"avg")}};I_.className="AveragePooling2D";se.registerClass(I_);var fP=class extends He{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new G(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];bn(this.poolSize,"poolSize"),bn(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Gt(this.dataFormat),ma(this.padding),this.inputSpec=[new Zt({ndim:5})]}computeOutputShape(e){e=rt(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=Ja(t,this.poolSize[0],this.padding,this.strides[0]),n=Ja(n,this.poolSize[1],this.padding,this.strides[1]),r=Ja(r,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return j(()=>(this.invokeCallHook(e,t),this.poolingFunction(Me(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},N_=class extends fP{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Gt(a),ma(r),hP(e,t,n,r,a,"max")}};N_.className="MaxPooling3D";se.registerClass(N_);var __=class extends fP{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Gt(a),ma(r),hP(e,t,n,r,a,"avg")}};__.className="AveragePooling3D";se.registerClass(__);var mP=class extends He{constructor(e){super(e),this.inputSpec=[new Zt({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new Ge}},C_=class extends mP{constructor(e){super(e||{})}call(e,t){return j(()=>{let n=Me(e);return Dt(n,1)})}};C_.className="GlobalAveragePooling1D";se.registerClass(C_);var T_=class extends mP{constructor(e){super(e||{})}call(e,t){return j(()=>{let n=Me(e);return la(n,1)})}};T_.className="GlobalMaxPooling1D";se.registerClass(T_);var gP=class extends He{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Gt(this.dataFormat),this.inputSpec=[new Zt({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new Ge}getConfig(){let e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},E_=class extends gP{call(e,t){return j(()=>{let n=Me(e);return this.dataFormat==="channelsLast"?Dt(n,[1,2]):Dt(n,[2,3])})}};E_.className="GlobalAveragePooling2D";se.registerClass(E_);var A_=class extends gP{call(e,t){return j(()=>{let n=Me(e);return this.dataFormat==="channelsLast"?la(n,[1,2]):la(n,[2,3])})}};A_.className="GlobalMaxPooling2D";se.registerClass(A_);var yP=class extends He{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){let e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){let r=t.layer,a=Ya(r,n);delete t.layer;let s={layer:a};return Object.assign(s,t),new e(s)}},$_=class extends yP{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=rt(e),e.length<3)throw new G(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];let t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=rt(e);let t=[e[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))}call(e,t){return j(()=>(e=Me(e),lP((n,r)=>[Me(this.layer.call(n,t)),[]],e,[],!1,null,null,!1,!0)[1]))}};$_.className="TimeDistributed";se.registerClass($_);function Tse(e){Ac(Cre,"BidirectionalMergeMode",e)}var Ese="concat",M_=class extends yP{constructor(e){super(e);let t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=Ya(n),t.goBackwards=t.goBackwards!==!0;let r={};if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=Ya(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?Ese:e.mergeMode,Tse(this.mergeMode),e.weights)throw new Ge("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){let t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let n,r,a;return this.returnState&&(a=t.slice(1)),n=t[0],n=n,this.mergeMode==="concat"?(n[n.length-1]*=2,r=[n]):this.mergeMode==null?r=[n,n.slice()]:r=[n],this.returnState?this.mergeMode==null?r.concat(a).concat(a.slice()):[n].concat(a).concat(a.slice()):mr(r)}apply(e,t){let n=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});let a=oP(e,n,r,this.numConstants);if(e=a.inputs,n=a.initialState,r=a.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(n==null||n.length===0)&&r==null)return super.apply(e,t);let s=[],i=[];if(n!=null){let l=n.length;if(l%2>0)throw new G("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,s.push(...n);let c=n.map(u=>new Zt({shape:u.shape}));this.forwardLayer.stateSpec=c.slice(0,l/2),this.backwardLayer.stateSpec=c.slice(l/2),i.push(...c)}if(r!=null)throw new Ge("Support for constants in Bidirectional layers is not implemented yet.");let o=s[0]instanceof ns;for(let l of s)if(l instanceof ns!==o)throw new G("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){let l=[e].concat(s),c=this.inputSpec.concat(i),u=this.inputSpec;this.inputSpec=c;let h=super.apply(l,t);return this.inputSpec=u,h}else return super.apply(e,t)}call(e,t){return j(()=>{let n=t.initialState,r,a;if(n==null)r=this.forwardLayer.call(e,t),a=this.backwardLayer.call(e,t);else{let o=n.slice(0,n.length/2),l=n.slice(n.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:o})),a=this.backwardLayer.call(e,Object.assign(t,{initialState:l}))}let s;this.returnState&&(Array.isArray(r)&&(s=r.slice(1).concat(a.slice(1))),r=r[0],a=a[0]),this.returnSequences&&(a=da(a,1));let i;return this.mergeMode==="concat"?i=pN([r,a]):this.mergeMode==="sum"?i=te(r,a):this.mergeMode==="ave"?i=U(.5,te(r,a)):this.mergeMode==="mul"?i=U(r,a):this.mergeMode==null&&(i=[r,a]),this.returnState?this.mergeMode==null?i.concat(s):[i].concat(s):i})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){El(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),El(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let n;if(this.returnSequences?this.mergeMode==null?n=[t,t]:n=t:this.mergeMode==null?n=[null,null]:n=null,this.returnState){let r=this.forwardLayer.states.map(a=>null);return Array.isArray(n)?n.concat(r).concat(r):[n].concat(r).concat(r)}else return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){let e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){let n=Ya(t.layer);if(delete t.layer,t.numConstants!=null)throw new Ge("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let r=t;return r.layer=n,new e(r)}};M_.className="Bidirectional";se.registerClass(M_);var F_=class extends He{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){let e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return j(()=>(e=Me(e),e.dtype!=="float32"&&(e=ci(e,"float32")),te(U(e,this.scale),this.offset)))}};F_.className="Rescaling";se.registerClass(F_);var{resizeBilinear:Ase,cropAndResize:$se}=ra,R_=class extends He{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,r,a,s,i,o){return j(()=>{let l,c=!1,u=t/s,h=n/i,d=(r+t)/s,p=(a+n)/i,f=[u,h,d,p],m=[];e.rank===3?(c=!0,l=Jt([e])):l=e;for(let b=0;b<l.shape[0];b++)m.push(f);let y=er(m,[m.length,4]),g=Kl(0,m.length,1,"int32"),x=$se(l,y,g,[r,a],"nearest");return ci(c?Me(Vt(x)):x,o)})}upsize(e,t,n,r){return j(()=>{let a=Ase(e,[t,n]);return ci(a,r)})}call(e,t){return j(()=>{let n=Me(e),r=n.dtype,a=n.shape,s=a[a.length-3],i=a[a.length-2],o=0;s!==this.height&&(o=Math.floor((s-this.height)/2));let l=0;return i!==this.width&&(l=Math.floor((i-this.width)/2),l===0&&(l=1)),o>=0&&l>=0?this.centerCrop(n,o,l,this.height,this.width,s,i,r):this.upsize(e,this.height,this.width,r)})}getConfig(){let e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=rt(e);let t=e.length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}};R_.className="CenterCrop";se.registerClass(R_);function Mse(e,t,n,r){let a=Me(e);if(a.dtype!=="int32"&&(a=ci(a,"int32")),t==="int")return a;let s=a.shape;if(a.rank===0&&(a=yn(a,-1)),t==="oneHot"&&a.shape[a.shape.length-1]!==1&&(a=yn(a,-1)),a.rank>2)throw new G(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${s} which would result in output rank ${a.rank}.`);let i=["multiHot","oneHot"].includes(t),o=a,l;if(typeof r<"u"&&t==="count"?l=sx(o,r,n,i):l=sx(o,[],n,i),t!=="tfIdf")return l;if(r)return U(l,r);throw new G("When outputMode is 'tfIdf', weights must be provided.")}var D_=class extends He{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){let e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=rt(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return j(()=>{e=Me(e),e.dtype!=="int32"&&(e=ci(e,"int32"));let n;if(typeof t.countWeights<"u"){if(this.outputMode!=="count")throw new G(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);n=Me(t.countWeights)}let r=la(e),a=Kh(e),s=or(this.numTokens,r).bufferSync().get(0),i=gi(a,0).bufferSync().get(0);if(!(s&&i))throw new G(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return Mse(e,this.outputMode,this.numTokens,n)})}};D_.className="CategoryEncoding";se.registerClass(D_);var Fse=["bilinear","nearest"],m$=new Set(Fse),O_=class extends He{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(m$.has(e.interpolation))this.interpolation=e.interpolation;else throw new G(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=rt(e);let t=e[2];return[this.height,this.width,t]}getConfig(){let e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return j(()=>{let n=[this.height,this.width];if(this.interpolation==="bilinear")return ra.resizeBilinear(e,n,!this.cropToAspectRatio);if(this.interpolation==="nearest")return ra.resizeNearestNeighbor(e,n,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...m$]} are supported`)})}};O_.className="Resizing";se.registerClass(O_);var xP=class{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}};xP.className="RandomSeed";var bP=class extends He{constructor(e){super(e),this.randomGenerator=new xP(e.seed)}getConfig(){let e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}};bP.className="BaseRandomLayer";var Rse=["bilinear","nearest"],g$=new Set(Rse),z_=class extends bP{constructor(e){super(e);let{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new G(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new G(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new G(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(n)if(g$.has(n))this.interpolation=n;else throw new G(`Invalid interpolation parameter: ${n} is not implemented`)}getConfig(){let e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=rt(e);let t=e[2];return[this.imgHeight,-1,t]}call(e,t){return j(()=>{let n=Me(e);this.imgHeight=n.shape[n.shape.length-3];let r=n.shape[n.shape.length-2];this.widthFactor=Wo([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let a=this.widthFactor.dataSync()[0]*r;a=Math.round(a);let s=[this.imgHeight,a];switch(this.interpolation){case"bilinear":return ra.resizeBilinear(e,s);case"nearest":return ra.resizeNearestNeighbor(e,s);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...g$]} are supported`)}})}};z_.className="RandomWidth";se.registerClass(z_);function Dse(e){return new _p(e)}function Ose(e){return new PN(e)}function zse(e){return new DN(e)}function Pse(e){return new ON(e)}function Lse(e){return new zN(e)}function Bse(e){return new BN(e)}function Wse(e){return new LN(e)}function Use(e){return new GN(e)}function Vse(e){return new hv(e)}function jse(e){return new UN(e)}function Gse(e){return new dv(e)}function Hse(e){return new VN(e)}function qse(e){return new jN(e)}function Kse(e){return new HN(e)}function Xse(e){return new qN(e)}function Zse(e){return new KN(e)}function Yse(e){return new n_(e)}function Jse(e){return new e_(e)}function Qse(e){return new yv(e)}function eie(e){return new QN(e)}function tie(e){return new t_(e)}function nie(e){return new r_(e)}function rie(e){return new a_(e)}function aie(e){return new s_(e)}function sie(e){return new o_(e)}function iie(e){return new l_(e)}function oie(e){return new c_(e)}function lie(e){return new p_(e)}function uie(e){return new h_(e)}function cie(e){return new d_(e)}function hie(e){return new u_(e)}function die(e){return new f_(e)}function pie(e){return new x_(e)}function fie(e){return new b_(e)}function mie(e){return new v_(e)}function P_(e){return new k_(e)}function gie(e){return P_(e)}function yie(e){return P_(e)}function L_(e){return new I_(e)}function xie(e){return L_(e)}function bie(e){return L_(e)}function B_(e){return new __(e)}function vie(e){return B_(e)}function wie(e){return B_(e)}function kie(e){return new C_(e)}function Sie(e){return new E_(e)}function vP(e){return new T_(e)}function wP(e){return new A_(e)}function kP(e){return new w_(e)}function SP(e){return new S_(e)}function Iie(e){return new N_(e)}function Nie(e){return new ZN(e)}function _ie(e){return new fv(e)}function Cie(e){return new YN(e)}function Tie(e){return new $g(e)}function Eie(e){return new XN(e)}function Aie(e){return new pv(e)}function $ie(e){return new JN(e)}function Mie(e){return new gv(e)}function Fie(e){return new bi(e)}function Rie(e){return new mv(e)}function Die(e){return new M_(e)}function Oie(e){return new $_(e)}var zie=vP,Pie=wP,Lie=kP,Bie=SP;function Wie(e){return new m_(e)}function Uie(e){return new g_(e)}function Vie(e){return new y_(e)}function jie(e){return new i_(e)}function Gie(e){return new F_(e)}function Hie(e){return new R_(e)}function qie(e){return new O_(e)}function Kie(e){return new D_(e)}function Xie(e){return new z_(e)}var IP={};Re(IP,{MAPE:()=>ioe,MSE:()=>uoe,binaryAccuracy:()=>Zie,binaryCrossentropy:()=>Yie,categoricalAccuracy:()=>Qie,categoricalCrossentropy:()=>eoe,cosineProximity:()=>roe,mape:()=>ooe,meanAbsoluteError:()=>aoe,meanAbsolutePercentageError:()=>soe,meanSquaredError:()=>loe,mse:()=>coe,precision:()=>toe,r2Score:()=>hoe,recall:()=>noe,sparseCategoricalAccuracy:()=>Jie});function Zie(e,t){return EN(e,t)}function Yie(e,t){return Cz(e,t)}function Jie(e,t){return Tz(e,t)}function Qie(e,t){return AN(e,t)}function eoe(e,t){return $N(e,t)}function toe(e,t){return _z(e,t)}function noe(e,t){return Fae(e,t)}function roe(e,t){return TN(e,t)}function aoe(e,t){return ov(e,t)}function soe(e,t){return Cp(e,t)}function ioe(e,t){return Cp(e,t)}function ooe(e,t){return Cp(e,t)}function loe(e,t){return $c(e,t)}function uoe(e,t){return $c(e,t)}function coe(e,t){return $c(e,t)}function hoe(e,t){return Rae(e,t)}var NP={};Re(NP,{modelFromJSON:()=>cse});var _P={};Re(_P,{l1:()=>poe,l1l2:()=>doe,l2:()=>foe});function doe(e){return new Eg(e)}function poe(e){return yse(e)}function foe(e){return xse(e)}var CP=class extends nd{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof ri))throw new Error("model must be a LayersModel, not some other Container");this.model=e}};function Vy(e,t){return e<t}function y$(e,t){return e>t}var TP=class extends CP{constructor(e){if(super(),e==null&&(e={}),e.restoreBestWeights)throw new Ge("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,["auto","min","max"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.mode==="min"?this.monitorFunc=Vy:this.mode==="max"?this.monitorFunc=y$:this.monitor.indexOf("acc")!==-1?this.monitorFunc=y$:this.monitorFunc=Vy,this.monitorFunc===Vy&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===Vy?1/0:-1/0}async onEpochEnd(e,t){await Oi(t);let n=this.getMonitorValue(t);n!=null&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){e==null&&(e={});let t=e[this.monitor];return t==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}};function moe(e){return new TP(e)}var goe={earlyStopping:moe},yoe=X();yoe.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var Er;(function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"})(Er||(Er={}));var x$;(function(e){(function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"})(e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))})(x$||(x$={}));var W_={};function xoe(e,t){let n={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t};W_[e]=n}function EP(e){return W_[e]}function boe(e){delete W_[e]}function S(e,t,n,r,a){let s=t.inputParams[e];if(s&&s.inputIndexStart!==void 0){let o=s.inputIndexStart,l=s.inputIndexEnd===0?void 0:s.inputIndexEnd===void 0?o+1:s.inputIndexEnd,c=o<0?t.inputNames.length+o:o;if(s.type==="tensor")return An(t.inputNames[c],n,r,a);if(s.type==="tensors"){let d=t.inputs.slice(o,l);return t.inputNames.slice(o,l).filter((p,f)=>{var m;return((m=d[f])===null||m===void 0?void 0:m.op)!=="NoOp"}).map(p=>An(p,n,r,a))}let u=An(t.inputNames[c],n,r,a),h=u.dataSync();return s.type==="number"?h[0]:k.toNestedArray(u.shape,h)}let i=t.attrParams[e];return i&&i.value}function An(e,t,n,r){let[a,s]=$r(e,n);if(r!=null){let o=r.getHashTableHandleByName(a);if(o!=null)return o}let i=n.currentContextIds.find(o=>!!t[gx(a,o)]);return i!==void 0?t[gx(a,i)][s]:void 0}function b$(e,t,n){return t[gx(e,n.currentContextId)]}function Ks(e,t){let[n,r,a]=$r(e,t);return[gx(n,t&&t.currentContextId),r,a]}function gx(e,t){return t?`${e}-${t}`:e}function $r(e,t){if(e==="")return["",0,void 0];let n=t!=null&&t.parseNodeNameCache!=null;if(n){let s=t.parseNodeNameCache.get(e);if(s!=null)return s}let r=e.split(":"),a;if(r.length===1)a=[e,0,void 0];else{let s=r[0],i=r.length===3?r[1]:void 0,o=Number(r[r.length-1]);a=[s,o,i]}return n&&t.parseNodeNameCache.set(e,a),a}function g0(e,t,n){let r=S("pad",e,t,n);if(r==="explicit"){r=S("explicitPaddings",e,t,n);let a=[[0,0],[0,0],[0,0],[0,0]];for(let s=0;s<4;s++)a[s][0]=r[s*2],a[s][1]=r[s*2+1];return a}return r}function Xs(e){return e.kept?e:Is(e)}var AP={};Re(AP,{json:()=>voe});var voe=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],$P={};Re($P,{json:()=>woe});var woe=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],MP={};Re(MP,{json:()=>koe});var koe=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],FP={};Re(FP,{json:()=>Soe});var Soe=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],RP={};Re(RP,{json:()=>Ioe});var Ioe=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],DP={};Re(DP,{json:()=>Noe});var Noe=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],OP={};Re(OP,{json:()=>_oe});var _oe=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],zP={};Re(zP,{json:()=>Coe});var Coe=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],PP={};Re(PP,{json:()=>Toe});var Toe=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],LP={};Re(LP,{json:()=>Eoe});var Eoe=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],BP={};Re(BP,{json:()=>Aoe});var Aoe=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],WP={};Re(WP,{json:()=>$oe});var $oe=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],UP={};Re(UP,{json:()=>Moe});var Moe=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],VP={};Re(VP,{json:()=>Foe});var Foe=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],jP={};Re(jP,{json:()=>Roe});var Roe=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],GP={};Re(GP,{json:()=>Doe});var Doe=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],HP={};Re(HP,{json:()=>Ooe});var Ooe=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],qP={};Re(qP,{json:()=>zoe});var zoe=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],KP={};Re(KP,{json:()=>Poe});var Poe=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],v$=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let e=[AP,$P,MP,FP,RP,DP,OP,zP,PP,LP,BP,WP,UP,VP,jP,GP,HP,qP,KP],t=[].concat(...e.map(n=>n.json));this.opMappers=t.reduce((n,r)=>(n[r.tfOpName]=r,n),{})}transformGraph(e,t={}){let n=e.node,r=[],a=[],s=[],i=n.reduce((f,m)=>(f[m.name]=this.mapNode(m),m.op.startsWith("Placeholder")?r.push(f[m.name]):m.op==="Const"?a.push(f[m.name]):(m.input==null||m.input.length===0)&&s.push(f[m.name]),f),{}),o=[],l=[],c={},u={};t!=null&&(c=this.mapSignatureEntries(t.inputs),u=this.mapSignatureEntries(t.outputs));let h=Object.keys(i);h.forEach(f=>{let m=i[f];m.inputNames.forEach((y,g)=>{let[x,,b]=Ks(y),v=i[x];if(v.outputs!=null){let w=v.outputs.indexOf(b);if(w!==-1){let I=`${x}:${w}`;m.inputNames[g]=I}}m.inputs.push(v),v.children.push(m)})}),Object.keys(u).length===0?h.forEach(f=>{let m=i[f];m.children.length===0&&l.push(m)}):Object.keys(u).forEach(f=>{let[m]=Ks(f),y=i[m];y!=null&&(y.signatureKey=u[f],l.push(y))}),Object.keys(c).length>0?Object.keys(c).forEach(f=>{let[m]=Ks(f),y=i[m];y&&(y.signatureKey=c[f],o.push(y))}):o=r;let d={};e.library!=null&&e.library.function!=null&&(d=e.library.function.reduce((f,m)=>(f[m.signature.name]=this.mapFunction(m),f),{}));let p={nodes:i,inputs:o,outputs:l,weights:a,placeholders:r,signature:t,functions:d};return s.length>0&&(p.initNodes=s),p}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,n)=>(t[e[n].name]=n,t),{})}mapNode(e){let t=EP(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});let n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(r=>r.startsWith("^")?r.slice(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(n.inputParams=t.inputs.reduce((r,a)=>(r[a.name]={type:a.type,inputIndexStart:a.start,inputIndexEnd:a.end},r),{})),t.attrs!=null&&(n.attrParams=t.attrs.reduce((r,a)=>{let s=a.type,i;switch(a.type){case"string":i=Uk(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Uk(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"string[]":i=Xk(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Xk(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number":i=jk(e.attr,a.tfName,a.defaultValue||0),i===void 0&&a.tfDeprecatedName&&(i=jk(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number[]":i=Kk(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Kk(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool":i=Vk(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Vk(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool[]":i=Yk(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Yk(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape":i=qk(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=qk(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape[]":i=Zk(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Zk(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype":i=Gk(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Gk(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype[]":i=Hk(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Hk(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"func":i=w$(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=w$(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${a.type} for op: ${e.op}`)}return r[a.name]={value:i,type:s},r},{})),n}mapFunction(e){let t=e.nodeDef,n=[],r=[],a={};t!=null&&(a=t.reduce((c,u)=>(c[u.name]=this.mapNode(u),u.op==="Const"&&r.push(c[u.name]),c),{}));let s=[],i=[];e.signature.inputArg.forEach(c=>{let[u]=Ks(c.name),h={name:u,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:U_(c.type),type:"dtype"}},children:[]};h.signatureKey=c.name,s.push(h),a[u]=h}),Object.keys(a).forEach(c=>{let u=a[c];u.inputNames.forEach((h,d)=>{let[p,,f]=Ks(h),m=a[p];if(m.outputs!=null){let y=m.outputs.indexOf(f);if(y!==-1){let g=`${p}:${y}`;u.inputNames[d]=g}}u.inputs.push(m),m.children.push(u)})});let o=e.ret;e.signature.outputArg.forEach(c=>{let[u,h]=Ks(o[c.name]),d=a[u];d!=null&&(d.defaultOutput=h,i.push(d))});let l=this.mapArgsToSignature(e);return{nodes:a,inputs:s,outputs:i,weights:r,placeholders:n,signature:l}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n),t),{}),outputs:e.signature.outputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t),{})}}mapArgToTensorInfo(e,t){let n=e.name;return t!=null&&(n=t[n]),{name:n,dtype:e.type}}};function Loe(e){let t=X().global;if(typeof t.atob<"u")return t.atob(e);if(typeof Buffer<"u")return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function XP(e,t){let n=Array.isArray(e)?String.fromCharCode.apply(null,e):Loe(e);return t?n:n.toLowerCase()}function Uk(e,t,n,r=!1){let a=e[t];return a!=null?XP(a.s,r):n}function Vk(e,t,n){let r=e[t];return r?r.b:n}function jk(e,t,n){let r=e[t]||{},a=r.i!=null?r.i:r.f!=null?r.f:n;return typeof a=="number"?a:parseInt(a,10)}function U_(e){switch(typeof e=="string"&&(e=Er[e]),e){case Er.DT_FLOAT:case Er.DT_HALF:return"float32";case Er.DT_INT32:case Er.DT_INT64:case Er.DT_INT8:case Er.DT_UINT8:return"int32";case Er.DT_BOOL:return"bool";case Er.DT_DOUBLE:return"float32";case Er.DT_STRING:return"string";case Er.DT_COMPLEX64:case Er.DT_COMPLEX128:return"complex64";default:return null}}function w$(e,t,n){let r=e[t];return r&&r.func?r.func.name:n}function Gk(e,t,n){let r=e[t];return r&&r.type?U_(r.type):n}function Hk(e,t,n){let r=e[t];return r&&r.list&&r.list.type?r.list.type.map(a=>U_(a)):n}function ZP(e){if(!e.unknownRank)return e.dim!=null?e.dim.map(t=>typeof t.size=="number"?t.size:parseInt(t.size,10)):[]}function qk(e,t,n){let r=e[t];return r&&r.shape?ZP(r.shape):n}function Kk(e,t,n){let r=e[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(a=>typeof a=="number"?a:parseInt(a,10)):n}function Xk(e,t,n,r=!1){let a=e[t];return a&&a.list&&a.list.s?a.list.s.map(s=>XP(s,r)):n}function Zk(e,t,n){let r=e[t];return r&&r.list&&r.list.shape?r.list.shape.map(a=>ZP(a)):n}function Yk(e,t,n){let r=e[t];return r&&r.list&&r.list.b?r.list.b:n}var Boe=class{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(r=>this.getInput(r)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((r,a)=>(r[a]=this.getAttr(a),r),{}))}getInput(e){return An(e,this.tensorMap,this.context)}getAttr(e,t){let n=this.node.rawAttrs[e];if(n.tensor!=null)return An(e,this.tensorMap,this.context);if(n.i!=null||n.f!=null)return jk(this.node.rawAttrs,e,t);if(n.s!=null)return Uk(this.node.rawAttrs,e,t);if(n.b!=null)return Vk(this.node.rawAttrs,e,t);if(n.shape!=null)return qk(this.node.rawAttrs,e,t);if(n.type!=null)return Gk(this.node.rawAttrs,e,t);if(n.list!=null){if(n.list.i!=null||n.list.f!=null)return Kk(this.node.rawAttrs,e,t);if(n.list.s!=null)return Xk(this.node.rawAttrs,e,t);if(n.list.shape!=null)return Zk(this.node.rawAttrs,e,t);if(n.list.b!=null)return Yk(this.node.rawAttrs,e,t);if(n.list.type!=null)return Hk(this.node.rawAttrs,e,t)}return t}},Sn={};Re(Sn,{OP_SCOPE_SUFFIX:()=>jS,abs:()=>Kt,acos:()=>XS,acosh:()=>ZS,add:()=>te,addN:()=>c3,all:()=>bb,any:()=>dm,argMax:()=>jl,argMin:()=>YS,asin:()=>JS,asinh:()=>QS,atan:()=>eI,atan2:()=>tI,atanh:()=>nI,avgPool:()=>mi,avgPool3d:()=>aI,basicLSTMCell:()=>f3,batchNorm:()=>_c,batchNorm2d:()=>sI,batchNorm3d:()=>iI,batchNorm4d:()=>oI,batchToSpaceND:()=>cg,bincount:()=>lI,bitwiseAnd:()=>m3,booleanMaskAsync:()=>aO,broadcastArgs:()=>g3,broadcastTo:()=>Tl,buffer:()=>Ve,cast:()=>le,ceil:()=>uI,clipByValue:()=>Ln,clone:()=>Is,complex:()=>ui,concat:()=>xt,concat1d:()=>cI,concat2d:()=>hI,concat3d:()=>dI,concat4d:()=>pI,conv1d:()=>vb,conv2d:()=>nr,conv2dTranspose:()=>wb,conv3d:()=>mI,conv3dTranspose:()=>gI,cos:()=>hg,cosh:()=>kb,cosineWindow:()=>Gb,cumprod:()=>mm,cumsum:()=>Sb,denseBincount:()=>sx,depthToSpace:()=>yI,depthwiseConv2d:()=>Cc,diag:()=>x3,dilation2d:()=>xI,div:()=>xe,divNoNan:()=>bI,dot:()=>vI,dropout:()=>XI,einsum:()=>pl,elu:()=>bp,enclosingPowerOfTwo:()=>ZI,ensureShape:()=>v3,equal:()=>Vr,erf:()=>Ib,euclideanNorm:()=>SI,exp:()=>Bn,expandDims:()=>yn,expm1:()=>II,eye:()=>Nb,fft:()=>wg,fill:()=>Wr,floor:()=>wp,floorDiv:()=>xb,fused:()=>ed,gather:()=>kp,gatherND:()=>lO,greater:()=>or,greaterEqual:()=>gi,ifft:()=>Qh,imag:()=>dg,image:()=>ra,inTopKAsync:()=>uO,irfft:()=>Pb,isFinite:()=>NI,isInf:()=>_I,isNaN:()=>CI,leakyRelu:()=>pg,less:()=>Xh,lessEqual:()=>Bo,linalg:()=>QI,linspace:()=>N3,localResponseNormalization:()=>TI,log:()=>jr,log1p:()=>fg,logSigmoid:()=>EI,logSoftmax:()=>Cb,logSumExp:()=>mg,logicalAnd:()=>Aa,logicalNot:()=>gg,logicalOr:()=>Tb,logicalXor:()=>AI,losses:()=>wO,lowerBound:()=>C3,matMul:()=>We,max:()=>la,maxPool:()=>pn,maxPool3d:()=>$I,maxPoolWithArgmax:()=>T3,maximum:()=>Ms,mean:()=>Dt,meshgrid:()=>E3,min:()=>Kh,minimum:()=>wo,mirrorPad:()=>MI,mod:()=>FI,moments:()=>yg,movingAverage:()=>sO,mul:()=>U,multiRNNCell:()=>A3,multinomial:()=>$3,neg:()=>Nt,norm:()=>vp,notEqual:()=>ql,oneHot:()=>Zh,ones:()=>gr,onesLike:()=>Gr,op:()=>W,outerProduct:()=>M3,pad:()=>ss,pad1d:()=>F3,pad2d:()=>R3,pad3d:()=>D3,pad4d:()=>O3,pool:()=>RI,pow:()=>Ts,prelu:()=>bg,print:()=>KS,prod:()=>DI,raggedGather:()=>z3,raggedRange:()=>P3,raggedTensorToTensor:()=>L3,rand:()=>B3,randomGamma:()=>j3,randomNormal:()=>Ab,randomStandardNormal:()=>G3,randomUniform:()=>Wo,randomUniformInt:()=>H3,range:()=>Kl,real:()=>Yh,reciprocal:()=>BI,relu:()=>ht,relu6:()=>$b,reshape:()=>V,reverse:()=>da,reverse1d:()=>q3,reverse2d:()=>K3,reverse3d:()=>X3,reverse4d:()=>Z3,rfft:()=>kg,round:()=>Mb,rsqrt:()=>Fb,scalar:()=>_e,scatterND:()=>iO,searchSorted:()=>Eb,selu:()=>Rb,separableConv2d:()=>Sp,setdiff1dAsync:()=>Y3,sigmoid:()=>Ca,sign:()=>WI,signal:()=>vO,sin:()=>Db,sinh:()=>Ob,slice:()=>Ke,slice1d:()=>vg,slice2d:()=>zb,slice3d:()=>Ip,slice4d:()=>Jh,softmax:()=>Uo,softplus:()=>Tc,spaceToBatchND:()=>xg,sparse:()=>kO,sparseToDense:()=>oO,spectral:()=>bO,split:()=>xr,sqrt:()=>wn,square:()=>gt,squaredDifference:()=>Lb,squeeze:()=>Vo,stack:()=>Jt,step:()=>Ec,stridedSlice:()=>UI,string:()=>SO,sub:()=>me,sum:()=>ke,tan:()=>VI,tanh:()=>vo,tensor:()=>er,tensor1d:()=>ut,tensor2d:()=>Ns,tensor3d:()=>Bb,tensor4d:()=>ko,tensor5d:()=>J3,tensor6d:()=>Q3,tensorScatterUpdate:()=>tO,tile:()=>Or,topk:()=>GI,transpose:()=>Ue,truncatedNormal:()=>Vb,unique:()=>HI,unsortedSegmentSum:()=>jb,unstack:()=>Vt,upperBound:()=>nO,variable:()=>qI,where:()=>vn,whereAsync:()=>KI,zeros:()=>Ot,zerosLike:()=>Ye});var Woe=(e,t,n,r=Sn)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(S("a",e,t,n),S("b",e,t,n))];case"AddN":return[r.addN(S("tensors",e,t,n))];case"FloorMod":case"Mod":return[r.mod(S("a",e,t,n),S("b",e,t,n))];case"Mul":return[r.mul(S("a",e,t,n),S("b",e,t,n))];case"RealDiv":case"Div":return[r.div(S("a",e,t,n),S("b",e,t,n))];case"DivNoNan":return[r.divNoNan(S("a",e,t,n),S("b",e,t,n))];case"FloorDiv":return[r.floorDiv(S("a",e,t,n),S("b",e,t,n))];case"Sub":return[r.sub(S("a",e,t,n),S("b",e,t,n))];case"Minimum":return[r.minimum(S("a",e,t,n),S("b",e,t,n))];case"Maximum":return[r.maximum(S("a",e,t,n),S("b",e,t,n))];case"Pow":return[r.pow(S("a",e,t,n),S("b",e,t,n))];case"SquaredDifference":return[r.squaredDifference(S("a",e,t,n),S("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},Uoe=(e,t,n,r=Sn)=>{switch(e.op){case"Abs":case"ComplexAbs":return[r.abs(S("x",e,t,n))];case"Acos":return[r.acos(S("x",e,t,n))];case"Acosh":return[r.acosh(S("x",e,t,n))];case"Asin":return[r.asin(S("x",e,t,n))];case"Asinh":return[r.asinh(S("x",e,t,n))];case"Atan":return[r.atan(S("x",e,t,n))];case"Atan2":return[r.atan2(S("x",e,t,n),S("y",e,t,n))];case"Atanh":return[r.atanh(S("x",e,t,n))];case"Ceil":return[r.ceil(S("x",e,t,n))];case"Complex":return[r.complex(S("real",e,t,n),S("imag",e,t,n))];case"Cos":return[r.cos(S("x",e,t,n))];case"Cosh":return[r.cosh(S("x",e,t,n))];case"Elu":return[r.elu(S("x",e,t,n))];case"Erf":return[r.erf(S("x",e,t,n))];case"Exp":return[r.exp(S("x",e,t,n))];case"Expm1":return[r.expm1(S("x",e,t,n))];case"Floor":return[r.floor(S("x",e,t,n))];case"Log":return[r.log(S("x",e,t,n))];case"Log1p":return[r.log1p(S("x",e,t,n))];case"Imag":return[r.imag(S("x",e,t,n))];case"Neg":return[r.neg(S("x",e,t,n))];case"Reciprocal":return[r.reciprocal(S("x",e,t,n))];case"Real":return[r.real(S("x",e,t,n))];case"Relu":return[r.relu(S("x",e,t,n))];case"Round":return[r.round(S("x",e,t,n))];case"Selu":return[r.selu(S("x",e,t,n))];case"Sigmoid":return[r.sigmoid(S("x",e,t,n))];case"Sin":return[r.sin(S("x",e,t,n))];case"Sign":return[r.sign(S("x",e,t,n))];case"Sinh":return[r.sinh(S("x",e,t,n))];case"Softplus":return[r.softplus(S("x",e,t,n))];case"Sqrt":return[r.sqrt(S("x",e,t,n))];case"Square":return[r.square(S("x",e,t,n))];case"Tanh":return[r.tanh(S("x",e,t,n))];case"Tan":return[r.tan(S("x",e,t,n))];case"ClipByValue":return[r.clipByValue(S("x",e,t,n),S("clipValueMin",e,t,n),S("clipValueMax",e,t,n))];case"Relu6":return[r.relu6(S("x",e,t,n))];case"Rsqrt":return[r.rsqrt(An(e.inputNames[0],t,n))];case"LeakyRelu":return[r.leakyRelu(S("x",e,t,n),S("alpha",e,t,n))];case"Prelu":return[r.prelu(S("x",e,t,n),S("alpha",e,t,n))];case"IsNan":return[r.isNaN(An(e.inputNames[0],t,n))];case"IsInf":return[r.isInf(An(e.inputNames[0],t,n))];case"IsFinite":return[r.isFinite(An(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function ka(e,t,n=""){if(!(typeof e=="number"||typeof t=="number")){k.assert(e.length===t.length,()=>n+` Shapes ${e} and ${t} must match`);for(let r=0;r<e.length;r++){let a=e[r],s=t[r];k.assert(a<0||s<0||a===s,()=>n+` Shapes ${e} and ${t} must match`)}}}function k$(e){return!(typeof e=="number"||e.some(t=>t<0))}function sf(e,t,n){let r=Jk(e,n),a=!k$(r);if(a&&t.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(a&&t.forEach(s=>{r=Jk(s.shape,r)}),!k$(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function Jk(e,t){if(typeof e=="number")return t;if(typeof t=="number")return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);let n=[];for(let r=0;r<e.length;++r){let a=e[r],s=t[r];if(a>=0&&s>=0&&a!==s)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[r]=a>=0?a:s}return n}var Voe=class{constructor(e,t,n,r,a,s,i){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=a,this.dynamicSize=s,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=_e(0),an(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);let t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);let n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),ka(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,an(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((n,r)=>this.write(n,t[r]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let r=0;r<this.size();r++)e.push(r)}if(e.length===0)return er([],[0].concat(this.elementShape));let n=this.readMany(e);return ka(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),Jt(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return er([],[0].concat(this.elementShape));let t=[];for(let r=0;r<this.size();r++)t.push(r);let n=this.readMany(t);return ka(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),xt(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);let n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,Vt(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0,r=e.map(o=>(n+=o,n));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);let a=n===0?0:t.size/n,s=[];j(()=>{t=V(t,[1,n,a]);for(let o=0;o<e.length;++o){let l=[0,o===0?0:r[o-1],0],c=[1,e[o],a];s[o]=V(Ke(t,l,c),this.elementShape)}return s});let i=[];for(let o=0;o<e.length;o++)i[o]=o;this.writeMany(i,s)}},bv=class Qk{get id(){return this.idTensor.id}constructor(t,n,r,a=-1){this.tensors=t,this.elementShape=n,this.elementDtype=r,t!=null&&t.forEach(s=>{if(r!==s.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${s.dtype}`);ka(n,s.shape,"TensorList shape mismatch: "),an(s)}),this.idTensor=_e(0),this.maxNumElements=a,an(this.idTensor)}copy(){return new Qk([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(n=>{(t==null||!t.has(n.id))&&n.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,n,r=-1){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(r!==-1&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);ka(t,this.elementShape,"TensorList shape mismatch: ");let a=sf(this.elementShape,this.tensors,t);return j(()=>{let s=this.tensors.map(i=>V(i,a));return Jt(s,0)})}popBack(t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");let r=sf(this.elementShape,this.tensors,t),a=this.tensors.pop();return a.kept=!1,ka(a.shape,t,"TensorList shape mismatch: "),V(a,r)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(ka(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");an(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(this.maxNumElements!==-1&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);let n=new Qk([],this.elementShape,this.elementDtype,this.maxNumElements);n.tensors.length=t;for(let r=0;r<Math.min(this.tensors.length,t);++r)n.tensors[r]=this.tensors[r];return n}getItem(t,n,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(this.tensors[t]==null)throw new Error(`element at index ${t} is null.`);ka(this.tensors[t].shape,n,"TensorList shape mismatch: ");let a=sf(this.elementShape,this.tensors,n);return V(this.tensors[t],a)}setItem(t,n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(t<0||this.maxNumElements!==-1&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);ka(this.elementShape,n.shape,"TensorList shape mismatch: "),an(n),this.tensors[t]!=null&&(this.tensors[t].kept=!1),this.tensors[t]=n}gather(t,n,r){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);ka(this.elementShape,r,"TensorList shape mismatch: "),t=t.slice(0,this.size());let a=sf(this.elementShape,this.tensors,r);return t.length===0?er([],[0].concat(a)):j(()=>{let s=t.map(i=>V(this.tensors[i],a));return Jt(s,0)})}concat(t,n){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);ka(this.elementShape,n,"TensorList shape mismatch: ");let r=sf(this.elementShape,this.tensors,n);return this.size()===0?er([],[0].concat(r)):j(()=>{let a=this.tensors.map(s=>V(s,r));return xt(a,0)})}};function joe(e,t,n){let r=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);let a=e.shape.slice(1);ka(a,t,"TensorList shape mismatch: ");let s=Vt(e);return new bv(s,t,r)}function Goe(e,t,n,r){return new bv([],e,t,r)}function Hoe(e,t,n,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);let a=Math.max(...t);if(r!=null&&r!==-1&&a>=r)throw new Error(`Max index must be < array size (${a}  vs. ${r})`);let s=new bv([],n,e.dtype,r),i=Vt(e,0);return t.forEach((o,l)=>{s.setItem(o,i[l])}),s}function qoe(e,t,n){let r=0,a=t.map(u=>(r+=u,r));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${e.shape}`);let s=e.shape.slice(1),i=Jk(s,n),o=r===0?0:e.size/r,l=j(()=>{let u=[];e=V(e,[1,r,o]);for(let h=0;h<t.length;++h){let d=[0,h===0?0:a[h-1],0],p=[1,t[h],o];u[h]=V(Ke(e,d,p),i)}return e.dispose(),u}),c=new bv([],n,e.dtype,t.length);for(let u=0;u<l.length;u++)c.setItem(u,l[u]);return c}var Koe=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{let r=S("thenBranch",e,t,n),a=S("elseBranch",e,t,n),s=S("cond",e,t,n),i=S("args",e,t,n);return(await s.data())[0]?n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[a].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{let r=S("body",e,t,n),a=S("cond",e,t,n),s=S("args",e,t,n),i=await n.functionMap[a].executeFunctionAsync(s,n.tensorArrayMap,n.tensorListMap),o=s.map(u=>u.id),l=await i[0].data();i.forEach(u=>{!u.kept&&o.indexOf(u.id)===-1&&u.dispose()});let c=s;for(;l[0];){let u=c;c=await n.functionMap[r].executeFunctionAsync(c,n.tensorArrayMap,n.tensorListMap);let h=c.map(p=>p.id);u.forEach(p=>{!p.kept&&o.indexOf(p.id)===-1&&h.indexOf(p.id)===-1&&p.dispose()});let d=await n.functionMap[a].executeFunctionAsync(c,n.tensorArrayMap,n.tensorListMap);l=await d[0].data(),d.forEach(p=>{!p.kept&&o.indexOf(p.id)===-1&&h.indexOf(p.id)===-1&&p.dispose()})}return c}case"LoopCond":{let r=S("pred",e,t,n);return[Xs(r)]}case"Switch":{let r=S("pred",e,t,n),a=S("data",e,t,n);return a.kept||(a=Xs(a)),(await r.data())[0]?[void 0,a]:[a,void 0]}case"Merge":{let r=e.inputNames.find(a=>An(a,t,n)!==void 0);if(r){let a=An(r,t,n);return[Xs(a)]}return}case"Enter":{let r=S("frameName",e,t,n),a=S("tensor",e,t,n);return n.enterFrame(r),[Xs(a)]}case"Exit":{let r=S("tensor",e,t,n);return n.exitFrame(),[Xs(r)]}case"NextIteration":{let r=S("tensor",e,t,n);return n.nextIteration(),[Xs(r)]}case"TensorArrayV3":{let r=S("size",e,t,n),a=S("dtype",e,t,n),s=S("elementShape",e,t,n),i=S("dynamicSize",e,t,n),o=S("clearAfterRead",e,t,n),l=S("identicalElementShapes",e,t,n),c=S("name",e,t,n),u=new Voe(c,a,r,s,l,i,o);return n.addTensorArray(u),[u.idTensor,_e(1)]}case"TensorArrayWriteV3":{let r=S("tensorArrayId",e,t,n),a=S("index",e,t,n),s=S("tensor",e,t,n),i=n.getTensorArray(r.id);return i.write(a,s),[i.idTensor]}case"TensorArrayReadV3":{let r=S("tensorArrayId",e,t,n),a=S("index",e,t,n);return[n.getTensorArray(r.id).read(a)]}case"TensorArrayGatherV3":{let r=S("tensorArrayId",e,t,n),a=S("indices",e,t,n),s=S("dtype",e,t,n);return[n.getTensorArray(r.id).gather(a,s)]}case"TensorArrayScatterV3":{let r=S("tensorArrayId",e,t,n),a=S("indices",e,t,n),s=S("tensor",e,t,n),i=n.getTensorArray(r.id);return i.scatter(a,s),[i.idTensor]}case"TensorArrayConcatV3":{let r=S("tensorArrayId",e,t,n),a=n.getTensorArray(r.id),s=S("dtype",e,t,n);return[a.concat(s)]}case"TensorArraySplitV3":{let r=S("tensorArrayId",e,t,n),a=S("tensor",e,t,n),s=S("lengths",e,t,n),i=n.getTensorArray(r.id);return i.split(s,a),[i.idTensor]}case"TensorArraySizeV3":{let r=S("tensorArrayId",e,t,n),a=n.getTensorArray(r.id);return[_e(a.size(),"int32")]}case"TensorArrayCloseV3":{let r=S("tensorArrayId",e,t,n),a=n.getTensorArray(r.id);return a.clearAndClose(),[a.idTensor]}case"TensorListSetItem":{let r=S("tensorListId",e,t,n),a=S("index",e,t,n),s=S("tensor",e,t,n),i=n.getTensorList(r.id);return i.setItem(a,s),[i.idTensor]}case"TensorListGetItem":{let r=S("tensorListId",e,t,n),a=S("index",e,t,n),s=S("elementShape",e,t,n),i=S("elementDType",e,t,n);return[n.getTensorList(r.id).getItem(a,s,i)]}case"TensorListScatterV2":case"TensorListScatter":{let r=S("indices",e,t,n),a=S("tensor",e,t,n),s=S("elementShape",e,t,n),i=S("numElements",e,t,n),o=Hoe(a,r,s,i);return n.addTensorList(o),[o.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let r=S("elementShape",e,t,n),a=S("elementDType",e,t,n),s;e.op==="TensorListReserve"?s="numElements":s="maxNumElements";let i=S(s,e,t,n),o=e.op==="TensorListReserve"?-1:i,l=Goe(r,a,i,o);return n.addTensorList(l),[l.idTensor]}case"TensorListGather":{let r=S("tensorListId",e,t,n),a=S("indices",e,t,n),s=S("elementShape",e,t,n),i=S("elementDType",e,t,n);return[n.getTensorList(r.id).gather(a,i,s)]}case"TensorListStack":{let r=S("tensorListId",e,t,n),a=S("elementShape",e,t,n),s=S("elementDType",e,t,n),i=S("numElements",e,t,n);return[n.getTensorList(r.id).stack(a,s,i)]}case"TensorListFromTensor":{let r=S("tensor",e,t,n),a=S("elementShape",e,t,n),s=S("elementDType",e,t,n),i=joe(r,a,s);return n.addTensorList(i),[i.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{let r=S("tensorListId",e,t,n),a=n.getTensorList(r.id),s=S("dtype",e,t,n),i=S("elementShape",e,t,n);return[a.concat(s,i)]}case"TensorListPushBack":{let r=S("tensorListId",e,t,n),a=S("tensor",e,t,n),s=n.getTensorList(r.id);return s.pushBack(a),[s.idTensor]}case"TensorListPopBack":{let r=S("tensorListId",e,t,n),a=S("elementShape",e,t,n),s=S("elementDType",e,t,n);return[n.getTensorList(r.id).popBack(a,s)]}case"TensorListSplit":{let r=S("tensor",e,t,n),a=S("elementShape",e,t,n),s=S("lengths",e,t,n),i=qoe(r,s,a);return n.addTensorList(i),[i.idTensor]}case"TensorListLength":{let r=S("tensorListId",e,t,n),a=n.getTensorList(r.id);return[_e(a.size(),"int32")]}case"TensorListResize":{let r=S("tensorListId",e,t,n),a=S("size",e,t,n),s=n.getTensorList(r.id).resize(a);return n.addTensorList(s),[s.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function S$(e,t,n){let[r,a]=S("fusedOps",e,t,n),s=r==="biasadd",i=!s,o=a==="prelu",l=r==="fusedbatchnorm",c=S("numArgs",e,t,n);if(s){if(o&&c!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&s&&c!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let u=S("strides",e,t,n),h=g0(e,t,n),d=S("dataFormat",e,t,n).toUpperCase(),p=S("dilations",e,t,n),[f,m]=S("args",e,t,n);i&&(m=f,f=void 0);let y=S("leakyreluAlpha",e,t,n);return{stride:u,pad:h,dataFormat:d,dilations:p,biasArg:f,preluArg:m,activationFunc:a,leakyreluAlpha:y}}var Xoe=(e,t,n,r=Sn)=>{switch(e.op){case"Conv1D":{let a=S("stride",e,t,n),s=S("pad",e,t,n),i=S("dataFormat",e,t,n).toUpperCase(),o=S("dilation",e,t,n);return[r.conv1d(S("x",e,t,n),S("filter",e,t,n),a,s,i,o)]}case"Conv2D":{let a=S("strides",e,t,n),s=g0(e,t,n),i=S("dataFormat",e,t,n).toUpperCase(),o=S("dilations",e,t,n);return[r.conv2d(S("x",e,t,n),S("filter",e,t,n),[a[1],a[2]],s,i,[o[1],o[2]])]}case"_FusedConv2D":{let{stride:a,pad:s,dataFormat:i,dilations:o,biasArg:l,preluArg:c,activationFunc:u,leakyreluAlpha:h}=S$(e,t,n);return[r.fused.conv2d({x:S("x",e,t,n),filter:S("filter",e,t,n),strides:[a[1],a[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:u,preluActivationWeights:c,leakyreluAlpha:h})]}case"FusedDepthwiseConv2dNative":{let{stride:a,pad:s,dataFormat:i,dilations:o,biasArg:l,preluArg:c,activationFunc:u,leakyreluAlpha:h}=S$(e,t,n);return[r.fused.depthwiseConv2d({x:S("x",e,t,n),filter:S("filter",e,t,n),strides:[a[1],a[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:u,preluActivationWeights:c,leakyreluAlpha:h})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let a=S("outputShape",e,t,n),s=S("strides",e,t,n),i=g0(e,t,n);return[r.conv2dTranspose(S("x",e,t,n),S("filter",e,t,n),a,[s[1],s[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let a=S("strides",e,t,n),s=g0(e,t,n),i=S("dilations",e,t,n),o=S("dataFormat",e,t,n).toUpperCase();return[r.depthwiseConv2d(S("input",e,t,n),S("filter",e,t,n),[a[1],a[2]],s,o,[i[1],i[2]])]}case"Conv3D":{let a=S("strides",e,t,n),s=S("pad",e,t,n),i=S("dataFormat",e,t,n).toUpperCase(),o=S("dilations",e,t,n);return[r.conv3d(S("x",e,t,n),S("filter",e,t,n),[a[1],a[2],a[3]],s,i,[o[1],o[2],o[3]])]}case"AvgPool":{let a=S("strides",e,t,n),s=S("pad",e,t,n),i=S("kernelSize",e,t,n);return[r.avgPool(S("x",e,t,n),[i[1],i[2]],[a[1],a[2]],s)]}case"MaxPool":{let a=S("strides",e,t,n),s=S("pad",e,t,n),i=S("kernelSize",e,t,n);return[r.maxPool(S("x",e,t,n),[i[1],i[2]],[a[1],a[2]],s)]}case"MaxPoolWithArgmax":{let a=S("strides",e,t,n),s=S("pad",e,t,n),i=S("kernelSize",e,t,n),o=S("includeBatchInIndex",e,t,n),{result:l,indexes:c}=r.maxPoolWithArgmax(S("x",e,t,n),[i[1],i[2]],[a[1],a[2]],s,o);return[l,c]}case"AvgPool3D":{let a=S("strides",e,t,n),s=S("pad",e,t,n),i=S("kernelSize",e,t,n);return[r.avgPool3d(S("x",e,t,n),[i[1],i[2],i[3]],[a[1],a[2],a[3]],s)]}case"MaxPool3D":{let a=S("strides",e,t,n),s=S("pad",e,t,n),i=S("kernelSize",e,t,n);return[r.maxPool3d(S("x",e,t,n),[i[1],i[2],i[3]],[a[1],a[2],a[3]],s)]}case"Dilation2D":{let a=S("strides",e,t,n),s=S("pad",e,t,n),i=S("dilations",e,t,n),o=a[1],l=a[2],c=i[1],u=i[2];return[r.dilation2d(S("x",e,t,n),S("filter",e,t,n),[o,l],s,[c,u],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},Zoe=(e,t,n,r=Sn)=>{switch(e.op){case"Fill":{let a=S("shape",e,t,n),s=S("dtype",e,t,n),i=S("value",e,t,n);return[r.fill(a,i,s)]}case"LinSpace":{let a=S("start",e,t,n),s=S("stop",e,t,n),i=S("num",e,t,n);return[r.linspace(a,s,i)]}case"Multinomial":{let a=S("logits",e,t,n),s=S("numSamples",e,t,n),i=S("seed",e,t,n);return[r.multinomial(a,s,i)]}case"OneHot":{let a=S("indices",e,t,n),s=S("depth",e,t,n),i=S("onValue",e,t,n),o=S("offValue",e,t,n),l=S("dtype",e,t,n);return[r.oneHot(a,s,i,o,l)]}case"Ones":return[r.ones(S("shape",e,t,n),S("dtype",e,t,n))];case"OnesLike":return[r.onesLike(S("x",e,t,n))];case"RandomStandardNormal":return[r.randomStandardNormal(S("shape",e,t,n),S("dtype",e,t,n),S("seed",e,t,n))];case"RandomUniform":return[r.randomUniform(S("shape",e,t,n),S("minval",e,t,n),S("maxval",e,t,n),S("dtype",e,t,n))];case"RandomUniformInt":return[r.randomUniformInt(S("shape",e,t,n),S("minval",e,t,n),S("maxval",e,t,n),S("seed",e,t,n))];case"Range":{let a=S("start",e,t,n),s=S("stop",e,t,n),i=S("step",e,t,n);return[r.range(a,s,i,S("dtype",e,t,n))]}case"TruncatedNormal":{let a=S("shape",e,t,n),s=S("mean",e,t,n),i=S("stdDev",e,t,n),o=S("seed",e,t,n);return[r.truncatedNormal(a,s,i,S("dtype",e,t,n),o)]}case"Zeros":return[r.zeros(S("shape",e,t,n),S("dtype",e,t,n))];case"ZerosLike":return[r.zerosLike(S("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function Qw(e,t,n){let r=S("boxes",e,t,n),a=S("scores",e,t,n),s=S("maxOutputSize",e,t,n),i=S("iouThreshold",e,t,n),o=S("scoreThreshold",e,t,n),l=S("softNmsSigma",e,t,n);return{boxes:r,scores:a,maxOutputSize:s,iouThreshold:i,scoreThreshold:o,softNmsSigma:l}}var Yoe=async(e,t,n,r,a=Sn)=>{switch(e.op){case"NonMaxSuppressionV5":{let{boxes:s,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:c,softNmsSigma:u}=Qw(e,t,n),h=await a.image.nonMaxSuppressionWithScoreAsync(s,i,o,l,c,u);return[h.selectedIndices,h.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:s,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:c}=Qw(e,t,n),u=S("padToMaxOutputSize",e,t,n),h=await a.image.nonMaxSuppressionPaddedAsync(s,i,o,l,c,u);return[h.selectedIndices,h.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:s,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:c}=Qw(e,t,n);return[await a.image.nonMaxSuppressionAsync(s,i,o,l,c)]}case"Where":{let s=a.cast(S("condition",e,t,n),"bool"),i=[await a.whereAsync(s)];return s.dispose(),i}case"ListDiff":return a.setdiff1dAsync(S("x",e,t,n),S("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}},Joe=(e,t,n,r=Sn)=>{switch(e.op){case"LowerBound":{let a=S("sortedSequence",e,t,n),s=S("values",e,t,n);return[r.lowerBound(a,s)]}case"TopKV2":{let a=S("x",e,t,n),s=S("k",e,t,n),i=S("sorted",e,t,n),o=r.topk(a,s,i);return[o.values,o.indices]}case"UpperBound":{let a=S("sortedSequence",e,t,n),s=S("values",e,t,n);return[r.upperBound(a,s)]}case"Unique":{let a=S("x",e,t,n),s=r.unique(a);return[s.values,s.indices]}case"UniqueV2":{let a=S("x",e,t,n),s=S("axis",e,t,n),i=r.unique(a,s);return[i.values,i.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},Qoe=(e,t,n,r=Sn)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":let a=S("default",e,t,n);return[An(e.name,t,n)||a];case"Placeholder":return[An(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let u=S("x",e,t,n);return[Xs(u)]}case"IdentityN":return S("x",e,t,n).map(u=>Xs(u));case"Snapshot":let s=S("x",e,t,n);return[Xs(s)];case"Shape":return[r.tensor1d(S("x",e,t,n).shape,"int32")];case"ShapeN":return S("x",e,t,n).map(u=>r.tensor1d(u.shape));case"Size":return[r.scalar(S("x",e,t,n).size,"int32")];case"Rank":return[r.scalar(S("x",e,t,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":let i=S("x",e,t,n),o=S("data",e,t,n),l=S("message",e,t,n),c=S("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let u=0;u<o.length;u++)console.log(Array.prototype.slice.call(o[u].dataSync()).slice(0,c));return[i];default:throw TypeError(`Node type ${e.op} is not implemented`)}},ele=class{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=_e(0),this.tensorMap=new Map,an(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return _e(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return this.tensorMap.forEach(r=>r.dispose()),this.tensorMap.clear(),j(()=>{let r=Vt(t),a=n.length,s=r.length;k.assert(a===s,()=>`The number of elements doesn't match, keys has ${a} elements, the values has ${s} elements.`);for(let i=0;i<a;i++){let o=n[i],l=r[i];an(l),this.tensorMap.set(o,l)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return j(()=>{let r=[];for(let a=0;a<n.length;a++){let s=n[a],i=this.findWithDefault(s,t);r.push(i)}return Jt(r)})}findWithDefault(e,t){let n=this.tensorMap.get(e);return n??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}},tle=async(e,t,n,r)=>{switch(e.op){case"HashTable":case"HashTableV2":{let a=r.getHashTableHandleByName(e.name);if(a!=null)return[a];{let s=S("keyDType",e,t,n),i=S("valueDType",e,t,n),o=new ele(s,i);return r.addHashTable(e.name,o),[o.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{let a=S("tableHandle",e,t,n,r),s=S("keys",e,t,n),i=S("values",e,t,n);return[await r.getHashTableById(a.id).import(s,i)]}case"LookupTableFind":case"LookupTableFindV2":{let a=S("tableHandle",e,t,n,r),s=S("keys",e,t,n),i=S("defaultValue",e,t,n);return[await r.getHashTableById(a.id).find(s,i)]}case"LookupTableSize":case"LookupTableSizeV2":{let a=S("tableHandle",e,t,n,r);return[r.getHashTableById(a.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},nle=(e,t,n,r=Sn)=>{switch(e.op){case"ResizeBilinear":{let a=S("images",e,t,n),s=S("size",e,t,n),i=S("alignCorners",e,t,n),o=S("halfPixelCenters",e,t,n);return[r.image.resizeBilinear(a,[s[0],s[1]],i,o)]}case"ResizeNearestNeighbor":{let a=S("images",e,t,n),s=S("size",e,t,n),i=S("alignCorners",e,t,n),o=S("halfPixelCenters",e,t,n);return[r.image.resizeNearestNeighbor(a,[s[0],s[1]],i,o)]}case"CropAndResize":{let a=S("image",e,t,n),s=S("boxes",e,t,n),i=S("boxInd",e,t,n),o=S("cropSize",e,t,n),l=S("method",e,t,n),c=S("extrapolationValue",e,t,n);return[r.image.cropAndResize(a,s,i,o,l,c)]}case"ImageProjectiveTransformV3":{let a=S("images",e,t,n),s=S("transforms",e,t,n),i=S("outputShape",e,t,n),o=S("fillValue",e,t,n),l=S("interpolation",e,t,n),c=S("fillMode",e,t,n);return[r.image.transform(a,s,l.toLowerCase(),c.toLowerCase(),o,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},rle=(e,t,n,r=Sn)=>{switch(e.op){case"Equal":return[r.equal(S("a",e,t,n),S("b",e,t,n))];case"NotEqual":return[r.notEqual(S("a",e,t,n),S("b",e,t,n))];case"Greater":return[r.greater(S("a",e,t,n),S("b",e,t,n))];case"GreaterEqual":return[r.greaterEqual(S("a",e,t,n),S("b",e,t,n))];case"Less":return[r.less(S("a",e,t,n),S("b",e,t,n))];case"LessEqual":return[r.lessEqual(S("a",e,t,n),S("b",e,t,n))];case"LogicalAnd":return[r.logicalAnd(S("a",e,t,n),S("b",e,t,n))];case"LogicalNot":return[r.logicalNot(S("a",e,t,n))];case"LogicalOr":return[r.logicalOr(S("a",e,t,n),S("b",e,t,n))];case"Select":case"SelectV2":return[r.where(S("condition",e,t,n),S("a",e,t,n),S("b",e,t,n))];case"BitwiseAnd":return[r.bitwiseAnd(S("a",e,t,n),S("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},ale=(e,t,n,r=Sn)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(S("a",e,t,n),S("b",e,t,n),S("transposeA",e,t,n),S("transposeB",e,t,n))];case"Einsum":return[r.einsum(S("equation",e,t,n),...S("tensors",e,t,n))];case"Transpose":return[r.transpose(S("x",e,t,n),S("perm",e,t,n))];case"_FusedMatMul":let[a,s]=S("fusedOps",e,t,n),i=a==="biasadd",o=s==="prelu",l=S("numArgs",e,t,n),c=S("leakyreluAlpha",e,t,n);if(i){if(o&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[u,h]=S("args",e,t,n);return[r.fused.matMul({a:S("a",e,t,n),b:S("b",e,t,n),transposeA:S("transposeA",e,t,n),transposeB:S("transposeB",e,t,n),bias:u,activation:s,preluActivationWeights:h,leakyreluAlpha:c})];case"MatrixBandPart":return[r.linalg.bandPart(S("a",e,t,n),S("numLower",e,t,n),S("numUpper",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},sle=(e,t,n,r=Sn)=>{switch(e.op){case"EuclideanNorm":return[r.euclideanNorm(S("x",e,t,n),S("axis",e,t,n),S("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":return[r.batchNorm(S("x",e,t,n),S("mean",e,t,n),S("variance",e,t,n),S("offset",e,t,n),S("scale",e,t,n),S("epsilon",e,t,n))];case"FusedBatchNormV3":return[r.batchNorm(S("x",e,t,n),S("mean",e,t,n),S("variance",e,t,n),S("offset",e,t,n),S("scale",e,t,n),S("epsilon",e,t,n))];case"LRN":return[r.localResponseNormalization(S("x",e,t,n),S("radius",e,t,n),S("bias",e,t,n),S("alpha",e,t,n),S("beta",e,t,n))];case"Softmax":return[r.softmax(S("x",e,t,n))];case"LogSoftmax":return[r.logSoftmax(S("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},ile=(e,t,n,r=Sn)=>{switch(e.op){case"RaggedGather":{let{outputNestedSplits:a,outputDenseValues:s}=r.raggedGather(S("paramsNestedSplits",e,t,n),S("paramsDenseValues",e,t,n),S("indices",e,t,n),S("outputRaggedRank",e,t,n));return a.concat(s)}case"RaggedRange":{let{rtNestedSplits:a,rtDenseValues:s}=r.raggedRange(S("starts",e,t,n),S("limits",e,t,n),S("splits",e,t,n));return[a,s]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(S("shape",e,t,n),S("values",e,t,n),S("defaultValue",e,t,n),S("rowPartitionTensors",e,t,n),S("rowPartitionTypes",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},ole=(e,t,n,r=Sn)=>{switch(e.op){case"Max":{let o=S("axis",e,t,n),l=S("keepDims",e,t,n);return[r.max(S("x",e,t,n),o,l)]}case"Mean":{let o=S("axis",e,t,n),l=S("keepDims",e,t,n);return[r.mean(S("x",e,t,n),o,l)]}case"Min":{let o=S("axis",e,t,n),l=S("keepDims",e,t,n);return[r.min(S("x",e,t,n),o,l)]}case"Sum":{let o=S("axis",e,t,n),l=S("keepDims",e,t,n);return[r.sum(S("x",e,t,n),o,l)]}case"All":{let o=S("axis",e,t,n),l=S("keepDims",e,t,n);return[r.all(S("x",e,t,n),o,l)]}case"Any":{let o=S("axis",e,t,n),l=S("keepDims",e,t,n);return[r.any(S("x",e,t,n),o,l)]}case"ArgMax":{let o=S("axis",e,t,n);return[r.argMax(S("x",e,t,n),o)]}case"ArgMin":{let o=S("axis",e,t,n);return[r.argMin(S("x",e,t,n),o)]}case"Prod":{let o=S("axis",e,t,n),l=S("keepDims",e,t,n);return[r.prod(S("x",e,t,n),o,l)]}case"Cumprod":{let o=S("axis",e,t,n),l=S("exclusive",e,t,n),c=S("reverse",e,t,n);return[r.cumprod(S("x",e,t,n),o,l,c)]}case"Cumsum":{let o=S("axis",e,t,n),l=S("exclusive",e,t,n),c=S("reverse",e,t,n);return[r.cumsum(S("x",e,t,n),o,l,c)]}case"Bincount":let a=S("x",e,t,n),s=S("weights",e,t,n),i=S("size",e,t,n);return[r.bincount(a,s,i)];case"DenseBincount":{let o=S("x",e,t,n),l=S("weights",e,t,n),c=S("size",e,t,n),u=S("binaryOutput",e,t,n);return[r.denseBincount(o,l,c,u)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},lle=(e,t,n,r=Sn)=>{switch(e.op){case"ConcatV2":case"Concat":{let a=S("n",e,t,n),s=S("axis",e,t,n),i=S("tensors",e,t,n);return i=i.slice(0,a),[r.concat(i,s)]}case"Gather":{let a=S("x",e,t,n),s=S("indices",e,t,n);return[r.gather(a,r.cast(s,"int32"),0)]}case"GatherV2":{let a=S("axis",e,t,n),s=S("batchDims",e,t,n),i=S("x",e,t,n),o=S("indices",e,t,n);return[r.gather(i,r.cast(o,"int32"),a,s)]}case"Reverse":{let a=S("dims",e,t,n),s=[];for(let o=0;o<a.length;o++)a[o]&&s.push(o);let i=S("x",e,t,n);return[r.reverse(i,s)]}case"ReverseV2":{let a=S("axis",e,t,n),s=S("x",e,t,n);return[r.reverse(s,a)]}case"Slice":{let a=S("begin",e,t,n),s=S("size",e,t,n);return[r.slice(S("x",e,t,n),a,s)]}case"StridedSlice":{let a=S("begin",e,t,n),s=S("end",e,t,n),i=S("strides",e,t,n),o=S("beginMask",e,t,n),l=S("endMask",e,t,n),c=S("ellipsisMask",e,t,n),u=S("newAxisMask",e,t,n),h=S("shrinkAxisMask",e,t,n),d=S("x",e,t,n);return[r.stridedSlice(d,a,s,i,o,l,c,u,h)]}case"Pack":return j(()=>{let a=S("axis",e,t,n),s=S("tensors",e,t,n),i=s[0].shape,o=r.squeeze(s[0]).shape,l=s.map(c=>{let u=k.arraysEqual(c.shape,i);if(!u&&!k.arraysEqual(r.squeeze(c).shape,o))throw new Error("the input tensors shape does not match");return u?c:r.reshape(c,i)});return[r.stack(l,a)]});case"Unpack":{let a=S("axis",e,t,n),s=S("tensor",e,t,n);return r.unstack(s,a)}case"Tile":{let a=S("reps",e,t,n);return[r.tile(S("x",e,t,n),a)]}case"Split":case"SplitV":{let a=S("axis",e,t,n),s=S("numOrSizeSplits",e,t,n),i=S("x",e,t,n);return r.split(i,s,a)}case"ScatterNd":{let a=S("indices",e,t,n),s=S("values",e,t,n),i=S("shape",e,t,n);return[r.scatterND(a,s,i)]}case"GatherNd":{let a=S("x",e,t,n),s=S("indices",e,t,n);return[r.gatherND(a,s)]}case"SparseToDense":{let a=S("sparseIndices",e,t,n),s=S("outputShape",e,t,n),i=S("sparseValues",e,t,n),o=S("defaultValue",e,t,n);return[r.sparseToDense(a,i,s,i.dtype===o.dtype?o:r.cast(o,i.dtype))]}case"TensorScatterUpdate":{let a=S("indices",e,t,n),s=S("values",e,t,n),i=S("tensor",e,t,n);return[r.tensorScatterUpdate(i,a,s)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},ule=(e,t,n,r=Sn)=>{switch(e.op){case"SparseFillEmptyRows":{let{outputIndices:a,outputValues:s,emptyRowIndicator:i,reverseIndexMap:o}=r.sparse.sparseFillEmptyRows(S("indices",e,t,n),S("values",e,t,n),S("denseShape",e,t,n),S("defaultValue",e,t,n));return[a,s,i,o]}case"SparseReshape":{let{outputIndices:a,outputShape:s}=r.sparse.sparseReshape(S("inputIndices",e,t,n),S("inputShape",e,t,n),S("newShape",e,t,n));return[a,s]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(S("data",e,t,n),S("indices",e,t,n),S("segmentIds",e,t,n))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(S("data",e,t,n),S("indices",e,t,n),S("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},cle=(e,t,n,r=Sn)=>{switch(e.op){case"FFT":return[r.fft(S("x",e,t,n))];case"IFFT":return[r.ifft(S("x",e,t,n))];case"RFFT":return[r.rfft(S("x",e,t,n))];case"IRFFT":return[r.irfft(S("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},hle=(e,t,n,r=Sn)=>{switch(e.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(S("input",e,t,n),S("pattern",e,t,n),S("rewrite",e,t,n),S("replaceGlobal",e,t,n))];case"StringNGrams":{let{nGrams:a,nGramsSplits:s}=r.string.stringNGrams(S("data",e,t,n),S("dataSplits",e,t,n),S("separator",e,t,n),S("nGramWidths",e,t,n),S("leftPad",e,t,n),S("rightPad",e,t,n),S("padWidth",e,t,n),S("preserveShortSequences",e,t,n));return[a,s]}case"StringSplit":{let{indices:a,values:s,shape:i}=r.string.stringSplit(S("input",e,t,n),S("delimiter",e,t,n),S("skipEmpty",e,t,n));return[a,s,i]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(S("input",e,t,n),S("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},dle=(e,t,n,r=Sn)=>{switch(e.op){case"Cast":return[r.cast(S("x",e,t,n),S("dtype",e,t,n))];case"ExpandDims":{let a=S("axis",e,t,n);return[r.expandDims(S("x",e,t,n),a)]}case"Squeeze":{let a=S("axis",e,t,n);return[r.squeeze(S("x",e,t,n),a)]}case"Reshape":return[r.reshape(S("x",e,t,n),S("shape",e,t,n))];case"EnsureShape":return[r.ensureShape(S("x",e,t,n),S("shape",e,t,n))];case"MirrorPad":return[r.mirrorPad(S("x",e,t,n),S("padding",e,t,n),S("mode",e,t,n))];case"PadV2":case"Pad":return[r.pad(S("x",e,t,n),S("padding",e,t,n),S("constantValue",e,t,n))];case"SpaceToBatchND":{let a=S("blockShape",e,t,n),s=S("paddings",e,t,n);return[r.spaceToBatchND(S("x",e,t,n),a,s)]}case"BatchToSpaceND":{let a=S("blockShape",e,t,n),s=S("crops",e,t,n);return[r.batchToSpaceND(S("x",e,t,n),a,s)]}case"DepthToSpace":{let a=S("blockSize",e,t,n),s=S("dataFormat",e,t,n).toUpperCase();return[r.depthToSpace(S("x",e,t,n),a,s)]}case"BroadcastTo":return[r.broadcastTo(S("x",e,t,n),S("shape",e,t,n))];case"BroadcastArgs":return[r.broadcastArgs(S("s0",e,t,n),S("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function I$(e,t,n,r,a=j){let s=((i,o,l)=>{switch(i.category){case"arithmetic":return a(()=>Woe(i,o,l));case"basic_math":return a(()=>Uoe(i,o,l));case"control":return Koe(i,o,l);case"convolution":return a(()=>Xoe(i,o,l));case"creation":return a(()=>Zoe(i,o,l));case"dynamic":return Yoe(i,o,l);case"evaluation":return a(()=>Joe(i,o,l));case"image":return a(()=>nle(i,o,l));case"graph":return a(()=>Qoe(i,o,l));case"logical":return a(()=>rle(i,o,l));case"matrices":return a(()=>ale(i,o,l));case"normalization":return a(()=>sle(i,o,l));case"ragged":return a(()=>ile(i,o,l));case"reduction":return a(()=>ole(i,o,l));case"slice_join":return a(()=>lle(i,o,l));case"sparse":return a(()=>ule(i,o,l));case"spectral":return a(()=>cle(i,o,l));case"string":return a(()=>hle(i,o,l));case"transformation":return a(()=>dle(i,o,l));case"hash_table":return tle(i,o,l,r);case"custom":let c=EP(i.op);if(c&&c.customExecutor)return c.customExecutor(new Boe(i,o,l));throw TypeError(`Custom op ${i.op} is not registered.`);default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return k.isPromise(s)?s.then(i=>[].concat(i)):[].concat(s)}var N$=class{constructor(e={},t={},n={},r={},a){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=r,this.parseNodeNameCache=a,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let e=[];for(let t=0;t<this.contexts.length-1;t++){let n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(let t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(let t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}};function _$(e,t,n,r){let a=new Set,s=[],i=null,o=null,l=new Set,c=new Set(Object.keys(e).map(d=>$r(d)[0]));r=r||[];let u=new Set(r.map(d=>$r(d.name)[0])),h=[...t];for(;h.length>0;){let d=h.pop();if((ml(d)||vle(d)||wle(d))&&i==null&&(i=d,o=i.children.map(p=>p.name).filter(p=>a.has(p))),a.add(d.name),n[d.name]==null&&!c.has(d.name)&&!u.has(d.name)){if(d.inputs.length===0){s.push(d.name);continue}d.inputs.forEach(p=>{l.has(p.name)||(l.add(p.name),h.push(p))})}}return{inputs:e,outputs:t,usedNodes:a,missingInputs:s,dynamicNode:i,syncInputs:o}}function ple(e,t){let{usedNodes:n,inputs:r}=t,a=Object.keys(r).map(y=>$r(y)[0]).map(y=>e.nodes[y]),s=e.initNodes||[],i=y=>n.has(typeof y=="string"?y:y.name);function o(y){return[...new Map(y.map(g=>[g.name,g])).values()]}let l=o([...a,...e.weights,...s]).filter(i),c=o([...l,...Object.values(e.nodes)]).filter(i),u=new Map(c.map(y=>[y.name,y])),h={};for(let y of c){h[y.name]=h[y.name]||0;for(let g of y.children)i(g)||(h[g.name]=Number.POSITIVE_INFINITY),h[g.name]=(h[g.name]||0)+1}let d=Object.entries(h).filter(([,y])=>y===0).map(([y])=>y),p=[...d];for(;d.length>0;){let y=d.pop(),g=u.get(y);for(let x of g.children.filter(i))--h[x.name]===0&&(p.push(x.name),d.push(x.name))}let f=p.map(y=>u.get(y)),m=fle(f,l);return mle(m,l),m}function fle(e,t){let n=new Map(e.map(s=>[s.name,s])),r=t.map(s=>s.name),a=new Set(r);for(;r.length>0;){let s=r.pop(),i=n.get(s);for(let o of i.children)!n.has(o.name)||a.has(o.name)||(a.add(o.name),r.push(o.name))}return e.filter(s=>a.has(s.name))}var jy=class extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}};function mle(e,t){let n=new Map(e.map((o,l)=>[o.name,l])),r=new Set(t.map(o=>o.name)),a=o=>r.has(typeof o=="string"?o:o.name),s=new Set(e.map(o=>o.name)),i=o=>s.has(typeof o=="string"?o:o.name);for(let o of e){for(let l of o.children.filter(i)){if(!n.has(l.name))throw new jy(`Child ${l.name} of node ${o.name} is unreachable.`);if(n.get(o.name)>n.get(l.name))throw new jy(`Node ${o.name} is scheduled to run after its child ${l.name}.`)}if(!a(o))for(let l of o.inputs){if(!n.has(l.name))throw new jy(`Input ${l.name} of node ${o.name} is unreachable.`);if(n.get(l.name)>n.get(o.name))throw new jy(`Node ${o.name} is scheduled to run before its input ${l.name}.`)}}}function gle(e){let t=new Map(e.map((o,l)=>[o.name,l])),n=Number.MAX_SAFE_INTEGER,r=e.map((o,l)=>ml(o)?n:l),a=o=>{let l=r[t.get(o.name)];return l??-1},s=e.map((o,l)=>o.children.map(a).reduce((c,u)=>Math.max(c,u),r[l])),i=new Map;for(let o=0;o<e.length;++o){let l=s[o];if(l===n)continue;let c=e[o],u=e[l];i.has(u.name)||i.set(u.name,[]),i.get(u.name).push(c)}return i}var yle=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),xle=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),ble=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function ml(e){return yle.has(e.op)}function vle(e){return xle.has(e.op)}function wle(e){return ble.has(e.op)}var C$=class YP{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){let n=Object.keys(t).map(r=>t[r].map(a=>a.id));this._weightIds=[].concat(...n),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{let n=t.signatureKey||t.name;return t.defaultOutput?`${n}:${t.defaultOutput}`:n})}get functions(){return Object.keys(this._functions).reduce((t,n)=>(t[n]=this._functions[n].signature,t),{})}constructor(t,n){this.graph=t,this.parent=n,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,t.functions!=null&&Object.keys(t.functions).forEach(r=>{this._functionExecutorMap[r]=new YP(t.functions[r],this)})}getCompilationKey(t,n){let r=t.map(s=>s.name).sort(),a=n.map(s=>s.name).sort();return r.join(this.SEPARATOR)+"--"+a.join(this.SEPARATOR)}compile(t,n){let r=_$(t,n,this.weightMap,this._initNodes),{missingInputs:a,dynamicNode:s,syncInputs:i}=r;if(s!=null)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(a.length>0){let c=n.map(h=>h.name),u=Object.keys(t);throw new Error(`Cannot compute the outputs [${c}] from the provided inputs [${u}]. Missing the following inputs: [${a}]`)}let o=ple(this.graph,r),l=gle(o);return{orderedNodes:o,nodeLiveUntilMap:l}}cloneAndKeepTensor(t){if(t==null)return null;let n=t.clone();return an(n),n}cloneTensorList(t){return t?t.map(n=>this.cloneAndKeepTensor(n)):null}cloneTensorMap(t){return Object.fromEntries(Object.entries(t).map(([n,r])=>[n,this.cloneTensorList(r)]))}execute(t,n){this.disposeIntermediateTensors(),t=this.mapInputs(t);let r=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),n=this.mapOutputs(n),this.checkOutputs(n);let a=r.map(d=>this.graph.nodes[$r(d)[0]]),s=n.map(d=>$r(d)[0]),i=new Set(s),o=s.map(d=>this.graph.nodes[d]);o.length===0&&(o=this._outputs);let l=this.getCompilationKey(a,o),c=this.compiledMap.get(l);c==null&&(c=this.compile(t,o),this.compiledMap.set(l,c));try{this.keepIntermediateTensors=X().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}let u={},h={};return j(()=>{let d=new N$(this.weightMap,u,h,this.functionExecutorMap,this.parseNodeNameCache),p=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(t).forEach(g=>{let[x,b]=$r(g,d),v=[];v[b]=t[g],p[x]=v,this.keepIntermediateTensors&&(this.clonedTensorsMap[x]=this.cloneTensorList(v))});let f=this.getFrozenTensorIds(p),{orderedNodes:m,nodeLiveUntilMap:y}=c;for(let g of m){if(p[g.name])continue;let x=I$(g,p,d,this._resourceManager);if(k.isPromise(x))throw new Error(`The execution of the op '${g.op}' returned a promise. Please use model.executeAsync() instead.`);p[g.name]=x,this.keepIntermediateTensors&&(this.clonedTensorsMap[g.name]=this.cloneTensorList(x)),this.checkTensorForDisposalWithNodeLiveUntilInfo(g,p,d,f,i,y.get(g.name))}return this.parent==null&&d.dispose(f),n.map(g=>An(g,p,d))})}getFrozenTensorIds(t){let n=[].concat.apply([],Object.keys(t).map(r=>t[r]).map(r=>r.map(a=>a.id)));return new Set(n)}checkTensorForDisposal(t,n,r,a,s,i,o){if(!(ml(n)||i.has(t))){for(let l of r[t])l!=null&&(o[l.id]=(o[l.id]||0)+n.children.length);for(let l of n.inputs){if(ml(l))continue;let c=b$(l.name,r,a);if(c!=null)for(let u of c){if(!u||u.kept||s.has(u.id))continue;let h=o[u.id];h===1?(u.dispose(),delete o[u.id]):h!=null&&o[u.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(t,n,r,a,s,i){function o(l){return ml(l)||s.has(l.name)}if(!(ml(t)||i==null))for(let l of i){if(o(l))continue;let c=b$(l.name,n,r);for(let u of c)!u||u.kept||a.has(u.id)||u.dispose()}}async executeAsync(t,n){return this._executeAsync(t,n)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(t=>{for(let n of t)n&&!n.isDisposed&&n.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(t,n,r=!1,a={},s={}){this.disposeIntermediateTensors(),r||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),n=this.mapOutputs(n),this.checkOutputs(n));try{this.keepIntermediateTensors=X().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}let i=new N$(this.weightMap,a,s,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));let o=await this.executeWithControlFlow(t,i,n,r),l=n.map(d=>An(d,o,i)),c=l.map(d=>d.id),u=Object.keys(t).map(d=>t[d].id),h=new Set([...c,...u,...this.weightIds]);return Object.values(o).forEach(d=>{d.forEach(p=>{p&&!p.isDisposed&&!h.has(p.id)&&p.dispose()})}),this.parent==null&&i.dispose(h),l}async executeFunctionAsync(t,n,r){let a=t.reduce((s,i,o)=>(s[this.inputs[o].name]=i,s),{});return this._executeAsync(a,this.outputNodes,!0,n,r)}async executeWithControlFlow(t,n,r,a){let s=Object.keys(t),i=s.map(v=>this.graph.nodes[$r(v)[0]]),o=r.map(v=>$r(v)[0]),l=new Set(o),c=o.map(v=>this.graph.nodes[v]);c.length===0&&(c=this._outputs);let{usedNodes:u,missingInputs:h,dynamicNode:d,syncInputs:p}=_$(t,c,this.weightMap,this._initNodes),f=[...i,...this.graph.weights,...this._initNodes||[]].map(v=>({node:v,contexts:n.currentContext})),m=Object.assign({},this.weightMap);Object.keys(t).forEach(v=>{let[w,I]=$r(v),_=[];_[I]=t[v],m[w]=_});let y={},g=this.getFrozenTensorIds(m),x={};for(;f.length>0;){let v=this.processStack(i,f,n,m,x,g,l,y,u);await Promise.all(v)}d==null&&!a&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let b=c.filter(v=>!ml(v)&&!An(v.name,m,n)).map(v=>v.name);if(b.length>0){let v="";throw d!=null&&(v=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${p}]`),new Error(`Cannot compute the outputs [${b}] from the provided inputs [${s}]. Consider providing the following inputs: [${h}]. ${v}`)}return m}processStack(t,n,r,a,s,i,o,l,c){let u=[];for(;n.length>0;){let h=n.pop();r.currentContext=h.contexts;let d="";if(h.node.op==="Enter"&&S("isConstant",h.node,a,r)&&([d]=Ks(h.node.name,r)),a[h.node.name]==null){let p=I$(h.node,a,r,this._resourceManager);d||([d]=Ks(h.node.name,r));let f=r.currentContext;k.isPromise(p)?u.push(p.then(m=>(a[d]=m,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(m)),r.currentContext=f,this.checkTensorForDisposal(d,h.node,a,r,i,o,l),this.processChildNodes(h.node,n,r,a,s,c),m))):(a[d]=p,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(p)),this.checkTensorForDisposal(d,h.node,a,r,i,o,l),this.processChildNodes(h.node,n,r,a,s,c))}else this.processChildNodes(h.node,n,r,a,s,c)}return u}processChildNodes(t,n,r,a,s,i){t.children.forEach(o=>{let[l]=Ks(o.name,r);s[l]||!i.has(o.name)||(o.op==="Merge"?o.inputNames.some(c=>!!An(c,a,r))&&(s[l]=!0,n.push({contexts:r.currentContext,node:o})):o.inputNames.every(c=>!!An(c,a,r))&&(s[l]=!0,n.push({contexts:r.currentContext,node:o})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(n=>n.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(n=>{let r=t[n],[a]=$r(n),s=this.graph.nodes[a];if(s.attrParams.shape&&s.attrParams.shape.value){let i=s.attrParams.shape.value,o=i.length===r.shape.length&&r.shape.every((l,c)=>i[c]===-1||i[c]===l);k.assert(o,()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${i}], but was [${r.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&k.assert(r.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(t){var n,r;let a={};for(let s in t){let i=(r=(n=this._signature)===null||n===void 0?void 0:n.inputs)===null||r===void 0?void 0:r[s];i!=null?a[i.name]=t[s]:a[s]=t[s]}return a}checkInputs(t){let n=Object.keys(t).filter(r=>{let[a]=$r(r);return this.graph.nodes[a]==null});if(n.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${n}] that are not part of graph`)}mapOutputs(t){return t.map(n=>{var r,a;let s=(a=(r=this._signature)===null||r===void 0?void 0:r.outputs)===null||a===void 0?void 0:a[n];return s!=null?s.name:n},{})}checkOutputs(t){t.forEach(n=>{let[r]=$r(n);if(!this.graph.nodes[r])throw new Error(`The output '${n}' is not found in the graph`)})}},kle=class{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(let e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(let e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}},Sle="?tfjs-format=file",Ile="model.json",V_=class{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},n=Mn){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=n,t==null&&(this.loadOptions={}),this.resourceManager=new kle}findIOHandler(){let e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{let t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let e=this.handler.load();return k.isPromise(e)?e.then(t=>t.getWeightStream==null?this.loadSync(t):this.loadStreaming(t)):this.loadSync(e)}loadSync(e){let t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");let t=await e3(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;let n=this.artifacts.modelTopology,r=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){let a=this.artifacts.userDefinedMetadata;a.signature!=null&&(r=a.signature),a.structuredOutputKeys!=null&&(this.structuredOutputKeys=a.structuredOutputKeys)}if(this.signature=r,this.version=`${n.versions.producer}.${n.versions.minConsumer}`,this.executor=new C$(v$.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){let a=v$.Instance.transformGraph(e.modelInitializer);this.initializer=new C$(a),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){let n=this.io.getSaveHandlers(e);if(n.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(n.length>1)throw new Error(`Found more than one (${n.length}) save handlers for URL '${e}'`);e=n[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){let t=e instanceof ze?[e]:e,n={};return t.forEach((r,a)=>n[this.structuredOutputKeys[a]]=r),n}return e}predict(e,t){let n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){let n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){var t;if(!(e instanceof ze)&&!Array.isArray(e)){let a=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(a!=null)for(let s in a){let i=a[s];i.resourceId!=null&&(e[s]=this.resourceIdToCapturedInput[i.resourceId])}return e}e=Array.isArray(e)?e:[e];let n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce((a,s)=>{var i,o,l;let c=(l=(o=(i=this.signature)===null||i===void 0?void 0:i.inputs)===null||o===void 0?void 0:o[s])===null||l===void 0?void 0:l.resourceId;return c!=null?a[s]=this.resourceIdToCapturedInput[c]:a[s]=e[r++],a},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){let t=this.initializerSignature.outputs,n=Object.keys(t);for(let r=0;r<n.length;r++){let a=n[r],s=t[a];this.resourceIdToCapturedInput[s.resourceId]=e[r]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,n)=>(t[n]=[e[n]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Fe(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}};async function Nle(e,t={},n=Mn){if(e==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");t==null&&(t={}),t.fromTFHub&&typeof e=="string"&&(e=Cle(e));let r=new V_(e,t,n);return await r.load(),r}function _le(e){if(e==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let t;if(e instanceof Array){let[r,a]=e;if(!r)throw new Error("modelJSON must be the first element of the array");if(!a||!(a instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in r))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in r))throw new Error("Model JSON is missing 'weightsManifest'");let s=Mn.getWeightSpecs(r.weightsManifest),i=Mn.getModelArtifactsForJSONSync(r,s,a);t=Mn.fromMemorySync(i)}else if("load"in e)t=e;else if("modelTopology"in e&&"weightSpecs"in e&&"weightData"in e)t=Mn.fromMemorySync(e);else throw new Error("Unknown model format");let n=new V_(t);return n.load(),n}function Cle(e){return e.endsWith("/")||(e=e+"/"),`${e}${Ile}${Sle}`}var Tle="4.22.0",JP={};Re(JP,{CSVDataset:()=>uL,Dataset:()=>Tp,FileDataSource:()=>gL,TextLineDataset:()=>lL,URLDataSource:()=>yL,array:()=>Yle,csv:()=>cue,func:()=>hue,generator:()=>due,microphone:()=>fue,version_data:()=>mue,webcam:()=>pue,zip:()=>Jle});var Ele=Ro(Jx()),Ale=Ro(Jx());function $le(e,t){return yx(e,t)}function yx(e,t,n=new Map,r=new Set){if(e==null)return null;if(typeof Blob=="function"&&e instanceof Blob)return e.slice();if(r.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);let a=t(e);if(a.recurse&&a.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(a.recurse)if(rd(e)){let s=Array.isArray(e)?[]:{};r.add(e);for(let i in e){let o=e[i],l=yx(o,t,n,r);s[i]=l}return r.delete(e),e.__proto__&&(s.__proto__=e.__proto__),s}else throw new Error(`Can't recurse into non-iterable type: ${e}`);else return n.set(e,a.value),a.value}function Mle(e,t=eL){return QP(e,t)}function QP(e,t,n=new Set){let r=e[0];if(n.has(r))throw new Error("Circular references are not supported.");let a=t(e);if(a.recurse&&a.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(a.recurse)if(rd(r)){let s=Array.isArray(r)?[]:{};n.add(r);for(let i in r){let o=e.map(c=>c[i]),l=QP(o,t,n);s[i]=l}return n.delete(r),s}else throw new Error(`Can't recurse into non-iterable type: ${r}`);else return a.value}function eL(e){return e===null?null:rd(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}async function tL(e,t){let n=new Map;yx(e,t,n);for(let r of Array.from(n.keys())){let a=n.get(r);if(k.isPromise(a)){let s=await a;n.set(r,s)}}return yx(e,t,n)}function rd(e){let t=!1;if(X().get("IS_BROWSER"))t=e instanceof TextDecoder;else{let{StringDecoder:n}=vD();t=e instanceof n}return e!=null&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||typeof e=="object"&&!(e instanceof ze)&&!(e instanceof Promise)&&!t)}function Fle(e){return e==null||Rle(e)||Array.isArray(e)||typeof e=="object"&&e instanceof ze||k.isTypedArray(e)}function Rle(e){return e===null||typeof e!="object"&&typeof e!="function"}function Dle(e){return $le(e,Ole)}function Ole(e){return e instanceof ze?{value:e.clone(),recurse:!1}:rd(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}var nL=class{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,e==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(let t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}},rL=class aL extends nL{constructor(){super(aL.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){let t=this.capacity*2,n=new Array(t),r=this.length();for(let a=0;a<r;a++)n[a]=this.get(this.wrap(this.begin+a));this.data=n,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=r}};rL.INITIAL_CAPACITY=32;function sL(e){return new Lle(e)}function j_(e){return new Ble(e)}function zle(e,t){return new iL(e,t)}function Ple(e,t=Zi.FAIL){return new Xle(e,t)}var kn=class{async toArray(){let e=[],t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){let e=this.prefetch(100),t=[],n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new qle(this,e)}filter(e){return new Gle(this,e)}map(e){return new Hle(this,e)}mapAsync(e){return new T$(this,e)}serialMapAsync(e){return new T$(this,e).serial()}flatmap(e){return new Kle(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(t=>t===!0)}rowMajorBatch(e,t=!0){return new jle(this,e,t)}columnMajorBatch(e,t=!0,n=eL){return this.rowMajorBatch(e,t).map(r=>Mle(r,n))}concatenate(e,t){return new iL(sL([this,e]),t)}take(e){return e<0||e==null?this:new Vle(this,e)}skip(e){return e<0||e==null?this:new Ule(this,e)}prefetch(e){return new oL(this,e)}shuffle(e,t){return new Zle(this,e,t)}serial(){return new Wle(this)}},Lle=class extends kn{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let e=this.items[this.trav];return this.trav++,{value:Dle(e),done:!1}}},Ble=class extends kn{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}},Wle=class extends kn{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}},Ule=class extends kn{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let e=await this.upstream.next();if(e.done)return e;Fe(e.value)}return this.upstream.next()}},Vle=class extends kn{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},jle=class extends kn{constructor(e,t,n=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){let e=[];for(;e.length<this.batchSize;){let t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}},Gle=class extends kn{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){let e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;Fe(e.value)}}},Hle=class extends kn{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=Za.getTensorsInContainer(e.value),n=this.transform(e.value),r=Za.getTensorsInContainer(n);for(let a of t)Za.isTensorInList(a,r)||a.dispose();return{value:n,done:!1}}},qle=class extends kn{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}},T$=class extends kn{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=Za.getTensorsInContainer(e.value),n=await this.transform(e.value),r=Za.getTensorsInContainer(n);for(let a of t)Za.isTensorInList(a,r)||a.dispose();return{value:n,done:!1}}},G_=class extends kn{constructor(){super(),this.outputQueue=new rL,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},Kle=class extends G_{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let e=await this.upstream.next();if(e.done)return!1;let t=Za.getTensorsInContainer(e.value),n=this.transform(e.value),r=Za.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(let a of t)Za.isTensorInList(a,r)||a.dispose();return!0}},iL=class extends kn{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,this.iterator==null){let n=await this.moreIterators.next();if(n.done)return{value:null,done:!0};this.iterator=n.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}},Zi;(function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"})(Zi||(Zi={}));var Xle=class extends kn{constructor(e,t=Zi.FAIL){super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,n=0;function r(s){return s instanceof kn?{value:s.next().then(i=>(t++,i.done&&n++,i.value)),recurse:!1}:{value:null,recurse:!0}}let a=await tL(this.iterators,r);if(t===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case Zi.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case Zi.SHORTEST:return{value:null,done:!0};case Zi.LONGEST:}return this.count++,{value:a,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}},oL=class extends kn{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new nL(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}},Zle=class extends oL{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=Ale.alea(n||k.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(t.done)this.upstreamExhausted=!0;else return this.refill(),t}return{value:null,done:!0}}},Tp=class{constructor(){this.size=null}batch(e,t=!0){let n=this;k.assert(e>0,()=>`batchSize needs to be positive, but it is
      ${e}`);let r;return this.size===1/0||this.size==null?r=this.size:t?r=Math.ceil(this.size/e):r=Math.floor(this.size/e),Ar(async()=>(await n.iterator()).columnMajorBatch(e,t,Qle),r)}concatenate(e){let t=this,n;return this.size===1/0||e.size===1/0?n=1/0:this.size!=null&&e.size!=null?n=this.size+e.size:n=null,Ar(async()=>(await t.iterator()).concatenate(await e.iterator()),n)}filter(e){let t=this,n;return this.size===1/0?n=1/0:n=null,Ar(async()=>(await t.iterator()).filter(r=>j(()=>e(r))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){let t=this;return Ar(async()=>(await t.iterator()).map(n=>j(()=>e(n))),this.size)}mapAsync(e){let t=this;return Ar(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(e==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let t=this;return Ar(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){let t=this,n;return this.size!=null&&e>0?n=this.size*e:e===0?n=0:this.size!=null&&(e===void 0||e<0)?n=1/0:n=null,Ar(async()=>{let r=j_(async()=>({value:await t.iterator(),done:!1}));return zle(r.take(e))},n)}skip(e){let t=this,n;return this.size!=null&&e>=0&&this.size>=e?n=this.size-e:this.size!=null&&(this.size<e||e===void 0||e<0)?n=0:n=null,Ar(async()=>(await t.iterator()).skip(e),n)}shuffle(e,t,n=!0){if(e==null||e<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let r=this,a=Ele.alea(t||k.now().toString());return Ar(async()=>{let s=a.int32();return n&&(s+=a.int32()),(await r.iterator()).shuffle(e,s.toString())},this.size)}take(e){let t=this,n;return this.size!=null&&this.size>e?n=e:this.size!=null&&this.size<=e?n=this.size:n=null,Ar(async()=>(await t.iterator()).take(e),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};Tp.MAX_BUFFER_SIZE=1e4;function Ar(e,t=null){return new class extends Tp{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function Yle(e){return Ar(async()=>sL(e),e.length)}function Jle(e){if(!rd(e))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(e))for(let n=0;n<e.length;n++)t=t==null?e[n].size:Math.min(t,e[n].size);else if(e instanceof Object)for(let n in e)t=t==null?e[n].size:Math.min(t,e[n].size);return Ar(async()=>{let n=await tL(e,r=>{if(r instanceof Tp)return{value:r.iterator(),recurse:!1};if(rd(r))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return Ple(n,Zi.SHORTEST)},t)}function Qle(e){if(e===null)return null;let t=e[0];return Fle(t)?{value:eue(e),recurse:!1}:{value:null,recurse:!0}}function eue(e){if(e.length===0)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof ze?Jt(e):er(e)}var lL=class extends Tp{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`
`).map(e=>(e.endsWith("\r")&&(e=e.slice(0,-1)),e))}},Gy='"',of=Symbol("out"),E$=Symbol("field"),Hy=Symbol("quote"),e1=Symbol("quoteafterquote"),A$=Symbol("quoteinquote"),uL=class extends Tp{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&k.assert(e.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=e);let t=this.fullColumnNames.reduce((r,a)=>(r[a]=r[a]+1||1,r),{}),n=Object.keys(t).filter(r=>t[r]>1);if(k.assert(n.length===0,()=>"Duplicate column names found: "+n.toString()),this.columnConfigs){for(let r of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(r)===-1)throw new Error('The key "'+r+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){let e=await(await this.base.iterator()).next();if(e.done)throw new Error("No data was found for CSV parsing.");let t=e.value;return this.parseRow(t,!1)}else return null}constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new lL(e),t||(t={}),this.hasHeader=t.hasHeader!==!1,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(k.assert(t.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map(t=>this.makeDataElement(t))}makeDataElement(e){let t=this.parseRow(e),n={},r={};for(let a=0;a<this.fullColumnNames.length;a++){let s=this.fullColumnNames[a],i=this.columnConfigs?this.columnConfigs[s]:null;if(!(this.configuredColumnsOnly&&!i)){let o=t[a],l=null;if(o==="")if(i&&i.default!==void 0)l=i.default;else{if(i&&(i.required||i.isLabel))throw new Error(`Required column ${s} is empty in this line: ${e}`);l=void 0}else{let c=Number(o);if(isNaN(c))i&&i.dtype==="bool"?l=this.getBoolean(o):l=o;else if(!i||!i.dtype)l=c;else switch(i.dtype){case"float32":l=c;break;case"int32":l=Math.floor(c);break;case"bool":l=this.getBoolean(o);break;default:l=c}}i&&i.isLabel?r[s]=l:n[s]=l}}return Object.keys(r).length===0?n:{xs:n,ys:r}}getBoolean(e){return e==="1"||e.toLowerCase()==="true"?1:0}parseRow(e,t=!0){let n=[],r=0,a=e.length,s=of;for(let i=0;i<a;i++)switch(s){case of:switch(e.charAt(i)){case Gy:r=i+1,s=Hy;break;case this.delimiter:if(r=i+1,this.delimiter===" "&&this.delimWhitespace)break;n.push(""),s=of;break;default:s=E$,r=i;break}break;case E$:switch(e.charAt(i)){case this.delimiter:n.push(e.substring(r,i)),s=of,r=i+1;break}break;case Hy:switch(e.charAt(i)){case Gy:s=e1;break}break;case e1:switch(e.charAt(i)){case this.delimiter:n.push(e.substring(r,i-1)),s=of,r=i+1;break;case Gy:s=Hy;break;default:s=A$;break}break;case A$:switch(e.charAt(i)){case Gy:s=Hy;break}break}if(s===e1?n.push(e.substring(r,a-1)):n.push(e.substring(r)),t&&n.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}},tue=class cL extends kn{constructor(t){super(),this.microphoneConfig=t,this.isClosed=!1,this.fftSize=t.fftSize||1024;let n=Math.log2(this.fftSize);if(this.fftSize<0||n<4||n>14||!Number.isInteger(n))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=t.numFramesPerSpectrogram||43,this.sampleRateHz=t.sampleRateHz,this.columnTruncateLength=t.columnTruncateLength||this.fftSize,this.audioTrackConstraints=t.audioTrackConstraints,this.smoothingTimeConstant=t.smoothingTimeConstant||0,this.includeSpectrogram=t.includeSpectrogram!==!1,this.includeWaveform=t.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(t={}){if(!X().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");let n=new cL(t);return await n.start(),n}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(r){throw new Error(`Error thrown while initializing video stream: ${r.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");let t=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new t,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);let n=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,n.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let t,n,r=await this.getAudioData();if(this.includeSpectrogram){let a=this.flattenQueue(r.freqDataQueue);t=this.getTensorFromAudioDataArray(a,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let a=this.flattenQueue(r.timeDataQueue);n=this.getTensorFromAudioDataArray(a,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:t,waveform:n},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let t=[],n=[],r=0;return new Promise(a=>{let s=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&a({freqDataQueue:t,timeDataQueue:n}),t.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),n.push(this.timeData.slice())),++r===this.numFrames&&(clearInterval(s),a({freqDataQueue:t,timeDataQueue:n}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(t){let n=t[0].length,r=new Float32Array(t.length*n);return t.forEach((a,s)=>r.set(a,s*n)),r}getTensorFromAudioDataArray(t,n){let r=new Float32Array(k.sizeFromShape(n));return r.set(t,r.length-t.length),er(r,n)}},nue=class hL extends kn{constructor(t,n){if(super(),this.webcamVideoElement=t,this.webcamConfig=n,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=ut([0],"int32"),this.webcamConfig.centerCrop){let r=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,a=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,s=(1-r)/2,i=(1-a)/2,o=s+r,l=a+i;this.cropBox=Ns([i,s,l,o],[1,4])}else this.cropBox=Ns([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(t,n={}){if(!X().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!t){if(t=document.createElement("video"),!n.resizeWidth||!n.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");t.width=n.resizeWidth,t.height=n.resizeHeight}let r=new hL(t,n);return await r.start(),r}async start(){this.webcamConfig.facingMode&&k.assert(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(t){throw t.message=`Error thrown while initializing video stream: ${t.message}`,t}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(t){console.log(t),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(t=>{this.webcamVideoElement.onloadedmetadata=()=>{t()}})}async next(){if(this.isClosed)return{value:null,done:!0};let t;try{t=Sg.fromPixels(this.webcamVideoElement)}catch(n){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(n)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(t),done:!1}}catch(n){throw new Error(`Error thrown cropping the video: ${n.message}`)}finally{t.dispose()}else return{value:t,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(t){return j(()=>{let n=yn(le(t,"float32"),0),r;r=ra.cropAndResize(n,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");let a=r.shape;return V(r,a.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(t=>t.stop());try{this.webcamVideoElement.srcObject=null}catch(t){console.log(t),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}},dL=class{},pL=class extends kn{split(e){return new rue(this,e)}},rue=class extends pL{constructor(e,t){super(),this.upstream=e,this.impl=new aue(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},aue=class extends G_{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let e=await this.upstream.next();if(e.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);let t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(let n of t.slice(0,-1))this.outputQueue.push(n);return this.carryover=t[t.length-1],!0}},sue=class extends kn{decodeUTF8(){return new iue(this)}},iue=class extends pL{constructor(e){super(),this.upstream=e,this.impl=new oue(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},oue=class extends G_{constructor(e){if(super(),this.upstream=e,X().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{let{StringDecoder:t}=vD();this.decoder=new t("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let e=await this.upstream.next(),t;if(e.done)return!1;t=e.value;let n;return X().get("IS_BROWSER")?n=this.decoder.decode(t,{stream:!0}):n=this.decoder.write(Buffer.from(t.buffer)),this.outputQueue.push(n),!0}},fL=class extends sue{constructor(e,t={}){super(),this.file=e,this.options=t,k.assert(e instanceof Uint8Array||(X().get("IS_BROWSER")?e instanceof File||e instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((e,t)=>{let n=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)e(new Uint8Array(this.file.slice(this.offset,n)));else{let r=new FileReader;r.onload=s=>{let i=r.result;if(i instanceof ArrayBuffer&&(i=new Uint8Array(i)),!(i instanceof Uint8Array))return t(new TypeError("FileReader returned unknown type."));e(i)},r.onabort=s=>t(new Error("Aborted")),r.onerror=s=>t(new Error(s.type));let a=this.file.slice(this.offset,n);r.readAsArrayBuffer(a)}this.offset=n}),done:!1}}};async function lue(e,t={},n){let r,a;typeof e=="string"?r=e:(r=e.url,a=uue(e));let s=await(0,k.fetch)(r,a);if(s.ok){let i=new Uint8Array(await s.arrayBuffer());return new fL(i,t)}else throw new Error(s.statusText)}var uue=e=>({method:e.method,headers:e.headers,body:e.body,mode:e.mode,credentials:e.credentials,cache:e.cache,redirect:e.redirect,referrer:e.referrer,integrity:e.integrity});function mL(e){return typeof e=="string"&&e.slice(0,7)==="file://"}var gL=class extends dL{constructor(e,t={}){super(),this.input=e,this.options=t}async iterator(){if(mL(this.input)&&X().get("IS_NODE")){let e=OS();this.input=e.readFileSync(this.input.slice(7))}return new fL(this.input,this.options)}},yL=class extends dL{constructor(e,t={}){super(),this.url=e,this.fileOptions=t}async iterator(){return mL(this.url)?new gL(this.url,this.fileOptions).iterator():lue(this.url,this.fileOptions)}};function cue(e,t={}){return new uL(new yL(e),t)}function hue(e){let t=j_(e);return Ar(async()=>t)}function due(e){return Ar(async()=>{let t=await e();return j_(()=>t.next())})}async function pue(e,t){return nue.create(e,t)}async function fue(e){return tue.create(e)}var mue="4.22.0";function Ie(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&k.assert(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}var gue=Fs.whereImpl,H_=class xL extends Dm{nextDataId(){return xL.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new Qx(this,wa())}write(t,n,r){this.firstUse&&(this.firstUse=!1,X().get("IS_NODE")&&E.warn(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));let a={id:this.nextDataId()};return this.data.set(a,{values:t,dtype:r,refCount:1}),a}makeTensorInfo(t,n,r){let a;if(n==="string"&&r!=null&&r.length>0&&k.isString(r[0])){let s=r.map(i=>k.encodeString(i));a=this.write(s,t,n)}else a=this.write(r,t,n);return{dataId:a,shape:t,dtype:n}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){let n=this.data.get(t);n.refCount++}decRef(t){if(this.data.has(t)){let n=this.data.get(t);n.refCount--}}move(t,n,r,a,s){this.data.set(t,{values:n,dtype:a,refCount:s})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){let{dtype:n,complexTensorInfos:r}=this.data.get(t);if(n==="complex64"){let a=this.readSync(r.real.dataId),s=this.readSync(r.imag.dataId);return E.mergeRealAndImagArrays(a,s)}return k.convertBackendValuesAndArrayBuffer(this.data.get(t).values,n)}bufferSync(t){let n=this.readSync(t.dataId);if(t.dtype==="string")try{let r=n.map(a=>k.decodeString(a));return Ve(t.shape,t.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Ve(t.shape,t.dtype,n)}makeOutput(t,n,r){return wa().makeTensorFromTensorInfo(this.makeTensorInfo(n,r,t),this)}disposeData(t,n=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!n&&this.data.get(t).refCount>0)return!1;let{complexTensorInfos:r}=this.data.get(t);r!=null&&(this.disposeData(r.real.dataId,!0),this.disposeData(r.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){let n=k.now();return t(),{kernelMs:k.now()-n}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){Ie([t],"where");let n=this.readSync(t.dataId);return gue(t.shape,n)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}};H_.nextDataId=0;var q_={};Re(q_,{addImpl:()=>wL,bincountImpl:()=>X_,bincountReduceImpl:()=>kL,bitwiseAndImpl:()=>SL,castImpl:()=>vL,ceilImpl:()=>IL,concatImpl:()=>Z_,equalImpl:()=>NL,expImpl:()=>CL,expm1Impl:()=>EL,floorDivImpl:()=>$L,floorImpl:()=>AL,gatherNdImpl:()=>ML,gatherV2Impl:()=>FL,greaterEqualImpl:()=>DL,greaterImpl:()=>RL,lessEqualImpl:()=>zL,lessImpl:()=>OL,linSpaceImpl:()=>PL,logImpl:()=>LL,maxImpl:()=>BL,maximumImpl:()=>WL,minimumImpl:()=>UL,multiplyImpl:()=>Y_,negImpl:()=>VL,notEqualImpl:()=>jL,prodImpl:()=>GL,raggedGatherImpl:()=>HL,raggedRangeImpl:()=>qL,raggedTensorToTensorImpl:()=>KL,rangeImpl:()=>Q_,rsqrtImpl:()=>XL,scatterImpl:()=>Nl,sigmoidImpl:()=>mce,simpleAbsImpl:()=>bL,sliceImpl:()=>bx,sparseFillEmptyRowsImpl:()=>YL,sparseReshapeImpl:()=>JL,sparseSegmentReductionImpl:()=>eC,sqrtImpl:()=>xce,squaredDifferenceImpl:()=>QL,staticRegexReplaceImpl:()=>e4,stridedSliceImpl:()=>t4,stringNGramsImpl:()=>tC,stringSplitImpl:()=>nC,stringToHashBucketFastImpl:()=>rC,subImpl:()=>n4,tileImpl:()=>r4,topKImpl:()=>s4,transposeImpl:()=>J_,uniqueImpl:()=>sC});function bL(e){let t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}var yue=e=>{let{x:t}=e.inputs,n=e.backend;Ie(t,"abs");let r=new Float32Array(k.sizeFromShape(t.shape)),a=n.data.get(t.dataId).values;return r=bL(a),n.makeOutput(r,t.shape,t.dtype)},xue={kernelName:gd,backendName:"cpu",kernelFunc:yue};function Ht(e){return(t,n,r,a,s)=>{let i=E.assertAndGetBroadcastShape(t,n),o=i.length,l=k.computeStrides(i),c=k.sizeFromShape(i),u=k.getTypedArrayFromDType(s,c),h=t.length,d=n.length,p=k.computeStrides(t),f=k.computeStrides(n),m=E.getBroadcastDims(t,i),y=E.getBroadcastDims(n,i);if(m.length+y.length===0)for(let g=0;g<u.length;++g)u[g]=e(r[g%r.length],a[g%a.length]);else for(let g=0;g<u.length;++g){let x=k.indexToLoc(g,o,l),b=x.slice(-h);m.forEach(_=>b[_]=0);let v=k.locToIndex(b,h,p),w=x.slice(-d);y.forEach(_=>w[_]=0);let I=k.locToIndex(w,d,f);u[g]=e(r[v],a[I])}return[u,i]}}function Fr(e){let{inputs:t,backend:n}=e,{real:r,imag:a}=t,s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,o=n.makeTensorInfo(r.shape,"complex64"),l=n.data.get(o.dataId);return l.complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",s),imag:n.makeTensorInfo(a.shape,"float32",i)},o}var bue={kernelName:nb,backendName:"cpu",kernelFunc:Fr};function xx(e,t,n="float32"){if(n==="complex64"){let a=xx(e,t,"float32"),s=xx(e,t,"float32");return Fr({inputs:{real:a,imag:s},backend:e})}let r=k.makeZerosTypedArray(k.sizeFromShape(t),n);return e.makeTensorInfo(t,n,r)}function As(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var vue={kernelName:zu,backendName:"cpu",kernelFunc:As};function Zl(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.real,s=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,s)}var wue={kernelName:fb,backendName:"cpu",kernelFunc:Zl};function vL(e,t,n,r){if(r==="int32"){let a=Int32Array.from(e);return[t,"int32",a]}if(r==="bool"){let a=k.toTypedArray([0],n),[s,i]=Ht((o,l)=>o!==l?1:0)(t,[],e,a,"bool");return[i,"bool",s]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}function Co(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dtype:s}=r;if(s==="complex64"){if(a.dtype==="complex64")return As({inputs:{x:a},backend:n});let u=xx(n,a.shape,a.dtype),h=Co({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),d=Fr({inputs:{real:h,imag:u},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),d}if(a.dtype==="complex64"){let u=Zl({inputs:{input:a},backend:n}),h=Co({inputs:{x:u},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(u),h}if(!k.hasEncodingLoss(a.dtype,s)){let u=As({inputs:{x:a},backend:n});return{dataId:u.dataId,shape:u.shape,dtype:s}}let i=n.data.get(a.dataId).values,[o,l,c]=vL(i,a.shape,a.dtype,s);return n.makeTensorInfo(o,l,c)}var kue={kernelName:xu,backendName:"cpu",kernelFunc:Co};function hn(e,t,n,r){return n==null?({inputs:a,backend:s})=>{let{a:i,b:o}=a,l=s;Ie([i,o],e);let c=l.data.get(i.dataId).values,u=l.data.get(o.dataId).values,h=i.dtype==="string"?E.fromUint8ToStringArray(c):c,d=i.dtype==="string"?E.fromUint8ToStringArray(u):u,p=r||i.dtype,[f,m]=t(i.shape,o.shape,h,d,p);return l.makeTensorInfo(m,p,f)}:({inputs:a,backend:s})=>{let{a:i,b:o}=a,l=s;if(i.dtype==="complex64"||o.dtype==="complex64"){let c=Co({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),u=l.data.get(c.dataId),h=u.complexTensorInfos.real,d=u.complexTensorInfos.imag,p=l.data.get(h.dataId).values,f=l.data.get(d.dataId).values,m=Co({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),y=l.data.get(m.dataId),g=y.complexTensorInfos.real,x=y.complexTensorInfos.imag,b=l.data.get(g.dataId).values,v=l.data.get(x.dataId).values,[w,I,_]=n(i.shape,o.shape,p,f,b,v),T=l.makeTensorInfo(_,"float32",w),A=l.makeTensorInfo(_,"float32",I),M=Fr({inputs:{real:T,imag:A},backend:l});return l.disposeIntermediateTensorInfo(c),l.disposeIntermediateTensorInfo(m),l.disposeIntermediateTensorInfo(T),l.disposeIntermediateTensorInfo(A),M}else{let c=l.data.get(i.dataId).values,u=l.data.get(o.dataId).values,h=r||i.dtype,[d,p]=t(i.shape,o.shape,c,u,h);return l.makeTensorInfo(p,h,d)}}}function K_(e){return(t,n,r,a,s,i)=>{let o=E.assertAndGetBroadcastShape(t,n),l=k.sizeFromShape(o),c=o.length,u=k.computeStrides(o),h=k.getTypedArrayFromDType("float32",l),d=k.getTypedArrayFromDType("float32",l),p=E.getBroadcastDims(t,o),f=E.getBroadcastDims(n,o),m=E.mergeRealAndImagArrays(r,a),y=E.mergeRealAndImagArrays(s,i),g=t.length,x=k.computeStrides(t),b=n.length,v=k.computeStrides(n);if(p.length+f.length===0)for(let w=0;w<h.length;w++){let I=w%m.length,_=w%y.length,T=e(m[I*2],m[I*2+1],y[_*2],y[_*2+1]);h[w]=T.real,d[w]=T.imag}else for(let w=0;w<h.length;w++){let I=k.indexToLoc(w,c,u),_=I.slice(-g);p.forEach(C=>_[C]=0);let T=k.locToIndex(_,g,x),A=I.slice(-b);f.forEach(C=>A[C]=0);let M=k.locToIndex(A,b,v),F=e(m[T*2],m[T*2+1],y[M*2],y[M*2+1]);h[w]=F.real,d[w]=F.imag}return[h,d,o]}}var wL=Ht((e,t)=>e+t),Sue=K_((e,t,n,r)=>({real:e+n,imag:t+r})),ad=hn(Do,wL,Sue),Iue={kernelName:Do,backendName:"cpu",kernelFunc:ad};function X_(e,t,n,r,a){let s=k.sizeFromShape(r),i=k.makeZerosTypedArray(a,n);for(let o=0;o<e.length;o++){let l=e[o];if(l<0)throw new Error("Input x must be non-negative!");l>=a||(s>0?i[l]+=t[o]:i[l]+=1)}return i}function kL(e,t,n,r=!1){let a=e.shape[0],s=e.shape[1],i=Ve([a,n],t.dtype);for(let o=0;o<a;o++)for(let l=0;l<s;l++){let c=e.get(o,l);if(c<0)throw new Error("Input x must be non-negative!");c>=n||(r?i.set(1,o,c):t.size>0?i.set(i.get(o,c)+t.get(o,l),o,c):i.set(i.get(o,c)+1,o,c))}return i}var SL=Ht((e,t)=>e&t),Nue=hn(Id,SL),_ue={kernelName:Id,backendName:"cpu",kernelFunc:Nue};function Rs(e){return(t,n,r)=>{let a=k.getArrayFromDType(n,t.length);for(let s=0;s<t.length;++s)a[s]=e(t[s],r);return a}}function pt(e,t,n){let r=Rs(t);return jo(e,r,n)}function jo(e,t,n){return({inputs:r,attrs:a,backend:s})=>{let{x:i}=r;Ie(i,e);let o=s,l=o.data.get(i.dataId).values,c;if(i.dtype==="string"){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");c=E.fromUint8ToStringArray(l)}else c=l;let u=n||i.dtype,h=t(c,u,a);return o.makeTensorInfo(i.shape,u,h)}}var IL=Rs(e=>Math.ceil(e)),Cue=jo(bu,IL),Tue={kernelName:bu,backendName:"cpu",kernelFunc:Cue};function Z_(e,t,n,r){let a=k.getArrayFromDType(n,k.sizeFromShape(t));if(r&&n!=="string"){let s=0;e.forEach(i=>{let o=k.sizeFromShape(i.shape);a.set(i.vals,s),s+=o})}else{let s=0;e.forEach(i=>{let o=n==="string"?E.fromUint8ToStringArray(i.vals):i.vals,l=0;for(let c=0;c<i.shape[0];++c){let u=c*t[1]+s;for(let h=0;h<i.shape[1];++h)a[u+h]=o[l++]}s+=i.shape[1]})}return a}var NL=Ht((e,t)=>e===t?1:0),_L=hn(Md,NL,null,"bool"),Eue={kernelName:Md,backendName:"cpu",kernelFunc:_L},CL=Rs(e=>Math.exp(e)),TL=jo($u,CL,"float32"),Aue={kernelName:$u,backendName:"cpu",kernelFunc:TL},EL=Rs(e=>Math.expm1(e)),$ue=jo(Mu,EL),Mue={kernelName:Mu,backendName:"cpu",kernelFunc:$ue},AL=Rs(e=>Math.floor(e)),Fue=jo(Fu,AL),Rue={kernelName:Fu,backendName:"cpu",kernelFunc:Fue},$L=Ht((e,t)=>Math.floor(e/t)),Due=hn(Ru,$L,null,"int32"),Oue={kernelName:Ru,backendName:"cpu",kernelFunc:Due};function ML(e,t,n,r,a,s,i,o,l){let c=Ve([r,s],n);for(let u=0;u<r;u++){let h=[],d=0;for(let p=0;p<a;p++){let f=e[u*a+p];d+=f*i[p],h.push(f)}if(d<0||d>=l/s)throw new Error(`Invalid indices: ${h} does not index into ${o}`);for(let p=0;p<s;p++)c.values[u*s+p]=t.get(...t.indexToLoc(d*s+p))}return c}function FL(e,t,n){let r=Ve(n,e.dtype);for(let a=0;a<r.size;++a){let s=r.indexToLoc(a).slice(),i=s[0],o=s[2],l=t.locToIndex([i,o]);s[2]=t.values[l];let c=e.locToIndex(s);0<=c&&c<e.values.length&&(r.values[a]=e.values[c])}return r}var RL=Ht((e,t)=>e>t?1:0),zue=hn(zd,RL,null,"bool"),Pue={kernelName:zd,backendName:"cpu",kernelFunc:zue},DL=Ht((e,t)=>e>=t?1:0),Lue=hn(Ou,DL,null,"bool"),Bue={kernelName:Ou,backendName:"cpu",kernelFunc:Lue},OL=Ht((e,t)=>e<t?1:0),Wue=hn(Pd,OL,null,"bool"),Uue={kernelName:Pd,backendName:"cpu",kernelFunc:Wue},zL=Ht((e,t)=>e<=t?1:0),Vue=hn(Ld,zL,null,"bool"),jue={kernelName:Ld,backendName:"cpu",kernelFunc:Vue};function PL(e,t,n){let r=(t-e)/(n-1),a=k.makeZerosTypedArray(n,"float32");a[0]=e;for(let s=1;s<a.length;s++)a[s]=a[s-1]+r;return a}var LL=Rs(e=>Math.log(e)),Gue=jo(Uu,LL),Hue={kernelName:Uu,backendName:"cpu",kernelFunc:Gue};function BL(e,t,n,r){let a=k.getTypedArrayFromDType(r,k.sizeFromShape(n));for(let s=0;s<a.length;++s){let i=s*t,o=e[i];for(let l=0;l<t;++l){let c=e[i+l];(Number.isNaN(c)||c>o)&&(o=c)}a[s]=o}return a}var WL=Ht((e,t)=>Math.max(e,t)),que=hn(Hu,WL),Kue={kernelName:Hu,backendName:"cpu",kernelFunc:que},UL=Ht((e,t)=>Math.min(e,t)),Xue=hn(Zu,UL),Zue={kernelName:Zu,backendName:"cpu",kernelFunc:Xue},Y_=Ht((e,t)=>e*t),Yue=K_((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n})),vv=hn(Qu,Y_,Yue),Jue={kernelName:Qu,backendName:"cpu",kernelFunc:vv};function VL(e,t,n){let r=k.createScalarValue(-1,n);return Y_([],t,r,e,n)}function Que(e){let{inputs:t,backend:n}=e,{x:r}=t;Ie(r,"neg");let a=n.data.get(r.dataId).values,[s,i]=VL(a,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,s)}var ece={kernelName:qd,backendName:"cpu",kernelFunc:Que},jL=Ht((e,t)=>e!==t?1:0),tce=hn(Kd,jL,null,"bool"),nce={kernelName:Kd,backendName:"cpu",kernelFunc:tce};function J_(e,t,n,r,a){let s=t.length,i=k.sizeFromShape(t),o=k.computeStrides(t),l=k.computeStrides(a),c=k.getTypedArrayFromDType(n,k.sizeFromShape(a));for(let u=0;u<i;++u){let h=k.indexToLoc(u,s,o),d=new Array(h.length);for(let f=0;f<d.length;f++)d[f]=h[r[f]];let p=k.locToIndex(d,s,l);c[p]=e[u]}return c}function kr(e){let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{perm:s}=n;Ie(a,"transpose");let i=a.shape.length,o=new Array(i);for(let u=0;u<o.length;u++)o[u]=a.shape[s[u]];let l=r.data.get(a.dataId).values,c=J_(l,a.shape,a.dtype,s,o);return{dataId:r.write(c,o,a.dtype),shape:o,dtype:a.dtype}}var rce={kernelName:ni,backendName:"cpu",kernelFunc:kr};function GL(e,t,n,r){let[a,s]=E.computeOutAndReduceShapes(e,r),i=ca(t,"int32"),o=k.makeZerosTypedArray(k.sizeFromShape(a),i),l=k.sizeFromShape(s);for(let c=0;c<o.length;++c){let u=c*l,h=1;for(let d=0;d<l;++d)h*=n[u+d];o[c]=h}return{outVals:o,outShape:a,outDtype:i}}function ace(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;Ie(a,"prod");let o=a.shape.length,l=k.parseAxisParam(s,a.shape),c=E.getAxesPermutation(l,o),u=l,h=a,d=[];c!=null&&(h=kr({inputs:{x:a},backend:n,attrs:{perm:c}}),d.push(h),u=E.getInnerMostAxes(u.length,o));let p=n.data.get(h.dataId).values,{outVals:f,outShape:m,outDtype:y}=GL(h.shape,h.dtype,p,u),g=m;return i&&(g=E.expandShapeToKeepDim(m,l)),d.forEach(x=>n.disposeIntermediateTensorInfo(x)),n.makeTensorInfo(g,y,f)}var sce={kernelName:ac,backendName:"cpu",kernelFunc:ace};function ice(e,t,n){e.forEach((r,a)=>{if(r<0||r>=n){let s=k.indexToLoc(a,t.length,k.computeStrides(t)).join(",");throw new Error(`indices[${s}] = ${r} is not in [0, ${n})`)}})}function oce(e,t){for(let n=0;n<e.length;++n){let r=e[n],a=n===e.length-1?t:e[n+1].length;if(r.length===0)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>a)throw new Error("Ragged splits must not point past values");for(let s=1;s<r.length;++s)if(r[s-1]>r[s])throw new Error("Ragged splits must be sorted in ascending order")}}function lce(e,t,n,r){let a=[],s=0,i=t.length-1+n.length,o=new Array(i).fill(null).map(()=>[0]);oce(n,r);let l=1;for(let c=0;c<t.length-1;++c){l*=t[c];let u=t[c+1];for(let h=1;h<l+1;++h)o[c].push(h*u)}for(let c=0;c<e.length;++c){let u=e[c],h=e[c]+1;for(let d=0;d<n.length;++d){let p=n[d],f=d+t.length-1;if(f>=0){let m=o[f],y=m[m.length-1]-p[u];for(let g=u;g<h;++g)o[f].push(p[g+1]+y)}u=p[u],h=p[h]}h!==u&&(a.push([u,h]),s+=h-u)}return{outSplits:o,valueSlices:a,numValues:s}}function uce(e){let t=[];for(let n=0;n<e.length;++n){let r=e[n].length,a=k.getArrayFromDType("int32",r);t.push(a),e[n].forEach((s,i)=>a[i]=s)}return t}function $$(e,t){let n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function cce(e,t,n,r,a,s){let i=$$(t,2)[1],o=$$(s,2)[1],l=0;for(let c of n)for(let u=c[0];u<c[1];++u){for(let h=0;h<r;++h)a[l*o+h]=e[u*i+h];++l}}function hce(e,t,n,r,a){let s=t.slice();s[0]=a;let i=k.getArrayFromDType(n,k.sizeFromShape(s)),o=e.length,l=o===0?0:o/t[0];return cce(e,t,r,l,i,s),[i,s]}function HL(e,t,n,r,a,s,i,o){if(e.length===0)throw new Error("paramsNestedSplits must be non empty");if(t[0].length===0)throw new Error("Split tensors must not be scalars");let l=t[0][0]-1;if(ice(s,i,l),r.length===0)throw new Error("params.rank must be nonzero");let c=r[0],{outSplits:u,valueSlices:h,numValues:d}=lce(s,i,e,c),p=uce(u),f=hce(n,r,a,h,d);return[p,f[0],f[1]]}var M$=2147483647;function qL(e,t,n,r,a,s,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(a.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");let o=t.length===0,l=a.length===0,c=i.length===0,u=[];o||u.push(t[0]),l||u.push(a[0]),c||u.push(i[0]);for(let y=1;y<u.length;++y)if(u[y]!==u[y-1])throw new Error("starts, limits, and deltas must have the same shape");let h=u.length===0?1:u[0],d=k.getArrayFromDType("int32",h+1);d[0]=0;for(let y=0;y<h;++y){let g=o?e[0]:e[y],x=l?r[0]:r[y],b=c?s[0]:s[y];if(b===0)throw new Error("Requires delta != 0");let v;if(b>0&&x<g||b<0&&x>g)v=0;else if(v=Math.ceil(Math.abs((x-g)/b)),v>M$)throw new Error(`Requires ((limit - start) / delta) <= ${M$}`);d[y+1]=d[y]+v}let p=d[h],f=k.getArrayFromDType(n,p),m=0;for(let y=0;y<h;++y){let g=d[y+1]-d[y],x=o?e[0]:e[y],b=c?s[0]:s[y];for(let v=0;v<g;++v)f[m++]=x,x+=b}return[d,f]}var ba=E.RowPartitionType,dce=class e2{constructor(t,n,r,a,s,i,o,l,c,u){this.shape=t,this.shapeShape=n,this.values=r,this.valuesShape=a,this.valuesDType=s,this.defaultValue=i,this.defaultValueShape=o,this.rowPartitionValues=l,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=E.getRowPartitionTypesHelper(u),this.raggedRank=E.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===ba.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===ba.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){let n=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case ba.VALUE_ROWIDS:return e2.getMaxWidthValueRowID(n);case ba.ROW_SPLITS:return e2.getMaxWidthRowSplit(n);default:throw new Error(`Cannot handle partition type ${ba[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){let n=t.length;if(n===0||n===1)return 0;let r=0;for(let a=0;a<n-1;++a){let s=t[a+1]-t[a];s>r&&(r=s)}return r}static getMaxWidthValueRowID(t){let n=t.length;if(n===0)return 0;let r=0,a=t[0],s=0;for(let i=1;i<n;++i){let o=t[i];o!==a&&(a=o,s=Math.max(i-r,s),r=i)}return Math.max(n-r,s)}tensorShapeFromTensor(t,n,r=!0){if(n.length===0){if(t[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return R$(t,r)}calculateOutputSize(t){let n=this.valuesShape,r=this.defaultValueShape;E.validateDefaultValueShape(r,n);let a=this.tensorShapeFromTensor(this.shape,this.shapeShape),s=E.combineRaggedTensorToTensorShapes(this.raggedRank,a,n);s[0]<0&&(s[0]=t);for(let i=1;i<=this.raggedRank;++i)s[i]<0&&(s[i]=this.getMaxWidth(i));return s}calculateFirstParentOutputIndex(t,n,r){let a=Math.min(t,r),s=[],i=0;for(let o=0;o<a;++o,i+=n)s.push(i);for(let o=a;o<t;++o)s.push(-1);return k.assert(s.length===t,()=>"Final length of result must be equal to firstDimension."),s}calculateOutputIndexRowSplit(t,n,r,a){let s=t.length,i=[];for(let o=0;o<s-1;++o){let l=t[o+1]-t[o],c=Math.min(a,l),u=n[o];u===-1&&(c=0);for(let h=0;h<c;++h)i.push(u),u+=r;for(let h=0;h<l-c;++h)i.push(-1)}if(s>0&&i.length!==t[s-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(t,n,r,a){let s=t.length,i=[];if(s===0)return[];let o=0,l=t[0];if(l>=n.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${n.length}`);let c=n[l];i.push(c);for(let u=1;u<s;++u){let h=t[u];if(h===l)c>=0&&(++o,o<a?c+=r:c=-1);else{if(o=0,l=h,h>=n.length)throw new Error(`Got nextValueRowId=${h} which is not less than ${n.length}`);c=n[h]}i.push(c)}if(i.length!==t.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(t,n,r,a){let s=this.getRowPartitionTensor(t),i=this.getRowPartitionTypeByDimension(t);switch(i){case ba.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,n,r,a);case ba.ROW_SPLITS:if(s.length-1>n.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${n.length}`);return this.calculateOutputIndexRowSplit(s,n,r,a);default:throw new Error(`Unsupported partition type: ${ba[i]}`)}}getFirstDimensionSize(){let t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");let n=this.rowPartitionTypes[0];switch(n){case ba.FIRST_DIM_SIZE:return t[0];case ba.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case ba.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${ba[n]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");let t=this.getFirstDimensionSize(),n=this.calculateOutputSize(t),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let i=r.length-2;i>=0;--i)r[i]=r[i+1]*n[i+1];let a=R$(n,!1),s=k.getArrayFromDType(this.valuesDType,k.sizeFromShape(a));if(r[0]*n[0]>0){let i=this.calculateFirstParentOutputIndex(t,r[0],n[0]);for(let o=1;o<=this.raggedRank;++o)i=this.calculateOutputIndex(o-1,i,r[o],n[o]);this.setOutput(this.raggedRank,i,s,a)}return[a,s]}setOutput(t,n,r,a){if(r.length===0)return;let s=this.values,i=r,o=a.slice();o=o.slice(t+1);let l=k.sizeFromShape(o),c=n.length,u=this.defaultValue;if(u.length!==l&&u.length!==1){let f=this.defaultValueShape;j(()=>{let m=V(u,f);u=Tl(m,o).dataSync()})}let h=0,d=0,p=0;for(let f=0;f<=c;++f){let m=f<c?n[f]:-1;if(m===p){++p;continue}if(d<p){let y=s.subarray(h*l),g=i.subarray(d*l),x=(p-d)*l;F$(g,y,x)}if(f>=c){let y=r.length;m=Math.floor(y/l)}if(m>p)if(this.defaultValue.length===1)i.subarray(p*l,m*l).fill(this.defaultValue[0]),p=m;else for(;m>p;){let y=i.slice(p*l);F$(y,u,l),++p}m<0?(h=f+1,d=p):(h=f,d=p,p=d+1)}}};function F$(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function R$(e,t){let n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function KL(e,t,n,r,a,s,i,o,l,c){return new dce(e,t,n,r,a,s,i,o,l,c).compute()}function Q_(e,t,n,r){let a=e===t,s=e<t&&n<0,i=t<e&&n>1;if(a||s||i)return k.makeZerosTypedArray(0,r);let o=Math.abs(Math.ceil((t-e)/n)),l=k.makeZerosTypedArray(o,r);t<e&&n===1&&(n=-1),l[0]=e;for(let c=1;c<l.length;c++)l[c]=l[c-1]+n;return l}var XL=Rs(e=>1/Math.sqrt(e)),pce=jo(dc,XL),fce={kernelName:dc,backendName:"cpu",kernelFunc:pce};function Nl(e,t,n,r,a,s,i,o,l,c){let u=[r/a,a],h=e.values,d=t.values;if(r===0)return Ve(n,t.dtype);let p=l instanceof Yt?l:Ve(u,t.dtype);typeof l=="string"||typeof l=="number"?p.values.fill(l):typeof l=="boolean"&&p.values.fill(+l);for(let f=0;f<s;f++){let m=[],y=0;for(let g=0;g<i;g++){let x=h[f*i+g];m.push(x),y+=x*o[g]}if(y<0||y>=r/a)throw new Error(`Invalid indices: ${m} does not index into ${n}`);for(let g=0;g<a;g++)c?p.values[y*a+g]+=d[f*a+g]:p.values[y*a+g]=t.rank===0?d[0]:d[f*a+g]}return p}var mce=Rs(e=>1/(1+Math.exp(-e))),ZL=pt(yc,e=>1/(1+Math.exp(-e))),gce={kernelName:yc,backendName:"cpu",kernelFunc:ZL};function bx(e,t,n,r,a){let s=ln.isSliceContinous(r,t,n),i=k.sizeFromShape(n),o=k.computeStrides(r);if(s){let h=ln.computeFlatOffset(t,o);return a==="string"?e.slice(h,h+i):e.subarray(h,h+i)}let l=a==="string"?E.fromUint8ToStringArray(e):e,c=Ve(r,a,l),u=Ve(n,a);for(let h=0;h<u.size;++h){let d=u.indexToLoc(h),p=d.map((f,m)=>f+t[m]);u.set(c.get(...p),...d)}return a==="string"?E.fromStringArrayToUint8(u.values):u.values}function Yl(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,size:i}=r;Ie(a,"slice");let[o,l]=ln.parseSliceParams(a,s,i);ln.assertParamsValid(a,o,l);let c=n.data.get(a.dataId).values,u=bx(c,o,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,u)}var yce={kernelName:op,backendName:"cpu",kernelFunc:Yl};function YL(e,t,n,r,a,s,i){let o=t[0],l=s[0],c=new Array(l),u=new Array(o),h=t[1];if(l===0){if(o!==0)throw new Error(E.getSparseFillEmptyRowsIndicesDenseShapeMismatch(o));let y=k.getArrayFromDType(n,0),g=k.getArrayFromDType(a,0);return[y,[0,h],g,c,u]}let d=!0,p=0,f=new Array(l).fill(0);for(let y=0;y<o;++y){let g=e[y*h];if(g<0)throw new Error(E.getSparseFillEmptyRowsNegativeIndexErrorMessage(y,g));if(g>=l)throw new Error(E.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(y,g,l));++f[g],d=d&&g>=p,p=g}let m=!0;for(let y=0;y<l;++y){let g=f[y]===0;c[y]=g,m=m&&!g,f[y]=Math.max(f[y],1),y>0&&(f[y]+=f[y-1])}if(m&&d){let y=e,g=r;for(let x=0;x<o;++x)u[x]=x;return[y,[o,h],g,c,u]}else{let y=f[l-1],g=k.getArrayFromDType(n,y*h),x=k.getArrayFromDType(a,y),b=new Array(l).fill(0);for(let v=0;v<o;++v){let w=e[v*h],I=b[w],_=(w===0?0:f[w-1])+I;b[w]++;for(let T=0;T<h;++T)g[_*h+T]=e[v*h+T];x[_]=r[v],u[v]=_}for(let v=0;v<l;++v)if(b[v]===0){let w=v===0?0:f[v-1];g[w*h+0]=v;for(let I=1;I<h;++I)g[w*h+I]=0;x[w]=i}return[g,[y,h],x,c,u]}}function JL(e,t,n,r,a){let s=k.sizeFromShape(r),i=t[0],o=a.length,l=[],c=1,u=-1;for(let m=0;m<o;++m){let y=a[m];if(y===-1){if(u!==-1)throw new Error(E.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(u,m));u=m,l.push(1)}else{if(y<0)throw new Error(E.getSparseReshapeNegativeOutputDimErrorMessage(m,y));c*=y,l.push(y)}}if(u!==-1){if(c<=0)throw new Error(E.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let m=Math.trunc(s/c);if(c*m!==s)throw new Error(E.getSparseReshapeInputOutputMultipleErrorMessage(r,l));l[u]=m}if(k.sizeFromShape(l)!==s)throw new Error(E.getSparseReshapeInputOutputMismatchErrorMessage(r,l));let h=r.length,d=[];if(h>0){d[h-1]=1;for(let m=h-2;m>=0;--m)d[m]=d[m+1]*r[m+1]}let p=[];if(o>0){p[o-1]=1;for(let m=o-2;m>=0;--m)p[m]=p[m+1]*l[m+1]}let f=k.getArrayFromDType(n,i*o);for(let m=0;m<i;++m){let y=0;for(let g=0;g<h;++g)y+=e[m*h+g]*d[g];for(let g=0;g<o;++g)f[m*o+g]=Math.trunc(y/p[g]),y%=p[g]}return[f,[i,o],l]}function eC(e,t,n,r,a,s=!1,i=0){let o=r.length,l=[t[0],e.length/t[0]],c=l[1],u=o>0?a[o-1]+1:0;if(u<0)throw new Error(E.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let h=t.slice();h[0]=u;let d=h.reduce((x,b)=>x*b,1),p=k.getArrayFromDType(n,d);if(o===0)return u>0&&p.fill(i),[p,h];if(u<=0)throw new Error(E.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let f=0,m=1,y=0,g=a[f];for(;;){let x=0;if(m<o){if(x=a[m],g===x){++m;continue}if(g>=x)throw new Error(E.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(g<0||g>=u)throw new Error(E.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(g,u));g>y&&p.fill(i,y*c,g*c);for(let b=f;b<m;++b){let v=r[b];if(v<0||v>=l[0])throw new Error(E.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(b,r[b],l[0]));for(let w=0;w<c;w++)p[g*c+w]+=e[v*c+w]}if(s)for(let b=0;b<c;b++)p[g*c+b]/=m-f;if(f=m,++m,y=g+1,g=x,m>o)break}return y<u&&p.fill(i,y*c,u*c),[p,h]}var xce=Rs(e=>Math.sqrt(e)),bce=pt(bc,e=>Math.sqrt(e)),vce={kernelName:bc,backendName:"cpu",kernelFunc:bce},QL=Ht((e,t)=>{let n=e-t;return n*n}),wce=hn(kc,QL),kce={kernelName:kc,backendName:"cpu",kernelFunc:wce},e4=Rs((e,t)=>{let{pattern:n,replaceGlobal:r,rewrite:a}=t;return e.replace(new RegExp(n,r?"g":""),a)}),Sce=jo(Jm,e4),Ice={kernelName:Jm,backendName:"cpu",kernelFunc:Sce};function t4(e,t,n,r){let a=Ve(e,t.dtype);for(let s=0;s<a.size;s++){let i=a.indexToLoc(s),o=new Array(i.length);for(let l=0;l<o.length;l++)o[l]=i[l]*n[l]+r[l];a.set(t.get(...o),...i)}return a}var Nce=class{constructor(e,t,n,r,a,s){this.separator=k.encodeString(e),this.nGramWidths=t,this.leftPad=k.encodeString(n),this.rightPad=k.encodeString(r),this.padWidth=a,this.preserveShort=s}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){let n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,a,s){for(let i=0;i<a;++i){let o=this.getPadWidth(s),l=Math.max(0,o-i),c=Math.max(0,o-(a-(i+1))),u=s-(l+c),h=t+(l>0?0:i-o),d=0;d+=l*this.leftPad.length;for(let g=0;g<u;++g)d+=e[h+g].length;d+=c*this.rightPad.length;let p=l+c+u-1;d+=p*this.separator.length,n[r+i]=new Uint8Array(d);let f=n[r+i],m=0,y=g=>g.forEach(x=>f[m++]=x);for(let g=0;g<l;++g)y(this.leftPad),y(this.separator);for(let g=0;g<u-1;++g)y(e[h+g]),y(this.separator);if(u>0){y(e[h+u-1]);for(let g=0;g<c;++g)y(this.separator),y(this.rightPad)}else{for(let g=0;g<c-1;++g)y(this.rightPad),y(this.separator);y(this.rightPad)}}}compute(e,t){let n=e.length,r=t.length;if(r>0){let o=t[0];if(o!==0)throw new Error(`First split value must be 0, got ${o}`);for(let l=1;l<r;++l){let c=t[l]>=o;if(c=c&&t[l]<=n,!c)throw new Error(`Invalid split value ${t[l]}, must be in [${o}, ${n}]`);o=t[l]}if(o!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${o}`)}let a=r-1,s=k.getArrayFromDType("int32",r);if(n===0||r===0){let o=new Array(n);for(let l=0;l<=a;++l)s[l]=0;return[o,s]}s[0]=0;for(let o=1;o<=a;++o){let l=t[o]-t[o-1],c=0;this.nGramWidths.forEach(u=>{c+=this.getNumNGrams(l,u)}),this.preserveShort&&l>0&&c===0&&(c=1),s[o]=s[o-1]+c}let i=new Array(s[a]);for(let o=0;o<a;++o){let l=t[o],c=s[o];if(this.nGramWidths.forEach(u=>{let h=t[o+1]-t[o],d=this.getNumNGrams(h,u);this.createNGrams(e,l,i,c,d,u),c+=d}),this.preserveShort&&c===s[o]){let u=t[o+1]-t[o];if(u===0)continue;let h=u+2*this.padWidth;this.createNGrams(e,l,i,c,1,h)}}return[i,s]}};function tC(e,t,n,r,a,s,i,o){return new Nce(n,r,a,s,i,o).compute(e,t)}function _ce(e,t,n,r){if(!e.length)return;if(t.length===0){for(let s=0;s<e.length;++s)r.push(e.subarray(s,s+1));return}if(t.length===1){let s=t[0],i=e.indexOf(s);for(;i!==-1;){let o=e.subarray(0,i);(!n||o.length!==0)&&r.push(o),e=e.subarray(i+1),i=e.indexOf(s)}(!n||e.length!==0)&&r.push(e);return}let a=0;for(let s=0;s<e.length+1;s++)if(s===e.length||t.indexOf(e[s])!==-1){let i=e.subarray(a,s);(!n||i.length!==0)&&r.push(i),a=s+1}}function nC(e,t,n){let r=e.length,a=[],s=0,i=0,o=new Array(r);for(let d=0;d<r;++d){let p=a.length;_ce(e[d],t,n,a);let f=a.length-p;o[d]=f,s+=f,i=Math.max(i,f)}let l=k.getArrayFromDType("int32",s*2),c=new Array(s),u=[r,i],h=0;for(let d=0;d<r;++d)for(let p=0;p<o[d];++p)l[h*2]=d,l[h*2+1]=p,c[h]=a[h],++h;return[l,c,u]}function rC(e,t){let n=k.getArrayFromDType("int32",e.length);for(let r=0;r<e.length;++r)n[r]=k.fingerPrint64(e[r]).modulo(t).getLowBitsUnsigned();return n}var n4=Ht((e,t)=>e-t),Cce=K_((e,t,n,r)=>({real:e-n,imag:t-r})),aC=hn(Sc,n4,Cce),Tce={kernelName:Sc,backendName:"cpu",kernelFunc:aC};function r4(e,t){let n=new Array(e.rank);for(let a=0;a<n.length;a++)n[a]=e.shape[a]*t[a];let r=Ve(n,e.dtype);for(let a=0;a<r.values.length;++a){let s=r.indexToLoc(a),i=new Array(e.rank);for(let l=0;l<i.length;l++)i[l]=s[l]%e.shape[l];let o=e.locToIndex(i);r.values[a]=e.values[o]}return r}var yf=(e,t)=>{let n=t.value-e.value;return n===0?e.index-t.index:n};function a4(e,t,n=0,r=e.length-1){for(;r>n;){if(r-n>600){let o=r-n+1,l=t-n+1,c=Math.log(o),u=.5*Math.exp(2*c/3),h=.5*Math.sqrt(c*u*(o-u)/o)*Math.sign(l-o/2),d=Math.max(n,Math.floor(t-l*u/o+h)),p=Math.min(r,Math.floor(t+(o-l)*u/o+h));a4(e,t,d,p)}let a=e[t],s=n,i=r;for(k.swap(e,n,t),yf(e[r],a)>0&&k.swap(e,n,r);s<i;){for(k.swap(e,s,i),s++,i--;yf(e[s],a)<0;)s=s+1;for(;yf(e[i],a)>0;)i=i-1}yf(e[n],a)===0?k.swap(e,n,i):(i=i+1,k.swap(e,i,r)),i<=t&&(n=i+1),t<=i&&(r=i-1)}}function s4(e,t,n,r,a){let s=t[t.length-1],[i,o]=[e.length/s,s],l=k.getTypedArrayFromDType(n,i*r),c=k.getTypedArrayFromDType("int32",i*r);for(let h=0;h<i;h++){let d=h*o,p=e.subarray(d,d+o),f=new Array(p.length);p.forEach((x,b)=>f[b]={value:x,index:b}),r<f.length&&(a4(f,r),f=f.slice(0,r)),a&&f.sort(yf);let m=h*r,y=l.subarray(m,m+r),g=c.subarray(m,m+r);for(let x=0;x<r;x++)y[x]=f[x].value,g[x]=f[x].index}let u=t.slice();return u[u.length-1]=r,[Ve(u,n,l),Ve(u,"int32",c)]}function sC(e,t,n,r){let a=k.parseAxisParam(t,n)[0],s=[1,n[0],1];for(let f=0;f<a;f++)s[0]*=n[f];s[1]=n[a];for(let f=a+1;f<n.length;f++)s[2]*=n[f];let i=new Map,o=new Int32Array(n[a]),l=new Yt(s,r,e),c=[],u=s[0]===1&&s[2]===1;for(let f=0;f<n[a];f++){let m;if(u)m=e[f].toString();else{let g=[];for(let x=0;x<s[0];x++)for(let b=0;b<s[2];b++)g.push(l.get(x,f,b));m=g.join(",")}let y=i.get(m);if(y!=null)o[f]=y;else{let g=i.size;i.set(m,g),o[f]=g,c.push(f)}}let h=s.slice();h[1]=i.size;let d=new Yt(h,r);c.forEach((f,m)=>{for(let y=0;y<s[0];y++)for(let g=0;g<s[2];g++)d.set(l.get(y,f,g),y,m,g)});let p=n.slice();return p[a]=h[1],{outputValues:d.values,outputShape:p,indices:o}}var Ece="4.22.0";yb("cpu",()=>new H_,1);var i4=pt(Eu,e=>e>=0?e:Math.exp(e)-1),Ace={kernelName:Eu,backendName:"cpu",kernelFunc:i4};function o4(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:s}=r;Ie([a],"leakyRelu");let i=k.sizeFromShape(a.shape),o=n.data.get(a.dataId).values,l=k.getTypedArrayFromDType("float32",i);for(let c=0;c<o.length;c++)l[c]=o[c]<0?s*o[c]:o[c];return n.makeTensorInfo(a.shape,"float32",l)}var $ce={kernelName:Wu,backendName:"cpu",kernelFunc:o4},Mce=Ht((e,t)=>e<0?t*e:e);function l4(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t;Ie([r,a],"prelu");let s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,[o,l]=Mce(r.shape,a.shape,s,i,"float32");return n.makeTensorInfo(l,"float32",o)}var Fce={kernelName:rc,backendName:"cpu",kernelFunc:l4},u4=pt(ic,e=>Math.max(0,e)),Rce={kernelName:ic,backendName:"cpu",kernelFunc:u4},c4=pt(uc,e=>Math.min(Math.max(0,e),6)),Dce={kernelName:uc,backendName:"cpu",kernelFunc:c4};function vx(e,t,n,r,a){if(n==="linear")return As({inputs:{x:t},backend:e});if(n==="relu")return u4({inputs:{x:t},backend:e});if(n==="elu")return i4({inputs:{x:t},backend:e});if(n==="relu6")return c4({inputs:{x:t},backend:e});if(n==="prelu")return l4({inputs:{x:t,alpha:r},backend:e});if(n==="leakyrelu")return o4({inputs:{x:t},backend:e,attrs:{alpha:a}});if(n==="sigmoid")return ZL({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function _t(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:s}=r,i=k.sizeFromShape(a.shape),o=k.inferFromImplicitShape(s,i),l=k.sizeFromShape(o);k.assert(i===l,()=>`The new shape (${o}) has ${l} elements and the old shape (${a.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),n.incRef(a.dataId);let c=n.data.get(a.dataId);if(c.complexTensorInfos!=null){let u=c.complexTensorInfos.real,h=c.complexTensorInfos.imag;u.shape=o,h.shape=o}return{dataId:a.dataId,shape:o,dtype:a.dtype}}var Oce={kernelName:ep,backendName:"cpu",kernelFunc:_t};function h4(e){let{inputs:t,backend:n,attrs:r}=e,{a,b:s}=t,{transposeA:i,transposeB:o}=r;Ie([a,s],"matMul");let l=a.shape.length,c=s.shape.length,u=i?a.shape[l-2]:a.shape[l-1],h=o?s.shape[c-1]:s.shape[c-2],d=i?a.shape[l-1]:a.shape[l-2],p=o?s.shape[c-2]:s.shape[c-1],f=a.shape.slice(0,-2),m=s.shape.slice(0,-2),y=k.sizeFromShape(f),g=k.sizeFromShape(m),x=xp.assertAndGetBroadcastShape(a.shape.slice(0,-2),s.shape.slice(0,-2)).concat([d,p]);k.assert(u===h,()=>`Error in matMul: inner shapes (${u}) and (${h}) of Tensors with shapes ${a.shape} and ${s.shape} and transposeA=${i} and transposeB=${o} must match.`);let b=i?[y,u,d]:[y,d,u],v=o?[g,p,h]:[g,h,p],w=_t({inputs:{x:a},backend:n,attrs:{shape:b}}),I=_t({inputs:{x:s},backend:n,attrs:{shape:v}}),_=i?w.shape[1]:w.shape[2],T=i?w.shape[2]:w.shape[1],A=o?I.shape[1]:I.shape[2],M=Math.max(y,g),F=n.data.get(w.dataId).values,C=n.data.get(I.dataId).values,D=k.computeStrides(w.shape),L=k.computeStrides(I.shape),[O,q,H]=i?[D[0],1,D[1]]:[D[0],D[1],1],[z,K,Z]=o?[1,L[1],L[0]]:[L[1],1,L[0]],J=T*A,Q=Ve([M,T,A],w.dtype),ne=Q.values,oe=n.blockSize;for(let ue=0;ue<M;ue++){let ve=ue%y,we=ue%g;for(let ge=0;ge<T;ge+=oe){let Te=Math.min(ge+oe,T);for(let $e=0;$e<A;$e+=oe){let Pe=Math.min($e+oe,A);for(let je=0;je<_;je+=oe){let ft=Math.min(je+oe,_);for(let Xe=ge;Xe<Te;Xe++)for(let tt=$e;tt<Pe;tt++){let De=0;for(let ot=je;ot<ft;ot++){let kt=F[ve*O+Xe*q+ot*H],_r=C[ot*z+tt*K+we*Z];De+=kt*_r}ne[ue*J+(Xe*A+tt)]+=De}}}}}return n.disposeIntermediateTensorInfo(w),n.disposeIntermediateTensorInfo(I),n.makeTensorInfo(x,Q.dtype,Q.values)}var zce={kernelName:yu,backendName:"cpu",kernelFunc:h4};function Pce(e){let{inputs:t,backend:n,attrs:r}=e,{a,b:s,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=r,d,p,f,m=[];d=h4({inputs:{a,b:s},attrs:{transposeA:l,transposeB:c},backend:n}),i&&(p=ad({inputs:{a:d,b:i},backend:n}),m.push(d),d=p),u&&(f=vx(n,d,u,o,h),m.push(d),d=f);for(let y of m)n.disposeIntermediateTensorInfo(y);return d}var Lce={kernelName:zl,backendName:"cpu",kernelFunc:Pce},Bce=pt(lu,e=>Math.acos(e)),Wce={kernelName:lu,backendName:"cpu",kernelFunc:Bce},Uce=pt(uu,e=>Math.acosh(e)),Vce={kernelName:uu,backendName:"cpu",kernelFunc:Uce};function jce(e){let{inputs:t,backend:n}=e,r=t;Ie(t,"addN");let a=r.map(o=>n.data.get(o.dataId).values),s=Ve(r[0].shape,r[0].dtype),i=s.values;for(let o=0;o<r.length;o++){let l=a[o];for(let c=0;c<i.length;c++)i[c]+=l[c]}return n.makeTensorInfo(s.shape,s.dtype,s.values)}var Gce={kernelName:cu,backendName:"cpu",kernelFunc:jce};function Hce(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;Ie(a,"all");let o=k.parseAxisParam(s,a.shape),l=o,c=E.getAxesPermutation(l,a.shape.length),u=a;c!=null&&(u=kr({inputs:{x:a},backend:n,attrs:{perm:c}}),l=E.getInnerMostAxes(l.length,a.shape.length)),E.assertAxesAreInnerMostDims("all",l,u.shape.length);let[h,d]=E.computeOutAndReduceShapes(u.shape,l),p=k.sizeFromShape(d),f=k.makeZerosTypedArray(k.sizeFromShape(h),u.dtype),m=n.data.get(u.dataId).values;for(let g=0;g<f.length;++g){let x=g*p,b=m[x];for(let v=0;v<p;++v){let w=m[x+v];b=b&&w}f[g]=b}c!=null&&n.disposeIntermediateTensorInfo(u);let y=n.makeTensorInfo(h,u.dtype,f);if(i){let g=E.expandShapeToKeepDim(h,o),x=_t({inputs:{x:y},backend:n,attrs:{shape:g}});return n.disposeIntermediateTensorInfo(y),x}return y}var qce={kernelName:yd,backendName:"cpu",kernelFunc:Hce};function Kce(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;Ie(a,"any");let o=k.parseAxisParam(s,a.shape),l=o,c=E.getAxesPermutation(l,a.shape.length),u=a;c!=null&&(u=kr({inputs:{x:a},backend:n,attrs:{perm:c}}),l=E.getInnerMostAxes(l.length,a.shape.length)),E.assertAxesAreInnerMostDims("any",l,u.shape.length);let[h,d]=E.computeOutAndReduceShapes(u.shape,l),p=k.sizeFromShape(d),f=k.makeZerosTypedArray(k.sizeFromShape(h),u.dtype),m=n.data.get(u.dataId).values;for(let g=0;g<f.length;++g){let x=g*p,b=m[x];for(let v=0;v<p;++v){let w=m[x+v];b=b||w}f[g]=b}c!=null&&n.disposeIntermediateTensorInfo(u);let y=n.makeTensorInfo(h,u.dtype,f);if(i){let g=E.expandShapeToKeepDim(h,o),x=_t({inputs:{x:y},backend:n,attrs:{shape:g}});return n.disposeIntermediateTensorInfo(y),x}return y}var Xce={kernelName:xd,backendName:"cpu",kernelFunc:Kce};function Zce(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;Ie(a,"argMax");let i=k.parseAxisParam(s,a.shape),o=E.getAxesPermutation(i,a.shape.length),l=a,c=[];o!=null&&(l=kr({inputs:{x:a},backend:n,attrs:{perm:o}}),c.push(l),i=E.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],E.assertAxesAreInnerMostDims("argMax",i,l.shape.length);let[u,h]=E.computeOutAndReduceShapes(l.shape,i),d=k.sizeFromShape(u),p=k.makeZerosTypedArray(d,"int32"),f=k.sizeFromShape(h),m=n.data.get(l.dataId).values;for(let y=0;y<p.length;++y){let g=y*f,x=m[g],b=0;for(let v=0;v<f;++v){let w=m[g+v];w>x&&(x=w,b=v)}p[y]=b}return c.forEach(y=>n.disposeIntermediateTensorInfo(y)),n.makeTensorInfo(u,"int32",p)}var Yce={kernelName:bd,backendName:"cpu",kernelFunc:Zce};function Jce(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;Ie(a,"argMin");let i=k.parseAxisParam(s,a.shape),o=E.getAxesPermutation(i,a.shape.length),l=a,c=[];o!=null&&(l=kr({inputs:{x:a},backend:n,attrs:{perm:o}}),c.push(l),i=E.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],E.assertAxesAreInnerMostDims("argMin",i,l.shape.length);let[u,h]=E.computeOutAndReduceShapes(l.shape,i),d=k.sizeFromShape(u),p=k.makeZerosTypedArray(d,"int32"),f=k.sizeFromShape(h),m=n.data.get(l.dataId).values;for(let y=0;y<p.length;++y){let g=y*f,x=m[g],b=0;for(let v=0;v<f;++v){let w=m[g+v];w<x&&(x=w,b=v)}p[y]=b}return c.forEach(y=>n.disposeIntermediateTensorInfo(y)),n.makeTensorInfo(u,"int32",p)}var Qce={kernelName:vd,backendName:"cpu",kernelFunc:Jce},ehe=pt(hu,e=>Math.asin(e)),the={kernelName:hu,backendName:"cpu",kernelFunc:ehe},nhe=pt(du,e=>Math.asinh(e)),rhe={kernelName:du,backendName:"cpu",kernelFunc:nhe},ahe=pt(pu,e=>Math.atan(e)),she={kernelName:pu,backendName:"cpu",kernelFunc:ahe},ihe=Ht((e,t)=>Math.atan2(e,t)),ohe=hn(mu,ihe),lhe={kernelName:mu,backendName:"cpu",kernelFunc:ohe},uhe=pt(fu,e=>Math.atanh(e)),che={kernelName:fu,backendName:"cpu",kernelFunc:uhe};function iC(e,t,n,r,a,s){let i=a.strideHeight,o=a.strideWidth,l=a.dilationHeight,c=a.dilationWidth,u=a.effectiveFilterHeight,h=a.effectiveFilterWidth,d=a.padInfo.top,p=a.padInfo.left,f=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=Ve(a.outShape,n),y=m.values,g=a.outShape[1]*a.outShape[2]*a.outShape[3],x=a.outShape[2]*a.outShape[3],b=a.outShape[3];for(let v=0;v<a.batchSize;++v){let w=v*g,I=v*r[0];for(let _=0;_<a.inChannels;++_)for(let T=0;T<a.outHeight;++T){let A=T*i-d,M=Math.max(0,A),F=Math.min(a.inHeight,u+A),C=w+T*x;for(let D=0;D<a.outWidth;++D){let L=D*o-p,O=Math.max(0,L),q=Math.min(a.inWidth,h+L),H=f,z=0,K=0;for(let J=M;J<F;J+=l){let Q=I+J*r[1];for(let ne=O;ne<q;ne+=c){let oe=Q+ne*r[2],ue=e[oe+_];s==="max"&&ue>H?H=ue:s==="avg"&&(z+=ue,K++)}if(isNaN(H))break}let Z=C+D*b+_;y[Z]=s==="avg"?z/K:H}}}return m}function d4(e,t,n,r,a=!1,s=!1){let i=Ve(r.outShape,"int32"),o=r.strideHeight,l=r.strideWidth,c=r.dilationHeight,u=r.dilationWidth,h=r.effectiveFilterHeight,d=r.effectiveFilterWidth,p=r.padInfo.top,f=r.padInfo.left,m=Ve(t,n,e);for(let y=0;y<r.batchSize;++y)for(let g=0;g<r.inChannels;++g)for(let x=0;x<r.outHeight;++x){let b=x*o-p,v=b;for(;v<0;)v+=c;let w=Math.min(r.inHeight,h+b);for(let I=0;I<r.outWidth;++I){let _=I*l-f,T=_;for(;T<0;)T+=u;let A=Math.min(r.inWidth,d+_),M=Number.NEGATIVE_INFINITY,F=-1;for(let C=v;C<w;C+=c){let D=C-b;for(let L=T;L<A;L+=u){let O=L-_,q=m.get(y,C,L,g);q>M&&(M=q,a?F=s?((y*r.inHeight+C)*r.inWidth+L)*r.inChannels+g:(C*r.inWidth+L)*r.inChannels+g:F=D*d+O)}}i.set(F,y,x,I,g)}}return i}function p4(e,t,n,r,a,s){let i=a.strideDepth,o=a.strideHeight,l=a.strideWidth,c=a.dilationDepth,u=a.dilationHeight,h=a.dilationWidth,d=a.effectiveFilterDepth,p=a.effectiveFilterHeight,f=a.effectiveFilterWidth,m=a.padInfo.front,y=a.padInfo.top,g=a.padInfo.left,x=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,b=Ve(a.outShape,n),v=b.values,w=a.outShape[1]*a.outShape[2]*a.outShape[3]*a.outShape[4],I=a.outShape[2]*a.outShape[3]*a.outShape[4],_=a.outShape[3]*a.outShape[4],T=a.outShape[4];for(let A=0;A<a.batchSize;++A){let M=A*w,F=A*r[0];for(let C=0;C<a.inChannels;++C)for(let D=0;D<a.outDepth;++D){let L=D*i-m,O=L;for(;O<0;)O+=c;let q=Math.min(a.inDepth,d+L),H=M+D*I;for(let z=0;z<a.outHeight;++z){let K=z*o-y,Z=K;for(;Z<0;)Z+=u;let J=Math.min(a.inHeight,p+K),Q=H+z*_;for(let ne=0;ne<a.outWidth;++ne){let oe=ne*l-g,ue=oe;for(;ue<0;)ue+=h;let ve=Math.min(a.inWidth,f+oe),we=Q+ne*T,ge=x,Te=0,$e=0;for(let je=O;je<q;je+=c){let ft=F+je*r[1];for(let Xe=Z;Xe<J;Xe+=u){let tt=ft+Xe*r[2];for(let De=ue;De<ve;De+=h){let ot=tt+De*r[3],kt=e[ot+C];if(s==="max"&&kt>ge?ge=kt:s==="avg"&&(Te+=kt,$e++),isNaN(ge))break}if(isNaN(ge))break}if(isNaN(ge))break}let Pe=we+C;v[Pe]=s==="avg"?Te/Math.max($e,1):ge}}}}return b}function hhe(e,t){let n=Ve(t.outShape,"int32"),r=t.strideDepth,a=t.strideHeight,s=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,l=t.dilationWidth,c=t.effectiveFilterDepth,u=t.effectiveFilterHeight,h=t.effectiveFilterWidth,d=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let y=0;y<t.inChannels;++y)for(let g=0;g<t.outDepth;++g){let x=g*r-d,b=x;for(;b<0;)b+=i;let v=Math.min(t.inDepth,c+x);for(let w=0;w<t.outHeight;++w){let I=w*a-p,_=I;for(;_<0;)_+=o;let T=Math.min(t.inHeight,u+I);for(let A=0;A<t.outWidth;++A){let M=A*s-f,F=M;for(;F<0;)F+=l;let C=Math.min(t.inWidth,h+M),D=Number.NEGATIVE_INFINITY,L=-1;for(let O=b;O<v;O+=i){let q=O-x;for(let H=_;H<T;H+=o){let z=H-I;for(let K=F;K<C;K+=l){let Z=K-M,J=e.get(m,O,H,K,y);J>=D&&(D=J,L=q*u*h+z*u+Z)}}}n.set(L,m,g,w,A,y)}}}return n}function dhe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;Ie(a,"avgPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r,c=1;k.assert(E.eitherStridesOrDilationsAreOne(i,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);let u=E.computePool2DInfo(a.shape,s,i,c,o,l),h;if(u.filterWidth===1&&u.filterHeight===1&&k.arraysEqual(u.inShape,u.outShape))h=As({inputs:{x:a},backend:n});else{let d=n.data.get(a.dataId).values,p=k.computeStrides(a.shape),f=iC(d,a.shape,a.dtype,p,u,"avg");h=n.makeTensorInfo(u.outShape,a.dtype,f.values)}return h}var phe={kernelName:gu,backendName:"cpu",kernelFunc:dhe};function fhe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:c}=r;Ie(a,"avgPool3d");let u=E.computePool3DInfo(a.shape,s,i,1,o,l,c),h=n.data.get(a.dataId).values,d=p4(h,a.shape,a.dtype,k.computeStrides(a.shape),u,"avg");return n.makeTensorInfo(d.shape,"float32",d.values)}var mhe={kernelName:wd,backendName:"cpu",kernelFunc:fhe};function ghe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:c}=r;Ie([a,s],"avgPool3DGrad");let u=E.computePool3DInfo(s.shape,i,o,1,l,c),h=u.strideDepth,d=u.strideHeight,p=u.strideWidth,f=u.filterDepth,m=u.filterHeight,y=u.filterWidth,g=u.dilationDepth,x=u.dilationHeight,b=u.dilationWidth,v=u.effectiveFilterDepth,w=u.effectiveFilterHeight,I=u.effectiveFilterWidth,_=v-1-u.padInfo.front,T=I-1-u.padInfo.left,A=w-1-u.padInfo.top,M=Ve(s.shape,"float32"),F=1/(f*m*y),C=n.bufferSync(a);for(let D=0;D<u.batchSize;++D)for(let L=0;L<u.inChannels;++L)for(let O=0;O<u.inDepth;++O)for(let q=0;q<u.inHeight;++q)for(let H=0;H<u.inWidth;++H){let z=O-_,K=q-A,Z=H-T,J=0;for(let Q=0;Q<v;Q+=g){let ne=(z+Q)/h;if(!(ne<0||ne>=u.outDepth||Math.floor(ne)!==ne))for(let oe=0;oe<w;oe+=x){let ue=(K+oe)/d;if(!(ue<0||ue>=u.outHeight||Math.floor(ue)!==ue))for(let ve=0;ve<I;ve+=b){let we=(Z+ve)/p;if(we<0||we>=u.outWidth||Math.floor(we)!==we)continue;let ge=C.get(D,ne,ue,we,L);J+=ge}}}M.set(J*F,D,O,q,H,L)}return n.makeTensorInfo(M.shape,M.dtype,M.values)}var yhe={kernelName:Pm,backendName:"cpu",kernelFunc:ghe};function xhe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s;Ie([a,s],"avgPoolGrad");let{filterSize:o,strides:l,pad:c}=r,u=E.computePool2DInfo(i.shape,o,l,1,c),h=u.strideHeight,d=u.strideWidth,p=u.filterHeight,f=u.filterWidth,m=u.dilationHeight,y=u.dilationWidth,g=u.effectiveFilterHeight,x=u.effectiveFilterWidth,b=x-1-u.padInfo.left,v=g-1-u.padInfo.top,w=Ve(i.shape,"float32"),I=1/(p*f),_=n.data.get(a.dataId).values,T=Ve(a.shape,"float32",_);for(let A=0;A<u.batchSize;++A)for(let M=0;M<u.inChannels;++M)for(let F=0;F<u.inHeight;++F)for(let C=0;C<u.inWidth;++C){let D=F-v,L=C-b,O=0;for(let q=0;q<g;q+=m){let H=(D+q)/h;if(!(H<0||H>=u.outHeight||Math.floor(H)!==H))for(let z=0;z<x;z+=y){let K=(L+z)/d;if(K<0||K>=u.outWidth||Math.floor(K)!==K)continue;let Z=T.get(A,H,K,M);O+=Z}}w.set(O*I,A,F,C,M)}return n.makeTensorInfo(w.shape,w.dtype,w.values)}var bhe={kernelName:zm,backendName:"cpu",kernelFunc:xhe};function vhe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,scale:s,offset:i,mean:o,variance:l}=t;k.assert(o.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),k.assert(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),k.assert(s==null||o.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Ie([a,o,l,s,i],"batchNorm");let{varianceEpsilon:c}=r;c==null&&(c=.001);let u=n.data.get(a.dataId).values,h=n.data.get(o.dataId).values,d=n.data.get(l.dataId).values,p=s?n.data.get(s.dataId).values:new Float32Array([1]),f=i?n.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(u.length),y=f.length,g=p.length,x=d.length,b=h.length,v=0,w=0,I=0,_=0;for(let T=0;T<u.length;++T)m[T]=f[v++]+(u[T]-h[w++])*p[I++]/Math.sqrt(d[_++]+c),v>=y&&(v=0),w>=b&&(w=0),I>=g&&(I=0),_>=x&&(_=0);return n.makeTensorInfo(a.shape,a.dtype,m)}var whe={kernelName:Du,backendName:"cpu",kernelFunc:vhe};function khe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r;Ie([a],"batchToSpaceND");let o=s.reduce((g,x)=>g*x),l=E.getReshaped(a.shape,s,o),c=E.getPermuted(l.length,s.length),u=E.getReshapedPermuted(a.shape,s,o),h=E.getSliceBeginCoords(i,s.length),d=E.getSliceSize(u,i,s.length),p=_t({inputs:{x:a},backend:n,attrs:{shape:l}}),f=kr({inputs:{x:p},backend:n,attrs:{perm:c}}),m=_t({inputs:{x:f},backend:n,attrs:{shape:u}}),y=Yl({inputs:{x:m},backend:n,attrs:{begin:h,size:d}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),y}var She={kernelName:kd,backendName:"cpu",kernelFunc:khe};function Ihe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i}=r,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,c=X_(o,l,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,c)}var Nhe={kernelName:Sd,backendName:"cpu",kernelFunc:Ihe};function _he(e){let{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,o=E.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}var Che={kernelName:Lm,backendName:"cpu",kernelFunc:_he},The=pt(Oo,(e,t)=>{let n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e}),Ehe={kernelName:Oo,backendName:"cpu",kernelFunc:The},Ahe=e=>{let{x:t}=e.inputs,n=e.backend,r=new Float32Array(k.sizeFromShape(t.shape)),a=n.data.get(t.dataId),s=a.complexTensorInfos.real,i=a.complexTensorInfos.imag,o=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values;for(let c=0;c<o.length;c++){let u=o[c],h=l[c];r[c]=Math.hypot(u,h)}return n.makeOutput(r,t.shape,"float32")},$he={kernelName:Bm,backendName:"cpu",kernelFunc:Ahe};function sd(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.imag,s=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,s)}var Mhe={kernelName:cb,backendName:"cpu",kernelFunc:sd};function id(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,s=k.parseAxisParam(a,t[0].shape)[0],i=t.map(m=>m.shape);E.assertParamsConsistent(i,s);let o=E.computeOutShape(t.map(m=>m.shape),s);if(k.sizeFromShape(o)===0)return n.makeTensorInfo(o,t[0].dtype,[]);let l=t.filter(m=>k.sizeFromShape(m.shape)>0);if(l.length===1)return As({inputs:{x:l[0]},backend:n});if(l[0].dtype==="complex64"){let m=l.map(v=>Zl({inputs:{input:v},backend:n})),y=l.map(v=>sd({inputs:{input:v},backend:n})),g=id({inputs:m,backend:n,attrs:{axis:s}}),x=id({inputs:y,backend:n,attrs:{axis:s}}),b=Fr({inputs:{real:g,imag:x},backend:n});return m.forEach(v=>n.disposeIntermediateTensorInfo(v)),y.forEach(v=>n.disposeIntermediateTensorInfo(v)),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(x),b}let c=l.map(m=>{let y=[-1,k.sizeFromShape(m.shape.slice(s))];return _t({inputs:{x:m},backend:n,attrs:{shape:y}})}),u=c.map(m=>({vals:n.data.get(m.dataId).values,shape:m.shape}));o=E.computeOutShape(c.map(m=>m.shape),1);let h=c[0].shape[0]===1,d=Z_(u,o,t[0].dtype,h),p=E.computeOutShape(l.map(m=>m.shape),s),f=n.makeTensorInfo(p,t[0].dtype,d);return c.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}var Fhe={kernelName:Nd,backendName:"cpu",kernelFunc:id};function f4(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dataFormat:l,dilations:c,dimRoundingMode:u}=r;Ie([a,s],"conv2d");let h=E.convertConv2DDataFormat(l),d=E.computeConv2DInfo(a.shape,s.shape,i,c,o,u,!1,h),p=d.filterHeight,f=d.filterWidth,m=d.dilationHeight,y=d.dilationWidth,g=d.padInfo.left,x=d.padInfo.top,b=d.dataFormat==="channelsLast",v=new Yt(d.outShape,a.dtype),w=k.computeStrides(a.shape),I=k.computeStrides(s.shape),_=w[0],T=b?w[1]:w[2],A=b?w[2]:1,M=b?1:w[1],F=v.strides[0],C=b?v.strides[1]:v.strides[2],D=b?v.strides[2]:1,L=b?1:v.strides[1],O=n.data.get(a.dataId).values,q=n.data.get(s.dataId).values,H=v.values;for(let z=0;z<d.batchSize;++z){let K=z*_,Z=z*F;for(let J=0;J<d.outHeight;++J){let Q=Z+J*C,ne=J*d.strideHeight-x;for(let oe=0;oe<p;++oe){let ue=ne+oe*m;if(ue<0||ue>=d.inHeight)continue;let ve=oe*I[0],we=K+ue*T;for(let ge=0;ge<d.outWidth;++ge){let Te=Q+ge*D,$e=ge*d.strideWidth-g;for(let Pe=0;Pe<f;++Pe){let je=$e+Pe*y;if(je<0||je>=d.inWidth)continue;let ft=ve+Pe*I[1],Xe=we+je*A,tt=ft;for(let De=0;De<d.inChannels;++De){let ot=O[Xe+De*M];for(let kt=0;kt<d.outChannels;++kt)H[Te+kt*L]+=ot*q[tt+kt];tt+=d.outChannels}}}}}}return n.makeTensorInfo(v.shape,v.dtype,H)}var Rhe={kernelName:vu,backendName:"cpu",kernelFunc:f4};function Dhe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:c,filterShape:u}=r;Ie([a,s],"conv2dBackpropFilter");let h=E.convertConv2DDataFormat(l),d=E.computeConv2DInfo(a.shape,u,i,1,o,c,!1,h),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:y}=d,g=d.dataFormat==="channelsLast",x=new Yt(d.filterShape,"float32"),b=d.padInfo.left,v=d.padInfo.top,w=n.data.get(a.dataId).values,I=n.data.get(s.dataId).values,_=new Yt(a.shape,a.dtype,w),T=new Yt(s.shape,s.dtype,I);for(let A=0;A<m;++A){let M=Math.max(0,Math.ceil((v-A)/p)),F=Math.min(d.outHeight,(d.inHeight+v-A)/p);for(let C=0;C<y;++C){let D=Math.max(0,Math.ceil((b-C)/f)),L=Math.min(d.outWidth,(d.inWidth+b-C)/f);for(let O=0;O<d.inChannels;++O)for(let q=0;q<d.outChannels;++q){let H=0;for(let z=0;z<d.batchSize;++z)for(let K=M;K<F;++K){let Z=A+K*p-v;for(let J=D;J<L;++J){let Q=C+J*f-b;g?H+=_.get(z,Z,Q,O)*T.get(z,K,J,q):H+=_.get(z,O,Z,Q)*T.get(z,q,K,J)}}x.set(H,A,C,O,q)}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}var Ohe={kernelName:rb,backendName:"cpu",kernelFunc:Dhe};function zhe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:c,dimRoundingMode:u}=r;Ie([a,s],"conv2dBackpropInput");let h=k.computeStrides(s.shape),d=k.computeStrides(a.shape),p=E.convertConv2DDataFormat(c),f=E.computeConv2DInfo(i,s.shape,o,1,l,u,!1,p),m=new Yt(f.inShape,"float32"),y=m.values,g=n.data.get(a.dataId).values,x=n.data.get(s.dataId).values,[b,v,w]=h,{batchSize:I,filterHeight:_,filterWidth:T,inChannels:A,inHeight:M,inWidth:F,outChannels:C,outHeight:D,outWidth:L,strideHeight:O,strideWidth:q}=f;p=f.dataFormat;let H=_-1-f.padInfo.top,z=T-1-f.padInfo.left,K=p==="channelsLast",Z=m.strides[0],J=K?m.strides[1]:m.strides[2],Q=K?m.strides[2]:1,ne=K?1:m.strides[1],oe=d[0],ue=K?d[1]:d[2],ve=K?d[2]:1,we=K?1:d[1];for(let ge=0;ge<I;++ge)for(let Te=0;Te<A;++Te)for(let $e=0;$e<M;++$e){let Pe=$e-H,je=Math.max(0,Math.ceil(Pe/O)),ft=Math.min(D,(_+Pe)/O);for(let Xe=0;Xe<F;++Xe){let tt=Xe-z,De=Math.max(0,Math.ceil(tt/q)),ot=Math.min(L,(T+tt)/q),kt=0;for(let Lt=je;Lt<ft;++Lt){let ur=Lt*O-Pe;for(let In=De;In<ot;++In){let cr=In*q-tt,ga=oe*ge+ue*Lt+ve*In,Cr=b*(_-1-ur)+v*(T-1-cr)+w*Te;for(let hr=0;hr<C;++hr){let Nn=g[ga+we*hr],Kr=x[Cr+hr];kt+=Nn*Kr}}}let _r=Z*ge+J*$e+Q*Xe+ne*Te;y[_r]=kt}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}var Phe={kernelName:wu,backendName:"cpu",kernelFunc:zhe};function Lhe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r;Ie([a,s],"conv3d");let c=E.computeConv3DInfo(a.shape,s.shape,i,l,o),{filterDepth:u,filterHeight:h,filterWidth:d,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:y}=c,g=y.front,x=y.left,b=y.top,v=new Yt(c.outShape,a.dtype),w=n.data.get(a.dataId).values,I=n.data.get(s.dataId).values,_=v.values,T=k.computeStrides(a.shape),A=k.computeStrides(s.shape);for(let M=0;M<c.batchSize;++M){let F=M*T[0],C=M*v.strides[0];for(let D=0;D<c.outDepth;++D){let L=C+D*v.strides[1],O=D*c.strideDepth-g;for(let q=0;q<u;++q){let H=O+q*p;if(H<0||H>=c.inDepth)continue;let z=q*A[0],K=F+H*T[1];for(let Z=0;Z<c.outHeight;++Z){let J=L+Z*v.strides[2],Q=Z*c.strideHeight-b;for(let ne=0;ne<h;++ne){let oe=Q+ne*f;if(oe<0||oe>=c.inHeight)continue;let ue=z+ne*A[1],ve=K+oe*T[2];for(let we=0;we<c.outWidth;++we){let ge=J+we*c.outChannels,Te=we*c.strideWidth-x;for(let $e=0;$e<d;++$e){let Pe=Te+$e*m;if(Pe<0||Pe>=c.inWidth)continue;let je=ue+$e*A[2],ft=ve+Pe*c.inChannels,Xe=je;for(let tt=0;tt<c.inChannels;++tt){let De=w[ft+tt];for(let ot=0;ot<c.outChannels;++ot)_[ge+ot]+=De*I[Xe+ot];Xe+=c.outChannels}}}}}}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}var Bhe={kernelName:ku,backendName:"cpu",kernelFunc:Lhe};function Whe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,filterShape:l}=r;Ie([a,s],"conv3dBackpropFilterV2");let c=k.computeStrides(a.shape),u=k.computeStrides(s.shape),h=E.computeConv3DInfo(a.shape,l,i,1,o),d=h.strideDepth,p=h.strideHeight,f=h.strideWidth,m=h.filterDepth,y=h.filterHeight,g=h.filterWidth,x=new Yt(h.filterShape,"float32"),b=x.values,[v,w,I,_]=x.strides,T=n.data.get(s.dataId).values,[A,M,F,C]=u,D=n.data.get(a.dataId).values,[L,O,q,H]=c,z=h.padInfo.front,K=h.padInfo.left,Z=h.padInfo.top;for(let J=0;J<m;++J){let Q=Math.max(0,Math.ceil((z-J)/d)),ne=Math.min(h.outDepth,(h.inDepth+z-J)/d),oe=J*v;for(let ue=0;ue<y;++ue){let ve=Math.max(0,Math.ceil((Z-ue)/p)),we=Math.min(h.outHeight,(h.inHeight+Z-ue)/p),ge=ue*w+oe;for(let Te=0;Te<g;++Te){let $e=Math.max(0,Math.ceil((K-Te)/f)),Pe=Math.min(h.outWidth,(h.inWidth+K-Te)/f),je=Te*I+ge;for(let ft=0;ft<h.inChannels;++ft){let Xe=ft*_+je;for(let tt=0;tt<h.outChannels;++tt){let De=0;for(let ot=0;ot<h.batchSize;++ot){let kt=ot*L,_r=ot*A;for(let Lt=Q;Lt<ne;++Lt){let ur=(J+Lt*d-z)*O+kt,In=Lt*M+_r;for(let cr=ve;cr<we;++cr){let ga=(ue+cr*p-Z)*q+ur,Cr=cr*F+In;for(let hr=$e;hr<Pe;++hr){let Nn=(Te+hr*f-K)*H+ga,Kr=hr*C+Cr;De+=D[Nn+ft]*T[Kr+tt]}}}}b[Xe+tt]=De}}}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}var Uhe={kernelName:_d,backendName:"cpu",kernelFunc:Whe};function Vhe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:i,strides:o,inputShape:l}=r;Ie([a],"conv3dBackpropInputV2");let c=k.computeStrides(a.shape),u=k.computeStrides(s.shape),h=E.computeConv3DInfo(l,s.shape,o,1,i),d=new Yt(h.inShape,"float32"),p=d.values,[f,m,y,g]=d.strides,x=n.data.get(a.dataId).values,[b,v,w,I]=c,_=n.data.get(s.dataId).values,[T,A,M,F]=u,{batchSize:C,filterDepth:D,filterHeight:L,filterWidth:O,inChannels:q,inDepth:H,inHeight:z,inWidth:K,outChannels:Z,outDepth:J,outHeight:Q,outWidth:ne,strideDepth:oe,strideHeight:ue,strideWidth:ve}=h,we=D-1-h.padInfo.front,ge=L-1-h.padInfo.top,Te=O-1-h.padInfo.left;for(let $e=0;$e<C;++$e)for(let Pe=0;Pe<q;++Pe)for(let je=0;je<H;++je){let ft=je-we,Xe=Math.max(0,Math.ceil(ft/oe)),tt=Math.min(J,(D+ft)/oe);for(let De=0;De<z;++De){let ot=De-ge,kt=Math.max(0,Math.ceil(ot/ue)),_r=Math.min(Q,(L+ot)/ue);for(let Lt=0;Lt<K;++Lt){let ur=Lt-Te,In=Math.max(0,Math.ceil(ur/ve)),cr=Math.min(ne,(O+ur)/ve),ga=0;for(let Cr=Xe;Cr<tt;++Cr){let hr=Cr*oe-ft;for(let Nn=kt;Nn<_r;++Nn){let Kr=Nn*ue-ot;for(let wi=In;wi<cr;++wi){let Lp=wi*ve-ur,Ds=b*$e+v*Cr+w*Nn+I*wi,Bp=T*(D-1-hr)+A*(L-1-Kr)+M*(O-1-Lp)+F*Pe;for(let os=0;os<Z;++os){let ki=x[Ds+os],_n=_[Bp+os];ga+=ki*_n}}}}p[f*$e+m*je+y*De+g*Lt+Pe]=ga}}}return n.makeTensorInfo(d.shape,d.dtype,d.values)}var jhe={kernelName:Cd,backendName:"cpu",kernelFunc:Vhe},Ghe=pt(Su,e=>Math.cos(e)),Hhe={kernelName:Su,backendName:"cpu",kernelFunc:Ghe},qhe=pt(Iu,e=>Math.cosh(e)),Khe={kernelName:Iu,backendName:"cpu",kernelFunc:qhe};function Xhe(e){let{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:c}=r,[u,h,d,p]=a.shape,f=s.shape[0],[m,y]=o,g=Ve([f,m,y,p],"float32"),x=n.data.get(s.dataId).values,b=n.data.get(i.dataId).values,v=n.data.get(a.dataId).values,w=k.computeStrides(a.shape),I=k.computeStrides(g.shape);for(let _=0;_<f;_++){let T=_*4,A=x[T],M=x[T+1],F=x[T+2],C=x[T+3],D=b[_];if(D>=u)continue;let L=m>1?(F-A)*(h-1)/(m-1):0,O=y>1?(C-M)*(d-1)/(y-1):0;for(let q=0;q<m;q++){let H=m>1?A*(h-1)+q*L:.5*(A+F)*(h-1);if(H<0||H>h-1){for(let z=0;z<y;z++)for(let K=0;K<p;K++){let Z=K+z*I[2]+q*I[1]+_*I[0];g.values[Z]=c}continue}if(l==="bilinear"){let z=Math.floor(H),K=Math.ceil(H),Z=H-z;for(let J=0;J<y;J++){let Q=y>1?M*(d-1)+J*O:.5*(M+C)*(d-1);if(Q<0||Q>d-1){for(let ve=0;ve<p;ve++){let we=ve+J*I[2]+q*I[1]+_*I[0];g.values[we]=c}continue}let ne=Math.floor(Q),oe=Math.ceil(Q),ue=Q-ne;for(let ve=0;ve<p;ve++){let we=ve+ne*w[2]+z*w[1]+D*w[0],ge=v[we];we=ve+oe*w[2]+z*w[1]+D*w[0];let Te=v[we];we=ve+ne*w[2]+K*w[1]+D*w[0];let $e=v[we];we=ve+oe*w[2]+K*w[1]+D*w[0];let Pe=v[we],je=ge+(Te-ge)*ue,ft=$e+(Pe-$e)*ue;we=ve+J*I[2]+q*I[1]+_*I[0],g.values[we]=je+(ft-je)*Z}}}else for(let z=0;z<y;++z){let K=y>1?M*(d-1)+z*O:.5*(M+C)*(d-1);if(K<0||K>d-1){for(let Q=0;Q<p;Q++){let ne=Q+z*I[2]+q*I[1]+_*I[0];g.values[ne]=c}continue}let Z=Math.round(K),J=Math.round(H);for(let Q=0;Q<p;Q++){let ne=Q+Z*w[2]+J*w[1]+D*w[0],oe=Q+z*I[2]+q*I[1]+_*I[0];g.values[oe]=v[ne]}}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}var Zhe={kernelName:Ed,backendName:"cpu",kernelFunc:Xhe};function Yhe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;Ie(a,"cumprod");let l=E.getAxesPermutation([s],a.shape.length),c=a;l!=null&&(c=kr({inputs:{x:a},backend:n,attrs:{perm:l}}));let u=E.getInnerMostAxes(1,a.shape.length)[0];if(u!==c.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${u}`);let h=ca(c.dtype,"int32"),d=k.makeOnesTypedArray(k.sizeFromShape(c.shape),h),p=n.data.get(c.dataId).values,f=c.shape[c.shape.length-1],m=o?(g,x)=>g+f-x-1:(g,x)=>g+x;for(let g=0;g<p.length;g+=f)for(let x=0;x<f;x++){let b=m(g,x);if(x===0)d[b]=i?1:p[b];else{let v=m(g,x-1);d[b]=i?p[v]*d[v]:p[b]*d[v]}}let y=n.makeTensorInfo(c.shape,h,d);if(l!=null){let g=E.getUndoAxesPermutation(l),x=kr({inputs:{x:y},backend:n,attrs:{perm:g}});return n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(c),x}return y}var Jhe={kernelName:Td,backendName:"cpu",kernelFunc:Yhe};function Qhe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;Ie(a,"cumsum");let l=E.getAxesPermutation([s],a.shape.length),c=a;l!=null&&(c=kr({inputs:{x:a},backend:n,attrs:{perm:l}}));let u=E.getInnerMostAxes(1,a.shape.length)[0];if(u!==c.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${u}`);let h=ca(c.dtype,"int32"),d=k.makeZerosTypedArray(k.sizeFromShape(c.shape),h),p=n.data.get(c.dataId).values,f=c.shape[c.shape.length-1],m=o?(g,x)=>g+f-x-1:(g,x)=>g+x;for(let g=0;g<p.length;g+=f)for(let x=0;x<f;x++){let b=m(g,x);if(x===0)d[b]=i?0:p[b];else{let v=m(g,x-1);d[b]=i?p[v]+d[v]:p[b]+d[v]}}let y=n.makeTensorInfo(c.shape,h,d);if(l!=null){let g=E.getUndoAxesPermutation(l),x=kr({inputs:{x:y},backend:n,attrs:{perm:g}});return n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(c),x}return y}var ede={kernelName:Nu,backendName:"cpu",kernelFunc:Qhe};function tde(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i,binaryOutput:o}=r;if(a.shape.length===1){let l=n.data.get(a.dataId).values,c=n.data.get(s.dataId).values,u=X_(l,c,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,u)}else if(a.shape.length===2){let l=n.bufferSync(a),c=n.bufferSync(s),u=kL(l,c,i,o);return n.makeTensorInfo(u.shape,s.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}var nde={kernelName:Wm,backendName:"cpu",kernelFunc:tde};function rde(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:s,dataFormat:i}=r;k.assert(i==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);let o=a.shape[0],l=a.shape[1],c=a.shape[2],u=a.shape[3],h=l*s,d=c*s,p=u/(s*s),f=n.data.get(a.dataId).values,m=new Float32Array(o*h*d*p),y=0;for(let g=0;g<o;++g)for(let x=0;x<h;++x){let b=Math.floor(x/s),v=x%s;for(let w=0;w<d;++w){let I=Math.floor(w/s),_=w%s,T=(v*s+_)*p;for(let A=0;A<p;++A){let M=A+T+u*(I+c*(b+l*g));m[y++]=f[M]}}}return n.makeTensorInfo([o,h,d,p],a.dtype,m)}var ade={kernelName:Ad,backendName:"cpu",kernelFunc:rde};function m4(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:c}=r;Ie([a,s],"depthwiseConv2DNative");let u=k.computeStrides(a.shape),h=k.computeStrides(s.shape),d=l;d==null&&(d=[1,1]),k.assert(E.eitherStridesOrDilationsAreOne(i,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`);let p=E.computeConv2DInfo(a.shape,s.shape,i,d,o,c,!0),{filterHeight:f,filterWidth:m,dilationHeight:y,dilationWidth:g,padInfo:x}=p,b=x.left,v=x.top,w=p.outChannels/p.inChannels,I=new Yt(p.outShape,a.dtype),_=n.data.get(a.dataId).values,T=n.data.get(s.dataId).values,A=I.values;for(let M=0;M<p.batchSize;++M){let F=M*u[0],C=M*I.strides[0];for(let D=0;D<p.outHeight;++D){let L=C+D*I.strides[1],O=D*p.strideHeight-v;for(let q=0;q<f;++q){let H=O+q*y;if(H<0||H>=p.inHeight)continue;let z=q*h[0],K=F+H*u[1];for(let Z=0;Z<p.outWidth;++Z){let J=L+Z*I.strides[2],Q=Z*p.strideWidth-b;for(let ne=0;ne<m;++ne){let oe=Q+ne*g;if(oe<0||oe>=p.inWidth)continue;let ue=z+ne*h[1],ve=K+oe*p.inChannels,we=J,ge=ue;for(let Te=0;Te<p.inChannels;++Te){let $e=_[ve+Te];for(let Pe=0;Pe<w;++Pe)A[we+Pe]+=$e*T[ge+Pe];we+=w,ge+=w}}}}}}return n.makeTensorInfo(I.shape,I.dtype,I.values)}var sde={kernelName:_u,backendName:"cpu",kernelFunc:m4};function ide(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:c,filterShape:u}=r;Ie([a,s],"depthwiseConv2dNativeBackpropFilter");let h=E.computeConv2DInfo(a.shape,u,i,o,l,c,!0),{strideHeight:d,strideWidth:p,filterHeight:f,filterWidth:m}=h,y=new Yt(h.filterShape,"float32"),g=h.padInfo.left,x=h.padInfo.top,b=h.outChannels/h.inChannels,v=n.data.get(a.dataId).values,w=new Yt(a.shape,a.dtype,v),I=n.data.get(s.dataId).values,_=new Yt(s.shape,s.dtype,I);for(let T=0;T<f;++T){let A=Math.max(0,Math.ceil((x-T)/d)),M=Math.min(h.outHeight,(h.inHeight+x-T)/d);for(let F=0;F<m;++F){let C=Math.max(0,Math.ceil((g-F)/p)),D=Math.min(h.outWidth,(h.inWidth+g-F)/p);for(let L=0;L<h.outChannels;++L){let O=Math.trunc(L/b),q=L%b,H=0;for(let z=0;z<h.batchSize;++z)for(let K=A;K<M;++K){let Z=T+K*d-x;for(let J=C;J<D;++J){let Q=F+J*p-g;H+=w.get(z,Z,Q,O)*_.get(z,K,J,L)}}y.set(H,T,F,O,q)}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}var ode={kernelName:ab,backendName:"cpu",kernelFunc:ide};function lde(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:c,inputShape:u}=r;Ie([a,s],"depthwiseConv2DNativeBackpropInput");let h=k.computeStrides(a.shape),d=k.computeStrides(s.shape),p=E.computeConv2DInfo(u,s.shape,i,o,l,c,!0),f=new Yt(p.inShape,"float32"),m=f.values,[y,g,x]=f.strides,b=n.data.get(a.dataId).values,[v,w,I]=h,_=n.data.get(s.dataId).values,[T,A,M]=d,{batchSize:F,filterHeight:C,filterWidth:D,inChannels:L,inHeight:O,inWidth:q,outChannels:H,outHeight:z,outWidth:K,strideHeight:Z,strideWidth:J}=p,Q=C-1-p.padInfo.top,ne=D-1-p.padInfo.left,oe=H/L;for(let ue=0;ue<F;++ue)for(let ve=0;ve<L;++ve)for(let we=0;we<O;++we){let ge=we-Q,Te=Math.max(0,Math.ceil(ge/Z)),$e=Math.min(z,(C+ge)/Z);for(let Pe=0;Pe<q;++Pe){let je=Pe-ne,ft=Math.max(0,Math.ceil(je/J)),Xe=Math.min(K,(D+je)/J),tt=0;for(let De=Te;De<$e;++De){let ot=De*Z-ge;for(let kt=ft;kt<Xe;++kt){let _r=kt*J-je,Lt=v*ue+w*De+I*kt,ur=T*(C-1-ot)+A*(D-1-_r)+M*ve;for(let In=0;In<oe;++In){let cr=ve*oe+In,ga=b[Lt+cr],Cr=_[ur+In];tt+=ga*Cr}}}m[y*ue+g*we+x*Pe+ve]=tt}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}var ude={kernelName:sb,backendName:"cpu",kernelFunc:lde};function cde(e){let{inputs:t,backend:n}=e,{x:r}=t,a=k.sizeFromShape(r.shape),s=n.data.get(r.dataId).values,i=Ve([a,a],r.dtype),o=i.values;for(let c=0;c<s.length;c++)o[c*a+c]=s[c];let l=[...r.shape,...r.shape];return n.makeTensorInfo(l,i.dtype,i.values)}var hde={kernelName:Um,backendName:"cpu",kernelFunc:cde},dde={kernelName:Cu,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:a}=e,{strides:s,pad:i,dilations:o}=n,l=t,c=l.data.get(r.dataId).values,u=r.shape.length,h=l.data.get(a.dataId).values,d=a.shape.length,{batchSize:p,inHeight:f,inWidth:m,inChannels:y,outHeight:g,outWidth:x,padInfo:b,strideHeight:v,strideWidth:w,filterHeight:I,filterWidth:_,dilationHeight:T,dilationWidth:A,outShape:M}=E.computeDilation2DInfo(r.shape,a.shape,s,i,"NHWC",o),F=k.sizeFromShape(M),C=M.length,D=k.getArrayFromDType(r.dtype,F);for(let L=0;L<p;++L)for(let O=0;O<g;++O){let q=O*v-b.top;for(let H=0;H<x;++H){let z=H*w-b.left;for(let K=0;K<y;++K){let Z=Number.MIN_SAFE_INTEGER;for(let Q=0;Q<I;++Q){let ne=q+Q*T;if(ne>=0&&ne<f)for(let oe=0;oe<_;++oe){let ue=z+oe*A;if(ue>=0&&ue<m){let ve=k.locToIndex([L,ne,ue,K],u,k.computeStrides(r.shape)),we=k.locToIndex([Q,oe,K],d,k.computeStrides(a.shape)),ge=c[ve]+h[we];ge>Z&&(Z=ge)}}}let J=k.locToIndex([L,O,H,K],C,k.computeStrides(M));D[J]=Z}}}return{dataId:l.write(k.toTypedArray(D,r.dtype),M,r.dtype),shape:M,dtype:r.dtype}}},pde={kernelName:Hh,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:a,dy:s}=e,{strides:i,pad:o,dilations:l}=n,c=t,u=k.toNestedArray(r.shape,c.data.get(r.dataId).values),h=k.toNestedArray(a.shape,c.data.get(a.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:m,outHeight:y,outWidth:g,padInfo:x,strideHeight:b,strideWidth:v,filterHeight:w,filterWidth:I,dilationHeight:_,dilationWidth:T,outShape:A}=E.computeDilation2DInfo(r.shape,a.shape,i,o,"NHWC",l);k.assert(s.rank===A.length,()=>`Error in ${Hh}, dy must have the same rank as output ${A.length}, but got ${s.rank}`);let M=k.toNestedArray(A,c.data.get(s.dataId).values),F=k.makeZerosNestedTypedArray(a.shape,a.dtype);for(let C=0;C<d;++C)for(let D=0;D<y;++D){let L=D*b-x.top;for(let O=0;O<g;++O){let q=O*v-x.left;for(let H=0;H<m;++H){let z=Number.MIN_SAFE_INTEGER,K=0,Z=0;for(let J=0;J<w;++J){let Q=L+J*_;if(Q>=0&&Q<p)for(let ne=0;ne<I;++ne){let oe=q+ne*T;if(oe>=0&&oe<f){let ue=u[C][Q][oe][H]+h[J][ne][H];ue>z&&(z=ue,K=J,Z=ne)}}}F[K][Z][H]+=M[C][D][O][H]}}}return{dataId:c.write(k.toTypedArray(F,r.dtype),a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},fde={kernelName:Gh,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:a,dy:s}=e,{strides:i,pad:o,dilations:l}=n,c=t,u=k.toNestedArray(r.shape,c.data.get(r.dataId).values),h=k.toNestedArray(a.shape,c.data.get(a.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:m,outHeight:y,outWidth:g,padInfo:x,strideHeight:b,strideWidth:v,filterHeight:w,filterWidth:I,dilationHeight:_,dilationWidth:T,outShape:A}=E.computeDilation2DInfo(r.shape,a.shape,i,o,"NHWC",l);k.assert(s.rank===A.length,()=>`Error in ${Gh}, dy must have the same rank as output ${A.length}, but got ${s.rank}`);let M=k.toNestedArray(A,c.data.get(s.dataId).values),F=k.makeZerosNestedTypedArray(r.shape,r.dtype);for(let C=0;C<d;++C)for(let D=0;D<y;++D){let L=D*b-x.top;for(let O=0;O<g;++O){let q=O*v-x.left;for(let H=0;H<m;++H){let z=Number.MIN_SAFE_INTEGER,K=L<0?0:L,Z=q<0?0:q;for(let J=0;J<w;++J){let Q=L+J*_;if(Q>=0&&Q<p)for(let ne=0;ne<I;++ne){let oe=q+ne*T;if(oe>=0&&oe<f){let ue=u[C][Q][oe][H]+h[J][ne][H];ue>z&&(z=ue,K=Q,Z=oe)}}}F[C][K][Z][H]+=M[C][D][O][H]}}}return{dataId:c.write(k.toTypedArray(F,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};function mde(e){let{inputs:t,backend:n,attrs:r}=e,{image:a}=t,{canvas:s,options:i}=r,{contextOptions:o,imageOptions:l}=i||{},c=(l==null?void 0:l.alpha)||1,u=(o==null?void 0:o.contextType)||"2d";if(u!=="2d")throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);let h=s.getContext(u,(o==null?void 0:o.contextAttributes)||{});if(h==null)throw new Error(`Could not get the context with ${u} type.`);let[d,p]=a.shape.slice(0,2),f=a.shape.length===2?1:a.shape[2],m=n.data.get(a.dataId).values,y=a.dtype==="float32"?255:1,g=new Uint8ClampedArray(p*d*4);for(let b=0;b<d*p;++b){let v=[0,0,0,255*c];for(let I=0;I<f;I++){let _=m[b*f+I];if(a.dtype==="float32"){if(_<0||_>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${_}.`)}else if(a.dtype==="int32"&&(_<0||_>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${_}.`);f===1?(v[0]=_*y,v[1]=_*y,v[2]=_*y):v[I]=_*y}let w=b*4;g[w+0]=Math.round(v[0]),g[w+1]=Math.round(v[1]),g[w+2]=Math.round(v[2]),g[w+3]=Math.round(v[3])}s.width=p,s.height=d;let x=new ImageData(g,p,d);return h.putImageData(x,0,0),a}var gde={kernelName:ib,backendName:"cpu",kernelFunc:mde};function Mg(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;Ie(a,"sum");let o;a.dtype==="bool"?o=Co({inputs:{x:a},backend:n,attrs:{dtype:"int32"}}):o=As({inputs:{x:a},backend:n});let l=o.shape.length,c=k.parseAxisParam(s,o.shape),u=E.getAxesPermutation(c,l),h=c,d=o;u!=null&&(d=kr({inputs:{x:o},backend:n,attrs:{perm:u}}),h=E.getInnerMostAxes(h.length,l)),E.assertAxesAreInnerMostDims("sum",h,d.shape.length);let[p,f]=E.computeOutAndReduceShapes(d.shape,h),m=E.upcastType(d.dtype,"int32"),y=xx(n,p,m),g=k.sizeFromShape(f),x=n.data.get(y.dataId).values,b=n.data.get(d.dataId).values;for(let v=0;v<x.length;++v){let w=v*g,I=0;for(let _=0;_<g;++_)I+=b[w+_];x[v]=I}if(i){let v=E.expandShapeToKeepDim(y.shape,c),w=y;y=_t({inputs:{x:y},backend:n,attrs:{shape:v}}),n.disposeIntermediateTensorInfo(w)}return n.disposeIntermediateTensorInfo(o),u!=null&&n.disposeIntermediateTensorInfo(d),y}var yde={kernelName:vc,backendName:"cpu",kernelFunc:Mg};function xde(e){let{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,s=t,{allDims:i,summedDims:o,idDims:l}=E.decodeEinsumEquation(a,s.length);E.checkEinsumDimSizes(i.length,l,s);let{path:c,steps:u}=E.getEinsumComputePath(o,l),h=u.length,d=null,p=i.length,f=[];for(let m=0;m<h;++m){for(let y of u[m]){let{permutationIndices:g,expandDims:x}=E.getEinsumPermutation(p,l[y]),b;E.isIdentityPermutation(g)?b=s[y]:(b=kr({inputs:{x:s[y]},backend:n,attrs:{perm:g}}),f.push(b));let v=b.shape.slice();for(let w=0;w<x.length;++w)v.splice(x[w],0,1);k.arraysEqual(b.shape,v)||(b=_t({inputs:{x:b},backend:n,attrs:{shape:v}}),f.push(b)),d===null?d=b:(d=vv({inputs:{a:b,b:d},backend:n}),f.push(d))}m<h-1&&(c[m]>=0&&(d=Mg({inputs:{x:d},backend:n,attrs:{axis:c[m]-(i.length-p),keepDims:!1}}),f.push(d)),p--)}for(let m of f)m!==d&&n.disposeIntermediateTensorInfo(m);return d}var bde={kernelName:ob,backendName:"cpu",kernelFunc:xde};function vde(e){let{inputs:t,backend:n}=e,{dy:r,y:a}=t;Ie([r,a],"eluGrad");let s=new Float32Array(k.sizeFromShape(a.shape)),i=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values;for(let l=0;l<i.length;++l){let c=i[l];c>=0?s[l]=o[l]:s[l]=o[l]*(c+1)}return n.makeTensorInfo(a.shape,"float32",s)}var wde={kernelName:$d,backendName:"cpu",kernelFunc:vde},kde=E.ERF_P,Sde=E.ERF_A1,Ide=E.ERF_A2,Nde=E.ERF_A3,_de=E.ERF_A4,Cde=E.ERF_A5,Tde=pt(Au,e=>{let t=Math.sign(e),n=Math.abs(e),r=1/(1+kde*n);return t*(1-((((Cde*r+_de)*r+Nde)*r+Ide)*r+Sde)*r*Math.exp(-n*n))}),Ede={kernelName:Au,backendName:"cpu",kernelFunc:Tde};function wx(e){let{inputs:t,backend:n,attrs:r}=e,{input:a}=t,{dim:s}=r,i=a.shape.length,o=a.shape.slice(),l=s;return s<0&&(k.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),o.splice(l,0,1),_t({inputs:{x:a},backend:n,attrs:{shape:o}})}var Ade={kernelName:Fd,backendName:"cpu",kernelFunc:wx},$de=Ht((e,t)=>e/t),oC=hn(Tu,$de),t2={kernelName:Tu,backendName:"cpu",kernelFunc:oC};function g4(e,t,n){let r=e.shape,a=r[0],s=r[1],i=n.data.get(e.dataId),o=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,c=[a,s],u=k.sizeFromShape(c),h=k.getTypedArrayFromDType("float32",u),d=k.getTypedArrayFromDType("float32",u);for(let y=0;y<a;y++){let g=Yl({inputs:{x:o},backend:n,attrs:{begin:[y,0],size:[1,s]}}),x=Yl({inputs:{x:l},backend:n,attrs:{begin:[y,0],size:[1,s]}}),b=Fr({inputs:{real:g,imag:x},backend:n}),{real:v,imag:w}=Mde(b,t,n),I=E.mergeRealAndImagArrays(v,w);for(let _=0;_<s;_++){let T=E.getComplexWithIndex(I,_);h[y*s+_]=T.real,d[y*s+_]=T.imag}n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(b)}let p=n.makeTensorInfo(c,"float32",h),f=n.makeTensorInfo(c,"float32",d),m=Fr({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}function Mde(e,t,n){let r=k.sizeFromShape(e.shape),a=n.data.get(e.dataId),s=n.data.get(a.complexTensorInfos.real.dataId).values,i=n.data.get(a.complexTensorInfos.imag.dataId).values;if(Fde(r)){let o=n2(s,i,r,t,n),l=[e.shape[0],e.shape[1]];if(t){let c=n.makeTensorInfo(l,"float32",o.real),u=n.makeTensorInfo(l,"float32",o.imag),h=n.makeTensorInfo([],"float32",k.createScalarValue(r,"float32")),d=As({inputs:{x:h},backend:n}),p=t2.kernelFunc({inputs:{a:c,b:h},backend:n}),f=t2.kernelFunc({inputs:{a:u,b:d},backend:n}),m=n.data.get(p.dataId).values,y=n.data.get(f.dataId).values;return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),{real:m,imag:y}}return o}else{let o=E.mergeRealAndImagArrays(s,i),l=Rde(o,r,t);return E.splitRealAndImagArrays(l)}}function Fde(e){return(e&e-1)===0}function n2(e,t,n,r,a){if(n===1)return{real:e,imag:t};let s=E.mergeRealAndImagArrays(e,t),i=n/2,o=E.complexWithEvenIndex(s),l=o.real,c=o.imag,u=[l.length],h=a.makeTensorInfo(u,"float32",l),d=a.makeTensorInfo(u,"float32",c),p=Fr({inputs:{real:h,imag:d},backend:a}),f=E.complexWithOddIndex(s),m=f.real,y=f.imag,g=[m.length],x=a.makeTensorInfo(g,"float32",m),b=a.makeTensorInfo(g,"float32",y),v=Fr({inputs:{real:x,imag:b},backend:a}),w=n2(l,c,i,r,a),I=w.real,_=w.imag,T=[I.length],A=a.makeTensorInfo(T,"float32",I),M=a.makeTensorInfo(T,"float32",_),F=Fr({inputs:{real:A,imag:M},backend:a}),C=n2(m,y,i,r,a),D=C.real,L=C.imag,O=[D.length],q=a.makeTensorInfo(O,"float32",D),H=a.makeTensorInfo(O,"float32",L),z=Fr({inputs:{real:q,imag:H},backend:a}),K=E.exponents(n,r),Z=[K.real.length],J=a.makeTensorInfo(Z,"float32",K.real),Q=a.makeTensorInfo(Z,"float32",K.imag),ne=Fr({inputs:{real:J,imag:Q},backend:a}),oe=vv({inputs:{a:ne,b:z},backend:a}),ue=ad({inputs:{a:F,b:oe},backend:a}),ve=aC({inputs:{a:F,b:oe},backend:a}),we=Zl({inputs:{input:ue},backend:a}),ge=Zl({inputs:{input:ve},backend:a}),Te=sd({inputs:{input:ue},backend:a}),$e=sd({inputs:{input:ve},backend:a}),Pe=id({inputs:[we,ge],backend:a,attrs:{axis:0}}),je=id({inputs:[Te,$e],backend:a,attrs:{axis:0}}),ft=a.data.get(Pe.dataId).values,Xe=a.data.get(je.dataId).values;return a.disposeIntermediateTensorInfo(h),a.disposeIntermediateTensorInfo(d),a.disposeIntermediateTensorInfo(p),a.disposeIntermediateTensorInfo(x),a.disposeIntermediateTensorInfo(b),a.disposeIntermediateTensorInfo(v),a.disposeIntermediateTensorInfo(A),a.disposeIntermediateTensorInfo(M),a.disposeIntermediateTensorInfo(F),a.disposeIntermediateTensorInfo(q),a.disposeIntermediateTensorInfo(H),a.disposeIntermediateTensorInfo(z),a.disposeIntermediateTensorInfo(J),a.disposeIntermediateTensorInfo(Q),a.disposeIntermediateTensorInfo(ne),a.disposeIntermediateTensorInfo(oe),a.disposeIntermediateTensorInfo(ue),a.disposeIntermediateTensorInfo(ve),a.disposeIntermediateTensorInfo(we),a.disposeIntermediateTensorInfo(Te),a.disposeIntermediateTensorInfo(ge),a.disposeIntermediateTensorInfo($e),a.disposeIntermediateTensorInfo(Pe),a.disposeIntermediateTensorInfo(je),{real:ft,imag:Xe}}function Rde(e,t,n){let r=new Float32Array(t*2);for(let a=0;a<t;a++){let s=0,i=0;for(let o=0;o<t;o++){let l=E.exponent(a*o,t,n),c=E.getComplexWithIndex(e,o);s+=c.real*l.real-c.imag*l.imag,i+=c.real*l.imag+c.imag*l.real}n&&(s/=t,i/=t),E.assignToTypedArray(r,s,i,a)}return r}function Dde(e){let{inputs:t,backend:n}=e,{input:r}=t,a=k.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=a/s,o=_t({inputs:{x:r},backend:n,attrs:{shape:[i,s]}}),l=g4(o,!1,n),c=_t({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),c}var Ode={kernelName:lb,backendName:"cpu",kernelFunc:Dde};function lC(e){let{backend:t,attrs:n}=e,{shape:r,value:a,dtype:s}=n,i=s||k.inferDtype(a),o=k.getArrayFromDType(i,k.sizeFromShape(r));return Pde(o,a),t.makeTensorInfo(r,i,o)}var zde={kernelName:Vm,backendName:"cpu",kernelFunc:lC};function Pde(e,t,n){e.fill(t)}var Lde={kernelName:Rd,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,a=n,s=k.getTypedArrayFromDType(r.dtype,k.sizeFromShape(r.shape)),[i,o,l,c]=r.shape,u=a.data.get(r.dataId).values;for(let h=0;h<i;h++){let d=h*l*o*c;for(let p=0;p<o;p++){let f=p*(l*c);for(let m=0;m<l;m++){let y=m*c;for(let g=0;g<c;g++){let x=Math.round(l-m-1),b=d+f+y+g,v=u[b];if(x>=0&&x<l){let w=x*c,I=d+f+w+g;v=u[I]}s[b]=v}}}}return{dataId:a.write(s,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};function Bde(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r,m=f4({inputs:{x:a,filter:s},backend:n,attrs:{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d}});if(i){let y=m;if(u==="NCHW"&&i.shape.length===1&&i.shape[0]!==1){let g=_t({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=ad({inputs:{a:m,b:g},backend:n}),n.disposeIntermediateTensorInfo(g)}else m=ad({inputs:{a:m,b:i},backend:n});n.disposeIntermediateTensorInfo(y)}if(p){let y=m;if(u==="NCHW"&&p==="prelu"&&o.shape.length===1&&o.shape[0]!==1){let g=_t({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=vx(n,m,p,g,f),n.disposeIntermediateTensorInfo(g)}else m=vx(n,m,p,o,f);n.disposeIntermediateTensorInfo(y)}return m}var Wde={kernelName:Pl,backendName:"cpu",kernelFunc:Bde};function Ude(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r,m=m4({inputs:{x:a,filter:s},backend:n,attrs:{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d}});if(i){let y=m;m=ad({inputs:{a:m,b:i},backend:n}),n.disposeIntermediateTensorInfo(y)}if(p){let y=m;m=vx(n,m,p,o,f),n.disposeIntermediateTensorInfo(y)}return m}var Vde={kernelName:Ll,backendName:"cpu",kernelFunc:Ude};function jde(e){let{inputs:t,backend:n}=e,{params:r,indices:a}=t,s=k.sizeFromShape(r.shape),i=a.shape,o=i[i.length-1],[l,c,u,h]=E.prepareAndValidate(r,a);if(c===0)return n.makeTensorInfo(l,r.dtype,[]);let d=n.data.get(a.dataId).values,p=n.bufferSync(r),f=ML(d,p,r.dtype,c,o,u,h,r.shape,s);return n.makeTensorInfo(l,r.dtype,f.values)}var Gde={kernelName:Od,backendName:"cpu",kernelFunc:jde};function Hde(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,indices:s}=t,{axis:i,batchDims:o}=r;Ie([a,s],"gatherV2");let l=k.parseAxisParam(i,a.shape)[0],c=n.data.get(s.dataId).values,u=a.shape[l];for(let v=0;v<c.length;++v){let w=c[v];k.assert(w<=u-1&&w>=0,()=>`GatherV2: the index value ${w} is not in [0, ${u-1}]`)}let h=o;o==null&&(h=0);let d=k.sizeFromShape(s.shape),p=E.segment_util.collectGatherOpShapeInfo(a,s,l,h),f=_t({inputs:{x:a},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=_t({inputs:{x:s},backend:n,attrs:{shape:[p.batchSize,d/p.batchSize]}}),y=[p.batchSize,p.outerSize,d/p.batchSize,p.sliceSize],g=n.bufferSync(m),x=n.bufferSync(f),b=FL(x,g,y);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(p.outputShape,b.dtype,b.values)}var qde={kernelName:Dd,backendName:"cpu",kernelFunc:Hde};function Kde(e){let{inputs:t,backend:n}=e,{input:r}=t,a=k.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=a/s,o=_t({inputs:{x:r},backend:n,attrs:{shape:[i,s]}}),l=g4(o,!0,n),c=_t({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),c}var Xde={kernelName:ub,backendName:"cpu",kernelFunc:Kde},Zde=pt(Pu,e=>Number.isFinite(e)?1:0,"bool"),Yde={kernelName:Pu,backendName:"cpu",kernelFunc:Zde},Jde=pt(Lu,e=>Math.abs(e)===1/0?1:0,"bool"),Qde={kernelName:Lu,backendName:"cpu",kernelFunc:Jde},epe=pt(Bu,e=>Number.isNaN(e)?1:0,"bool"),tpe={kernelName:Bu,backendName:"cpu",kernelFunc:epe};function npe(e){let{backend:t,attrs:n}=e,{start:r,stop:a,num:s}=n,i=PL(r,a,s);return t.makeTensorInfo([i.length],"float32",i)}var rpe={kernelName:Bd,backendName:"cpu",kernelFunc:npe},ape=pt(Vu,e=>Math.log1p(e)),spe={kernelName:Vu,backendName:"cpu",kernelFunc:ape},ipe=Ht((e,t)=>e&&t),ope=hn(Wd,ipe,null,"bool"),lpe={kernelName:Wd,backendName:"cpu",kernelFunc:ope},upe=pt(Ud,e=>e?0:1,"bool"),cpe={kernelName:Ud,backendName:"cpu",kernelFunc:upe},hpe=Ht((e,t)=>e||t),dpe=hn(Vd,hpe,null,"bool"),ppe={kernelName:Vd,backendName:"cpu",kernelFunc:dpe};function fpe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=r;Ie(a,"LRN");let c=a.shape[3],u=c-1,h=n.data.get(a.dataId).values,d=k.sizeFromShape(a.shape),p=new Float32Array(d);function f(m){let y=m%c,g=m-y+Math.max(0,y-s),x=m-y+Math.min(y+s,u),b=0;for(;g<=x;g++){let v=h[g];b+=v*v}return b}for(let m=0;m<d;m++){let y=f(m),g=h[m]*Math.pow(i+o*y,-l);p[m]=g}return n.makeTensorInfo(a.shape,a.dtype,p)}var mpe={kernelName:ju,backendName:"cpu",kernelFunc:fpe};function gpe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:c,beta:u}=r;Ie(i,"LRNGrad");let h=k.sizeFromShape(i.shape),d=i.shape[3],p=n.data.get(i.dataId).values,f=n.data.get(a.dataId).values,m=n.data.get(s.dataId).values,y=new Float32Array(h),g=h;for(let x=0;x<g;x++){let b=x%d,v=x-b+Math.max(0,b-o),w=x-b+Math.min(d,b+o+1),I=0;for(let _=v;_<w;_++)I+=Math.pow(f[_],2);I=c*I+l;for(let _=v;_<w;_++){let T=-2*c*u*f[_]*m[x]/I;x===_&&(T+=Math.pow(I,-u)),T*=p[x],y[_]+=T}}return n.makeTensorInfo(i.shape,a.dtype,y)}var ype={kernelName:jd,backendName:"cpu",kernelFunc:gpe};function y4(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:s,keepDims:i}=r,o=n,l=a.shape,c=l.length,u=k.parseAxisParam(s,l),h=u,d=E.getAxesPermutation(h,c),p=o.data.get(a.dataId).values;if(d!=null){let v=new Array(c);for(let w=0;w<v.length;w++)v[w]=l[d[w]];p=J_(p,l,a.dtype,d,v),h=E.getInnerMostAxes(h.length,c),l=v}Ie(a,"max"),E.assertAxesAreInnerMostDims("max",h,c);let[f,m]=E.computeOutAndReduceShapes(l,h),y=k.sizeFromShape(m),g=BL(p,y,f,a.dtype),x=o.write(g,f,a.dtype),b=f;return i&&(b=E.expandShapeToKeepDim(f,u)),{dataId:x,shape:b,dtype:a.dtype}}var xpe={kernelName:Gu,backendName:"cpu",kernelFunc:y4};function bpe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;Ie(a,"maxPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r,c=1;k.assert(E.eitherStridesOrDilationsAreOne(i,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);let u=E.computePool2DInfo(a.shape,s,i,c,o,l),h;if(u.filterWidth===1&&u.filterHeight===1&&k.arraysEqual(u.inShape,u.outShape))h=As({inputs:{x:a},backend:n});else{let d=n.data.get(a.dataId).values,p=k.computeStrides(a.shape),f=iC(d,a.shape,a.dtype,p,u,"max");h=n.makeTensorInfo(u.outShape,a.dtype,f.values)}return h}var vpe={kernelName:qu,backendName:"cpu",kernelFunc:bpe};function wpe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:c}=r;Ie(a,"maxPool3d");let u=E.computePool3DInfo(a.shape,s,i,1,o,l,c),h=n.data.get(a.dataId).values,d=p4(h,a.shape,a.dtype,k.computeStrides(a.shape),u,"max");return n.makeTensorInfo(d.shape,"float32",d.values)}var kpe={kernelName:Gd,backendName:"cpu",kernelFunc:wpe};function Spe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:c}=r;Ie([a,s],"maxPool3DGrad");let u=E.computePool3DInfo(s.shape,i,o,1,l,c),h=n.bufferSync(s),d=hhe(h,u),p=u.strideDepth,f=u.strideHeight,m=u.strideWidth,y=u.dilationDepth,g=u.dilationHeight,x=u.dilationWidth,b=u.effectiveFilterDepth,v=u.effectiveFilterHeight,w=u.effectiveFilterWidth,I=b-1-u.padInfo.front,_=w-1-u.padInfo.left,T=v-1-u.padInfo.top,A=Ve(s.shape,"float32"),M=n.bufferSync(a);for(let F=0;F<u.batchSize;++F)for(let C=0;C<u.inChannels;++C)for(let D=0;D<u.inDepth;++D)for(let L=0;L<u.inHeight;++L)for(let O=0;O<u.inWidth;++O){let q=D-I,H=L-T,z=O-_,K=0;for(let Z=0;Z<b;Z+=y){let J=(q+Z)/p;if(!(J<0||J>=u.outDepth||Math.floor(J)!==J))for(let Q=0;Q<v;Q+=g){let ne=(H+Q)/f;if(!(ne<0||ne>=u.outHeight||Math.floor(ne)!==ne))for(let oe=0;oe<w;oe+=x){let ue=(z+oe)/m;if(ue<0||ue>=u.outWidth||Math.floor(ue)!==ue)continue;let ve=b*v*w-1-d.get(F,J,ne,ue,C),we=Z*v*w+Q*w+oe,ge=ve===we?1:0;if(ge===0)continue;let Te=M.get(F,J,ne,ue,C);K+=Te*ge}}}A.set(K,F,D,L,O,C)}return n.makeTensorInfo(A.shape,A.dtype,A.values)}var Ipe={kernelName:Gm,backendName:"cpu",kernelFunc:Spe};function Npe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s,output:i}=t,o=s;Ie([s,i],"maxPoolGrad");let{filterSize:l,strides:c,pad:u,dimRoundingMode:h}=r,d=E.computePool2DInfo(o.shape,l,c,1,u,h),p=n.data.get(o.dataId).values,f=Ve(d.outShape,o.dtype,d4(p,o.shape,o.dtype,d).values),m=d.strideHeight,y=d.strideWidth,g=d.dilationHeight,x=d.dilationWidth,b=d.effectiveFilterHeight,v=d.effectiveFilterWidth,w=v-1-d.padInfo.left,I=b-1-d.padInfo.top,_=Ve(o.shape,"float32"),T=n.data.get(a.dataId).values,A=Ve(a.shape,"float32",T);for(let M=0;M<d.batchSize;++M)for(let F=0;F<d.inChannels;++F)for(let C=0;C<d.inHeight;++C)for(let D=0;D<d.inWidth;++D){let L=C-I,O=D-w,q=0;for(let H=0;H<b;H+=g){let z=(L+H)/m;if(!(z<0||z>=d.outHeight||Math.floor(z)!==z))for(let K=0;K<v;K+=x){let Z=(O+K)/y;if(Z<0||Z>=d.outWidth||Math.floor(Z)!==Z)continue;let J=b*v-1-f.get(M,z,Z,F),Q=H*v+K,ne=J===Q?1:0;if(ne===0)continue;let oe=A.get(M,z,Z,F);q+=oe*ne}}_.set(q,M,C,D,F)}return n.makeTensorInfo(_.shape,_.dtype,_.values)}var _pe={kernelName:jm,backendName:"cpu",kernelFunc:Npe};function Cpe(e,t,n,r,a){let s=k.computeStrides(t),i=iC(e,t,n,s,a,"max"),o=d4(e,t,n,a,!0,r);return[i.values,o.values]}var Tpe={kernelName:Hm,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{filterSize:a,strides:s,pad:i,includeBatchInIndex:o}=t,l=n;Ie(r,"MaxPoolWithArgmax");let c=l.data.get(r.dataId).values,u=E.computePool2DInfo(r.shape,a,s,[1,1],i),[h,d]=Cpe(c,r.shape,r.dtype,o,u),p=l.write(h,u.outShape,r.dtype),f=l.write(d,u.outShape,r.dtype);return[{dataId:p,shape:u.outShape,dtype:r.dtype},{dataId:f,shape:u.outShape,dtype:"int32"}]}};function Epe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=k.parseAxisParam(s,a.shape),l=E.computeOutAndReduceShapes(a.shape,o)[1],c=k.sizeFromShape(l),u=[],h=n.makeTensorInfo([],"float32",new Float32Array([c]));u.push(h);let d=Co({inputs:{x:a},backend:n,attrs:{dtype:"float32"}});u.push(d);let p=oC({inputs:{a:d,b:h},backend:n});u.push(p);let f=Mg({inputs:{x:p},backend:n,attrs:{axis:s,keepDims:i}});return u.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}var Ape={kernelName:Ku,backendName:"cpu",kernelFunc:Epe};function $pe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;Ie(a,"min");let o=k.parseAxisParam(s,a.shape),l=o,c=E.getAxesPermutation(l,a.shape.length),u=a;c!=null&&(u=kr({inputs:{x:a},backend:n,attrs:{perm:c}}),l=E.getInnerMostAxes(l.length,a.shape.length)),E.assertAxesAreInnerMostDims("min",l,u.shape.length);let[h,d]=E.computeOutAndReduceShapes(u.shape,l),p=k.sizeFromShape(d),f=k.makeZerosTypedArray(k.sizeFromShape(h),u.dtype),m=n.data.get(u.dataId).values;for(let g=0;g<f.length;++g){let x=g*p,b=m[x];for(let v=0;v<p;++v){let w=m[x+v];(Number.isNaN(w)||w<b)&&(b=w)}f[g]=b}c!=null&&n.disposeIntermediateTensorInfo(u);let y=n.makeTensorInfo(h,u.dtype,f);if(i){let g=E.expandShapeToKeepDim(h,o),x=_t({inputs:{x:y},backend:n,attrs:{shape:g}});return n.disposeIntermediateTensorInfo(y),x}return y}var Mpe={kernelName:Xu,backendName:"cpu",kernelFunc:$pe};function Fpe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,mode:i}=r;Ie(a,"mirrorPad");let o=s.map((x,b)=>x[0]+a.shape[b]+x[1]),l=s.map(x=>x[0]),c=s.map((x,b)=>x[0]+a.shape[b]),u=i==="reflect"?0:1,h=n.data.get(a.dataId).values,d=a.shape.length,p=k.computeStrides(a.shape),f=k.sizeFromShape(o),m=o.length,y=k.computeStrides(o),g=k.getTypedArrayFromDType(a.dtype,f);for(let x=0;x<f;x++){let b=k.indexToLoc(x,m,y);for(let w=0;w<m;w++)b[w]<l[w]?b[w]=l[w]*2-b[w]-u:b[w]>=c[w]&&(b[w]=(c[w]-1)*2-b[w]+u);b=b.map((w,I)=>w-l[I]);let v=k.locToIndex(b,d,p);g[x]=h[v]}return{dataId:n.write(g,o,a.dtype),shape:o,dtype:a.dtype}}var Rpe={kernelName:Yu,backendName:"cpu",kernelFunc:Fpe},Dpe=Ht((e,t)=>{let n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t}),Ope=hn(Ju,Dpe),zpe={kernelName:Ju,backendName:"cpu",kernelFunc:Ope},Ppe=Ro(Jx());function x4(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:s}=r,i=a.shape.length,o=s;if(o===-1&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);let l=k.parseAxisParam([o],a.shape),c=y4({inputs:{x:a},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),u=E.expandShapeToKeepDim(c.shape,l),h=_t({inputs:{x:c},backend:n,attrs:{shape:u}}),d=aC({inputs:{a,b:h},backend:n}),p=TL({inputs:{x:d},backend:n}),f=Mg({inputs:{x:p},backend:n,attrs:{axis:l,keepDims:!1}}),m=_t({inputs:{x:f},backend:n,attrs:{shape:u}}),y=oC({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),y}var Lpe={kernelName:wc,backendName:"cpu",kernelFunc:x4};function Bpe(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:i,normalized:o}=r;Ie(a,"multinomial");let l=o?a:x4({inputs:{logits:a},backend:n,attrs:{dim:-1}}),c=l.shape[0],u=l.shape[1],h=n.data.get(l.dataId).values,d=[c,s],p=k.makeZerosTypedArray(k.sizeFromShape(d),"int32");for(let f=0;f<c;++f){let m=f*u,y=new Float32Array(u-1);y[0]=h[m];for(let b=1;b<y.length;++b)y[b]=y[b-1]+h[m+b];let g=Ppe.alea(i.toString()),x=f*s;for(let b=0;b<s;++b){let v=g();p[x+b]=y.length;for(let w=0;w<y.length;w++)if(v<y[w]){p[x+b]=w;break}}}return o||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(d,"int32",p)}var Wpe={kernelName:Hd,backendName:"cpu",kernelFunc:Bpe},Upe=Fs.nonMaxSuppressionV3Impl;function Vpe(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r;Ie(a,"NonMaxSuppression");let c=n.data.get(a.dataId).values,u=n.data.get(s.dataId).values,{selectedIndices:h}=Upe(c,u,i,o,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}var jpe={kernelName:Xd,backendName:"cpu",kernelFunc:Vpe},Gpe=Fs.nonMaxSuppressionV4Impl;function Hpe(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:c}=r;Ie(a,"NonMaxSuppressionPadded");let u=n.data.get(a.dataId).values,h=n.data.get(s.dataId).values,{selectedIndices:d,validOutputs:p}=Gpe(u,h,i,o,l,c);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}var qpe={kernelName:Zd,backendName:"cpu",kernelFunc:Hpe},Kpe=Fs.nonMaxSuppressionV5Impl;function Xpe(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:c}=r;Ie(a,"NonMaxSuppressionWithScore");let u=n.data.get(a.dataId).values,h=n.data.get(s.dataId).values,d=i,p=o,f=l,m=c,{selectedIndices:y,selectedScores:g}=Kpe(u,h,d,p,f,m);return[n.makeTensorInfo([y.length],"int32",new Int32Array(y)),n.makeTensorInfo([g.length],"float32",new Float32Array(g))]}var Zpe={kernelName:Yd,backendName:"cpu",kernelFunc:Xpe};function Ype(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:s,depth:i,onValue:o,offValue:l}=r;Ie(a,"oneHot");let c=k.sizeFromShape(a.shape),u=new Float32Array(c*i);u.fill(l);let h=n.data.get(a.dataId).values;for(let d=0;d<c;++d)h[d]>=0&&h[d]<i&&(u[d*i+h[d]]=o);return n.makeTensorInfo([...a.shape,i],s,u)}var Jpe={kernelName:ec,backendName:"cpu",kernelFunc:Ype};function kx(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(r.dtype==="complex64"){let a=Zl({inputs:{input:r},backend:n}),s=kx({inputs:{x:a},backend:n}),i=sd({inputs:{input:r},backend:n}),o=kx({inputs:{x:i},backend:n}),l=Fr({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return lC({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}var Qpe={kernelName:gp,backendName:"cpu",kernelFunc:kx};function b4(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(r.dtype==="complex64"){let a=Zl({inputs:{input:r},backend:n}),s=b4({inputs:{x:a},backend:n}),i=sd({inputs:{input:r},backend:n}),o=kx({inputs:{x:i},backend:n}),l=Fr({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return lC({backend:n,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}var efe={kernelName:Jd,backendName:"cpu",kernelFunc:b4};function v4(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(t.length===1)return wx({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let s=t[0].shape,i=t[0].dtype;t.forEach(u=>{k.assertShapesMatch(s,u.shape,"All tensors passed to stack must have matching shapes"),k.assert(i===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],l=t.map(u=>{let h=wx({inputs:{input:u},backend:n,attrs:{dim:a}});return o.push(h),h}),c=id({inputs:l,backend:n,attrs:{axis:a}});return o.forEach(u=>n.disposeIntermediateTensorInfo(u)),c}var tfe={kernelName:Qd,backendName:"cpu",kernelFunc:v4};function nfe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,constantValue:i}=r;Ie(a,"pad");let o=s.map((g,x)=>g[0]+a.shape[x]+g[1]),l=s.map(g=>g[0]),c=n.data.get(a.dataId).values,u=k.sizeFromShape(a.shape),h=a.shape.length,d=k.computeStrides(a.shape),p=k.sizeFromShape(o),f=o.length,m=k.computeStrides(o),y=k.getTypedArrayFromDType(a.dtype,p);i!==0&&y.fill(i);for(let g=0;g<u;g++){let x=k.indexToLoc(g,h,d).map((v,w)=>v+l[w]),b=k.locToIndex(x,f,m);y[b]=c[g]}return{dataId:n.write(y,o,a.dtype),shape:o,dtype:a.dtype}}var w4={kernelName:tc,backendName:"cpu",kernelFunc:nfe},rfe=Ht((e,t)=>Math.pow(e,t)),afe=hn(nc,rfe),sfe={kernelName:nc,backendName:"cpu",kernelFunc:afe};function ife(e){let{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:a,paramsDenseValues:s,indices:i}=t,o=a.map(y=>n.data.get(y.dataId).values),l=a.map(y=>y.shape),c=n.data.get(s.dataId).values,u=n.data.get(i.dataId).values,[h,d,p]=HL(o,l,c,s.shape,s.dtype,u,i.shape),f=h.map(y=>n.makeTensorInfo([y.length],"int32",y)),m=n.makeTensorInfo(p,s.dtype,d);return f.concat([m])}var ofe={kernelName:hb,backendName:"cpu",kernelFunc:ife};function lfe(e){let{inputs:t,backend:n}=e,{starts:r,limits:a,deltas:s}=t,i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[c,u]=qL(i,r.shape,r.dtype,o,a.shape,l,s.shape),h=n.makeTensorInfo([c.length],"int32",c),d=n.makeTensorInfo([u.length],r.dtype,u);return[h,d]}var ufe={kernelName:db,backendName:"cpu",kernelFunc:lfe};function cfe(e){let{inputs:t,backend:n,attrs:r}=e,{shape:a,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,c=n.data.get(a.dataId).values,u=n.data.get(s.dataId).values,h=n.data.get(i.dataId).values,d=o.map(y=>n.data.get(y.dataId).values),p=o.map(y=>y.shape),[f,m]=KL(c,a.shape,u,s.shape,s.dtype,h,i.shape,d,p,l);return n.makeTensorInfo(f,s.dtype,m)}var hfe={kernelName:pb,backendName:"cpu",kernelFunc:cfe};function dfe(e){let{backend:t,attrs:n}=e,{start:r,stop:a,dtype:s,step:i}=n,o=Q_(r,a,i,s);return t.makeTensorInfo([o.length],s,o)}var pfe={kernelName:qm,backendName:"cpu",kernelFunc:dfe},ffe=pt(sc,e=>1/e),mfe={kernelName:sc,backendName:"cpu",kernelFunc:ffe};function gfe(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r;Ie(a,"resizeBilinear");let l=k.computeStrides(a.shape),[c,u]=o,[h,d,p,f]=a.shape,m=n.data.get(a.dataId).values,y=new Float32Array(k.sizeFromShape([h,c,u,f])),g=[s&&c>1?d-1:d,s&&u>1?p-1:p],x=[s&&c>1?c-1:c,s&&u>1?u-1:u],b=0,v=g[0]/x[0],w=g[1]/x[1];for(let I=0;I<h;I++)for(let _=0;_<c;_++){let T;i?T=v*(_+.5)-.5:T=v*_;let A=Math.max(0,Math.floor(T)),M=T-A,F=Math.min(d-1,Math.ceil(T)),C=I*l[0]+A*l[1],D=I*l[0]+F*l[1];for(let L=0;L<u;L++){let O;i?O=w*(L+.5)-.5:O=w*L;let q=Math.max(0,Math.floor(O)),H=O-q,z=Math.min(p-1,Math.ceil(O)),K=C+q*l[2],Z=D+q*l[2],J=C+z*l[2],Q=D+z*l[2];for(let ne=0;ne<f;ne++){let oe=m[K+ne],ue=m[Z+ne],ve=m[J+ne],we=m[Q+ne],ge=oe+(ve-oe)*H,Te=ue+(we-ue)*H,$e=ge+(Te-ge)*M;y[b++]=$e}}}return n.makeTensorInfo([h,c,u,f],"float32",y)}var yfe={kernelName:lc,backendName:"cpu",kernelFunc:gfe};function xfe(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r;Ie([s,a],"resizeBilinearGrad");let o=k.computeStrides(a.shape),[l,c,u,h]=a.shape,[,d,p]=s.shape,f=new Float32Array(l*c*u*h),m=[i&&d>1?c-1:c,i&&p>1?u-1:u],y=[i&&d>1?d-1:d,i&&p>1?p-1:p],g=m[0]/y[0],x=m[1]/y[1],b=n.data.get(s.dataId).values,v=0;for(let w=0;w<l;w++){let I=w*o[0];for(let _=0;_<d;_++){let T=_*g,A=Math.floor(T),M=Math.min(Math.ceil(T),c-1),F=I+A*o[1],C=I+M*o[1],D=T-A,L=1-D;for(let O=0;O<p;O++){let q=O*x,H=Math.floor(q),z=Math.min(Math.ceil(q),u-1),K=q-H,Z=1-K,J=F+H*o[2],Q=F+z*o[2],ne=C+H*o[2],oe=C+z*o[2],ue=L*Z,ve=L*K,we=D*Z,ge=D*K;for(let Te=0;Te<h;Te++){let $e=b[v++];f[J+Te]+=$e*ue,f[Q+Te]+=$e*ve,f[ne+Te]+=$e*we,f[oe+Te]+=$e*ge}}}}return n.makeTensorInfo([l,u,c,h],"float32",f)}var bfe={kernelName:np,backendName:"cpu",kernelFunc:xfe};function vfe(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r;Ie(a,"resizeNearestNeighbor");let l=k.computeStrides(a.shape),[c,u]=o,[h,d,p,f]=a.shape,m=n.data.get(a.dataId).values,y=new Float32Array(h*c*u*f),g=[s&&c>1?d-1:d,s&&u>1?p-1:p],x=[s&&c>1?c-1:c,s&&u>1?u-1:u],b=g[0]/x[0],v=g[1]/x[1],w=0;for(let I=0;I<h;I++){let _=I*l[0];for(let T=0;T<c;T++){let A=i?b*(T+.5):b*T,M=Math.min(d-1,s?Math.round(A):Math.floor(A));i&&(M=Math.max(0,M));let F=_+M*l[1];for(let C=0;C<u;C++){let D=i?v*(C+.5):v*C,L=Math.min(p-1,s?Math.round(D):Math.floor(D));i&&(L=Math.max(0,L));let O=F+L*l[2];for(let q=0;q<f;q++){let H=m[O+q];y[w++]=H}}}}return n.makeTensorInfo([h,c,u,f],a.dtype,y)}var wfe={kernelName:oc,backendName:"cpu",kernelFunc:vfe};function kfe(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r;Ie([s,a],"resizeNearestNeighborGrad");let o=k.computeStrides(a.shape),l=k.computeStrides(s.shape),[c,u,h,d]=a.shape,[,p,f]=s.shape,m=new Float32Array(c*u*h*d),y=n.data.get(s.dataId).values,g=[i&&p>1?u-1:u,i&&f>1?h-1:h],x=[i&&p>1?p-1:p,i&&f>1?f-1:f],b=g[0]/x[0],v=g[1]/x[1],w=1/b,I=1/v,_=Math.ceil(w)*2+2,T=Math.ceil(I)*2+2;for(let A=0;A<c;A++){let M=A*o[0];for(let F=0;F<u;F++){let C=M+F*o[1],D=Math.floor(F*w),L=Math.floor(D-_/2);for(let O=0;O<h;O++){let q=C+O*o[2],H=Math.floor(O*I),z=Math.floor(H-T/2);for(let K=0;K<d;K++){let Z=0;for(let J=0;J<_;J++){let Q=J+L;if(Q<0||Q>=p)continue;let ne=M+Q*l[1],oe=Q*b,ue=Math.min(u-1,i?Math.round(oe):Math.floor(oe));if(F===ue)for(let ve=0;ve<T;ve++){let we=ve+z;if(we<0||we>=f)continue;let ge=ne+we*l[2],Te=we*v,$e=Math.min(h-1,i?Math.round(Te):Math.floor(Te));O===$e&&(Z+=y[ge+K])}}m[q+K]=Z}}}}return n.makeTensorInfo(a.shape,a.dtype,m)}var Sfe={kernelName:tp,backendName:"cpu",kernelFunc:kfe};function Ife(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r;Ie(a,"reverse");let i=a.shape.length,o=k.parseAxisParam(s,a.shape);if(i===0)return As({inputs:{x:a},backend:n});let l=new Yt(a.shape,a.dtype),c=n.bufferSync(a);for(let u=0;u<l.size;u++){let h=l.indexToLoc(u),d=h.slice();o.forEach(p=>d[p]=a.shape[p]-1-d[p]),l.set(c.get(...d),...h)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}var Nfe={kernelName:cc,backendName:"cpu",kernelFunc:Ife},_fe={kernelName:yp,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,{radians:a,fillValue:s,center:i}=t,o=n,l=k.getTypedArrayFromDType(r.dtype,k.sizeFromShape(r.shape)),[c,u,h,d]=r.shape,[p,f]=E.getImageCenter(i,u,h),m=255,y=Math.sin(a),g=Math.cos(a),x=o.data.get(r.dataId).values;for(let b=0;b<c;b++){let v=b*h*u*d;for(let w=0;w<u;w++){let I=w*(h*d);for(let _=0;_<h;_++){let T=_*d;for(let A=0;A<d;A++){let M=[c,w,_,A],F=M[2],C=M[1],D=(F-p)*g-(C-f)*y,L=(F-p)*y+(C-f)*g;D=Math.round(D+p),L=Math.round(L+f);let O=s;if(typeof s!="number"&&(A===3?O=m:O=s[A]),D>=0&&D<h&&L>=0&&L<u){let H=L*(h*d),z=D*d,K=v+H+z+A;O=x[K]}let q=v+I+T+A;l[q]=O}}}}return{dataId:o.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},Cfe=pt(hc,e=>{let t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1}),Tfe={kernelName:hc,backendName:"cpu",kernelFunc:Cfe};function Efe(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:s}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=E.calculateShapes(s,a,i),d=!0,p=n.bufferSync(a),f=n.bufferSync(s),m=Nl(p,f,i,h,c,l,o,u,0,d);return n.makeTensorInfo(i,m.dtype,m.values)}var Afe={kernelName:rp,backendName:"cpu",kernelFunc:Efe};function $fe(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<t?n=a+1:r=a;return r}function Mfe(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<=t?n=a+1:r=a;return r}function Ffe(e,t,n,r,a,s){let i=k.getArrayFromDType("int32",n*a);for(let o=0;o<n;++o){let l=e.slice(o*r,(o+1)*r),c=o*a;for(let u=0;u<a;++u)i[c+u]=s==="left"?$fe(l,t[u+c]):Mfe(l,t[u+c])}return i}function Rfe(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:i}=r,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,c=Ffe(o,l,a.shape[0],a.shape[1],s.shape[1],i);return n.makeTensorInfo(s.shape,"int32",c)}var Dfe={kernelName:sp,backendName:"cpu",kernelFunc:Rfe};function Ofe(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t;Ie([r,a,s],"select");let i=r.shape.length,o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,c=n.data.get(s.dataId).values,u=ca(a.dtype,s.dtype),h=k.makeZerosTypedArray(k.sizeFromShape(a.shape),u),d=0,p=i===0||i>1||a.shape.length===1?1:k.sizeFromShape(a.shape.slice(1));for(let f=0;f<o.length;f++)for(let m=0;m<p;m++)o[f]===1?h[d++]=l[f]:h[d++]=c[f];return n.makeTensorInfo(a.shape,u,h)}var zfe={kernelName:ip,backendName:"cpu",kernelFunc:Ofe},Pfe=E.SELU_SCALEALPHA,Lfe=E.SELU_SCALE,Bfe=pt(pc,e=>e>=0?Lfe*e:Pfe*(Math.exp(e)-1)),Wfe={kernelName:pc,backendName:"cpu",kernelFunc:Bfe},Ufe=pt(gc,e=>e<0?-1:e>0?1:0),Vfe={kernelName:gc,backendName:"cpu",kernelFunc:Ufe},jfe=pt(fc,e=>Math.sin(e)),Gfe={kernelName:fc,backendName:"cpu",kernelFunc:jfe},Hfe=pt(mc,e=>Math.sinh(e)),qfe={kernelName:mc,backendName:"cpu",kernelFunc:Hfe},Kfe=11920928955078125e-23,D$=Math.log(Kfe)+2,Xfe=pt(xc,e=>{let t=e>-D$,n=e<D$,r=Math.exp(e),a;return n?a=r:t?a=e:a=Math.log(1+r),a}),Zfe={kernelName:xc,backendName:"cpu",kernelFunc:Xfe};function Yfe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r;Ie([a],"spaceToBatchND");let o=k.sizeFromShape(s),l=[[0,0]];l.push(...i);for(let y=1+s.length;y<a.shape.length;++y)l.push([0,0]);let c=w4.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),u=E.getReshaped(c.shape,s,o,!1),h=E.getPermuted(u.length,s.length,!1),d=E.getReshapedPermuted(c.shape,s,o,!1),p=_t({inputs:{x:c},backend:n,attrs:{shape:u}}),f=kr({inputs:{x:p},backend:n,attrs:{perm:h}}),m=_t({inputs:{x:f},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}var Jfe={kernelName:lp,backendName:"cpu",kernelFunc:Yfe};function Qfe(e){let{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:s,defaultValue:i}=t;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${s.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${r.shape}`);if(a.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${a.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,c=n.data.get(s.dataId).values,u=n.data.get(i.dataId).values[0],[h,d,p,f,m]=YL(o,r.shape,r.dtype,l,a.dtype,c,u);return[n.makeTensorInfo(d,r.dtype,h),n.makeTensorInfo([d[0]],a.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(y=>Number(y)))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}var eme={kernelName:Km,backendName:"cpu",kernelFunc:Qfe};function tme(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:s}=t;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(a.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${a.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(n.data.get(a.dataId).values),o=n.data.get(r.dataId).values,l=Array.from(n.data.get(s.dataId).values),[c,u,h]=JL(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(u,r.dtype,c),n.makeTensorInfo([h.length],s.dtype,new Int32Array(h))]}var nme={kernelName:cp,backendName:"cpu",kernelFunc:tme};function rme(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(a.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${a.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${s.shape}`);if(a.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[c,u]=eC(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(u,r.dtype,c)}var ame={kernelName:Xm,backendName:"cpu",kernelFunc:rme};function sme(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(a.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${a.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${s.shape}`);if(a.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[c,u]=eC(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(u,r.dtype,c)}var ime={kernelName:Zm,backendName:"cpu",kernelFunc:sme};function ome(e){let{inputs:t,backend:n,attrs:r}=e,{sparseIndices:a,sparseValues:s,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:d}=E.calculateShapes(s,a,o),p=!1,f=n.bufferSync(a),m;switch(s.dtype){case"bool":{let y=n.bufferSync(s),g=!!n.data.get(i.dataId).values[0];m=Nl(f,y,o,d,u,c,l,h,g,p);break}case"float32":{let y=n.bufferSync(s),g=n.data.get(i.dataId).values[0];m=Nl(f,y,o,d,u,c,l,h,g,p);break}case"int32":{let y=n.bufferSync(s),g=n.data.get(i.dataId).values[0];m=Nl(f,y,o,d,u,c,l,h,g,p);break}case"string":{let y=n.bufferSync(s),g=k.decodeString(n.data.get(i.dataId).values[0]);m=Nl(f,y,o,d,u,c,l,h,g,p);break}default:throw new Error(`Unsupported type ${s.dtype}`)}return n.makeTensorInfo(o,m.dtype,m.values)}var lme={kernelName:hp,backendName:"cpu",kernelFunc:ome};function ume(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=r,o=k.parseAxisParam(i,a.shape)[0],l=E.prepareSplitSize(a,s,o),c=new Array(a.shape.length).fill(0),u=a.shape.slice();return l.map(h=>{let d=[...u];d[o]=h;let p=Yl({inputs:{x:a},backend:n,attrs:{begin:c,size:d}});return c[o]+=h,p})}var cme={kernelName:up,backendName:"cpu",kernelFunc:ume},hme={kernelName:Ym,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{let{x:n}=e,r=t;Ie(n,"square");let a=r.data.get(n.dataId).values,s=new Float32Array(a.length);for(let i=0;i<a.length;++i){let o=a[i];s[i]=o*o}return{dataId:r.write(s,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},dme=pt(Po,(e,t)=>{let n=t;return isNaN(e)?NaN:e>0?1:n.alpha}),pme={kernelName:Po,backendName:"cpu",kernelFunc:dme};function fme(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,end:i,strides:o,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:d}=r;Ie(a,"stridedSlice");let{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:y,isSimpleSlice:g,begin:x,end:b,strides:v}=ln.sliceInfo(a.shape,s,i,o,l,c,u,h,d),w;if(m)w=_t({inputs:{x:a},backend:n,attrs:{shape:f}});else if(y||g){k.assert(a.shape.length>=1,()=>`Input must have rank at least 1, got: ${a.shape.length}`);let I=ln.computeOutShape(x,b,v),_=Yl({inputs:{x:a},backend:n,attrs:{begin:x,size:I}});w=_t({inputs:{x:_},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(_)}else{let I=n.bufferSync(a),_=t4(p,I,v,x);w=n.makeTensorInfo(f,_.dtype,_.values)}return w}var mme={kernelName:dp,backendName:"cpu",kernelFunc:fme};function gme(e){let{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:c}=r,{data:u,dataSplits:h}=t,d=n.data.get(u.dataId).values,p=n.data.get(h.dataId).values,[f,m]=tC(d,p,a,s,i,o,l,c);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}var yme={kernelName:Qm,backendName:"cpu",kernelFunc:gme};function xme(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:s,delimiter:i}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let o=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values[0],[c,u,h]=nC(o,l,a),d=u.length;return[n.makeTensorInfo([d,2],"int32",c),n.makeTensorInfo([d],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(h))]}var bme={kernelName:eg,backendName:"cpu",kernelFunc:xme};function vme(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");let i=n.data.get(s.dataId).values,o=rC(i,a);return n.makeTensorInfo(s.shape,"int32",o)}var wme={kernelName:tg,backendName:"cpu",kernelFunc:vme},kme=pt(Ic,e=>Math.tan(e)),Sme={kernelName:Ic,backendName:"cpu",kernelFunc:kme},Ime=pt(Nc,e=>Math.tanh(e)),Nme={kernelName:Nc,backendName:"cpu",kernelFunc:Ime};function _me(e){let{inputs:t,backend:n}=e,{tensor:r,indices:a,updates:s}=t,{sliceRank:i,numUpdates:o,sliceSize:l,strides:c,outputSize:u}=E.calculateShapes(s,a,r.shape),h=!1,d=n.bufferSync(a),p=n.bufferSync(s),f=n.bufferSync(r),m=Nl(d,p,r.shape,u,l,o,i,c,f,h);return n.makeTensorInfo(r.shape,m.dtype,m.values)}var Cme={kernelName:ap,backendName:"cpu",kernelFunc:_me};function Tme(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:s}=r;Ie(a,"tile");let i=r4(n.bufferSync(a),s);return n.makeTensorInfo(i.shape,i.dtype,i.values)}var Eme={kernelName:zo,backendName:"cpu",kernelFunc:Tme};function Ame(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:s,sorted:i}=r;Ie(a,"topk");let o=n.data.get(a.dataId).values,[l,c]=s4(o,a.shape,a.dtype,s,i);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(c.shape,c.dtype,c.values)]}var $me={kernelName:pp,backendName:"cpu",kernelFunc:Ame};function Mme(e){let{inputs:t,attrs:n,backend:r}=e,{image:a,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:c}=n,[u,h,d,p]=a.shape,[f,m]=c??[h,d],y=[u,f,m,p],g=k.computeStrides(a.shape),x=g[0],b=g[1],v=g[2],w=k.computeStrides(y),I=w[0],_=w[1],T=w[2],A=k.getTypedArrayFromDType(a.dtype,k.sizeFromShape(y));A.fill(l);let M=r.data.get(a.dataId).values,F=r.data.get(s.dataId).values;for(let C=0;C<u;++C){let D=s.shape[0]===1?F:F.subarray(C*8,C*8+8);for(let L=0;L<f;++L)for(let O=0;O<m;++O)for(let q=0;q<p;++q){let H,z=D[6]*O+D[7]*L+1;if(z===0)continue;let K=(D[0]*O+D[1]*L+D[2])/z,Z=(D[3]*O+D[4]*L+D[5])/z,J=O$(K,d,o),Q=O$(Z,h,o);switch(i){case"nearest":H=Pme(M,h,d,x,b,v,C,Q,J,q,l);break;case"bilinear":H=Lme(M,h,d,x,b,v,C,Q,J,q,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}let ne=C*I+L*_+O*T+q;A[ne]=H}return r.makeTensorInfo(y,a.dtype,A)}return{dataId:r.write(A,y,a.dtype),shape:a.shape,dtype:a.dtype}}var Fme={kernelName:fp,backendName:"cpu",kernelFunc:Mme};function O$(e,t,n){switch(n){case"reflect":return Rme(e,t);case"wrap":return Dme(e,t);case"nearest":return zme(e,t);case"constant":default:return Ome(e)}}function Rme(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let r=2*t;n<r&&(n=r*Math.trunc(-n/r)+n),n=n<-t?n+r:-n-1}else if(n>t-1)if(t<=1)n=0;else{let r=2*t;n-=r*Math.trunc(n/r),n>=t&&(n=r-n-1)}return k.clamp(0,n,t-1)}function Dme(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let r=t-1;n+=t*(Math.trunc(-n/r)+1)}else if(n>t-1)if(t<=1)n=0;else{let r=t-1;n-=t*Math.trunc(n/r)}return k.clamp(0,n,t-1)}function Ome(e,t){return e}function zme(e,t){return k.clamp(0,e,t-1)}function xf(e,t,n,r,a,s,i,o,l,c,u){let h=i*r+o*a+l*s+c;return 0<=o&&o<t&&0<=l&&l<n?e[h]:u}function Pme(e,t,n,r,a,s,i,o,l,c,u){let h=Math.round(o),d=Math.round(l);return xf(e,t,n,r,a,s,i,h,d,c,u)}function Lme(e,t,n,r,a,s,i,o,l,c,u){let h=Math.floor(o),d=Math.floor(l),p=h+1,f=d+1,m=(f-l)*xf(e,t,n,r,a,s,i,h,d,c,u)+(l-d)*xf(e,t,n,r,a,s,i,h,f,c,u),y=(f-l)*xf(e,t,n,r,a,s,i,p,d,c,u)+(l-d)*xf(e,t,n,r,a,s,i,p,f,c,u);return(p-o)*m+(o-h)*y}function Bme(e){let{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t;Ie(s,"unique");let i=r.data.get(s.dataId).values,{outputValues:o,outputShape:l,indices:c}=sC(i,a,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,o),r.makeTensorInfo([c.length],"int32",c)]}var Wme={kernelName:ng,backendName:"cpu",kernelFunc:Bme};function Ume(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:s}=r;s<0&&(s+=a.shape.length);let i=a.shape.length,o=a.shape[s],l=new Array(i-1),c=0;for(let p=0;p<i;p++)p!==s&&(l[c++]=a.shape[p]);let u=new Array(i).fill(0),h=a.shape.slice();h[s]=1;let d=new Array(o);for(let p=0;p<d.length;p++){u[s]=p;let f=Yl({inputs:{x:a},backend:n,attrs:{begin:u,size:h}});d[p]=_t({inputs:{x:f},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(f)}return d}var Vme={kernelName:mp,backendName:"cpu",kernelFunc:Ume};function jme(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:s}=t,{numSegments:i}=r;Ie(a,"unsortedSegmentSum");let o=a.shape.length,l=s.shape.length,c=[],u=[],h=o-l,d=s;for(let f=0;f<h;++f){let m=wx({inputs:{input:d},backend:n,attrs:{dim:f+1}});d=m,u.push(m)}for(let f=0;f<i;++f){let m=k.createScalarValue(f,"int32"),y=n.makeTensorInfo([],"int32",m),g=_L({inputs:{a:y,b:d},backend:n}),x=Co({inputs:{x:g},backend:n,attrs:{dtype:"float32"}}),b=vv({inputs:{a:x,b:a},backend:n}),v=Mg({inputs:{x:b},backend:n,attrs:{axis:0,keepDims:!1}});c.push(v),u.push(y),u.push(g),u.push(x),u.push(b),u.push(v)}let p=v4({inputs:c,backend:n,attrs:{axis:0}});return u.forEach(f=>n.disposeIntermediateTensorInfo(f)),p}var Gme={kernelName:rg,backendName:"cpu",kernelFunc:jme},Hme=[Lce,xue,Wce,Vce,Iue,Gce,qce,Xce,Yce,Qce,the,rhe,she,lhe,che,phe,mhe,yhe,bhe,zce,whe,She,Nhe,_ue,Che,kue,Tue,Ehe,bue,$he,Fhe,Rhe,Ohe,Phe,Bhe,Uhe,jhe,Hhe,Khe,Zhe,Jhe,ede,nde,ade,sde,ode,ude,hde,dde,pde,fde,gde,bde,Ace,wde,Eue,Ede,Aue,Ade,Mue,Ode,zde,Lde,Rue,Oue,Wde,Vde,Gde,qde,Pue,Bue,vue,Xde,Mhe,Yde,Qde,tpe,$ce,Uue,jue,rpe,Hue,spe,lpe,cpe,ppe,mpe,ype,xpe,Kue,vpe,kpe,Ipe,_pe,Tpe,Ape,Mpe,Zue,Rpe,zpe,Wpe,Jue,ece,jpe,qpe,Zpe,nce,Jpe,efe,tfe,w4,sfe,Fce,sce,ofe,ufe,hfe,pfe,wue,t2,mfe,Rce,Dce,Oce,yfe,bfe,wfe,Sfe,Nfe,_fe,Tfe,fce,Afe,Dfe,zfe,Wfe,gce,Vfe,Gfe,qfe,yce,Lpe,Zfe,Jfe,eme,nme,ame,ime,lme,cme,vce,hme,kce,Ice,pme,mme,yme,bme,wme,Tce,yde,Sme,Nme,Cme,Eme,$me,Fme,rce,Wme,Vme,Gme,Qpe];for(let e of Hme)ag(e);var k4={};Re(k4,{assertNotComplex:()=>Ap,bindCanvasToFramebuffer:()=>rge,bindColorTextureToFramebuffer:()=>x0,bindTextureToProgramUniformSampler:()=>P4,bindTextureUnit:()=>D4,bindVertexBufferToProgramAttribute:()=>r2,callAndCheck:()=>fe,canBeRepresented:()=>I4,createFragmentShader:()=>C4,createFramebuffer:()=>R4,createProgram:()=>T4,createStaticIndexBuffer:()=>$4,createStaticVertexBuffer:()=>A4,createTexture:()=>M4,createVertexShader:()=>_4,getBatchDim:()=>Jl,getExtensionOrThrow:()=>bf,getFramebufferErrorMessage:()=>L4,getMaxTexturesInShader:()=>V4,getNumChannels:()=>tge,getProgramUniformLocation:()=>z4,getProgramUniformLocationOrThrow:()=>O4,getRowsCols:()=>Ql,getShapeAs3D:()=>wf,getTextureShapeFromLogicalShape:()=>W4,getWebGLDisjointQueryTimerVersion:()=>j4,getWebGLErrorMessage:()=>N4,getWebGLMaxTextureSize:()=>U4,hasExtension:()=>sa,isCapableOfRenderingToFloatTexture:()=>G4,isDownloadFloatTextureEnabled:()=>H4,isReshapeFree:()=>vm,isWebGLFenceEnabled:()=>q4,isWebGLVersionEnabled:()=>s2,linkProgram:()=>E4,logShaderSourceAndInfoLog:()=>cC,resetMaxTextureSize:()=>age,resetMaxTexturesInShader:()=>sge,unbindColorTextureFromFramebuffer:()=>a2,unbindTextureUnit:()=>nge,validateFramebuffer:()=>vf,validateProgram:()=>y0,validateTextureSize:()=>F4});var gl={},qy={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function S4(e,t){gl[e]=t}function rs(e,t){if(!(e in gl)||t!=null){let r=Kme(e,t);if(r!==null)gl[e]=r;else return console.log("Could not get context for WebGL version",e),null}let n=gl[e];return n==null||n.isContextLost()?(delete gl[e],rs(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),gl[e])}function qme(e){if(!X().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&e===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function Kme(e,t){if(e!==1&&e!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let n=t??qme(e);return n.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete gl[e]},!1),X().getBool("SOFTWARE_WEBGL_ENABLED")&&(qy.failIfMajorPerformanceCaveat=!1),e===1?n.getContext("webgl",qy)||n.getContext("experimental-webgl",qy):n.getContext("webgl2",qy)}var bm;(function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"})(bm||(bm={}));var aa;(function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"})(aa||(aa={}));var $n;(function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})($n||($n={}));function Fg(e,t){return[t,e]}function Xme(e,t){return e*t}function Ky(e){let t=k.sizeFromShape(e),n=Math.ceil(t/4);return k.sizeToSquarishShape(n)}function Ep(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function Zme(e,t){let[n,r]=Ep(e,t);return n*r*4}function uC(e,t){let n=e,r,a,s,i,o,l,c,u,h,d;return X().getNumber("WEBGL_VERSION")===2?(r=n.R32F,a=n.R16F,s=n.RGBA16F,i=n.RGBA32F,o=n.RED,c=4,u=1,h=n.HALF_FLOAT,d=n.FLOAT,l=n.RGBA8):(r=e.RGBA,a=e.RGBA,s=e.RGBA,i=n.RGBA,o=e.RGBA,c=4,u=4,h=t!=null?t.HALF_FLOAT_OES:null,d=e.FLOAT,l=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:a,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:i,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:u,textureTypeHalfFloat:h,textureTypeFloat:d}}function fe(e,t){let n=t();return X().getBool("DEBUG")&&Yme(e),n}function Yme(e){let t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+N4(e,t))}var Jme=596e-10,Qme=65504;function I4(e){return!!(X().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||e===0||Jme<Math.abs(e)&&Math.abs(e)<Qme)}function N4(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function bf(e,t){return vi(e,()=>e.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function _4(e,t){let n=vi(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(fe(e,()=>e.shaderSource(n,t)),fe(e,()=>e.compileShader(n)),e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function C4(e,t){let n=vi(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(fe(e,()=>e.shaderSource(n,t)),fe(e,()=>e.compileShader(n)),X().get("ENGINE_COMPILE_ONLY"))return n;if(e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw cC(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}var ege=/ERROR: [0-9]+:([0-9]+):/g;function cC(e,t){let n=ege.exec(t);if(n==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(e);return}let r=+n[1],a=e.split(`
`),s=a.length.toString().length+2,i=a.map((h,d)=>k.rightPad((d+1).toString(),s)+h),o=0;for(let h=0;h<i.length;h++)o=Math.max(i[h].length,o);let l=i.slice(0,r-1),c=i.slice(r-1,r),u=i.slice(r);console.log(l.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${k.rightPad(c[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join(`
`))}function T4(e){return vi(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}function E4(e,t){if(fe(e,()=>e.linkProgram(t)),!X().get("ENGINE_COMPILE_ONLY")&&e.getProgramParameter(t,e.LINK_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function y0(e,t){if(fe(e,()=>e.validateProgram(t)),e.getProgramParameter(t,e.VALIDATE_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function A4(e,t){let n=vi(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return fe(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),fe(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function $4(e,t){let n=vi(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return fe(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)),fe(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function tge(){return X().getNumber("WEBGL_VERSION")===2?1:4}function M4(e){return vi(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}function F4(e,t){let n=X().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){let r=`[${e}x${t}]`;throw new Error("Requested texture size "+r+" is invalid.")}if(e>n||t>n){let r=`[${e}x${t}]`,a=`[${n}x${n}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+a+".")}}function R4(e){return vi(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function r2(e,t,n,r,a,s,i){let o=e.getAttribLocation(t,n);return o===-1?!1:(fe(e,()=>e.bindBuffer(e.ARRAY_BUFFER,r)),fe(e,()=>e.vertexAttribPointer(o,a,e.FLOAT,!1,s,i)),fe(e,()=>e.enableVertexAttribArray(o)),!0)}function D4(e,t,n){B4(e,n),fe(e,()=>e.activeTexture(e.TEXTURE0+n)),fe(e,()=>e.bindTexture(e.TEXTURE_2D,t))}function nge(e,t){B4(e,t),fe(e,()=>e.activeTexture(e.TEXTURE0+t)),fe(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function O4(e,t,n){return vi(e,()=>e.getUniformLocation(t,n),'uniform "'+n+'" not present in program.')}function z4(e,t,n){return e.getUniformLocation(t,n)}function P4(e,t,n,r){fe(e,()=>D4(e,t,r)),fe(e,()=>e.uniform1i(n,r))}function rge(e){fe(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),fe(e,()=>e.viewport(0,0,e.canvas.width,e.canvas.height)),fe(e,()=>e.scissor(0,0,e.canvas.width,e.canvas.height))}function x0(e,t,n){fe(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),fe(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function a2(e,t){fe(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),fe(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function vf(e){let t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+L4(e,t))}function L4(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function vi(e,t,n){let r=fe(e,()=>t());if(r==null)throw new Error(n);return r}function B4(e,t){let n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){let a=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${a}.`)}}function Jl(e,t=2){return k.sizeFromShape(e.slice(0,e.length-t))}function Ql(e){if(e.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function wf(e){let t=[1,1,1];return e.length===0||e.length===1&&e[0]===1||(t=[Jl(e),...Ql(e)]),t}function W4(e,t=!1){let n=X().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=X().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&X().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),t&&(n=n*2,r=r*2,e=e.map((o,l)=>l>=e.length-2?k.nearestLargerEven(e[l]):e[l]),e.length===1&&(e=[2,e[0]])),e.length!==2&&(e=k.squeezeShape(e).newShape);let a=k.sizeFromShape(e),s=null;e.length<=1&&a<=n?s=[1,a]:e.length===2&&e[0]<=n&&e[1]<=n?s=e:e.length===3&&e[0]*e[1]<=n&&e[2]<=n?s=[e[0]*e[1],e[2]]:e.length===3&&e[0]<=n&&e[1]*e[2]<=n?s=[e[0],e[1]*e[2]]:e.length===4&&e[0]*e[1]*e[2]<=n&&e[3]<=n?s=[e[0]*e[1]*e[2],e[3]]:e.length===4&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(s=[e[0],e[1]*e[2]*e[3]]);let i=s!=null&&Math.max(...s)>r&&Math.min(...s)<=(t?2:1)&&Math.min(...s)>0;if(s==null||i)if(t){let o=Jl(e),l=2,c=2;e.length&&([l,c]=Ql(e)),a=o*(l/2)*(c/2),s=k.sizeToSquarishShape(a).map(u=>u*2)}else s=k.sizeToSquarishShape(a);return s}function Xy(e){return e%2===0}function vm(e,t){if(e=e.slice(-2),t=t.slice(-2),k.arraysEqual(e,t)||!e.length||!t.length||e[0]===0||e[1]===0||t[0]===0||t[1]===0)return!0;if(e.length!==t.length){let n=e[e.length-1],r=t[t.length-1];if(n===r||Xy(n)&&Xy(r)&&(e[0]===1||t[0]===1))return!0}return e[1]===t[1]&&Xy(e[0])&&Xy(t[0])}var b0,v0;function U4(e){if(b0==null){let t=rs(e);b0=t.getParameter(t.MAX_TEXTURE_SIZE)}return b0}function age(){b0=null}function sge(){v0=null}function V4(e){if(v0==null){let t=rs(e);v0=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,v0)}function j4(e){if(e===0)return 0;let t,n=rs(e);return sa(n,"EXT_disjoint_timer_query_webgl2")&&e===2?t=2:sa(n,"EXT_disjoint_timer_query")?t=1:t=0,t}function sa(e,t){return e.getExtension(t)!=null}function s2(e){try{if(rs(e)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function G4(e){if(e===0)return!1;let t=rs(e);if(e===1){if(!sa(t,"OES_texture_float"))return!1}else if(!sa(t,"EXT_color_buffer_float"))return!1;return i2(t)}function H4(e){if(e===0)return!1;let t=rs(e);if(e===1){if(!sa(t,"OES_texture_float")||!sa(t,"WEBGL_color_buffer_float"))return!1}else{if(sa(t,"EXT_color_buffer_float"))return i2(t);let n="EXT_color_buffer_half_float";if(sa(t,n)){let r=t.getExtension(n);return ige(t,r)}return!1}return i2(t)}function i2(e){let t=uC(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);let r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);let a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),a}function ige(e,t){let n=uC(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r),e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);let a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);let s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(a),s}function q4(e){return e!==2?!1:rs(e).fenceSync!=null}function Ap(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&k.assert(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}var Ne=X();Ne.registerFlag("HAS_WEBGL",()=>Ne.getNumber("WEBGL_VERSION")>0);Ne.registerFlag("WEBGL_VERSION",()=>s2(2)?2:s2(1)?1:0);Ne.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Ne.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Ne.get("WEBGL_VERSION")===2);Ne.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Ne.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Ne.registerFlag("WEBGL_PACK",()=>Ne.getBool("HAS_WEBGL"));Ne.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Ne.getBool("WEBGL_PACK"));Ne.registerFlag("WEBGL_PACK_CLIP",()=>Ne.getBool("WEBGL_PACK"));Ne.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Ne.getBool("WEBGL_PACK"));Ne.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Ne.getBool("WEBGL_PACK"));Ne.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Ne.getBool("WEBGL_PACK"));Ne.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Ne.getBool("WEBGL_PACK"));Ne.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Ne.getBool("WEBGL_PACK"));Ne.registerFlag("WEBGL_PACK_REDUCE",()=>Ne.getBool("WEBGL_PACK"));Ne.registerFlag("WEBGL_LAZILY_UNPACK",()=>Ne.getBool("WEBGL_PACK"));Ne.registerFlag("WEBGL_CONV_IM2COL",()=>Ne.getBool("WEBGL_PACK"));Ne.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>Ne.getBool("WEBGL_PACK"));Ne.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>U4(Ne.getNumber("WEBGL_VERSION")));Ne.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>V4(Ne.getNumber("WEBGL_VERSION")));Ne.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let e=Ne.getNumber("WEBGL_VERSION");return e===0?0:j4(e)});Ne.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Ne.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!og.isMobile());Ne.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>G4(Ne.getNumber("WEBGL_VERSION")));Ne.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Ne.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Ne.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Ne.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>H4(Ne.getNumber("WEBGL_VERSION")));Ne.registerFlag("WEBGL_FENCE_API_ENABLED",()=>q4(Ne.getNumber("WEBGL_VERSION")));Ne.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Ne.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Ne.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,e=>{if(typeof e!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&e!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)});Ne.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>og.isMobile()?1:-1,e=>{if(typeof e!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);if(e<0&&e!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)});Ne.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Ne.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Ne.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Ne.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);Ne.registerFlag("WEBGL_EXP_CONV",()=>!1);Ne.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Ne.getBool("IS_TEST"));Ne.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);Ne.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);Ne.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);Ne.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function lr(){let e,t,n,r,a,s,i,o,l,c;return X().getNumber("WEBGL_VERSION")===2?(e="#version 300 es",t="in",n="out",r="in",a="texture",s="outputColor",i="out vec4 outputColor;",o=X().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",c=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(e="",t="attribute",n="varying",r="varying",a="texture2D",s="gl_FragColor",i="",o=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,c=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:a,output:s,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:l,defineRound:c}}function Fc(e,t,n="index"){let r=k.computeStrides(t);return r.map((a,s)=>{let i=`int ${e[s]} = ${n} / ${a}`,o=s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * ${a}`:`index -= ${e[s]} * ${a}`;return`${i}; ${o};`}).join("")}function wv(e,t,n="index"){let r=k.computeStrides(t);return r.map((a,s)=>{let i=`int ${e[s]} = ${n} / outShapeStrides[${s}]`,o=s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * outShapeStrides[${s}]`:`index -= ${e[s]} * outShapeStrides[${s}]`;return`${i}; ${o};`}).join("")}function oge(e,t){let n=e.length,r=e.map(s=>`${t}[${s}]`),a=new Array(n-1);a[n-2]=r[n-1];for(let s=n-3;s>=0;--s)a[s]=`(${a[s+1]} * ${r[s+1]})`;return a}function lge(e,t,n="index"){let r=e.map((s,i)=>i),a=oge(r,t);return a.map((s,i)=>{let o=`int ${e[i]} = ${n} / ${a[i]}`,l=i===a.length-1?`int ${e[i+1]} = ${n} - ${e[i]} * ${a[i]}`:`index -= ${e[i]} * ${a[i]}`;return`${o}; ${l};`}).join("")}function hC(e){let t=k.computeStrides(e).map(n=>n.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function dC(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}var K4=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`,{getBroadcastDims:X4}=E;function uge(e,t,n){let r=[];if(e.forEach(d=>{let p=k.sizeFromShape(d.shapeInfo.logicalShape);if(d.shapeInfo.isUniform?r.push(`uniform float ${d.name}${p>1?`[${p}]`:""};`):(r.push(`uniform sampler2D ${d.name};`),r.push(`uniform int offset${d.name};`)),n.enableShapeUniforms){let{uniformShape:f}=pC(n.packedInputs,d.shapeInfo.logicalShape,d.shapeInfo.texShape);switch(f.length){case 1:r.push(`uniform int ${d.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${d.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${d.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${d.name}Shape;`);break}r.push(`uniform ivec2 ${d.name}TexShape;`)}}),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(d=>{r.push(`uniform ${d.type} ${d.name}${d.arrayIndex?`[${d.arrayIndex}]`:""};`)});let a=r.join(`
`),s=e.map(d=>cge(d,t,n.packedInputs,n.enableShapeUniforms)).join(`
`),i=t.texShape,o=lr(),l=pge(o),c,u,h=gge(o);return t.isPacked?(c=hge(t.logicalShape,i,n.enableShapeUniforms),u=mge(o)):(c=dge(t.logicalShape,i,n.enableShapeUniforms),u=fge(o)),n.packedInputs&&(h+=vge),[h,l,u,a,c,s,n.userCode].join(`
`)}function $p(e,t=!1){let n=e.shapeInfo.logicalShape;switch(n.length){case 0:return Mge(e,t);case 1:return Rge(e,t);case 2:return Oge(e,t);case 3:return Pge(e,t);case 4:return Bge(e,t);case 5:return Wge(e);case 6:return Uge(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function Z4(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return $ge(e);case 1:return Fge(e,t);case 2:return Dge(e,t);case 3:return zge(e,t);default:return Lge(e,t)}}function cge(e,t,n=!1,r){let a="";n?a+=Z4(e,r):a+=$p(e,r);let s=e.shapeInfo.logicalShape,i=t.logicalShape;return s.length<=i.length&&(n?a+=Vge(e,t):a+=jge(e,t)),a}function hge(e,t,n){switch(e.length){case 0:return Y4();case 1:return wge(e,t,n);case 2:return Ege(e,t,n);case 3:return Sge(e,t,n);default:return Nge(e,t,n)}}function dge(e,t,n){switch(e.length){case 0:return Y4();case 1:return kge(e,t,n);case 2:return Age(e,t,n);case 3:return Ige(e,t,n);case 4:return _ge(e,t,n);case 5:return Cge(e,t);case 6:return Tge(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}function pge(e){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${e.texture2D}(textureSampler, uv).r;
    }
  `}function fge(e){return`
    void setOutput(float val) {
      ${e.output} = vec4(val, 0, 0, 0);
    }
  `}function mge(e){return`
    void setOutput(vec4 val) {
      ${e.output} = val;
    }
  `}function gge(e){return`${e.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${e.varyingFs} vec2 resultUV;
    ${e.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${e.defineSpecialNaN}
    ${e.defineSpecialInf}
    ${e.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${yge}
    ${xge}
    ${bge}
  `}var yge=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,xge=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,bge=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,vge=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function Y4(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function wge(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return r[0]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `}function kge(e,t,n){return t[0]===1?n?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?n?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function Sge(e,t,n){if(n)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[2]/2),s=a*Math.ceil(e[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${a});
      int c = imod(index, ${a}) * 2;

      return ivec3(b, r, c);
    }
  `}function Ige(e,t,n){if(n)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${wv(["r","c","d"],e)}
    return ivec3(r, c, d);
  }
`;let r=Fc(["r","c","d"],e);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `}function Nge(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[e.length-1]/2),s=a*Math.ceil(e[e.length-2]/2),i=s,o="",l="b, r, c";for(let c=2;c<e.length-1;c++)i*=e[e.length-c-1],o=`
      int b${c} = index / ${i};
      index -= b${c} * ${i};
    `+o,l=`b${c}, `+l;return`
    ivec${e.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${o}

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${a});
      int c = imod(index, ${a}) * 2;

      return ivec${e.length}(${l});
    }
  `}function _ge(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${wv(["r","c","d","d2"],e)}
      return ivec4(r, c, d, d2);
    }
  `;let r=Fc(["r","c","d","d2"],e);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `}function Cge(e,t){let n=Fc(["r","c","d","d2","d3"],e);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function Tge(e,t){let n=Fc(["r","c","d","d2","d3","d4"],e);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function Ege(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(k.arraysEqual(e,t))return n?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;let a=Math.ceil(e[1]/2);return n?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${a});
      int c = imod(index, ${a}) * 2;

      return ivec2(r, c);
    }
  `}function Age(e,t,n){return k.arraysEqual(e,t)?n?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:e[1]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:e[0]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:n?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${e[1]};
      int c = index - r * ${e[1]};
      return ivec2(r, c);
    }
  `}function Rc(e){return`offset${e}`}function $ge(e){let t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=lr();return`
    vec4 ${n}() {
      return ${r.texture2D}(${t}, halfCR);
    }
  `}function Mge(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;let[a,s]=e.shapeInfo.texShape;if(a===1&&s===1)return`
      float ${r}() {
        return sampleTexture(${n}, halfCR);
      }
    `;let i=Rc(n);if(t)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});
      return sampleTexture(${n}, uv);
    }
  `;let[o,l]=e.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${o}, ${l}, ${i});
      return sampleTexture(${n}, uv);
    }
  `}function Fge(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=e.shapeInfo.texShape,s=lr();if(t)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${s.texture2D}(${n}, uv);
    }
  `;let i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${s.texture2D}(${n}, uv);
    }
  `}function Rge(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${Mp(e)}
      }
    `;let a=e.shapeInfo.texShape,s=a[0],i=a[1];if(i===1&&s===1)return`
      float ${r}(int index) {
        return sampleTexture(${n}, halfCR);
      }
    `;let o=Rc(n);return i===1?t?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${s}.0);
        return sampleTexture(${n}, uv);
      }
    `:s===1?t?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${n}, uv);
      }
    `:t?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${s}, ${i}, index + ${o});
      return sampleTexture(${n}, uv);
    }
  `}function Dge(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape,i=s[0],o=s[1],l=lr();if(s!=null&&k.arraysEqual(n,s))return t?`
      vec4 ${a}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${l.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${a}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);

        return ${l.texture2D}(${r}, uv);
      }
    `;if(t)return`
    vec4 ${a}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `;let c=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],u=Math.ceil(n[1]/2);return`
    vec4 ${a}(int row, int col) {
      vec2 uv = packedUVfrom2D(${u}, ${c[0]}, ${c[1]}, row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `}function Oge(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape;if(s!=null&&k.arraysEqual(n,s)){if(t)return`
      float ${a}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;let d=s[0],p=s[1];return`
    float ${a}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${p}.0, ${d}.0);
      return sampleTexture(${r}, uv);
    }
  `}let{newShape:i,keptDims:o}=k.squeezeShape(n),l=i;if(l.length<n.length){let d=Fp(e,l),p=["row","col"];return`
      ${$p(d,t)}
      float ${a}(int row, int col) {
        return ${a}(${Rp(p,o)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${a}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));
        ${Mp(e)}
      }
    `;let c=s[0],u=s[1],h=Rc(r);return u===1?t?`
      float ${a}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${a}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);
      return sampleTexture(${r}, uv);
    }
  `:c===1?t?`
      float ${a}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${a}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `:t?`
      float ${a}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${h};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `:`
  float ${a}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n[1]} + col + ${h};
    vec2 uv = uvFromFlat(${c}, ${u}, index);
    return sampleTexture(${r}, uv);
  }
`}function zge(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape,i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(n[0]===1){let d=n.slice(1),p=[1,2],f=Fp(e,d),m=["b","row","col"];return`
        ${Z4(f,t)}
        vec4 ${a}(int b, int row, int col) {
          return ${a}(${Rp(m,p)});
        }
      `}let o=lr();if(t)return`
    vec4 ${a}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${o.texture2D}(${r}, uv);
    }
  `;let l=i[0],c=i[1],u=Math.ceil(n[2]/2),h=u*Math.ceil(n[1]/2);return`
    vec4 ${a}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${c}, ${h}, ${u}, b, row, col);
      return ${o.texture2D}(${r}, uv);
    }
  `}function Pge(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[1]*n[2],i=n[2],{newShape:o,keptDims:l}=k.squeezeShape(n),c=o;if(c.length<n.length){let m=Fp(e,c),y=["row","col","depth"];return`
        ${$p(m,t)}
        float ${a}(int row, int col, int depth) {
          return ${a}(${Rp(y,l)});
        }
      `}if(e.shapeInfo.isUniform)return`
      float ${a}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${s}, ${i}, 1)));
        ${Mp(e)}
      }
    `;let u=e.shapeInfo.texShape,h=u[0],d=u[1],p=e.shapeInfo.flatOffset;if(d===s&&p==null)return t?`
      float ${a}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
        float ${a}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${d}.0, ${h}.0);
          return sampleTexture(${r}, uv);
        }
      `;if(d===i&&p==null)return t?`
      float ${a}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${a}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${h}.0);
      return sampleTexture(${r}, uv);
    }
  `;let f=Rc(r);return t?`
    float ${a}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${f};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `:`
      float ${a}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s} + col * ${i} + depth + ${f};
        vec2 uv = uvFromFlat(${h}, ${d}, index);
        return sampleTexture(${r}, uv);
      }
  `}function Lge(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=lr();if(t)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${a.texture2D}(${n}, uv);
    }
  `;let s=e.shapeInfo.logicalShape,i=s.length,o=e.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],c=l[0],u=l[1],h=Math.ceil(s[i-1]/2),d=h*Math.ceil(s[i-2]/2),p="int b, int row, int col",f=`b * ${d} + (row / 2) * ${h} + (col / 2)`;for(let m=2;m<i-1;m++)p=`int b${m}, `+p,d*=s[i-m-1],f=`b${m} * ${d} + `+f;return`
    vec4 ${r}(${p}) {
      int index = ${f};
      int texR = index / ${u};
      int texC = index - texR * ${u};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${c});
      return ${a.texture2D}(${n}, uv);
    }
  `}function Bge(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[3],i=n[2]*s,o=n[1]*i,{newShape:l,keptDims:c}=k.squeezeShape(n);if(l.length<n.length){let x=Fp(e,l),b=["row","col","depth","depth2"];return`
      ${$p(x,t)}
      float ${a}(int row, int col, int depth, int depth2) {
        return ${a}(${Rp(b,c)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${a}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${o}, ${i}, ${s}, 1)));
        ${Mp(e)}
      }
    `;let u=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,d=h[0],p=h[1],f=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,y=`int stride0 = ${r}Shape[1] * stride1;`;if(p===o&&u==null)return t?`
      float ${a}(int row, int col, int depth, int depth2) {
        ${f}
        ${m}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${a}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${d}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(p===s&&u==null)return t?`
      float ${a}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${a}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n[1]*n[2]}, ${n[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${d}.0);
        return sampleTexture(${r}, uv);
      }
    `;let g=Rc(r);return t?`
    float ${a}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${f}
      ${m}
      ${y}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${g});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${a}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${i} +
          depth * ${s} + depth2;
      vec2 uv = uvFromFlat(${d}, ${p}, index + ${g});
      return sampleTexture(${r}, uv);
    }
  `}function Wge(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=t[4],s=t[3]*a,i=t[2]*s,o=t[1]*i,{newShape:l,keptDims:c}=k.squeezeShape(t);if(l.length<t.length){let m=Fp(e,l),y=["row","col","depth","depth2","depth3"];return`
      ${$p(m)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${Rp(y,c)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${o}, ${i}, ${s}, ${a})) +
          depth3;
        ${Mp(e)}
      }
    `;let u=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,d=h[0],p=h[1];if(p===o&&u==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${s}, ${a}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${d}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(p===a&&u==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${d}.0);
        return sampleTexture(${n}, uv);
      }
    `;let f=Rc(n);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${i} + depth * ${s} +
          depth2 * ${a} + depth3 + ${f};
      vec2 uv = uvFromFlat(${d}, ${p}, index);
      return sampleTexture(${n}, uv);
    }
  `}function Uge(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:a,keptDims:s}=k.squeezeShape(t);if(a.length<t.length){let y=Fp(e,a),g=["row","col","depth","depth2","depth3","depth4"];return`
      ${$p(y)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${Rp(g,s)});
      }
    `}let i=t[5],o=t[4]*i,l=t[3]*o,c=t[2]*l,u=t[1]*c;if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${u}, ${c}, ${l}, ${o})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${Mp(e)}
      }
    `;let h=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,p=d[0],f=d[1];if(f===u&&h==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${c}, ${l}, ${o}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(f===i&&h==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;let m=Rc(n);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${u} + col * ${c} + depth * ${l} +
          depth2 * ${o} + depth3 * ${i} + depth4 + ${m};
      vec2 uv = uvFromFlat(${p}, ${f}, index);
      return sampleTexture(${n}, uv);
    }
  `}function Mp(e){let t=e.name,n=k.sizeFromShape(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`
    for (int i = 0; i < ${n}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function Vge(e,t){let n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",s=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,o=X4(e.shapeInfo.logicalShape,t.logicalShape),l=vt(i),c=i-s,u,h=["x","y","z","w","u","v"];s===0?u="":i<2&&o.length>=1?u="coords = 0;":u=o.map(y=>`coords.${h[y+c]} = 0;`).join(`
`);let d="";i<2&&s>0?d="coords":d=e.shapeInfo.logicalShape.map((y,g)=>`coords.${h[g+c]}`).join(", ");let p="return outputValue;",f=k.sizeFromShape(e.shapeInfo.logicalShape)===1,m=k.sizeFromShape(t.logicalShape)===1;if(s===1&&!f&&!m)p=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(f&&!m)i===1?p=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:p=`
        return vec4(outputValue.x);
      `;else if(o.length){let y=s-2,g=s-1;o.indexOf(y)>-1&&o.indexOf(g)>-1?p="return vec4(outputValue.x);":o.indexOf(y)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(g)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${a}() {
      ${l} coords = getOutputCoords();
      ${u}
      vec4 outputValue = get${r}(${d});
      ${p}
    }
  `}function jge(e,t){let n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",s=t.texShape,i=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===l&&e.shapeInfo.flatOffset==null&&k.arraysEqual(i,s))return`
      float ${a}() {
        return sampleTexture(${n}, resultUV);
      }
    `;let c=vt(l),u=X4(e.shapeInfo.logicalShape,t.logicalShape),h=l-o,d,p=["x","y","z","w","u","v"];o===0?d="":l<2&&u.length>=1?d="coords = 0;":d=u.map(m=>`coords.${p[m+h]} = 0;`).join(`
`);let f="";return l<2&&o>0?f="coords":f=e.shapeInfo.logicalShape.map((m,y)=>`coords.${p[y+h]}`).join(", "),`
    float ${a}() {
      ${c} coords = getOutputCoords();
      ${d}
      return get${r}(${f});
    }
  `}function vt(e){if(e<=1)return"int";if(e===2)return"ivec2";if(e===3)return"ivec3";if(e===4)return"ivec4";if(e===5)return"ivec5";if(e===6)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function pC(e,t,n){let{newShape:r,keptDims:a}=k.squeezeShape(t),s=t.length,i=e&&s===3&&t[0]===1,o=i?t.slice(1):r,l=!e&&s>1&&!k.arraysEqual(t,n)&&r.length<s||i;return{useSqueezeShape:l,uniformShape:l?o:t,keptDims:a}}function Fp(e,t){let n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function Rp(e,t){return t.map(n=>e[n]).join(", ")}function Gge(e,t,n,r){let a=n.map((u,h)=>{let d={logicalShape:u.shape,texShape:u.isUniform?null:u.texData.texShape,isUniform:u.isUniform,isPacked:u.isUniform?!1:u.texData.isPacked,flatOffset:null};return u.texData!=null&&u.texData.slice!=null&&u.texData.slice.flatOffset>0&&(d.flatOffset=u.texData.slice.flatOffset),{name:t.variableNames[h],shapeInfo:d}}),s=a.map(u=>u.shapeInfo),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},o=uge(a,i,t),l=C4(e.gl,o),c=e.createProgram(l);return X().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:o,webGLProgram:c,inShapeInfos:s,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(c),Object.assign({program:t,fragmentShader:l,source:o,webGLProgram:c,inShapeInfos:s,outShapeInfo:i},J4(e,t,c)))}function J4(e,t,n){let r=[],a=[],s,i,o,l=null,c=null;c=e.getUniformLocation(n,"NAN",!1),X().getNumber("WEBGL_VERSION")===1&&(l=e.getUniformLocation(n,"INFINITY",!1));let u=!1;for(let h of t.variableNames){let d={name:h,uniform:e.getUniformLocation(n,h,u),offset:e.getUniformLocation(n,`offset${h}`,u)};t.enableShapeUniforms&&(d.shape=e.getUniformLocation(n,`${h}Shape`,u),d.texShape=e.getUniformLocation(n,`${h}TexShape`,u)),r.push(d)}if(t.enableShapeUniforms&&(s=e.getUniformLocation(n,"outShape",u),o=e.getUniformLocation(n,"outShapeStrides",u),i=e.getUniformLocation(n,"outTexShape",u)),t.customUniforms)for(let h of t.customUniforms)a.push(e.getUniformLocation(n,h.name,u));return{variablesLocations:r,customUniformLocations:a,infLoc:l,nanLoc:c,outShapeLocation:s,outShapeStridesLocation:o,outTexShapeLocation:i}}function z$(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach((n,r)=>{let a=n.logicalShape,s=t[r],i=s.shape;if(!k.arraysEqual(a,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${a} and ${i} must match`);if(n.isUniform&&s.isUniform)return;let o=n.texShape,l=s.isUniform?null:s.texData.texShape;if(!k.arraysEqual(o,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${l} must match`)})}function Hge(e,t,n,r,a){t.program.enableShapeUniforms||(z$(t.inShapeInfos,n),z$([t.outShapeInfo],[r]));let s=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(s.texture,i[0],i[1]):e.setOutputMatrixTexture(s.texture,i[0],i[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),X().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&e.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&e.gl.uniform1f(t.nanLoc,NaN);for(let l=0;l<n.length;++l){let c=n[l],{uniform:u,offset:h,shape:d,texShape:p}=t.variablesLocations[l];if(d){let{uniformShape:f}=pC(t.program.packedInputs,c.shape,c.texData.texShape);switch(f.length){case 1:e.gl.uniform1iv(d,new Int32Array(f));break;case 2:e.gl.uniform2iv(d,new Int32Array(f));break;case 3:e.gl.uniform3iv(d,new Int32Array(f));break;case 4:e.gl.uniform4iv(d,new Int32Array(f));break}}if(p&&e.gl.uniform2i(p,c.texData.texShape[0],c.texData.texShape[1]),u!=null){if(c.isUniform){if(k.sizeFromShape(c.shape)<2)e.gl.uniform1f(u,c.uniformValues[0]);else{let f=c.uniformValues;f instanceof Float32Array||(f=new Float32Array(f)),e.gl.uniform1fv(u,f)}continue}c.texData.slice!=null&&h!=null&&e.gl.uniform1i(h,c.texData.slice.flatOffset),e.setInputMatrixTexture(c.texData.texture.texture,u,l)}}let o=t.outShapeLocation;if(o)switch(r.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(r.shape));break}if(t.outShapeStridesLocation){let l=k.computeStrides(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(l));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(l));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(l));break}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&a)for(let l=0;l<t.program.customUniforms.length;++l){let c=t.program.customUniforms[l],u=t.customUniformLocations[l],h=a[l];if(c.type==="float")e.gl.uniform1fv(u,h);else if(c.type==="vec2")e.gl.uniform2fv(u,h);else if(c.type==="vec3")e.gl.uniform3fv(u,h);else if(c.type==="vec4")e.gl.uniform4fv(u,h);else if(c.type==="int")e.gl.uniform1iv(u,h);else if(c.type==="ivec2")e.gl.uniform2iv(u,h);else if(c.type==="ivec3")e.gl.uniform3iv(u,h);else if(c.type==="ivec4")e.gl.uniform4iv(u,h);else throw Error(`uniform type ${c.type} is not supported yet.`)}e.executeProgram()}function qge(e,t,n){let r="";t.concat(n).forEach(i=>{let o=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!i.isUniform){let l=i.texData.texShape,{useSqueezeShape:c,uniformShape:u,keptDims:h}=pC(e.packedInputs,i.shape,l),d="",p="",f="";if(u.length===1&&e.packedInputs){let w=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];d=`${w[0]>1}_${w[1]>1}`}else if(u.length===2&&!e.packedInputs)p=`${u[0]>1}_${u[1]>1}`;else if(u.length>2&&!e.packedInputs){let w=k.computeStrides(u);f=`${w[0]===l[1]}_${w[w.length-1]===l[1]}`}let m=i.shape.length,y=u.length===2&&k.arraysEqual(i.shape,l),g=k.sizeFromShape(i.shape)===1,x=E.getBroadcastDims(i.shape,n.shape),b=!e.packedInputs&&m===n.shape.length&&k.arraysEqual(l,n.texData.texShape),v=e.packedInputs||u.length>2?"":`${l[0]>1}_${l[1]>1}`;r+=`${m}_${b}_${c?h:""}_${u.length}_${g}_${x}_${y}_${d}_${p}_${f}_${v}_${o}`}else{let l=i.isUniform?"uniform":i.texData.texShape;r+=`${i.shape}_${l}_${o}`}});let a=e.userCode,s=e.constructor.name;return s+="_"+r+"_"+a+`${X().getNumber("WEBGL_VERSION")}`,s}function Un(e){return X().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}var Kge=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=bm.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=lr();this.outputShape=e,this.enableShapeUniforms=Un(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?wv(["r","c","d"],e):Fc(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}},Xge=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=bm.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=lr();this.outputShape=e,this.enableShapeUniforms=Un(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?wv(["r","c","d"],e):Fc(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}},Zge=class{constructor(e){this.variableNames=["A"],this.outTexUsage=aa.DOWNLOAD;let t=lr();this.outputShape=e,this.userCode=`
      ${K4}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}},Yge=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=aa.DOWNLOAD;let t=lr();this.outputShape=e,this.userCode=`
      ${K4}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}},Jge={R:0,G:1,B:2,A:3},P$=class{constructor(e,t=!1,n="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let r=lr();this.outputShape=e,this.enableShapeUniforms=Un(this.outputShape.length);let a="result";t&&(a="floor(result * 255. + 0.5)");let s="";for(let i=0;i<n.length;i++){let o=n[i];s+=`
          if(offset == ${i}) {
            result = values[${Jge[o]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?dC():hC(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${n.length});

        flatIndex = idiv(flatIndex, ${n.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${r.texture2D}(A, uv);
          ${s}
        }
        ${r.output} = vec4(${a}, 0., 0., 0.);
      }
    `}},Qge=class{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=lr();this.outputShape=e,this.enableShapeUniforms=Un(this.outputShape.length);let r="",a="result";t&&(a="floor(result * 255. + 0.5)");for(let s=0;s<=1;s++)for(let i=0;i<=1;i++){let o=s*2+i;r+=`
          localCoords = coords;
          if(localCoords[2] + ${i} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${i};
          if (localCoords[1] + ${s} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${s};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${n.texture2D}(A, uv);

            if (offset == 0) {
              result[${o}] = values[0];
            } else if (offset == 1) {
              result[${o}] = values[1];
            } else if (offset == 2) {
              result[${o}] = values[2];
            } else {
              result[${o}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?dC():hC(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${n.output} = ${a};
        }
    `}},Q4={};Re(Q4,{bindVertexProgramAttributeStreams:()=>lB,createBufferFromOutputTexture:()=>hB,createFloat16MatrixTexture:()=>aB,createFloat16PackedMatrixTexture:()=>oB,createFloat32MatrixTexture:()=>rB,createIndexBuffer:()=>nB,createPackedMatrixTexture:()=>iB,createUnsignedBytesMatrixTexture:()=>sB,createVertexBuffer:()=>tB,createVertexShader:()=>eB,downloadByteEncodedFloatMatrixFromOutputTexture:()=>pB,downloadFloat32MatrixFromBuffer:()=>dB,downloadMatrixFromPackedOutputTexture:()=>mB,downloadPackedMatrixFromBuffer:()=>fB,getInternalFormatForFloat16MatrixTexture:()=>mC,getInternalFormatForFloat16PackedMatrixTexture:()=>xC,getInternalFormatForFloat32MatrixTexture:()=>fC,getInternalFormatForPackedMatrixTexture:()=>yC,getInternalFormatForUnsignedBytesMatrixTexture:()=>gC,uploadDenseMatrixToTexture:()=>uB,uploadPixelDataToTexture:()=>cB});function eB(e){let t=lr(),n=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return _4(e,n)}function tB(e){let t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return A4(e,t)}function nB(e){let t=new Uint16Array([0,1,2,2,1,3]);return $4(e,t)}function Rg(e,t,n,r,a,s){F4(t,n);let i=M4(e),o=e.TEXTURE_2D;return fe(e,()=>e.bindTexture(o,i)),fe(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),fe(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),fe(e,()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST)),fe(e,()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST)),X().getNumber("WEBGL_VERSION")===1?fe(e,()=>e.texImage2D(o,0,r,t,n,0,a,s,null)):fe(e,()=>e.texStorage2D(o,1,r,t,n)),fe(e,()=>e.bindTexture(e.TEXTURE_2D,null)),{texture:i,texShape:[n,t]}}function fC(e){return e.internalFormatFloat}function rB(e,t,n,r){let[a,s]=Fg(t,n);return Rg(e,a,s,fC(r),r.textureFormatFloat,e.FLOAT)}function mC(e){return e.internalFormatHalfFloat}function aB(e,t,n,r){let[a,s]=Fg(t,n);return Rg(e,a,s,mC(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function gC(e){return e.downloadTextureFormat}function sB(e,t,n,r){let[a,s]=Fg(t,n);return Rg(e,a,s,gC(r),e.RGBA,e.UNSIGNED_BYTE)}function yC(e){return e.internalFormatPackedFloat}function iB(e,t,n,r){let[a,s]=Ep(t,n);return Rg(e,a,s,yC(r),e.RGBA,e.FLOAT)}function xC(e){return e.internalFormatPackedHalfFloat}function oB(e,t,n,r){let[a,s]=Ep(t,n);return Rg(e,a,s,xC(r),e.RGBA,r.textureTypeHalfFloat)}function lB(e,t,n){return fe(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),r2(e,t,"clipSpacePos",n,3,20,0)&&r2(e,t,"uv",n,2,20,12)}function uB(e,t,n,r,a,s){fe(e,()=>e.bindTexture(e.TEXTURE_2D,t));let i,o,l;a instanceof Uint8Array?(i=new Uint8Array(n*r*4),o=e.UNSIGNED_BYTE,l=e.RGBA):(i=new Float32Array(n*r*4),o=e.FLOAT,l=s.internalFormatPackedFloat),i.set(a),X().getNumber("WEBGL_VERSION")===2?fe(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,o,i)):fe(e,()=>e.texImage2D(e.TEXTURE_2D,0,l,n,r,0,e.RGBA,o,i)),fe(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function cB(e,t,n){fe(e,()=>e.bindTexture(e.TEXTURE_2D,t)),n.data instanceof Uint8Array?X().getNumber("WEBGL_VERSION")===2?fe(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data)):fe(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data)):X().getNumber("WEBGL_VERSION")===2?fe(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n)):fe(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)),fe(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function hB(e,t,n,r){let a=e.createBuffer();fe(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,a));let s=4*4*t*n;return fe(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,s,e.STREAM_READ)),fe(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)),fe(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),a}function dB(e,t,n){let r=e,a=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,a),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),a}function pB(e,t,n,r){let[a,s]=Fg(t,n),i=4,o=new Uint8Array(Xme(t*n,i));return fe(e,()=>e.readPixels(0,0,a,s,r.downloadTextureFormat,e.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}function fB(e,t,n,r,a,s,i,o){let l=e,c=new Float32Array(Zme(s,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,c),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),c}function mB(e,t,n){let r=new Float32Array(t*n*4);return fe(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r)),r}var w0=class{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];let t=X().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,S4(t,e)):this.gl=rs(t),e=this.gl,X().getNumber("WEBGL_VERSION")===2){let a=e;this.createVertexArray=()=>fe(a,()=>a.createVertexArray()),this.bindVertexArray=s=>fe(a,()=>a.bindVertexArray(s)),this.deleteVertexArray=s=>fe(a,()=>a.deleteVertexArray(s)),this.getVertexArray=()=>fe(a,()=>a.getParameter(a.VERTEX_ARRAY_BINDING))}else if(e!=null){let a=e.getExtension("OES_vertex_array_object");if(a==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>fe(e,()=>a.createVertexArrayOES()),this.bindVertexArray=s=>fe(e,()=>a.bindVertexArrayOES(s)),this.deleteVertexArray=s=>fe(e,()=>a.deleteVertexArrayOES(s)),this.getVertexArray=()=>fe(e,()=>e.getParameter(a.VERTEX_ARRAY_BINDING_OES))}let n="WEBGL_color_buffer_float",r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),X().getNumber("WEBGL_VERSION")===1){let a="OES_texture_float",s="OES_texture_half_float";if(this.textureFloatExtension=bf(this.gl,a),sa(this.gl,s))this.textureHalfFloatExtension=bf(this.gl,s);else if(X().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),sa(this.gl,r))this.colorBufferHalfFloatExtension=bf(this.gl,r);else if(X().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",sa(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else if(sa(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=tB(this.gl),this.indexBuffer=nB(this.gl),this.framebuffer=R4(this.gl),this.textureConfig=uC(this.gl,this.textureHalfFloatExtension)}get debug(){return X().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let e=this.gl;fe(e,()=>e.finish()),fe(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),fe(e,()=>e.deleteFramebuffer(this.framebuffer)),fe(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),fe(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),fe(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),rB(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),aB(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),sB(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),cB(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),uB(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),oB(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),iB(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(a2(this.gl,this.framebuffer),this.outputTexture=null),fe(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>pB(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,r,a,s){return fB(this.gl,e,t,n,r,a,s,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return dB(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);let r=hB(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(X().getBool("WEBGL_FENCE_API_ENABLED")){let r=e,a=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{let s=r.clientWaitSync(a,0,0);return s===r.ALREADY_SIGNALED||s===r.CONDITION_SATISFIED},t=a}else X().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,X().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>mB(this.gl,t,n))}createProgram(e){this.throwIfDisposed();let t=this.gl;this.vertexShader==null&&(this.vertexShader=eB(t));let n=T4(t);fe(t,()=>t.attachShader(n,this.vertexShader)),fe(t,()=>t.attachShader(n,e)),E4(t,n);let r=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&y0(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);let t=this.gl;fe(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),lB(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(fe(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&y0(this.gl,this.program),fe(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?O4(this.gl,e,t):z4(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),fe(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),P4(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();let[r,a]=Ep(t,n);this.setOutputMatrixTextureDriver(e,r,a)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&y0(this.gl,this.program),vf(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let e=this.gl;if(this.debug){let t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}fe(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),fe(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=bf(this.gl,X().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(X().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let n=this.gl,r=this.getQueryTimerExtensionWebGL2(),a=n.createQuery();return n.beginQuery(r.TIME_ELAPSED_EXT,a),a}let e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(X().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let t=this.gl,n=this.getQueryTimerExtensionWebGL2();t.endQuery(n.TIME_ELAPSED_EXT);return}let e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await k.repeatedTry(()=>this.disposed||this.isQueryAvailable(e,X().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,X().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){let n=this.gl;return n.getQueryParameter(e,n.QUERY_RESULT)/1e6}else{let n=this.getQueryTimerExtensionWebGL1();return n.getQueryObjectEXT(e,n.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){let n=this.gl,r=this.getQueryTimerExtensionWebGL2(),a=n.getQueryParameter(e,n.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),a&&!this.disjoint}else{let n=this.getQueryTimerExtensionWebGL1(),r=n.getQueryObjectEXT(e,n.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){let e=eye(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){let{resolveFn:n}=this.itemsToPoll[t];n()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in X().platform&&(n=X().platform.setTimeoutCustom.bind(X().platform)),k.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),x0(this.gl,e,this.framebuffer),this.debug&&vf(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(x0(this.gl,this.outputTexture,this.framebuffer),this.debug&&vf(this.gl)):a2(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);let n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();let r=this.gl;x0(r,e,this.framebuffer),this.debug&&vf(r),this.outputTexture=e,fe(r,()=>r.viewport(0,0,t,n)),fe(r,()=>r.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),fe(this.gl,()=>this.gl.scissor(e,t,n,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}};function eye(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}var{addImpl:tye,bincountImpl:gB,bincountReduceImpl:nye,bitwiseAndImpl:rye,castImpl:aye,ceilImpl:sye,concatImpl:iye,equalImpl:oye,expImpl:lye,expm1Impl:uye,floorImpl:cye,gatherNdImpl:hye,gatherV2Impl:dye,greaterImpl:pye,greaterEqualImpl:fye,lessImpl:mye,lessEqualImpl:gye,linSpaceImpl:yye,logImpl:xye,maxImpl:bye,maximumImpl:vye,minimumImpl:wye,multiplyImpl:kye,negImpl:Sye,notEqualImpl:Iye,prodImpl:Nye,raggedGatherImpl:_ye,raggedRangeImpl:Cye,raggedTensorToTensorImpl:Tye,rangeImpl:Eye,rsqrtImpl:Aye,scatterImpl:$ye,sigmoidImpl:Mye,simpleAbsImpl:yB,sliceImpl:Fye,sparseFillEmptyRowsImpl:Rye,sparseReshapeImpl:Dye,sparseSegmentReductionImpl:xB,sqrtImpl:Oye,staticRegexReplaceImpl:zye,stridedSliceImpl:Pye,stringNGramsImpl:Lye,stringSplitImpl:Bye,stringToHashBucketFastImpl:Wye,subImpl:Uye,tileImpl:Vye,topKImpl:jye,transposeImpl:bC,uniqueImpl:Gye}=q_;function bB(e,t){return["x","y","z","w","u","v"].slice(0,t).map(n=>`${e}.${n}`)}function Jn(e,t){return t===1?[e]:bB(e,t)}function Hye(e,t){if(e===1)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}var qye=class{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=Un(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let t=Jn("rc",this.rank),n=vt(this.rank),r=this.getOutOfBoundsCondition(t),a=this.getSetup(t),s=this.getOutput(t);this.userCode=`
        void main() {
          ${n} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${a}

            setOutput(vec4(${s}));
          }
        }
      `}}getSourceCoordsArr(e){let t=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let a=`${n===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let s=2;s<this.rank;s++)a=`${e[e.length-1-s]},`+a;t.push(a)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";let t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${n};
      bool rEdge = rp1 >= ${r};
    `}getOutput(e){let t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}},vB=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=Un(this.outputShape.length);let n="";for(let r=0;r<4;r++){let a="thisRC = rc;";r%2===1&&(a+="thisRC.z += 1;"),r>1&&(a+="thisRC.y += 1;"),n+=`
        ${a}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${Kye(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?dC():hC(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${n}

        setOutput(result);
      }
    `}};function Kye(e,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?lge(["r","c","d"],"inputShape"):Fc(["r","c","d"],e)}
      return ivec3(r, c, d);
    }
  `}var Xye=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){let r=B$(t,n),a=W$(e,r,n);a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]);let s=L$(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=s,this.log();let o=this.freeTextures[a].pop();return this.usedTextures[a].push(o),o}let i;return r===$n.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===$n.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===$n.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===$n.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===$n.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[a].push(i),this.numUsedTextures++,this._numBytesAllocated+=s,this.log(),i}releaseTexture(e,t,n,r){if(this.freeTextures==null)return;let a=B$(n,r),s=W$(t,a,r);s in this.freeTextures||(this.freeTextures[s]=[]);let i=L$(t,a,this.gpgpu.gl,this.gpgpu.textureConfig,r),o=X().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");o!==-1&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[s].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;let l=this.usedTextures[s],c=l&&l.indexOf(e);if(c==null||c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[c]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;let e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);let t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(let e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function Zye(e,t){let n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F||t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function L$(e,t,n,r,a){let s=Yye(t,r),i;if(a){let[l,c]=Ep(e[0],e[1]);i=l*c}else{let[l,c]=Fg(e[0],e[1]);i=l*c}let o=Zye(n,s);return i*o}function Yye(e,t){switch(e){case $n.PACKED_2X2_FLOAT32:return yC(t);case $n.PACKED_2X2_FLOAT16:return xC(t);case $n.UNPACKED_FLOAT32:return fC(t);case $n.UNPACKED_FLOAT16:return mC(t);case $n.PACKED_4X1_UNSIGNED_BYTE:return gC(t);default:throw new Error(`Unknown physical texture type ${e}`)}}function Jye(e){return X().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?$n.PACKED_2X2_FLOAT32:$n.UNPACKED_FLOAT32:e?$n.PACKED_2X2_FLOAT16:$n.UNPACKED_FLOAT16}function B$(e,t){if(e===aa.UPLOAD)return $n.PACKED_2X2_FLOAT32;if(e===aa.RENDER||e==null)return Jye(t);if(e===aa.DOWNLOAD||e===aa.PIXELS)return $n.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function W$(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}var ws=class{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=Un(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}},Fa="if (isnan(x)) return x;",Qye="return x;",U$="return abs(x);",e0e="return (x >= 0.0) ? x : (exp(x) - 1.0);",t0e=Fa+`
  return (x < 0.0) ? 0.0 : x;
`,n0e=Fa+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Wi="return x;",r0e="return 1.0 / (1.0 + exp(-1.0 * x));",a0e="return x;",s0e=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,i0e=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,o0e=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,l0e="return 1.0 / (1.0 + exp(-1.0 * x));",Yi=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=Un(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}},u0e=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=Un(this.outputShape.length);let t=e.length,n=Jn("rc",t),r=vt(t),a=Hye(t,n),s=n.slice(-2),i=t<=1?"rc":`vec2(${s.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${a});

        setOutput(getChannel(packedInput, ${i}));
      }
    `}},c0e=Fs.whereImpl,h0e=1e-7,d0e=1e-4,t1={};function p0e(e){return e in t1||(t1[e]={}),t1[e]}var f0e=X().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),m0e=600;function g0e(){return X().global.screen==null?1024:X().global.screen.height*X().global.screen.width*window.devicePixelRatio*m0e/1024/1024}var vC=class wB extends Dm{nextDataId(){return wB.nextDataId++}constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!X().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let n;if(t!=null){if(t instanceof w0)n=t;else{let r=rs(X().getNumber("WEBGL_VERSION"),t);n=new w0(r)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let r=rs(X().getNumber("WEBGL_VERSION"));n=new w0(r),this.binaryCache=p0e(X().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=n,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Xye(this.gpgpu),this.numMBBeforeWarning=g0e(),this.texData=new Qx(this,wa())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(t,n,r,a,s,i){let o=this.makeTensorInfo(n,r),l=this.texData.get(o.dataId);l.isPacked=!1,l.texture={texture:t,texShape:[a,s]},l.texShape=[a,s];let c=wf(n),u=new P$(c,!1,i),h=this.runWebGLProgram(u,[o],r,[[a,s]]);return h.shape=n,l.texture=null,this.disposeIntermediateTensorInfo(o),h.dataId}write(t,n,r){if((X().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||X().getBool("DEBUG"))&&this.checkNumericalProblems(t),r==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let a={id:this.nextDataId()};return this.texData.set(a,{shape:n,dtype:r,values:t,usage:aa.UPLOAD,refCount:1}),a}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){let n=this.texData.get(t);n.refCount++}decRef(t){if(this.texData.has(t)){let n=this.texData.get(t);n.refCount--}}move(t,n,r,a,s){if(X().getBool("DEBUG")&&this.checkNumericalProblems(n),a==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:r,dtype:a,values:n,usage:aa.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){let n=this.texData.get(t),{values:r,dtype:a,complexTensorInfos:s,slice:i,shape:o,isPacked:l}=n;if(i!=null){let d;l?d=new Yi(o,Wi):d=new ws(o,Wi);let p=this.runWebGLProgram(d,[{dataId:t,shape:o,dtype:a}],a),f=this.readSync(p.dataId);return this.disposeIntermediateTensorInfo(p),f}if(r!=null)return this.convertAndCacheOnCPU(t);if(a==="string")return r;let c=this.activeTimers!=null,u;c&&(u=k.now());let h;if(a==="complex64"){let d=this.readSync(s.real.dataId),p=this.readSync(s.imag.dataId);h=E.mergeRealAndImagArrays(d,p)}else h=this.getValuesFromTexture(t);return c&&(this.downloadWaitMs+=k.now()-u),this.convertAndCacheOnCPU(t,h)}async read(t){if(this.pendingRead.has(t)){let f=this.pendingRead.get(t);return new Promise(m=>f.push(m))}let n=this.texData.get(t),{values:r,shape:a,slice:s,dtype:i,complexTensorInfos:o,isPacked:l}=n;if(s!=null){let f;l?f=new Yi(a,Wi):f=new ws(a,Wi);let m=this.runWebGLProgram(f,[{dataId:t,shape:a,dtype:i}],i),y=this.read(m.dataId);return this.disposeIntermediateTensorInfo(m),y}if(r!=null)return this.convertAndCacheOnCPU(t);if(X().getBool("DEBUG")&&!X().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&X().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c=null,u;if(i!=="complex64"&&X().get("WEBGL_BUFFER_SUPPORTED")){u=this.decode(t);let f=this.texData.get(u.dataId);c=this.gpgpu.createBufferFromTexture(f.texture.texture,...Ky(a))}this.pendingRead.set(t,[]),i!=="complex64"&&await this.gpgpu.createAndWaitForFence();let h;if(i==="complex64"){let f=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),m=f[0],y=f[1];h=E.mergeRealAndImagArrays(m,y)}else if(c==null)h=this.getValuesFromTexture(t);else{let f=k.sizeFromShape(a);h=this.gpgpu.downloadFloat32MatrixFromBuffer(c,f)}if(u!=null&&this.disposeIntermediateTensorInfo(u),c!=null){let f=this.gpgpu.gl;fe(f,()=>f.deleteBuffer(c))}let d=this.convertAndCacheOnCPU(t,h),p=this.pendingRead.get(t);return this.pendingRead.delete(t),p.forEach(f=>f(d)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&wa().removeDataId(t,this),this.pendingDeletes--),d}readToGPU(t,n={}){let r=this.texData.get(t),{values:a,shape:s,slice:i,dtype:o,isPacked:l,texture:c}=r;if(o==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(i!=null){let p;l?p=new Yi(s,Wi):p=new ws(s,Wi);let f=this.runWebGLProgram(p,[{dataId:t,shape:s,dtype:o}],o),m=this.readToGPU(f,n);return this.disposeIntermediateTensorInfo(f),m}if(c==null)throw a!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let u=this.decode(t,n.customTexShape),h=wa().makeTensorFromTensorInfo(u),d=this.texData.get(u.dataId);return Object.assign({tensorRef:h},d.texture)}bufferSync(t){let n=this.readSync(t.dataId);if(t.dtype==="string")try{let r=n.map(a=>k.decodeString(a));return Ve(t.shape,t.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Ve(t.shape,t.dtype,n)}checkNumericalProblems(t){if(t!=null)for(let n=0;n<t.length;n++){let r=t[n];if(!I4(r))throw X().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${r} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${r} cannot be represented on this device.`)}}getValuesFromTexture(t){let{shape:n,dtype:r,isPacked:a}=this.texData.get(t),s=k.sizeFromShape(n);if(X().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let d=this.decode(t),p=this.texData.get(d.dataId),f=this.gpgpu.downloadMatrixFromPackedTexture(p.texture.texture,...Ky(n)).subarray(0,s);return this.disposeIntermediateTensorInfo(d),f}let i=X().getBool("WEBGL_PACK")&&a===!0,o=i?wf(n):n,l=i?new Yge(o):new Zge(o),c=this.runWebGLProgram(l,[{shape:o,dtype:r,dataId:t}],"float32"),u=this.texData.get(c.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(c),h}timerAvailable(){return X().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){let n=this.activeTimers,r=[],a=!1;this.programTimersStack==null?(this.programTimersStack=r,a=!0):this.activeTimers.push(r),this.activeTimers=r,t();let s=k.flatten(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),i=k.flatten(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=n,a&&(this.programTimersStack=null);let o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(X().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let l=await Promise.all(s);o.kernelMs=k.sum(l),o.getExtraProfileInfo=()=>l.map((c,u)=>({name:i[u],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return X().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:k.now(),endMs:null}}endTimer(t){return X().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=k.now(),t)}async getQueryTime(t){if(X().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);let n=t;return n.endMs-n.startMs}disposeData(t,n=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(n?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!n&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);let{complexTensorInfos:r}=this.texData.get(t);return r!=null&&(this.disposeData(r.real.dataId,n),this.disposeData(r.imag.dataId,n)),this.texData.delete(t),!0}releaseGPUData(t){let{texture:n,dtype:r,texShape:a,usage:s,isPacked:i,slice:o}=this.texData.get(t),l=o&&o.origDataId||t,c=this.dataRefCount.get(l);c>1?this.dataRefCount.set(l,c-1):(this.dataRefCount.delete(l),n!=null&&(this.numBytesInGPU-=this.computeBytes(a,r),this.textureManager.releaseTexture(n,a,s,i)));let u=this.texData.get(t);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,n=f0e){return X().getBool("WEBGL_CPU_FORWARD")&&t.every(r=>this.texData.get(r.dataId).texture==null&&k.sizeFromShape(r.shape)<n)}getGPGPUContext(){return this.gpgpu}where(t){E.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let n=t.dataSync();return c0e(t.shape,n)}packedUnaryOp(t,n,r){let a=new Yi(t.shape,n),s=this.compileAndRun(a,[t],r);return wa().makeTensorFromTensorInfo(s)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){let a=yB(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,a)}if(X().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,U$,t.dtype);let n=new ws(t.shape,U$),r=this.compileAndRun(n,[t]);return wa().makeTensorFromTensorInfo(r)}makeTensorInfo(t,n,r){let a;if(n==="string"&&r!=null&&r.length>0&&k.isString(r[0])){let s=r.map(i=>k.encodeString(i));a=this.write(s,t,n)}else a=this.write(r,t,n);return this.texData.get(a).usage=null,{dataId:a,shape:t,dtype:n}}makeOutput(t,n,r){return wa().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,r),this)}unpackTensor(t){let n=new u0e(t.shape);return this.runWebGLProgram(n,[t],t.dtype)}packTensor(t){let n=new qye(t.shape);return this.runWebGLProgram(n,[t],t.dtype,null,!0)}packedReshape(t,n){let r=[Jl(t.shape),...Ql(t.shape)],a={dtype:t.dtype,shape:r,dataId:t.dataId},s=[Jl(n),...Ql(n)],i=new vB(s,r),o=!0,l=[r],c=this.runWebGLProgram(i,[a],t.dtype,l,o);return{dataId:c.dataId,shape:n,dtype:c.dtype}}decode(t,n){let r=this.texData.get(t),{isPacked:a,shape:s,dtype:i}=r;if(n!=null){let d=k.sizeFromShape(s),p=n[0]*n[1]*4;k.assert(d<=p,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}let o=wf(s),l;a?l=new Xge(o):l=new Kge(o);let c=!0,u=[n??Ky(o)],h=this.runWebGLProgram(l,[{shape:o,dtype:i,dataId:t}],i,u,c,n);return{dtype:i,shape:s,dataId:h.dataId}}runWebGLProgram(t,n,r,a,s=!1,i){let o=this.makeTensorInfo(t.outputShape,r),l=this.texData.get(o.dataId);if(t.packedOutput&&(l.isPacked=!0),t.outPackingScheme===bm.DENSE){let g=i??Ky(t.outputShape);l.texShape=g.map(x=>x*2)}if(t.outTexUsage!=null&&(l.usage=t.outTexUsage),k.sizeFromShape(o.shape)===0)return l.values=k.getTypedArrayFromDType(o.dtype,0),o;let c=[],u=n.map(g=>{if(g.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let x=this.texData.get(g.dataId);if(x.texture==null){if(!t.packedInputs&&k.sizeFromShape(g.shape)<=X().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:g.shape,texData:null,isUniform:!0,uniformValues:x.values};t.packedInputs&&(x.isPacked=!0,x.shape=g.shape)}if(this.uploadToGPU(g.dataId),!!x.isPacked!=!!t.packedInputs)g=x.isPacked?this.unpackTensor(g):this.packTensor(g),c.push(g),x=this.texData.get(g.dataId);else if(x.isPacked&&!vm(x.shape,g.shape)){let b=g,v=g.shape;g.shape=x.shape,g=this.packedReshape(g,v),c.push(g),x=this.texData.get(g.dataId),b.shape=v}return{shape:g.shape,texData:x,isUniform:!1}});this.uploadToGPU(o.dataId);let h={shape:o.shape,texData:l,isUniform:!1},d=qge(t,u,h),p=this.getAndSaveBinary(d,()=>Gge(this.gpgpu,t,u,h)),f=this.activeTimers!=null,m;f&&(m=this.startTimer()),X().get("ENGINE_COMPILE_ONLY")||Hge(this.gpgpu,p,u,h,a),c.forEach(g=>this.disposeIntermediateTensorInfo(g)),f&&(m=this.endTimer(m),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(m)}));let y=X().getNumber("WEBGL_FLUSH_THRESHOLD");if(y>0){let g=k.now();g-this.lastGlFlushTime>y&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=g)}if(!X().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&s===!1){let g=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),g}return o}compileAndRun(t,n,r,a,s=!1){return r=r||n[0].dtype,this.runWebGLProgram(t,n,r,a,s)}getAndSaveBinary(t,n){return t in this.binaryCache||(this.binaryCache[t]=n()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(X().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=j(()=>{if(!X().get("WEBGL_RENDER_FLOAT32_ENABLED")){let t=X().getBool("DEBUG");X().set("DEBUG",!1);let n=this.abs(_e(1e-8)).dataSync()[0];if(X().set("DEBUG",t),n>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?h0e:d0e}uploadToGPU(t){let n=this.texData.get(t),{shape:r,dtype:a,values:s,texture:i,usage:o,isPacked:l}=n;if(i!=null)return;let c=this.activeTimers!=null,u;c&&(u=k.now());let h=n.texShape;if(h==null&&(h=W4(r,l),n.texShape=h),s!=null){let d=wf(r),p,f=h[1],m=h[0],y=s instanceof Uint8Array||s instanceof Uint8ClampedArray;(l||!y)&&([f,m]=Ep(h[0],h[1])),l?p=new Qge(d,y):p=new P$(d,y);let g=y?[m,f]:h,x=this.makeTensorInfo(g,a),b=this.texData.get(x.dataId);y?b.usage=aa.PIXELS:b.usage=aa.UPLOAD,b.texShape=g,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(x.dataId),f,m,s);let v=[[m,f]],w=this.runWebGLProgram(p,[x],a,v,!0),I=this.texData.get(w.dataId);n.texShape=I.texShape,n.isPacked=I.isPacked,n.usage=I.usage,X().get("ENGINE_COMPILE_ONLY")?this.disposeData(w.dataId):(n.texture=I.texture,n.values=null,this.texData.delete(w.dataId)),this.disposeIntermediateTensorInfo(x),c&&(this.uploadWaitMs+=k.now()-u)}else{let d=this.acquireTexture(h,o,a,l);n.texture=d}}convertAndCacheOnCPU(t,n){let r=this.texData.get(t),{dtype:a}=r;return n!=null&&(r.values=y0e(n,a)),r.values}acquireTexture(t,n,r,a){if(this.numBytesInGPU+=this.computeBytes(t,r),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let s=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${s} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,n,a)}computeBytes(t,n){return t[0]*t[1]*k.bytesPerElement(n)}checkCompileCompletion(){for(let[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){let t=[];if(this.gpgpu.parallelCompilationExtension){for(let[,n]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(n));return Promise.all(t)}else{for(let[,n]of Object.entries(this.binaryCache)){let r=new Promise(a=>{try{this.checkCompletion_(n),a(!0)}catch(s){throw s}});t.push(r)}return Promise.all(t)}}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await uN(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(cC(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let t of Object.values(this.binaryCache)){this.gpgpu.buildVao(t.webGLProgram);let{variablesLocations:n,customUniformLocations:r,infLoc:a,nanLoc:s,outShapeLocation:i,outShapeStridesLocation:o,outTexShapeLocation:l}=J4(this.gpgpu,t.program,t.webGLProgram);t.variablesLocations=n,t.customUniformLocations=r,t.infLoc=a,t.nanLoc=s,t.outShapeLocation=i,t.outShapeStridesLocation=o,t.outTexShapeLocation=l}}createTensorFromGPUData(t,n,r){t.channels=t.channels||"RGBA";let{texture:a,height:s,width:i,channels:o}=t,l=wa().backend;if(!l.gpgpu.gl.isTexture(a))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");let c=l.writeTexture(a,n,r,s,i,o);return wa().makeTensorFromDataId(c,n,r,l)}};vC.nextDataId=0;function y0e(e,t){if(t==="float32"||t==="complex64")return e;if(t==="int32"||t==="bool"){let n=t==="int32"?new Int32Array(e.length):new Uint8Array(e.length);for(let r=0;r<n.length;++r)n[r]=Math.round(e[r]);return n}else throw new Error(`Unknown dtype ${t}`)}var x0e="4.22.0";function kB(){X().set("WEBGL_FORCE_F16_TEXTURES",!0)}og.isBrowser()&&yb("webgl",()=>new vC,2);var b0e={forceHalfFloat:kB},wC=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,eu=class{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=E.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=Un(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}},Dc=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`,Dp=class{constructor(e,t,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=E.assertAndGetBroadcastShape(t,n);let a=this.outputShape.length;this.enableShapeUniforms=Un(a);let s="";if(r)if(a===0||k.sizeFromShape(this.outputShape)===1)s=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(s=`
          ${vt(a)} coords = getOutputCoords();
        `,a===1)this.enableShapeUniforms?s+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:s+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let i=Jn("coords",a);this.enableShapeUniforms?s+=`
            bool nextRowOutOfBounds =
              (${i[a-2]} + 1) >= outShape[${a} - 2];
            bool nextColOutOfBounds =
              (${i[a-1]} + 1) >= outShape[${a} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:s+=`
            bool nextRowOutOfBounds =
              (${i[a-2]} + 1) >= ${this.outputShape[a-2]};
            bool nextColOutOfBounds =
              (${i[a-1]} + 1) >= ${this.outputShape[a-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${s}

        setOutput(result);
      }
    `}};function Hr(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var v0e={kernelName:zu,backendName:"webgl",kernelFunc:Hr};function Go(e){let{inputs:t,backend:n}=e,{real:r,imag:a}=t,s=n.makeTensorInfo(r.shape,"complex64"),i=n.texData.get(s.dataId),o=Hr({inputs:{x:r},backend:n}),l=Hr({inputs:{x:a},backend:n});return i.complexTensorInfos={real:o,imag:l},s}var w0e={kernelName:nb,backendName:"webgl",kernelFunc:Go},SB="return (a < 0.) ? b * a : a;",IB=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function k0e(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:s}=r,i=n.makeTensorInfo([],"float32",k.createScalarValue(s,"float32")),o=X().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Dp(IB,a.shape,i.shape):new eu(SB,a.shape,i.shape),l=n.runWebGLProgram(o,[a,i],"float32");return n.disposeIntermediateTensorInfo(i),l}var S0e={kernelName:Wu,backendName:"webgl",kernelFunc:k0e},NB="return (a < 0.) ? b * a : a;",_B=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function I0e(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t,s=X().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Dp(_B,r.shape,a.shape):new eu(NB,r.shape,a.shape);return n.runWebGLProgram(s,[r,a],"float32")}var N0e={kernelName:rc,backendName:"webgl",kernelFunc:I0e},Op="if (isnan(x)) return x;";function nt({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return({inputs:a,backend:s})=>{let{x:i}=a,o=s,l=r||i.dtype;if(o.shouldExecuteOnCPU([i])&&n!=null){let h=o.texData.get(i.dataId),d=n(h.values,l);return o.makeTensorInfo(i.shape,l,d)}let c=X().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null,u;return c?u=new Yi(i.shape,t):u=new ws(i.shape,e),o.runWebGLProgram(u,[i],l)}}function Dn({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:a,dtype:s}){return({inputs:i,backend:o})=>{let{a:l,b:c}=i,u=o;if(r&&l.dtype==="complex64"){let f=u.texData.get(l.dataId),m=u.texData.get(c.dataId),[y,g]=[[f.complexTensorInfos.real,m.complexTensorInfos.real],[f.complexTensorInfos.imag,m.complexTensorInfos.imag]].map(b=>{let[v,w]=b,I={dataId:v.dataId,dtype:v.dtype,shape:l.shape},_={dataId:w.dataId,dtype:w.dtype,shape:c.shape},T=new eu(e,l.shape,c.shape);return u.runWebGLProgram(T,[I,_],ca(v.dtype,w.dtype))}),x=Go({inputs:{real:y,imag:g},backend:u});return u.disposeIntermediateTensorInfo(y),u.disposeIntermediateTensorInfo(g),x}let h=s||ca(l.dtype,c.dtype);if((l.dtype==="string"||c.dtype==="string"||u.shouldExecuteOnCPU([l,c]))&&a!=null){let f=u.texData.get(l.dataId).values,m=u.texData.get(c.dataId).values,y=l.dtype==="string"?E.fromUint8ToStringArray(f):f,g=l.dtype==="string"?E.fromUint8ToStringArray(m):m,[x,b]=a(l.shape,c.shape,y,g,h),v=u.makeTensorInfo(b,h),w=u.texData.get(v.dataId);return w.values=x,v}let d=X().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null,p;return d?p=new Dp(t,l.shape,c.shape,n):p=new eu(e,l.shape,c.shape),u.runWebGLProgram(p,[l,c],h)}}function wm(e,t=!1){if(e==="linear")return t?a0e:Qye;if(e==="relu")return t?i0e:t0e;if(e==="elu")return t?s0e:e0e;if(e==="relu6")return t?o0e:n0e;if(e==="prelu")return t?_B:NB;if(e==="leakyrelu")return t?IB:SB;if(e==="sigmoid")return t?l0e:r0e;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}var CB=class{constructor(e,t,n,r=!1,a=!1,s=!1,i=null,o=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=Un(this.outputShape.length);let c=r?e[1]:e[2],u=Math.ceil(c/2),h=r?"i * 2, rc.y":"rc.y, i * 2",d=a?"rc.z, i * 2":"i * 2, rc.z",p=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],m="",y="";i&&(o?m=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${i}
        }`:l?m=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${i}
        }`:m=`vec4 activation(vec4 x) {
          ${i}
        }`,y="result = activation(result);");let g=s?"result += getBiasAtOutCoords();":"";s&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let x="rc.x",b="rc.x";e[0]<t[0]?x=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(b=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${m}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${u}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${x};
        int batchB = ${b};
        for (int i = 0; i < ${u}; i++) {
          vec4 a = getMatrixA(batchA, ${h});
          vec4 b = getMatrixB(batchB, ${d});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${p[0]} * ${f[0]});
          result += (${p[1]} * ${f[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${g}

        ${y}

        setOutput(result);
      }
    `}},V$={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},j$=class{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=E.assertAndGetBroadcastShape(t,n),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}},G$="return a * b;";function kC(e){let{inputs:t,backend:n}=e,{a:r,b:a}=t,s=E.upcastType(r.dtype,a.dtype);if(r.dtype==="complex64"){let o=n.texData.get(r.dataId),l=n.texData.get(a.dataId),c=new j$(V$.REAL,r.shape,a.shape),u=new j$(V$.IMAG,r.shape,a.shape),h=[{dataId:o.complexTensorInfos.real.dataId,dtype:o.complexTensorInfos.real.dtype,shape:r.shape},{dataId:o.complexTensorInfos.imag.dataId,dtype:o.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:a.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:a.shape}],d=n.runWebGLProgram(c,h,"float32"),p=n.runWebGLProgram(u,h,"float32"),f=Go({inputs:{real:d,imag:p},backend:n});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),f}if(n.shouldExecuteOnCPU([r,a])){let o=n.texData.get(r.dataId),l=n.texData.get(a.dataId),[c,u]=kye(r.shape,a.shape,o.values,l.values,s),h=n.makeTensorInfo(u,s),d=n.texData.get(h.dataId);return d.values=c,h}let i;return X().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new Dp(G$,r.shape,a.shape):i=new eu(G$,r.shape,a.shape),n.runWebGLProgram(i,[r,a],s)}var _0e={kernelName:Qu,backendName:"webgl",kernelFunc:kC};function C0e(e,t,n){let r=[Jl(e.shape),...Ql(e.shape)],a={dtype:e.dtype,shape:r,dataId:e.dataId},s=[Jl(t),...Ql(t)],i=new vB(s,r),o=!0,l=[r],c=n.runWebGLProgram(i,[a],e.dtype,l,o);return{dataId:c.dataId,shape:t,dtype:c.dtype}}function pe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:s}=r,i=n,o=k.sizeFromShape(a.shape),l=k.inferFromImplicitShape(s,o),c=k.sizeFromShape(l);k.assert(o===c,()=>`The new shape (${l}) has ${c} elements and the old shape (${a.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);let u=i.texData.get(a.dataId);return u.isPacked&&!vm(a.shape,l)&&!(u.texture!==null&&vm(u.shape,l))?C0e(a,l,i):(i.incRef(a.dataId),{dataId:a.dataId,shape:l,dtype:a.dtype})}var T0e={kernelName:ep,backendName:"webgl",kernelFunc:pe},H$=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:a,outSize:s}=e;this.outputShape=[r,s];let i=Math.floor(n/4)*4,o=n%4,l="sumValue += dot(values, ones);";if(t!=null){let u=1/t;l=`sumValue += dot(values * ${k.isInt(u)?u.toPrecision(2):u}, ones);`}let c="";a%n>0&&(c=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        float sumValue = 0.0;

        for (int i = 0; i < ${i}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${l}
        }

        int inIdx = inOffset + ${i};
        if (${o===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${l}
        } else if (${o===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${l}
        } else if (${o===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${l}
        }
        setOutput(sumValue);
      }
    `}},E0e=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:a,outSize:s}=e;this.outputShape=[r,s];let i="0.0",o="";t==="prod"?i="1.0":t==="min"?(i="1.0 / 1e-20",o="min"):t==="max"&&(i="-1.0 / 1e-20",o="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?l="sumValue":t==="prod"?l="prodValue":t==="all"?l="allValue":t==="any"&&(l="anyValue");let c=Math.floor(n/4)*4,u=n%4,h=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${o}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${o}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,d="vec4";t==="all"?(i="1.0",h=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,d="bvec4"):t==="any"&&(i="0.0",h=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,d="bvec4");let p="";a%n>0&&(p=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${i};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        vec4 minMaxValue = vec4(${i});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${h}
        }

        int inIdx = inOffset + ${c};
        if (${u===1}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${h}
        } else if (${u===2}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${h}
        } else if (${u===3}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${h}
        }
        setOutput(${l});
      }
    `}};function A0e(e){let t=[];for(;t.length===0||t[t.length-1].outSize!==1;){let n=t.length?t[t.length-1].outSize:e[1],r=E.computeOptimalWindowSize(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}function Oc(e,t,n,r){let a=A0e(e.shape),s=e;for(let i=0;i<a.length;i++){let{inSize:o,windowSize:l,outSize:c}=a[i],u,h;n==="mean"?u=i===0?new H$({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:c},o):new H$({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:c}):u=new E0e({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:c},n),h=s,s=r.runWebGLProgram(u,[s],t),h.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(h)}return s}var $0e=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[t[s]];this.outputShape=n,this.rank=n.length;let r=vt(this.rank),a=M0e(t);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${a}));
    }
    `}};function M0e(e){let t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let a=0;a<e.length;a++)r[e[a]]=n[a];return r.join()}var F0e=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let n=new Array(e.length);for(let c=0;c<n.length;c++)n[c]=e[t[c]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let r=vt(this.rank),a=bB("rc",this.rank),s=new Array(this.rank);for(let c=0;c<t.length;c++)s[t[c]]=a[c];let i=`vec2(${s.slice(-2).join()})`,o=`++${a[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${s.join()}), ${i})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${l};
      if(${o}) {
        result[1] = ${l};
      }
      --${a[this.rank-1]};
      if(++${a[this.rank-2]} < ${n[this.rank-2]}) {
        result[2] = ${l};
        if(${o}) {
          result[3] = ${l};
        }
      }
      setOutput(result);
    }
    `}};function kv(e,t,n){let r=X().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new F0e(e.shape,t):new $0e(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function R0e(e,t,n,r){let a=t,s=e.shape.length,i=k.parseAxisParam(a,e.shape),o=i,l=E.getAxesPermutation(o,s),c=l!=null,u=e;c&&(u=kv(e,l,r),o=E.getInnerMostAxes(o.length,s)),E.assertAxesAreInnerMostDims("sum",o,s);let[h,d]=E.computeOutAndReduceShapes(u.shape,o),p=h;n&&(p=E.expandShapeToKeepDim(h,i));let f=k.sizeFromShape(d),m=k.sizeFromShape(e.shape)/f,y=pe({inputs:{x:u},attrs:{shape:[m,f]},backend:r}),g=gb(e.dtype),x=Oc(y,g,"sum",r),b=pe({inputs:{x},attrs:{shape:p},backend:r});return r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(x),c&&r.disposeIntermediateTensorInfo(u),b}function Sv(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;return R0e(a,s,i,n)}var D0e={kernelName:vc,backendName:"webgl",kernelFunc:Sv};function rr(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{perm:s}=r,i=n,o=a.shape.length,l=new Array(o);for(let u=0;u<l.length;u++)l[u]=a.shape[s[u]];let c;if(i.shouldExecuteOnCPU([a])){let u=i.texData.get(a.dataId).values,h=bC(u,a.shape,a.dtype,s,l);c=i.makeTensorInfo(l,a.dtype);let d=i.texData.get(c.dataId);d.values=h}else c=kv(a,s,i);return c}var O0e={kernelName:ni,backendName:"webgl",kernelFunc:rr},TB=1e3;function Sx({a:e,b:t,transposeA:n,transposeB:r,backend:a,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}){let c=e.shape.length,u=t.shape.length,h=n?e.shape[c-2]:e.shape[c-1],d=r?t.shape[u-1]:t.shape[u-2],p=n?e.shape[c-1]:e.shape[c-2],f=r?t.shape[u-2]:t.shape[u-1],m=e.shape.slice(0,-2),y=t.shape.slice(0,-2),g=k.sizeFromShape(m),x=k.sizeFromShape(y),b=xp.assertAndGetBroadcastShape(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([p,f]);k.assert(h===d,()=>`Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`);let v=n?[g,h,p]:[g,p,h],w=r?[x,f,d]:[x,d,f],I=pe({inputs:{x:e},backend:a,attrs:{shape:v}}),_=pe({inputs:{x:t},backend:a,attrs:{shape:w}}),T=[I,_],A=Math.max(g,x),M=n?I.shape[1]:I.shape[2],F=s!=null,C=i!=null,D=l==="leakyrelu",L=l!=null?wm(l,!0):null,O=F||C||D||L!=null,q;if((p===1||f===1)&&M>TB&&O===!1){let z=I,K=_;n&&(z=rr({inputs:{x:I},backend:a,attrs:{perm:[0,2,1]}}),T.push(z)),r&&(K=rr({inputs:{x:_},backend:a,attrs:{perm:[0,2,1]}}),T.push(K));let Z=f!==1,J=f===1,Q=z;Z&&(Q=pe({inputs:{x:z},backend:a,attrs:{shape:[A,M,1]}}),T.push(Q));let ne=f===1?2:1,oe=K;J&&(oe=pe({inputs:{x:K},backend:a,attrs:{shape:[A,1,M]}}),T.push(oe));let ue=kC({inputs:{a:Q,b:oe},backend:a});q=Sv({inputs:{x:ue},backend:a,attrs:{axis:ne,keepDims:!0}}),T.push(ue)}else{let z=ca(e.dtype,t.dtype),K=new CB(v,w,[A,p,f],n,r,F,L,C,D),Z=[I,_];if(s!=null&&Z.push(s),C&&Z.push(i),D){let J=a.makeTensorInfo([],"float32",k.createScalarValue(o,"float32"));Z.push(J),T.push(J)}q=a.runWebGLProgram(K,Z,z)}let H=pe({inputs:{x:q},backend:a,attrs:{shape:b}});T.push(q);for(let z of T)a.disposeIntermediateTensorInfo(z);return H}function z0e(e){let{inputs:t,backend:n,attrs:r}=e,{a,b:s,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=r;return Sx({a,b:s,transposeA:l,transposeB:c,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:h,activation:u})}var P0e={kernelName:zl,backendName:"webgl",kernelFunc:z0e},q$="return abs(x);";function L0e(e){let{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){let s=n.texData.get(r.dataId),i=yB(s.values);return n.makeTensorInfo(r.shape,r.dtype,i)}let a;return X().getBool("WEBGL_PACK_UNARY_OPERATIONS")?a=new Yi(r.shape,q$):a=new ws(r.shape,q$),n.runWebGLProgram(a,[r],r.dtype)}var B0e={kernelName:gd,backendName:"webgl",kernelFunc:L0e},W0e=Fa+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,U0e=nt({opSnippet:W0e}),V0e={kernelName:lu,backendName:"webgl",kernelFunc:U0e},j0e=Fa+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,G0e=nt({opSnippet:j0e}),H0e={kernelName:uu,backendName:"webgl",kernelFunc:G0e},K$="return a + b;",q0e=Dn({opSnippet:K$,packedOpSnippet:K$,supportsComplex:!0,cpuKernelImpl:tye}),K0e={kernelName:Do,backendName:"webgl",kernelFunc:q0e},X0e=class{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((a,s)=>`T${s}`);let n=[];this.variableNames.forEach(a=>{n.push(`float v${a} = get${a}AtOutCoords();`)});let r=this.variableNames.map(a=>`v${a}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}},Z0e=class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((a,s)=>`T${s}`);let n=[];this.variableNames.forEach(a=>{n.push(`vec4 v${a} = get${a}AtOutCoords();`)});let r=this.variableNames.map(a=>`v${a}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}};function k0(e){let{inputs:t,backend:n}=e,r=t;if(r.length===1)return Hr({inputs:{x:r[0]},backend:n});if(r.length>X().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let o=Math.floor(r.length/2),l=k0({inputs:r.slice(0,o),backend:n}),c=k0({inputs:r.slice(o),backend:n});return k0({inputs:[l,c],backend:n})}let a=r.map(o=>o.dtype).reduce((o,l)=>ca(o,l)),s=r.map(o=>o.shape),i=X().getBool("WEBGL_PACK")?new Z0e(r[0].shape,s):new X0e(r[0].shape,s);return n.runWebGLProgram(i,r,a)}var Y0e={kernelName:cu,backendName:"webgl",kernelFunc:k0};function J0e(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=k.parseAxisParam(s,a.shape),c=l,u=E.getAxesPermutation(c,o),h=a;u!=null&&(h=rr({inputs:{x:a},backend:n,attrs:{perm:u}}),c=E.getInnerMostAxes(c.length,o)),E.assertAxesAreInnerMostDims("all",c,o);let[d,p]=E.computeOutAndReduceShapes(h.shape,c),f=k.sizeFromShape(p),m=pe({inputs:{x:h},backend:n,attrs:{shape:[-1,f]}}),y=Oc(m,m.dtype,"all",n),g;if(i){let x=E.expandShapeToKeepDim(d,l);g=pe({inputs:{x:y},backend:n,attrs:{shape:x}})}else g=pe({inputs:{x:y},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),u!=null&&n.disposeIntermediateTensorInfo(h),g}var Q0e={kernelName:yd,backendName:"webgl",kernelFunc:J0e};function exe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=k.parseAxisParam(s,a.shape),c=l,u=E.getAxesPermutation(c,o),h=a;u!=null&&(h=rr({inputs:{x:a},backend:n,attrs:{perm:u}}),c=E.getInnerMostAxes(c.length,o)),E.assertAxesAreInnerMostDims("any",c,o);let[d,p]=E.computeOutAndReduceShapes(h.shape,c),f=k.sizeFromShape(p),m=pe({inputs:{x:h},backend:n,attrs:{shape:[-1,f]}}),y=Oc(m,m.dtype,"any",n),g;if(i){let x=E.expandShapeToKeepDim(d,l);g=pe({inputs:{x:y},backend:n,attrs:{shape:x}})}else g=pe({inputs:{x:y},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),u!=null&&n.disposeIntermediateTensorInfo(h),g}var txe={kernelName:xd,backendName:"webgl",kernelFunc:exe},nxe=class{constructor(e,t,n){this.variableNames=["A"];let{windowSize:r,batchSize:a,outSize:s}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[a,s];let i=t==="max"?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${o};
          float candidate = getA(batch, inIdx);
          if (candidate ${i} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}},rxe=class{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,k.assert(e.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);let a=e[e.length-1],s=Math.ceil(a/t);this.outputShape=e.slice(0,-1),s>1&&this.outputShape.push(s),r||this.variableNames.push("bestIndicesA");let i=this.outputShape,o=i.length,l=vt(o),c=Jn("coords",o),u,h;if(s===1){h=o+1;let _=vt(h);u=`
        ${_} sourceLocR = ${_}(${c.join()}, 0);
        ++${c[o-1]};
        ${_} sourceLocG = ${_}(${c.join()}, 0);
        ++${c[o-2]};
        ${_} sourceLocA = ${_}(${c.join()}, 0);
        --${c[o-1]};
        ${_} sourceLocB = ${_}(${c.join()}, 0);
        --${c[o-2]};`}else h=o,u=`
        ${l} sourceLocR = coords;
        ++${c[o-1]};
        ${l} sourceLocG = coords;
        ++${c[o-2]};
        ${l} sourceLocA = coords;
        --${c[o-1]};
        ${l} sourceLocB = coords;
        --${c[o-2]};`;let d=["x","y","z","w","u","v"].slice(0,h),p="."+d[h-1],f=d.map(_=>"int "+_),m=Jn("sourceLocR",h-1).concat("inIdx.r"),y=Jn("sourceLocG",h-1).concat("inIdx.g"),g=Jn("sourceLocB",h-1).concat("inIdx.b"),x=Jn("sourceLocA",h-1).concat("inIdx.a"),b=n==="max"?"greaterThan":"lessThan",v=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${x.join()})));`,w=`vec4(
            getAChannel(${m.join()}),
            hasNextCol ? getAChannel(${y.join()}) : 0.,
            hasNextRow ? getAChannel(${g.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${x.join()}) : 0.)`,I=r?"":`
      float getBestIndicesAChannel(${f.join()}) {
        return getChannel(getBestIndicesA(${d.join()}),
                                          vec2(${d.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${f.join()}) {
        return getChannel(getA(${d.join()}),
                               vec2(${d.slice(-2).join()}));
      }
      ${I}
      void main() {
        ${l} coords = getOutputCoords();
        bool hasNextCol = ${c[o-1]} < ${i[o-1]-1};
        bool hasNextRow = ${c[o-2]} < ${i[o-2]-1};
        ${u}
        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},
          sourceLocB${p}, sourceLocA${p}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${w};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${v}
          vec4 candidate = ${w};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${b}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}};function EB(e,t,n,r=null){let a=t.shape[0],s=t.shape[1];r!=null&&(a=r.shape[0],s=r.shape[1]);let i=E.computeOptimalWindowSize(s),o={windowSize:i,inSize:s,batchSize:a,outSize:Math.ceil(s/i)},l=new nxe(o,n,r==null),c=[t];r!=null&&c.push(r);let u=e.runWebGLProgram(l,c,"int32");if(u.shape[1]===1)return u;let h=EB(e,t,n,u);return e.disposeIntermediateTensorInfo(u),h}function AB(e,t,n,r=null){let a=r!=null?r.shape:t.shape,s=a[a.length-1],i=E.computeOptimalWindowSize(s),o=new rxe(a,i,n,r==null),l=r==null?[t]:[t,r],c=e.runWebGLProgram(o,l,"int32");if(c.shape.length===t.shape.length){let u=AB(e,t,n,c);return e.disposeIntermediateTensorInfo(c),u}return c}function $B(e,t,n,r){let a=[n];if(E.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),a,t.shape.length),!X().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){let s=[],i=e.texData.get(t.dataId),o=i!==null&&i.isPacked,l=t;o&&(l=e.unpackTensor(t),s.push(l));let[c,u]=E.computeOutAndReduceShapes(l.shape,a),h=k.sizeFromShape(u),d=pe({inputs:{x:l},backend:e,attrs:{shape:[-1,h]}});s.push(d);let p=EB(e,d,r);s.push(p);let f=pe({inputs:{x:p},backend:e,attrs:{shape:c}});return s.forEach(m=>e.disposeIntermediateTensorInfo(m)),f}return AB(e,t,r)}function axe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r,i=k.parseAxisParam(s,a.shape),o=E.getAxesPermutation(i,a.shape.length),l=a,c=[];o!=null&&(l=rr({inputs:{x:a},backend:n,attrs:{perm:o}}),c.push(l),i=E.getInnerMostAxes(i.length,l.shape.length)),E.assertAxesAreInnerMostDims("argMax",[i[0]],l.shape.length);let u=$B(n,l,i[0],"max");return c.forEach(h=>n.disposeIntermediateTensorInfo(h)),u}var sxe={kernelName:bd,backendName:"webgl",kernelFunc:axe};function ixe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r,i=k.parseAxisParam(s,a.shape),o=E.getAxesPermutation(i,a.shape.length),l=a,c=[];o!=null&&(l=rr({inputs:{x:a},backend:n,attrs:{perm:o}}),c.push(l),i=E.getInnerMostAxes(i.length,l.shape.length)),E.assertAxesAreInnerMostDims("argMin",[i[0]],l.shape.length);let u=$B(n,l,i[0],"min");return c.forEach(h=>n.disposeIntermediateTensorInfo(h)),u}var oxe={kernelName:vd,backendName:"webgl",kernelFunc:ixe},lxe=Fa+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,uxe=nt({opSnippet:lxe}),cxe={kernelName:hu,backendName:"webgl",kernelFunc:uxe},hxe=Fa+"return log(x + sqrt(x * x + 1.0));",dxe=nt({opSnippet:hxe}),pxe={kernelName:du,backendName:"webgl",kernelFunc:dxe},fxe=Fa+`
  return atan(x);
`,mxe=nt({opSnippet:fxe}),gxe={kernelName:pu,backendName:"webgl",kernelFunc:mxe},yxe=wC+`
  return atan(a, b);
`,xxe=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Dc+`
  return result;
`,bxe=Dn({opSnippet:yxe,packedOpSnippet:xxe}),vxe={kernelName:mu,backendName:"webgl",kernelFunc:bxe},wxe=Fa+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,kxe=nt({opSnippet:wxe}),Sxe={kernelName:fu,backendName:"webgl",kernelFunc:kxe},km=class{constructor(e,t,n,r=!1,a=!1){if(this.variableNames=["x"],t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let s=e.filterWidth,i=e.strideHeight,o=e.strideWidth,l=e.dilationHeight,c=e.dilationWidth,u=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;let f=t==="avg",m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,y=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`,g="0.0";if(f||(g="-1.0 / 1e-20"),n){let _=">=";this.userCode=`
        const ivec2 strides = ivec2(${i}, ${o});
        const ivec2 pads = ivec2(${d}, ${p});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${u};
              wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${h};
                wC += ${c}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${_} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?a?m:y:`wR * ${h} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let x="max",b=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(b="avgValue / max(count, 1.0)");let v=Math.floor(s/4)*4,w=s%4,I=`
      if (${f}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${x}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${o});
      const ivec2 pads = ivec2(${d}, ${p});
      const float initializationValue = ${g};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${g});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${u};
            wR += ${l}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${v}; wC += 4) {
            int xC = xCCorner + wC * ${c};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              getValue(batch, xR, xC + 3 * ${c}, d)
            );

            ${I}
          }

          int xC = xCCorner + ${v};
          if (${w===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${I}
          } else if (${w===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              initializationValue,
              initializationValue
            );

            ${I}
          } else if (${w===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              initializationValue
            );

            ${I}
          }
        }
        setOutput(${b});
      }
    `}},SC=class{constructor(e,t,n,r=!1,a=!1){if(this.variableNames=["x"],t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let s=e.filterWidth,i=e.strideDepth,o=e.strideHeight,l=e.strideWidth,c=e.dilationDepth,u=e.dilationHeight,h=e.dilationWidth,d=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,y=e.padInfo.top,g=e.padInfo.left;this.outputShape=e.outShape;let x=t==="avg",b="0.0";if(x||(b="-1.0 / 1e-20"),n){let A=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${i}, ${o}, ${l});
        const ivec3 pads = ivec3(${m}, ${y}, ${g});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${d};
              wD += ${c}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${p};
                wR += ${u}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${f};
                  wC += ${h}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${A} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?a?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${p} * ${f} +
                      wR * ${f} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let v="max",w=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(w="avgValue / max(count, 1.0)");let I=Math.floor(s/4)*4,_=s%4,T=`
      if (${x}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${v}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${i}, ${o}, ${l});
      const ivec3 pads = ivec3(${m}, ${y}, ${g});
      const float initializationValue = ${b};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${b});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${c}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${p};
            wR += ${u}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${I}; wC += 4) {
              int xC = xCCorner + wC * ${h};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h}, ch),
                getValue(batch, xD, xR, xC + 2 * ${h}, ch),
                getValue(batch, xD, xR, xC + 3 * ${h}, ch)
              );

              ${T}
            }

            int xC = xCCorner + ${I};
            if (${_===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${T}
            } else if (${_===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h}, ch),
                initializationValue,
                initializationValue
              );

              ${T}
            } else if (${_===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h}, ch),
                getValue(batch, xD, xR, xC + 2 * ${h}, ch),
                initializationValue
              );

              ${T}
            }
          }
        }
        setOutput(${w});
      }
    `}};function Ixe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;Ap(a,"avgPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r,c=1;k.assert(E.eitherStridesOrDilationsAreOne(i,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);let u=E.computePool2DInfo(a.shape,s,i,c,o,l);if(u.filterWidth===1&&u.filterHeight===1&&k.arraysEqual(u.inShape,u.outShape))return Hr({inputs:{x:a},backend:n});let h=new km(u,"avg",!1);return n.runWebGLProgram(h,[a],"float32")}var Nxe={kernelName:gu,backendName:"webgl",kernelFunc:Ixe};function _xe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:c}=r,u=[1,1,1],h=E.computePool3DInfo(a.shape,s,i,u,o,l,c),d=new SC(h,"avg",!1);return n.runWebGLProgram(d,[a],"float32")}var Cxe={kernelName:wd,backendName:"webgl",kernelFunc:_xe},Txe=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterHeight,l=e.effectiveFilterWidth,c=o-1-e.padInfo.top,u=l-1-e.padInfo.left,h=1/(t*n);this.userCode=`
      const ivec2 pads = ivec2(${c}, ${u});
      const float avgMultiplier = float(${h});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${o};
            wR += ${s}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${l};
            wC+= ${i}) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},Exe=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,c=e.dilationWidth,u=e.effectiveFilterDepth,h=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=u-1-e.padInfo.front,f=h-1-e.padInfo.top,m=d-1-e.padInfo.left,y=1/(t*n*r);this.userCode=`
      const ivec3 pads = ivec3(${p}, ${f}, ${m});
      const float avgMultiplier = float(${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${u};
            wD += ${o}) {
          float dyD = float(dyDCorner + wD) / ${a}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${h};
              wR += ${l}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${c}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Axe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s,{filterSize:o,strides:l,pad:c,dimRoundingMode:u}=r,h=[1,1,1],d=E.computePool3DInfo(i.shape,o,l,h,c,u),p=new Exe(d);return n.runWebGLProgram(p,[a],i.dtype)}var $xe={kernelName:Pm,backendName:"webgl",kernelFunc:Axe};function Mxe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s;Ap([a,s],"avgPoolGrad");let{filterSize:o,strides:l,pad:c}=r,u=E.computePool2DInfo(i.shape,o,l,1,c),h=new Txe(u);return n.runWebGLProgram(h,[a],i.dtype)}var Fxe={kernelName:zm,backendName:"webgl",kernelFunc:Mxe};function Rxe(e){let{inputs:t,backend:n,attrs:r}=e,{a,b:s}=t,{transposeA:i,transposeB:o}=r;return Sx({a,b:s,transposeA:i,transposeB:o,backend:n})}var Dxe={kernelName:yu,backendName:"webgl",kernelFunc:Rxe},Oxe=class{constructor(e,t,n,r,a,s){this.outputShape=[],this.variableNames=["x","mean","variance"],E.assertAndGetBroadcastShape(e,t),E.assertAndGetBroadcastShape(e,n);let i="0.0";r!=null&&(E.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="1.0";a!=null&&(E.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${i};
        float scale = ${o};
        float inv = scale * inversesqrt(variance + float(${s}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}},zxe=class{constructor(e,t,n,r,a,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],E.assertAndGetBroadcastShape(e,t),E.assertAndGetBroadcastShape(e,n);let i="vec4(0.0)";r!=null&&(E.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="vec4(1.0)";a!=null&&(E.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${i};
        vec4 scale = ${o};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${s}));

        setOutput((x - mean) * inv + offset);
      }
    `}},Pxe=({inputs:e,backend:t,attrs:n})=>{let{x:r,mean:a,variance:s,offset:i,scale:o}=e;k.assert(a.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),k.assert(i==null||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),k.assert(o==null||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=n;l==null&&(l=.001);let c=[r,a,s],u=null;i!=null&&(u=i.shape,c.push(i));let h=null;o!=null&&(h=o.shape,c.push(o));let d=X().getBool("WEBGL_PACK_NORMALIZATION")?new zxe(r.shape,a.shape,s.shape,u,h,l):new Oxe(r.shape,a.shape,s.shape,u,h,l);return t.runWebGLProgram(d,c,c[0].dtype)},Lxe={kernelName:Du,backendName:"webgl",kernelFunc:Pxe},Bxe=class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;let t=vt(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let n=Wxe(this.rank),r,a=e.map((s,i)=>`sourceLoc.${o2[i]} = start[${i}] + coords.${o2[i]};`);r=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${a.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${n}));
      }
    `}},o2=["x","y","z","w","u","v"];function Wxe(e){if(e===1)return"sourceLoc";if(e<=6)return o2.slice(0,e).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}var Uxe=class{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let t=vt(this.rank),n=Jn("coords",this.rank),r=Jn("sourceLoc",this.rank),a=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,s=`getChannel(getSource(${r.join()}), ${a})`,i=`
      result.x = ${s};
      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${s};
        --${r[this.rank-1]};
      }
    `,o=this.rank===1?"":`
      --${n[this.rank-1]};
      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${s};
        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${s};
        }
      }
    `,l=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((c,u)=>`start[${u}]`).join()});`:e.map((c,u)=>`${r[u]} = ${n[u]} + start[${u}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${l}
        vec4 result = vec4(0.);
        ${i}
        ${o}
        setOutput(result);
      }
    `}};function Vxe(e,t,n,r){let a=r.texData.get(e.dataId),s=r.makeTensorInfo(n,e.dtype),i=r.texData.get(s.dataId);Object.assign(i,a),i.refCount=1,i.shape=n,i.dtype=e.dtype;let o=ln.computeFlatOffset(t,k.computeStrides(e.shape));a.slice&&(o+=a.slice.flatOffset),i.slice={flatOffset:o,origDataId:a.slice&&a.slice.origDataId||e.dataId};let l=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,l+1),s}function zp(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,size:i}=r,[o,l]=ln.parseSliceParams(a,s,i);if(ln.assertParamsValid(a,o,l),k.sizeFromShape(l)===0)return n.makeTensorInfo(l,a.dtype,[]);if(n.shouldExecuteOnCPU([a])||a.dtype==="string"){let h=n.texData.get(a.dataId),d=Fye(h.values,o,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,d)}let{isPacked:c}=n.texData.get(a.dataId),u=ln.isSliceContinous(a.shape,o,l);if(c||!u){let h=X().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Uxe(l):new Bxe(l),d=[o];return n.runWebGLProgram(h,[a],a.dtype,d)}return n.uploadToGPU(a.dataId),Vxe(a,o,l,n)}var jxe={kernelName:op,backendName:"webgl",kernelFunc:zp},Gxe=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r;k.assert(a.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let o=s.reduce((x,b)=>x*b),l=E.getReshaped(a.shape,s,o),c=E.getPermuted(l.length,s.length),u=E.getReshapedPermuted(a.shape,s,o),h=E.getSliceBeginCoords(i,s.length),d=E.getSliceSize(u,i,s.length),p=[],f=pe({inputs:{x:a},backend:n,attrs:{shape:l}}),m=rr({inputs:{x:f},backend:n,attrs:{perm:c}}),y=pe({inputs:{x:m},backend:n,attrs:{shape:u}}),g=zp({inputs:{x:y},backend:n,attrs:{begin:h,size:d}});return p.push(f),p.push(m),p.push(y),p.forEach(x=>n.disposeIntermediateTensorInfo(x)),g},Hxe={kernelName:kd,backendName:"webgl",kernelFunc:Gxe};function qxe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i}=r,o=n.readSync(a.dataId),l=n.readSync(s.dataId),c=gB(o,l,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,c)}var Kxe={kernelName:Sd,backendName:"webgl",kernelFunc:qxe},Xxe=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,Zxe=`
  return float(int(a.r) & int(b.r));
`;function Yxe(e){let{inputs:t,backend:n}=e,{a:r,b:a}=t,s=X().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=X().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([r,a])||i===1){let l=n.texData.get(r.dataId).values,c=n.texData.get(a.dataId).values,[u,h]=rye(r.shape,a.shape,l,c,r.dtype),d=n.makeTensorInfo(h,r.dtype),p=n.texData.get(d.dataId);return p.values=u,d}let o;return s?o=new Dp(Xxe,r.shape,a.shape,!1):o=new eu(Zxe,r.shape,a.shape),n.runWebGLProgram(o,[r,a],r.dtype)}var Jxe={kernelName:Id,backendName:"webgl",kernelFunc:Yxe};function Qxe(e){let{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.readSync(r.dataId),i=n.readSync(a.dataId),o=E.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}var ebe={kernelName:Lm,backendName:"webgl",kernelFunc:Qxe},tbe="return float(a != b);",MB=Dn({opSnippet:tbe,cpuKernelImpl:Iye,dtype:"bool"}),nbe={kernelName:Kd,backendName:"webgl",kernelFunc:MB};function Dg(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.texData.get(r.dataId);return Hr({inputs:{x:a.complexTensorInfos.real},backend:n})}var rbe={kernelName:fb,backendName:"webgl",kernelFunc:Dg},abe="return float(int(x));";function sbe(e,t){let n=new ws(e.shape,abe),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}function l2(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dtype:s}=r;if(s==="complex64"){if(a.dtype==="complex64")return Hr({inputs:{x:a},backend:n});let i=Ot(a.shape),o=l2({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),l=Go({inputs:{real:o,imag:i},backend:n});return i.dispose(),n.disposeIntermediateTensorInfo(o),l}if(a.dtype==="complex64"){let i=Dg({inputs:{input:a},backend:n}),o=l2({inputs:{x:i},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(i),o}if(!k.hasEncodingLoss(a.dtype,s)){let i=Hr({inputs:{x:a},backend:n});return{dataId:i.dataId,shape:i.shape,dtype:s}}if(n.shouldExecuteOnCPU([a])){let i=n.texData.get(a.dataId).values,[o,l,c]=aye(i,a.shape,a.dtype,s);return n.makeTensorInfo(o,l,c)}if(s==="int32")return sbe(a,n);if(s==="bool"){let i=n.makeTensorInfo([],"bool",k.getTypedArrayFromDType("bool",1)),o=MB({inputs:{a,b:i},backend:n});return n.disposeIntermediateTensorInfo(i),o}throw new Error(`Error in Cast: failed to cast ${a.dtype} to ${s}`)}var ibe={kernelName:xu,backendName:"webgl",kernelFunc:l2},X$="return ceil(x);",obe=nt({opSnippet:X$,packedOpSnippet:X$,cpuKernelImpl:sye}),lbe={kernelName:bu,backendName:"webgl",kernelFunc:obe},ube=class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}},cbe=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}};function hbe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{clipValueMin:s,clipValueMax:i}=r,o;X().getBool("WEBGL_PACK_CLIP")?o=new cbe(a.shape):o=new ube(a.shape);let l=[[s],[i]];return n.runWebGLProgram(o,[a],a.dtype,l)}var dbe={kernelName:Oo,backendName:"webgl",kernelFunc:hbe},pbe=class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};function Z$(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}function fbe(e){let{inputs:t,backend:n}=e,{x:r}=t,a=n.texData.get(r.dataId),s=new pbe(r.shape),i=[Z$(r,a.complexTensorInfos.real),Z$(r,a.complexTensorInfos.imag)];return n.runWebGLProgram(s,i,i[0].dtype)}var mbe={kernelName:Bm,backendName:"webgl",kernelFunc:fbe},gbe=class{constructor(e){this.outputShape=[],this.outputShape=E.computeOutShape(e,1),this.variableNames=e.map((s,i)=>`T${i}`);let t=new Array(e.length-1);t[0]=e[0][1];for(let s=1;s<t.length;s++)t[s]=t[s-1]+e[s][1];let n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let s=1;s<t.length;s++){let i=t[s-1];n.push(`else if (yC < ${t[s]}) setOutput(getT${s}(yR, yC-${i}));`)}let r=t.length,a=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${a}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${n.join(`
        `)}
      }
    `}},ybe=class{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=E.computeOutShape(e,t);let n=this.outputShape,r=n.length,a=vt(r),s=Jn("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((f,m)=>`T${m}`);let o=new Array(e.length-1);o[0]=e[0][t];for(let f=1;f<o.length;f++)o[f]=o[f-1]+e[f][t];let l=i[t],c=i.slice(-2),u=i.join(),h=`if (${l} < ${o[0]}) {
        return getChannel(
            getT0(${u}), vec2(${c.join()}));
        }`;for(let f=1;f<o.length;f++){let m=o[f-1];h+=`
        if (${l} < ${o[f]}  && ${l} >= ${o[f-1]}) {
          return getChannel(
            getT${f}(${Zy(i,l,m)}),
            vec2(${Zy(c,l,m)}));
        }`}let d=o.length,p=o[o.length-1];h+=`
        return getChannel(
          getT${d}(${Zy(i,l,p)}),
          vec2(${Zy(c,l,p)}));`,this.userCode=`
      float getValue(${i.map(f=>"int "+f)}) {
        ${h}
      }

      void main() {
        ${a} coords = getOutputCoords();
        vec4 result = vec4(getValue(${s}), 0., 0., 0.);

        ${s[r-1]} = ${s[r-1]} + 1;
        if (${s[r-1]} < ${n[r-1]}) {
          result.g = getValue(${s});
        }

        ${s[r-2]} = ${s[r-2]} + 1;
        if (${s[r-2]} < ${n[r-2]}) {
          result.a = getValue(${s});
        }

        ${s[r-1]} = ${s[r-1]} - 1;
        if (${s[r-2]} < ${n[r-2]} &&
            ${s[r-1]} < ${n[r-1]}) {
          result.b = getValue(${s});
        }
        setOutput(result);
      }
    `}};function Zy(e,t,n){let r=e.indexOf(t);return e.map((a,s)=>s===r?`${a} - ${n}`:a).join()}function Iv(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.texData.get(r.dataId);return Hr({inputs:{x:a.complexTensorInfos.imag},backend:n})}var xbe={kernelName:cb,backendName:"webgl",kernelFunc:Iv};function kf(e,t,n){let r=e[0].dtype;if(r==="complex64"){let p=e.map(x=>Dg({inputs:{input:x},backend:n})),f=e.map(x=>Iv({inputs:{input:x},backend:n})),m=kf(p,t,n),y=kf(f,t,n),g=Go({inputs:{real:m,imag:y},backend:n});return p.forEach(x=>n.disposeIntermediateTensorInfo(x)),f.forEach(x=>n.disposeIntermediateTensorInfo(x)),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),g}let a=n.shouldExecuteOnCPU(e);if(r==="string"&&(a=!0),a){let p=e.map(v=>{let w=[-1,k.sizeFromShape(v.shape.slice(t))];return pe({inputs:{x:v},backend:n,attrs:{shape:w}})}),f=p.map(v=>({vals:n.readSync(v.dataId),shape:v.shape})),m=E.computeOutShape(p.map(v=>v.shape),1),y=p[0].shape[0]===1,g=iye(f,m,r,y),x=E.computeOutShape(e.map(v=>v.shape),t),b=n.makeTensorInfo(x,r,g);return p.forEach(v=>n.disposeIntermediateTensorInfo(v)),b}let s=e.filter(p=>k.sizeFromShape(p.shape)>0),i=X().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(s.length===1){let p=i?new ws(e[0].shape,Wi):new Yi(e[0].shape,Wi);return n.runWebGLProgram(p,e,r)}let o=X().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>o){let p=[];for(let m=0;m<s.length;m+=o){let y=s.slice(m,m+o);p.push(kf(y,t,n))}let f=kf(p,t,n);for(let m of p)n.disposeIntermediateTensorInfo(m);return f}if(i){let p=new ybe(s.map(f=>f.shape),t);return n.runWebGLProgram(p,s,r)}let{tensors2D:l,outShape:c}=bbe(s,t,n),u=new gbe(l.map(p=>p.shape)),h=n.runWebGLProgram(u,l,r);l.forEach(p=>n.disposeIntermediateTensorInfo(p));let d=pe({inputs:{x:h},attrs:{shape:c},backend:n});return n.disposeIntermediateTensorInfo(h),d}function bbe(e,t,n){let r=E.computeOutShape(e.map(a=>a.shape),t);return{tensors2D:e.map(a=>pe({inputs:{x:a},attrs:{shape:[-1,k.sizeFromShape(a.shape.slice(t))]},backend:n})),outShape:r}}function FB(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,s=k.parseAxisParam(a,t[0].shape)[0],i=t.map(c=>c.shape);E.assertParamsConsistent(i,s);let o=E.computeOutShape(t.map(c=>c.shape),s);if(k.sizeFromShape(o)===0)return n.makeTensorInfo(o,t[0].dtype,[]);let l=t.filter(c=>k.sizeFromShape(c.shape)>0);return l.length===1?Hr({inputs:{x:l[0]},backend:n}):kf(l,s,n)}var vbe={kernelName:Nd,backendName:"webgl",kernelFunc:FB},RB=class{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;let s=e.padInfo.top,i=e.padInfo.left,o=e.strideHeight,l=e.strideWidth,c=e.dilationHeight,u=e.dilationWidth,h=e.filterHeight,d=e.filterWidth,p=Math.floor(e.inChannels/4)*4,f=e.inChannels%4,m=e.dataFormat==="channelsLast",y=m?1:2,g=m?2:3,x=m?3:1,b="",v="";n&&(r?b=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:a?b=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:b=`
          float activation(float x) {
            ${n}
          }
        `,v="result = activation(result);");let w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${b}

      const ivec2 strides = ivec2(${o}, ${l});
      const ivec2 pads = ivec2(${s}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${x}];

        ivec2 xRCCorner =
            ivec2(coords[${y}], coords[${g}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${h}; wR++) {
          int xR = xRCorner + wR * ${c};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${d}; wC++) {
            int xC = xCCorner + wC * ${u};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${p}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${m}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${f===1}) {

              if (${m}) {
                dotProd +=
                    getX(batch, xR, xC, ${p}) *
                    getW(wR, wC, ${p}, d2);
              } else {
                dotProd +=
                    getX(batch, ${p}, xR, xC) *
                    getW(wR, wC, ${p}, d2);
              }

            } else if (${f===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${p}, d2),
                getW(wR, wC, ${p} + 1, d2)
              );

              if (${m}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${p}),
                  getX(batch, xR, xC, ${p} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${p}, xR, xC),
                  getX(batch, ${p} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${f===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${p}, d2),
                getW(wR, wC, ${p} + 1, d2),
                getW(wR, wC, ${p} + 2, d2)
              );

              if (${m}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${p}),
                  getX(batch, xR, xC, ${p} + 1),
                  getX(batch, xR, xC, ${p} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${p}, xR, xC),
                  getX(batch, ${p} + 1, xR, xC),
                  getX(batch, ${p} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${w}
        ${v}
        setOutput(result);
      }
    `}},wbe=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,c=e.dilationWidth,u=e.filterDepth,h=e.filterHeight,d=e.filterWidth,p=Math.floor(e.inChannels/4)*4,f=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${a}, ${s}, ${i});
      const ivec3 pads = ivec3(${t}, ${n}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${u}; wF++) {
          int xF = xFCorner + wF * ${o};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${h}; wR++) {
            int xR = xRCorner + wR * ${l};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d}; wC++) {
              int xC = xCCorner + wC * ${c};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${p}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${f===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${p}) *
                  getW(wF, wR, wC, ${p}, d2);
              } else if (${f===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${p}),
                  getX(batch, xF, xR, xC, ${p} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${p}, d2),
                  getW(wF, wR, wC, ${p} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${f===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${p}),
                  getX(batch, xF, xR, xC, ${p} + 1),
                  getX(batch, xF, xR, xC, ${p} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${p}, d2),
                  getW(wF, wR, wC, ${p} + 1, d2),
                  getW(wF, wR, wC, ${p} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},DB=class{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Un(this.outputShape.length);let s=e.padInfo.left,i=e.strideWidth,o=e.dilationWidth,l=e.filterHeight,c=e.filterWidth,u=c,h=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let m=0;m<c;m++)h+=`
           vec4 xTexelC${m*2};
           int xTexelC${m*2}Ready;
           vec4 xTexelC${m*2+1};
           int xTexelC${m*2+1}Ready;
           vec4 xC${m};`;h+=`
     for (int r = 0; r < ${l}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let m=0;m<c;m++)h+=`
           xTexelC${m*2} = vec4(0.0);
           xTexelC${m*2}Ready = 0;
           xTexelC${m*2+1} = vec4(0.0);
           xTexelC${m*2+1}Ready = 0;
           xC${m} = vec4(0.0);`;h+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let m=0;m<(u+1)/2;m++){let y=m*2;if(h+=`
           xC = xCCorner + ${y*o};
           `,i===1){if(y<c&&(s%2===1?(h+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }
               `,o===1&&y>0?h+=`
                 xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);
                 `:h+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${y} = vec4(previous.zw, xTexelC${y}.xy);
                   } else {
                     xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);
                   }
                   `):h+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xC${y} = xTexelC${y};
                 `,y+1<c)){let g=s%2===0?k.nearestLargerEven(o):o;o%2===0&&s%2===1||o%2!==0&&s%2!==1?(h+=`
                   xCOffset = xC + imod(pads[1], 2) + ${g};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                     xTexelC${y+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${y+1}.zw = vec2(0.0);
                     }
                     xTexelC${y+1}Ready = 1;
                   }
                   `,o>1?h+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);
                     } else {
                      xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);
                     }
                     `:h+=`
                     xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);
                     `):g===1?h+=`
                     xC${y+1} = xTexelC${y};
                     `:h+=`
                     xCOffset = xC + ${g};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                       xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${y+1}.zw = vec2(0.0);
                       }
                       xTexelC${y+1}Ready = 1;
                     }

                     xC${y+1} = xTexelC${y+1};
                     `}}else y<c&&(s%2===1?(h+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.0);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
               `,y+1<c&&(h+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);
                 `)):(h+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(
                   xTexelC${y}.xy, xTexelC${y+1}.xy);
               `,y+1<c&&(h+=`
                   xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
                 `)));y<c&&(h+=`
             wTexel = getW(r, ${y}, d1, d2);
             dotProd += xC${y}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${y}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,y+1<c&&(h+=`
               wTexel = getW(r, ${y+1}, d1, d2);
               dotProd += xC${y+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${y+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}h+=`
     }
   `,h+=`
     }
   `,h+=`
     }
   `;let d="",p="";n&&(r?d=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${n}
         }`:a?d=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${n}
         }`:d=`vec4 activation(vec4 x) {
           ${n}
         }`,p="result = activation(result);");let f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${d}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${h}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${f}
         ${p}
         setOutput(result);
       }
     `}},kbe=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=Un(this.outputShape.length);let{dataFormat:n}=t,r=lr(),a=n==="channelsLast",s=a?1:2,i=a?2:3,o=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`,l="";for(let c=0;c<=1;c++)for(let u=0;u<=1;u++)l+=`
          blockIndex = rc.z + ${u};
          pos = rc.y + ${c};

          ${o}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${s}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${i}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${a}) {
                  innerDims = vec2(d1, ch);
                  result[${c*2+u}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${c*2+u}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${l}

        ${r.output} = result;
      }
    `}};function Ix(e,t){let n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&n===1&&e[0]>1?[e[0],1]:null}function OB({x:e,filter:t,convInfo:n,backend:r,bias:a=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:o=null}){let l=e.shape,c=r.texData.get(e.dataId),u=n.inChannels,h=l[0]*l[1]*l[2],d=n.outChannels,p=n.dataFormat==="channelsLast",f=!1,m=!1,y,g=[];if(s!=null){let x=Ix(s.shape,p);x!=null&&(s=pe({inputs:{x:s},backend:r,attrs:{shape:x}}),g.push(s))}if(a!=null){let x=Ix(a.shape,p);x!=null&&(a=pe({inputs:{x:a},backend:r,attrs:{shape:x}}),g.push(a))}if(!((h===1||d===1)&&u>TB)&&c.isPacked&&p&&c.texture!=null&&l[2]%2!==0&&k.arraysEqual(c.shape.slice(-3),l.slice(-3))){let x=l[0]*l[1]*(l[2]+1),b={dataId:e.dataId,shape:[1,x,n.inChannels],dtype:e.dtype},v=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,k.assert(vm(c.shape,b.shape),()=>`packed reshape ${c.shape} to ${b.shape} isn't free`);let w=pe({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});g.push(w);let I=Sx({a:b,b:w,backend:r,transposeA:f,transposeB:m,bias:a,activation:o,preluActivationWeights:s,leakyreluAlpha:i}),_=r.texData.get(I.dataId);k.assert(_.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=v,_.shape=n.outShape,y=Hr({inputs:{x:I},backend:r}),y.shape=n.outShape,g.push(I)}else{let x=n.outHeight*n.outWidth,b=pe({inputs:{x:e},backend:r,attrs:{shape:p?[n.batchSize,x,n.inChannels]:[n.batchSize,n.inChannels,x]}}),v=pe({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),w=Sx({a:p?b:v,b:p?v:b,transposeA:!p,transposeB:m,backend:r,bias:a,activation:o,preluActivationWeights:s,leakyreluAlpha:i});y=pe({inputs:{x:w},backend:r,attrs:{shape:n.outShape}}),g.push(b),g.push(v),g.push(w)}for(let x of g)r.disposeIntermediateTensorInfo(x);return y}function zB({x:e,filter:t,convInfo:n,backend:r,bias:a=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:o=null}){let{filterWidth:l,filterHeight:c,inChannels:u,outWidth:h,outHeight:d,dataFormat:p}=n,f=p==="channelsLast",m=l*c*u,y=d*h,g=[n.batchSize,m,y],x=!0,b=!1,v=[];if(s!=null){let z=Ix(s.shape,f);z!=null&&(s=pe({inputs:{x:s},backend:r,attrs:{shape:z}}),v.push(s))}if(a!=null){let z=Ix(a.shape,f);z!=null&&(a=pe({inputs:{x:a},backend:r,attrs:{shape:z}}),v.push(a))}let w=pe({inputs:{x:t},backend:r,attrs:{shape:[1,m,k.sizeFromShape(t.shape)/m]}});v.push(w);let I=new kbe(g,n),_=[e.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],T=r.runWebGLProgram(I,[e],"float32",_),A=pe({inputs:{x:T},backend:r,attrs:{shape:g}});v.push(T),v.push(A);let M=a!=null,F=s!=null,C=o==="leakyrelu",D=o?wm(o,!0):null,L=new CB(f?A.shape:w.shape,f?w.shape:A.shape,f?[n.batchSize,y,n.outChannels]:[n.batchSize,n.outChannels,y],x,b,M,D,F,C),O=f?[A,w]:[w,A];if(a&&O.push(a),F&&O.push(s),C){let z=r.makeTensorInfo([],"float32",k.createScalarValue(i,"float32"));O.push(z),v.push(z)}let q=r.runWebGLProgram(L,O,"float32"),H=pe({inputs:{x:q},backend:r,attrs:{shape:n.outShape}});v.push(q);for(let z of v)r.disposeIntermediateTensorInfo(z);return H}function Sbe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dataFormat:l,dilations:c,dimRoundingMode:u}=r,h=E.convertConv2DDataFormat(l),d=E.computeConv2DInfo(a.shape,s.shape,i,c,o,u,!1,h),p;if(d.filterHeight===1&&d.filterWidth===1&&d.dilationHeight===1&&d.dilationWidth===1&&d.strideHeight===1&&d.strideWidth===1&&(d.padInfo.type==="SAME"||d.padInfo.type==="VALID"))p=OB({x:a,filter:s,convInfo:d,backend:n});else if(d.strideWidth<=2&&h==="channelsLast"&&X().getBool("WEBGL_EXP_CONV")){let m=new DB(d),y=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];p=n.runWebGLProgram(m,[a,s],"float32",y)}else if(X().getBool("WEBGL_CONV_IM2COL"))p=zB({x:a,filter:s,convInfo:d,backend:n});else{let m=new RB(d);p=n.runWebGLProgram(m,[a,s],"float32")}let f=pe({inputs:{x:p},backend:n,attrs:{shape:d.outShape}});return n.disposeIntermediateTensorInfo(p),f}var Ibe={kernelName:vu,backendName:"webgl",kernelFunc:Sbe},Nbe=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,s=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${a};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${s?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}},_be=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s=e.dataFormat==="channelsLast",i=t-1-e.padInfo.top,o=n-1-e.padInfo.left,l=s?1:2,c=s?2:3,u=s?3:1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${u}];

        ivec2 dyCorner = ivec2(coords[${l}], coords[${c}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${s}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},Cbe=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.padInfo.front,s=e.padInfo.top,i=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${a};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${n} - ${s};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${i};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Tbe=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.front,l=n-1-e.padInfo.top,c=r-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${o}, ${l}, ${c});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${a}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${n}; wR++) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${n} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Ebe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:c,filterShape:u}=r,h=E.convertConv2DDataFormat(l),d=E.computeConv2DInfo(a.shape,u,i,1,o,c,!1,h),p=new Nbe(d);return n.runWebGLProgram(p,[a,s],"float32")}var Abe={kernelName:rb,backendName:"webgl",kernelFunc:Ebe},$be=class{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=Un(this.outputShape.length);let t=e.filterHeight,n=e.filterWidth,r=t-1-e.padInfo.top,a=n-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${r}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            int wCPerm = ${n} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}};function Mbe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:c,dimRoundingMode:u}=r,h=E.convertConv2DDataFormat(c),d=E.computeConv2DInfo(i,s.shape,o,1,l,u,!1,h);if(X().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&h==="channelsLast"){let p=[[d.strideHeight,d.strideWidth]],f=new $be(d);return n.runWebGLProgram(f,[a,s],"float32",p)}else{let p=new _be(d);return n.runWebGLProgram(p,[a,s],"float32")}}var Fbe={kernelName:wu,backendName:"webgl",kernelFunc:Mbe};function Rbe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r,c=E.computeConv3DInfo(a.shape,s.shape,i,l,o),u=new wbe(c);return n.runWebGLProgram(u,[a,s],"float32")}var Dbe={kernelName:ku,backendName:"webgl",kernelFunc:Rbe};function Obe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,filterShape:l}=r,c=E.computeConv3DInfo(a.shape,l,i,1,o),u=new Cbe(c);return n.runWebGLProgram(u,[a,s],"float32")}var zbe={kernelName:_d,backendName:"webgl",kernelFunc:Obe};function Pbe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:i,strides:o,inputShape:l}=r,c=E.computeConv3DInfo(l,s.shape,o,1,i),u=new Tbe(c);return n.runWebGLProgram(u,[a,s],"float32")}var Lbe={kernelName:Cd,backendName:"webgl",kernelFunc:Pbe},Bbe=Op+`
  return cos(x);
`,Wbe=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Dc}
  return result;
`,Ube=nt({opSnippet:Bbe,packedOpSnippet:Wbe}),Vbe={kernelName:Su,backendName:"webgl",kernelFunc:Ube},jbe=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,Gbe=nt({opSnippet:jbe}),Hbe={kernelName:Iu,backendName:"webgl",kernelFunc:Gbe},qbe=class{constructor(e,t,n,r,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[s,i,o,l]=e,[c]=t,[u,h]=n;this.outputShape=[c,u,h,l];let d=r==="bilinear"?1:0,[p,f]=[`${i-1}.0`,`${o-1}.0`],[m,y,g]=u>1?[`${(i-1)/(u-1)}`,"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[x,b,v]=h>1?[`${(o-1)/(h-1)}`,"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`
      const float height_ratio = float(${m});
      const float width_ratio = float(${x});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${s}) {
          return;
        }

        float height_scale = ${y};
        float width_scale = ${b};

        float in_y = ${g};
        if( in_y < 0.0 || in_y > ${p} ) {
          setOutput(float(${a}));
          return;
        }
        float in_x = ${v};
        if( in_x < 0.0 || in_x > ${f} ) {
          setOutput(float(${a}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${d} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}},Kbe=e=>{let{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:c}=r,u=new qbe(a.shape,s.shape,o,l,c);return n.runWebGLProgram(u,[a,s,i],"float32")},Xbe={kernelName:Ed,backendName:"webgl",kernelFunc:Kbe},Sm;(function(e){e.Prod="*",e.Sum="+"})(Sm||(Sm={}));var Y$=class{constructor(e,t,n,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];let a=this.outputShape.length,s=this.op===Sm.Prod?"1.0":"0.0",i=n?s:`getX(${J$(a,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1],l="",c="";n?(l=r?`end != ${o-1}`:"end != 0",c=r?"end + 1":"end - 1"):(l=r?`end + pow2 < ${o}`:"end >= pow2",c=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${vt(a)} coords = getOutputCoords();
        int end = ${Q$(a,"coords",this.op)};
        float val = ${i};
        int pow2 = int(pow(2.0, index));
        if (${l}) {
          int idx = ${c};
          ${Q$(a,"coords",this.op)} = idx;
          val ${this.op}= getX(${J$(a,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function J$(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.x, ${t}.y`;if(e===3)return`${t}.x, ${t}.y, ${t}.z`;if(e===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function Q$(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.y`;if(e===3)return`${t}.z`;if(e===4)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function PB(e,t,n,r,a,s){let i=t.shape.length,o=E.getAxesPermutation([r],i),l=t;o!=null&&(l=rr({inputs:{x:t},backend:n,attrs:{perm:o}}));let c=E.getInnerMostAxes(1,i)[0];if(c!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);let u=l.shape[c],h=Hr({inputs:{x:l},backend:n});for(let d=0;d<=Math.ceil(Math.log2(u))-1;d++){let p=new Y$(e,l.shape,!1,s),f=[[d]],m=h;h=n.runWebGLProgram(p,[h],h.dtype,f),n.disposeIntermediateTensorInfo(m)}if(a){let d=new Y$(e,l.shape,a,s),p=h;h=n.runWebGLProgram(d,[h],h.dtype),n.disposeIntermediateTensorInfo(p)}if(o!=null){let d=E.getUndoAxesPermutation(o),p=rr({inputs:{x:h},backend:n,attrs:{perm:d}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(l),p}return h}function Zbe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;return PB(Sm.Prod,a,n,s,i,o)}var Ybe={kernelName:Td,backendName:"webgl",kernelFunc:Zbe};function Jbe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;return PB(Sm.Sum,a,n,s,i,o)}var Qbe={kernelName:Nu,backendName:"webgl",kernelFunc:Jbe};function eve(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i,binaryOutput:o}=r;if(a.shape.length===1){let l=n.readSync(a.dataId),c=n.readSync(s.dataId),u=gB(l,c,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,u)}else if(a.shape.length===2){let l=n.bufferSync(a),c=n.bufferSync(s),u=nye(l,c,i,o);return n.makeTensorInfo(u.shape,s.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}var tve={kernelName:Wm,backendName:"webgl",kernelFunc:eve},nve=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function rve(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:s,dataFormat:i}=r,o=a.shape[0],l=i==="NHWC"?a.shape[1]:a.shape[2],c=i==="NHWC"?a.shape[2]:a.shape[3],u=i==="NHWC"?a.shape[3]:a.shape[1],h=l*s,d=c*s,p=u/(s*s),f=i==="NHWC"?[o,h,d,p]:[o,p,h,d],m=new nve(f,s,i);return n.runWebGLProgram(m,[a],a.dtype)}var ave={kernelName:Ad,backendName:"webgl",kernelFunc:rve},LB=class{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Un(this.outputShape.length);let s=e.filterHeight,i=e.filterWidth,o=e.outChannels/e.inChannels,l="",c="";n&&(r?l=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:a?l=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:l=`
          float activation(float x) {
            ${n}
          }
        `,c="result = activation(result);");let u=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${l}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${s}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${i}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${u}
        ${c}
        setOutput(result);
      }
    `}},BB=class{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Un(this.outputShape.length);let s=e.outChannels/e.inChannels,i=e.padInfo.left,o=e.strideWidth,l=e.dilationWidth,c=e.filterHeight,u=e.filterWidth,h=u,d=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let y=0;y<u;y++)d+=`
          vec4 xTexelC${y*2};
          int xTexelC${y*2}Ready;
          vec4 xTexelC${y*2+1};
          int xTexelC${y*2+1}Ready;
          vec4 xC${y};`;d+=`
    for (int r = 0; r < ${c}; r++) {
      `;for(let y=0;y<u;y++)d+=`
          xTexelC${y*2} = vec4(0.0);
          xTexelC${y*2}Ready = 0;
          xTexelC${y*2+1} = vec4(0.0);
          xTexelC${y*2+1}Ready = 0;
          xC${y} = vec4(0.0);`;d+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let y=0;y<(h+1)/2;y++){let g=y*2;if(d+=`
          xC = xCCorner + ${g*l};
          `,o===1){if(g<u&&(i%2===1?(d+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g}Ready == 0) {
                  xTexelC${g} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${g}.zw = vec2(0.0);
                  }
                  xTexelC${g}Ready = 1;
                }
              `,l===1&&g>0?d+=`
                xC${g} = vec4(xTexelC${g-2}.zw, xTexelC${g}.xy);
                `:d+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${g} = vec4(previous.zw, xTexelC${g}.xy);
                  } else {
                    xC${g} = vec4(0.0, 0.0, xTexelC${g}.xy);
                  }
                  `):d+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${g}Ready == 0) {
                  xTexelC${g} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${g}.zw = vec2(0.0);
                  }
                  xTexelC${g}Ready = 1;
                }

                xC${g} = xTexelC${g};
                `,g+1<u)){let x=i%2===0?k.nearestLargerEven(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(d+=`
                  xCOffset = xC + imod(pads[1], 2) + ${x};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {
                    xTexelC${g+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${g+1}.zw = vec2(0.0);
                    }
                    xTexelC${g+1}Ready = 1;
                  }
                  `,l>1?d+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${g+1} = vec4(previous.zw, xTexelC${g+1}.xy);
                    } else {
                     xC${g+1} = vec4(0.0, 0.0, xTexelC${g+1}.xy);
                    }
                    `:d+=`
                    xC${g+1} = vec4(xTexelC${g}.zw, xTexelC${g+1}.xy);
                    `):x===1?d+=`
                    xC${g+1} = xTexelC${g};
                    `:d+=`
                    xCOffset = xC + ${x};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {
                      xTexelC${g+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${g+1}.zw = vec2(0.0);
                      }
                      xTexelC${g+1}Ready = 1;
                    }

                    xC${g+1} = xTexelC${g+1};
                    `}}else g<u&&(i%2===1?(d+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g}Ready == 0) {
                  xTexelC${g} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${g}.zw = vec2(0.0);
                  }
                  xTexelC${g}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${g+1}Ready == 0) {
                  xTexelC${g+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${g+1}.zw = vec2(0.0);
                  }
                  xTexelC${g+1}Ready = 1;
                }

                xC${g} = vec4(xTexelC${g}.zw, xTexelC${g+1}.zw);
              `,g+1<u&&(d+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${g+1} = vec4(xTexelC${g+1}.xy, final.xy);
                `)):(d+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${g}Ready == 0) {
                  xTexelC${g} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${g}.zw = vec2(0.0);
                  }
                  xTexelC${g}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {
                  xTexelC${g+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${g+1}.zw = vec2(0.);
                  }
                  xTexelC${g+1}Ready = 1;
                }

                xC${g} = vec4(
                  xTexelC${g}.xy, xTexelC${g+1}.xy);
              `,g+1<u&&(d+=`
                  xC${g+1} = vec4(xTexelC${g}.zw, xTexelC${g+1}.zw);
                `)));g<u&&(d+=`
            wTexel = getW(r, ${g}, d1, q);
            dotProd += xC${g} * vec4(wTexel.xz, wTexel.xz);
          `,g+1<u&&(d+=`
              wTexel = getW(r, ${g+1}, d1, q);
              dotProd += xC${g+1} * vec4(wTexel.xz, wTexel.xz);
            `))}d+=`
    }
  `,d+=`
      }
    `;let p="",f="";n&&(r?p=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:a?p=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:p=`vec4 activation(vec4 x) {
          ${n}
        }`,f="result = activation(result);");let m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${p}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${s};
        int q = d2 - d1 * ${s};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${d}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${m}
        ${f}
        setOutput(result);
      }
    `}};function sve(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:c}=r,u=l;u==null&&(u=[1,1]),k.assert(E.eitherStridesOrDilationsAreOne(i,u),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let h=E.computeConv2DInfo(a.shape,s.shape,i,u,o,c,!0),d;X().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?d=new BB(h):d=new LB(h);let p=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return n.runWebGLProgram(d,[a,s],"float32",p)}var ive={kernelName:_u,backendName:"webgl",kernelFunc:sve},ove=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,s=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${s} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${a};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},lve=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s=t-1-e.padInfo.top,i=n-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${s}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${o}; dm++) {
              int d2 = d1 * ${o} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function uve(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:c,filterShape:u}=r,h=E.computeConv2DInfo(a.shape,u,i,o,l,c,!0),d=new ove(h);return n.runWebGLProgram(d,[a,s],"float32")}var cve={kernelName:ab,backendName:"webgl",kernelFunc:uve};function hve(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:c,inputShape:u}=r,h=E.computeConv2DInfo(u,s.shape,i,o,l,c,!0),d=new lve(h);return n.runWebGLProgram(d,[a,s],"float32")}var dve={kernelName:sb,backendName:"webgl",kernelFunc:hve},pve=class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};function fve(e){let{inputs:t,backend:n}=e,{x:r}=t,a=[...r.shape,...r.shape],s=k.sizeFromShape(r.shape),i=pe({inputs:{x:r},backend:n,attrs:{shape:[s]}}),o=new pve(s),l=n.runWebGLProgram(o,[i],i.dtype),c=pe({inputs:{x:l},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),c}var mve={kernelName:Um,backendName:"webgl",kernelFunc:fve},gve=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let{inHeight:t,inWidth:n,padInfo:r,strideHeight:a,strideWidth:s,filterHeight:i,filterWidth:o,dilationHeight:l,dilationWidth:c}=e,{top:u,left:h}=r;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${s});
      const ivec2 pads = ivec2(${u}, ${h});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${i}; h++) {
          int hIn = hBeg + h * ${l};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${o}; w++) {
              int wIn = wBeg + w * ${c};

              if (wIn >= 0 && wIn < ${n}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};function yve(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r,c=E.computeDilation2DInfo(a.shape,s.shape,i,o,"NHWC",l),u,h=new gve(c);u=n.runWebGLProgram(h,[a,s],"float32");let d=pe({inputs:{x:u},backend:n,attrs:{shape:c.outShape}});return n.disposeIntermediateTensorInfo(u),d}var xve={kernelName:Cu,backendName:"webgl",kernelFunc:yve};function bve(e){let{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,s=t,{allDims:i,summedDims:o,idDims:l}=E.decodeEinsumEquation(a,s.length);E.checkEinsumDimSizes(i.length,l,s);let{path:c,steps:u}=E.getEinsumComputePath(o,l),h=u.length,d=null,p=i.length,f=[];for(let m=0;m<h;++m){for(let y of u[m]){let{permutationIndices:g,expandDims:x}=E.getEinsumPermutation(p,l[y]),b;E.isIdentityPermutation(g)?b=s[y]:(b=rr({inputs:{x:s[y]},backend:n,attrs:{perm:g}}),f.push(b));let v=b.shape.slice();for(let w=0;w<x.length;++w)v.splice(x[w],0,1);k.arraysEqual(b.shape,v)||(b=pe({inputs:{x:b},backend:n,attrs:{shape:v}}),f.push(b)),d===null?d=b:(d=kC({inputs:{a:b,b:d},backend:n}),f.push(d))}m<h-1&&(c[m]>=0&&(d=Sv({inputs:{x:d},backend:n,attrs:{axis:c[m]-(i.length-p),keepDims:!1}}),f.push(d)),p--)}for(let m of f)m!==d&&n.disposeIntermediateTensorInfo(m);return d}var vve={kernelName:ob,backendName:"webgl",kernelFunc:bve},wve="return (x >= 0.0) ? x : (exp(x) - 1.0);",kve=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,Sve=nt({opSnippet:wve,packedOpSnippet:kve}),Ive={kernelName:Eu,backendName:"webgl",kernelFunc:Sve},Nve="return (b >= 0.0) ? a : a * (b + 1.0);",_ve=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,Cve=e=>{let{inputs:t,backend:n}=e,{dy:r,y:a}=t,s=X().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Dp(_ve,r.shape,a.shape):new eu(Nve,r.shape,a.shape);return n.runWebGLProgram(s,[r,a],r.dtype)},Tve={kernelName:$d,backendName:"webgl",kernelFunc:Cve},Eve=`
  return vec4(equal(a, b));
`,Ave="return float(a == b);",$ve=Dn({opSnippet:Ave,packedOpSnippet:Eve,dtype:"bool",cpuKernelImpl:oye}),Mve={kernelName:Md,backendName:"webgl",kernelFunc:$ve},Fve=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${E.ERF_P};
  float a1 = ${E.ERF_A1};
  float a2 = ${E.ERF_A2};
  float a3 = ${E.ERF_A3};
  float a4 = ${E.ERF_A4};
  float a5 = ${E.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,Rve=nt({opSnippet:Fve}),Dve={kernelName:Au,backendName:"webgl",kernelFunc:Rve},Ove=Op+`
  return exp(x);
`,zve=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,WB=nt({opSnippet:Ove,packedOpSnippet:zve,cpuKernelImpl:lye,dtype:"float32"}),Pve={kernelName:$u,backendName:"webgl",kernelFunc:WB};function u2(e){let{inputs:t,attrs:n,backend:r}=e,{dim:a}=n,{input:s}=t,i=s.shape.length,o=s.shape.slice(),l=a;return a<0&&(k.assert(-(i+1)<=a,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+a+1),o.splice(l,0,1),pe({inputs:{x:s},backend:r,attrs:{shape:o}})}var Lve={kernelName:Fd,backendName:"webgl",kernelFunc:u2},eM="return exp(x) - 1.0;",Bve=nt({opSnippet:eM,packedOpSnippet:eM,cpuKernelImpl:uye}),Wve={kernelName:Mu,backendName:"webgl",kernelFunc:Bve},tM=class{constructor(e,t,n){this.variableNames=["real","imag"];let r=t[1];this.outputShape=t;let a=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,s=n?`${r}.0`:"1.0",i;if(e==="real")i="return real * expR - imag * expI;";else if(e==="imag")i="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${a};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${i}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${s};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};function UB(e,t,n){let r=n.texData.get(e.dataId),a=k.sizeFromShape(e.shape),s=e.shape[e.shape.length-1],i=a/s,o=pe({inputs:{x:e},backend:n,attrs:{shape:[i,s]}}),l=o.shape,c=new tM("real",l,t),u=new tM("imag",l,t),h=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],d=n.runWebGLProgram(c,h,"float32"),p=n.runWebGLProgram(u,h,"float32"),f=Go({inputs:{real:d,imag:p},backend:n});n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p);let m=pe({inputs:{x:f},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(f),m}function Uve(e){let{inputs:t,backend:n}=e,{input:r}=t;return UB(r,!1,n)}var Vve={kernelName:lb,backendName:"webgl",kernelFunc:Uve},jve=class{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};function Og(e){let{backend:t,attrs:n}=e,{shape:r,value:a}=n,{dtype:s}=n;if(s=s||k.inferDtype(a),s==="string"){let i=k.getArrayFromDType(s,k.sizeFromShape(r));return i.fill(a),t.makeTensorInfo(r,s,i)}else{let i=new jve(r,a),o=[[a]];return t.runWebGLProgram(i,[],s,o)}}var Gve={kernelName:Vm,backendName:"webgl",kernelFunc:Og},Hve=class{constructor(e){this.variableNames=["Image"],this.outputShape=[];let t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}},qve={kernelName:Rd,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{let{image:n}=e,r=t,a=new Hve(n.shape);return r.runWebGLProgram(a,[n],n.dtype)}},nM="return floor(x);",Kve=nt({opSnippet:nM,packedOpSnippet:nM,cpuKernelImpl:cye}),Xve={kernelName:Fu,backendName:"webgl",kernelFunc:Kve},Zve=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,Yve=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,Jve=Dn({opSnippet:Zve,packedOpSnippet:Yve,dtype:"int32"}),Qve={kernelName:Ru,backendName:"webgl",kernelFunc:Jve},ewe=class{constructor(e){this.variableNames=["A"];let t=lr(),[n,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}},twe=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let t=lr(),[n,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${n}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}},nwe={kernelName:nx,backendName:"webgl",kernelFunc:rwe},rh,n1=X().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function rwe(e){let{inputs:t,backend:n,attrs:r}=e,{pixels:a}=t,{numChannels:s}=r,i=typeof HTMLVideoElement<"u"&&a instanceof HTMLVideoElement,o=typeof HTMLImageElement<"u"&&a instanceof HTMLImageElement,[l,c]=i?[a.videoWidth,a.videoHeight]:[a.width,a.height],u=[c,l],h=[c,l,s];if(o||i){let m=X().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(rh==null||m!==n1)&&(n1=m,rh=document.createElement("canvas").getContext("2d",{willReadFrequently:n1})),rh.canvas.width=l,rh.canvas.height=c,rh.drawImage(a,0,0,l,c),a=rh.canvas}let d=n.makeTensorInfo(u,"int32");n.texData.get(d.dataId).usage=aa.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),a);let p=X().getBool("WEBGL_PACK")?new twe(h):new ewe(h),f=n.runWebGLProgram(p,[d],"int32");return n.disposeData(d.dataId),f}function awe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r,m=E.convertConv2DDataFormat(u),y=E.computeConv2DInfo(a.shape,s.shape,l,h,c,d,!1,m),g,x=[],b=i!=null,v=o!=null,w=p==="leakyrelu",I=()=>{let T=[a,s],A=(M,F)=>{if(F==="NCHW"&&M.shape.length===1&&M.shape[0]!==1){let C=pe({inputs:{x:M},backend:n,attrs:{shape:[M.shape[0],1,1]}});return x.push(C),C}return M};if(b&&T.push(A(i,u)),v&&T.push(A(o,u)),w){let M=n.makeTensorInfo([],"float32",k.createScalarValue(f,"float32"));T.push(M),x.push(M)}return T};if(y.filterHeight===1&&y.filterWidth===1&&y.dilationHeight===1&&y.dilationWidth===1&&y.strideHeight===1&&y.strideWidth===1&&(y.padInfo.type==="SAME"||y.padInfo.type==="VALID"))g=OB({x:a,filter:s,convInfo:y,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else if(y.strideWidth<=2&&m==="channelsLast"&&X().getBool("WEBGL_EXP_CONV")){let T=p?wm(p,!0):null,A=new DB(y,b,T,v,w),M=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],F=I();g=n.runWebGLProgram(A,F,"float32",M)}else if(X().getBool("WEBGL_CONV_IM2COL"))g=zB({x:a,filter:s,convInfo:y,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else{let T=p?wm(p,!1):null,A=new RB(y,b,T,v,w),M=I();g=n.runWebGLProgram(A,M,"float32")}let _=pe({inputs:{x:g},backend:n,attrs:{shape:y.outShape}});return x.push(g),x.forEach(T=>n.disposeIntermediateTensorInfo(T)),_}var swe={kernelName:Pl,backendName:"webgl",kernelFunc:awe};function iwe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:c,dilations:u,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=r,f=[],m=u;m==null&&(m=[1,1]),k.assert(E.eitherStridesOrDilationsAreOne(l,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`);let y=E.computeConv2DInfo(a.shape,s.shape,l,m,c,h,!0),g=X().getBool("WEBGL_PACK_DEPTHWISECONV")&&y.strideWidth<=2&&y.outChannels/y.inChannels===1,x=d?wm(d,g):null,b=[a,s],v=i!=null,w=o!=null,I=d==="leakyrelu";if(v&&b.push(i),w&&b.push(o),I){let M=n.makeTensorInfo([],"float32",k.createScalarValue(p,"float32"));b.push(M),f.push(M)}let _;g?_=new BB(y,v,x,w,I):_=new LB(y,v,x,w,I);let T=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],A=n.runWebGLProgram(_,b,"float32",T);return f.forEach(M=>n.disposeIntermediateTensorInfo(M)),A}var owe={kernelName:Ll,backendName:"webgl",kernelFunc:iwe},lwe=class{constructor(e,t,n,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;let a=vt(n.length),s=`
    int index;`;for(let i=0;i<this.sliceDim;i++)s+=`
          index = round(getIndices(coords[0], ${i}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[i]};
          flattenIndex += index * ${this.strides[i]};`;this.userCode=`
         void main() {
          ${a} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${s}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}};function uwe(e){let{inputs:t,backend:n}=e,{params:r,indices:a}=t,s=a.shape,i=s[s.length-1],o=k.sizeFromShape(r.shape),[l,c,u,h]=E.prepareAndValidate(r,a),d=pe({inputs:{x:a},backend:n,attrs:{shape:[c,i]}}),p=pe({inputs:{x:r},backend:n,attrs:{shape:[k.sizeFromShape(r.shape)/u,u]}});if(n.shouldExecuteOnCPU([r,a])||r.dtype==="string"){let g=n.readSync(a.dataId),x=n.bufferSync(r),b=hye(g,x,r.dtype,c,i,u,h,r.shape,o);return n.makeTensorInfo(l,r.dtype,b.values)}let f=new lwe(i,h,[c,u],r.shape),m=n.runWebGLProgram(f,[p,d],p.dtype),y=pe({inputs:{x:m},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),y}var cwe={kernelName:Od,backendName:"webgl",kernelFunc:uwe},hwe=class{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;let n=vt(this.rank),r=dwe(e);this.userCode=`
      void main() {
        ${n} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}};function dwe(e,t){let n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let a=0;a<e.length;a++)a===2?r.push("index"):r.push(`${n[a]}`);return r.join()}function VB(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,indices:s}=t,{axis:i,batchDims:o}=r,l=k.parseAxisParam(i,a.shape)[0];if(X().get("DEBUG")){let x=n.readSync(s.dataId),b=a.shape[l];for(let v=0;v<x.length;++v){let w=x[v];k.assert(w<=b-1&&w>=0,()=>`GatherV2: the index value ${w} is not in [0, ${b-1}]`)}}let c=E.segment_util.collectGatherOpShapeInfo(a,s,l,o),u=k.sizeFromShape(s.shape),h=[],d=pe({inputs:{x:a},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),p=pe({inputs:{x:s},backend:n,attrs:{shape:[c.batchSize,u/c.batchSize]}});h.push(d),h.push(p);let f=[c.batchSize,c.outerSize,u/c.batchSize,c.sliceSize];if(n.shouldExecuteOnCPU([a,s])||a.dtype==="string"){let x=n.bufferSync(p),b=n.bufferSync(d),v=dye(b,x,f);return h.forEach(w=>n.disposeIntermediateTensorInfo(w)),n.makeTensorInfo(c.outputShape,v.dtype,v.values)}let m=new hwe(d.shape,f),y=n.runWebGLProgram(m,[d,p],d.dtype);h.push(y);let g=pe({inputs:{x:y},backend:n,attrs:{shape:c.outputShape}});return h.forEach(x=>n.disposeIntermediateTensorInfo(x)),g}var pwe={kernelName:Dd,backendName:"webgl",kernelFunc:VB},fwe="return float(a > b);",mwe=`
  return vec4(greaterThan(a, b));
`,gwe=Dn({opSnippet:fwe,packedOpSnippet:mwe,cpuKernelImpl:pye,dtype:"bool"}),ywe={kernelName:zd,backendName:"webgl",kernelFunc:gwe},xwe="return float(a >= b);",bwe=`
  return vec4(greaterThanEqual(a, b));
`,vwe=Dn({opSnippet:xwe,packedOpSnippet:bwe,dtype:"bool",cpuKernelImpl:fye}),wwe={kernelName:Ou,backendName:"webgl",kernelFunc:vwe};function kwe(e){let{inputs:t,backend:n}=e,{input:r}=t;return UB(r,!0,n)}var Swe={kernelName:ub,backendName:"webgl",kernelFunc:kwe},Iwe="return float(!isnan(x) && !isinf(x));",Nwe=nt({opSnippet:Iwe,dtype:"bool"}),_we={kernelName:Pu,backendName:"webgl",kernelFunc:Nwe},Cwe="return float(isinf(x));",Twe=nt({opSnippet:Cwe,dtype:"bool"}),Ewe={kernelName:Lu,backendName:"webgl",kernelFunc:Twe},Awe="return float(isnan(x));",$we=nt({opSnippet:Awe,dtype:"bool"}),Mwe={kernelName:Bu,backendName:"webgl",kernelFunc:$we},Fwe="return float(a < b);",Rwe=`
  return vec4(lessThan(a, b));
`,Dwe=Dn({opSnippet:Fwe,packedOpSnippet:Rwe,cpuKernelImpl:mye,dtype:"bool"}),Owe={kernelName:Pd,backendName:"webgl",kernelFunc:Dwe},zwe="return float(a <= b);",Pwe=`
  return vec4(lessThanEqual(a, b));
`,Lwe=Dn({opSnippet:zwe,packedOpSnippet:Pwe,cpuKernelImpl:gye,dtype:"bool"}),Bwe={kernelName:Ld,backendName:"webgl",kernelFunc:Lwe};function Wwe(e){let{backend:t,attrs:n}=e,{start:r,stop:a,num:s}=n,i=yye(r,a,s);return t.makeTensorInfo([i.length],"float32",i)}var Uwe={kernelName:Bd,backendName:"webgl",kernelFunc:Wwe},Vwe=Op+`
  return x < 0.0 ? 0./0. : log(x);
`,jwe=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,Gwe=nt({opSnippet:Vwe,packedOpSnippet:jwe,cpuKernelImpl:xye}),Hwe={kernelName:Uu,backendName:"webgl",kernelFunc:Gwe},qwe=Op+`
  return log(1.0 + x);
`,Kwe=nt({opSnippet:qwe}),Xwe={kernelName:Vu,backendName:"webgl",kernelFunc:Kwe},Zwe="return float(a >= 1.0 && b >= 1.0);",Ywe=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,Jwe=Dn({opSnippet:Zwe,packedOpSnippet:Ywe,dtype:"bool"}),Qwe={kernelName:Wd,backendName:"webgl",kernelFunc:Jwe},e1e="return float(!(x >= 1.0));",t1e=nt({opSnippet:e1e}),n1e={kernelName:Ud,backendName:"webgl",kernelFunc:t1e},r1e="return float(a >= 1.0 || b >= 1.0);",a1e=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,s1e=Dn({opSnippet:r1e,packedOpSnippet:a1e,dtype:"bool"}),i1e={kernelName:Vd,backendName:"webgl",kernelFunc:s1e},o1e=class{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[];let s=t,i=e[3]-1;this.outputShape=e;let o,l=`float(${n}) + float(${r}) * sum`;a===.5?o=`inversesqrt(${l})`:a===1?o=`1.0/(${l})`:o=`exp(log(${l}) * float(-${a}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${s}; j <= ${s}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${i}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${o};
        setOutput(val);
      }
    `}},l1e=class{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let s=t,i=e[3]-1;this.outputShape=e;let o,l=`float(${n}) + float(${r}) * sum`;a===.5?o=`inversesqrt(${l})`:a===1?o=`1.0/(${l})`:o=`exp(log(${l}) * float(-${a}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${s};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${s}; j <= ${s}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${o};
        setOutput(result);
      }
    `}},u1e=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=r,c=X().getBool("WEBGL_PACK_NORMALIZATION")?new l1e(a.shape,s,i,o,l):new o1e(a.shape,s,i,o,l);return n.runWebGLProgram(c,[a],a.dtype)},c1e={kernelName:ju,backendName:"webgl",kernelFunc:u1e},h1e=class{constructor(e,t,n,r,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=a,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${n});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${a})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${a});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}},d1e=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:c,beta:u}=r,h=new h1e(a.shape,o,l,c,u);return n.runWebGLProgram(h,[a,s,i],a.dtype)},p1e={kernelName:jd,backendName:"webgl",kernelFunc:d1e};function f1e(e,t,n,r){let a=k.sizeFromShape(t),s=k.sizeFromShape(e.shape)/a,i=pe({inputs:{x:e},attrs:{shape:[s,a]},backend:r}),o=Oc(i,e.dtype,"max",r),l=pe({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(o),l}function jB(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:s,keepDims:i}=r,o=a.shape.length,l=k.parseAxisParam(s,a.shape),c=l,u=E.getAxesPermutation(c,o),h=u!=null,d=n.shouldExecuteOnCPU([a]),p=a;if(h){if(d){let x=n.texData.get(p.dataId).values,b=new Array(o);for(let I=0;I<b.length;I++)b[I]=a.shape[u[I]];let v=bC(x,a.shape,a.dtype,u,b);p=n.makeTensorInfo(b,a.dtype);let w=n.texData.get(p.dataId);w.values=v}else p=kv(a,u,n);c=E.getInnerMostAxes(c.length,o)}E.assertAxesAreInnerMostDims("max",c,o);let[f,m]=E.computeOutAndReduceShapes(p.shape,c),y=f;i&&(y=E.expandShapeToKeepDim(f,l));let g;if(d){let x=n.texData.get(p.dataId).values,b=bye(x,k.sizeFromShape(m),y,a.dtype);g=n.makeTensorInfo(y,a.dtype);let v=n.texData.get(g.dataId);v.values=b}else g=f1e(p,m,y,n);return h&&n.disposeIntermediateTensorInfo(p),g}var m1e={kernelName:Gu,backendName:"webgl",kernelFunc:jB},g1e=wC+`
  return max(a, b);
`,y1e=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Dc+`
  return result;
`,x1e=Dn({opSnippet:g1e,packedOpSnippet:y1e,cpuKernelImpl:vye}),b1e={kernelName:Hu,backendName:"webgl",kernelFunc:x1e};function v1e(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;Ap(a,"maxPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r,c=1;k.assert(E.eitherStridesOrDilationsAreOne(i,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);let u=E.computePool2DInfo(a.shape,s,i,c,o,l);if(u.filterWidth===1&&u.filterHeight===1&&k.arraysEqual(u.inShape,u.outShape))return Hr({inputs:{x:a},backend:n});let h=new km(u,"max",!1);return n.runWebGLProgram(h,[a],a.dtype)}var w1e={kernelName:qu,backendName:"webgl",kernelFunc:v1e};function k1e(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dataFormat:l,dimRoundingMode:c}=r,u=[1,1,1],h=E.computePool3DInfo(a.shape,s,i,u,o,c,l),d=new SC(h,"max",!1);return n.runWebGLProgram(d,[a],a.dtype)}var S1e={kernelName:Gd,backendName:"webgl",kernelFunc:k1e},I1e=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,a=e.effectiveFilterHeight,s=e.effectiveFilterWidth,i=a-1-e.padInfo.top,o=s-1-e.padInfo.left,l=a*s-1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${a};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${n}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${s} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},N1e=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.dilationDepth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterDepth,l=e.effectiveFilterHeight,c=e.effectiveFilterWidth,u=o-1-e.padInfo.front,h=l-1-e.padInfo.top,d=c-1-e.padInfo.left,p=o*l*c-1;this.userCode=`
      const ivec3 pads = ivec3(${u}, ${h}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${o};
           wD += ${a}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${l};
              wR += ${s}) {
            float dyR = float(dyRCorner + wR) / ${n}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${c};
                wC += ${i}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${p} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${l} * ${c} +
                  wR * ${c} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function _1e(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s,{filterSize:o,strides:l,pad:c,dimRoundingMode:u}=r,h=[1,1,1],d=E.computePool3DInfo(i.shape,o,l,h,c,u),p=new SC(d,"max",!0),f=n.runWebGLProgram(p,[i],i.dtype),m=new N1e(d),y=n.runWebGLProgram(m,[a,f],i.dtype);return n.disposeIntermediateTensorInfo(f),y}var C1e={kernelName:Gm,backendName:"webgl",kernelFunc:_1e};function T1e(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s,output:i}=t,o=s;Ap([s,i],"maxPoolGrad");let{filterSize:l,strides:c,pad:u,dimRoundingMode:h}=r,d=E.computePool2DInfo(o.shape,l,c,1,u,h),p=!0,f=new km(d,"max",p),m=n.runWebGLProgram(f,[o],o.dtype),y=new I1e(d),g=n.runWebGLProgram(y,[a,m],o.dtype);return n.disposeIntermediateTensorInfo(m),g}var E1e={kernelName:jm,backendName:"webgl",kernelFunc:T1e};function A1e(e,t,n,r){let a=new km(n,"max",!1),s=r.runWebGLProgram(a,[e],"float32");a=new km(n,"max",!0,!0,t);let i=r.runWebGLProgram(a,[e],"float32");return[s,i]}var $1e={kernelName:Hm,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{filterSize:a,strides:s,pad:i,includeBatchInIndex:o}=t,l=n;k.assert(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);let c=[1,1];k.assert(E.eitherStridesOrDilationsAreOne(s,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${c}'`);let u=E.computePool2DInfo(r.shape,a,s,c,i),[h,d]=A1e(r,o,u,l);return[h,d]}};function M1e(e,t,n,r){let a=k.sizeFromShape(t),s=k.sizeFromShape(e.shape)/a,i=pe({inputs:{x:e},attrs:{shape:[s,a]},backend:r}),o=Oc(i,"float32","mean",r),l=pe({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(o),l}var F1e={kernelName:Ku,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{keepDims:a,axis:s}=t,i=n,o=r.shape.length,l=k.parseAxisParam(s,r.shape),c=l,u=E.getAxesPermutation(c,o),h=u!=null,d=i.shouldExecuteOnCPU([r]),p=[],f=r;if(h){if(d){let b=i.texData.get(f.dataId).values,v=new Array(o);for(let _=0;_<v.length;_++)v[_]=r.shape[u[_]];let w=bC(b,r.shape,r.dtype,u,v);f=i.makeTensorInfo(v,r.dtype);let I=i.texData.get(f.dataId);I.values=w}else f=kv(r,u,i);p.push(f),c=E.getInnerMostAxes(c.length,o)}E.assertAxesAreInnerMostDims("sum",c,o);let[m,y]=E.computeOutAndReduceShapes(f.shape,c),g=m;a&&(g=E.expandShapeToKeepDim(m,l));let x=M1e(f,y,g,i);for(let b of p)i.disposeIntermediateTensorInfo(b);return x}};function R1e(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=k.parseAxisParam(s,a.shape),c=l,u=E.getAxesPermutation(c,o),h=a;u!=null&&(h=rr({inputs:{x:a},backend:n,attrs:{perm:u}}),c=E.getInnerMostAxes(c.length,a.shape.length)),E.assertAxesAreInnerMostDims("min",c,o);let[d,p]=E.computeOutAndReduceShapes(h.shape,c),f=k.sizeFromShape(p),m=pe({inputs:{x:h},backend:n,attrs:{shape:[-1,f]}}),y=Oc(m,m.dtype,"min",n),g;if(i){let x=E.expandShapeToKeepDim(d,l);g=pe({inputs:{x:y},backend:n,attrs:{shape:x}})}else g=pe({inputs:{x:y},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),u!=null&&n.disposeIntermediateTensorInfo(h),g}var D1e={kernelName:Xu,backendName:"webgl",kernelFunc:R1e},O1e=wC+`
  return min(a, b);
`,z1e=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Dc+`
  return result;
`,P1e=Dn({opSnippet:O1e,packedOpSnippet:z1e,cpuKernelImpl:wye}),L1e={kernelName:Zu,backendName:"webgl",kernelFunc:P1e},B1e=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map((c,u)=>c[0]+e[u]+c[1]);let r=e.length,a=vt(r),s=t.map(c=>c[0]).join(","),i=t.map((c,u)=>c[0]+e[u]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l=n==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${s};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${l};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${l};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${a} start = ${a}(${s});
      ${a} end = ${a}(${i});

      void main() {
        ${a} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${l};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};
          }
        }
        ${a} coords = outC - start;
        setOutput(getX(${o}));
      }
    `}},W1e=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((p,f)=>p[0]+e[f]+p[1]);let r=e.length,a=vt(r),s=t.map(p=>p[0]).join(","),i=t.map((p,f)=>p[0]+e[f]).join(","),o=Jn("rc",r),l=Jn("source",r),c=`${o[r-1]} < ${this.outputShape[r-1]}`,u=r===1?"source":`vec2(${l.slice(-2).join()})`,h=n==="reflect"?0:1,d="";if(r===1){let p=`
        ${a} source = rc;
        if (source < start) {
          source = start * 2 - source - ${h};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${h};
        }
        source -= start;
      `;d=`
        ${a} rc = outputLoc;
        ${p}
        result[0] = getChannel(getX(${l.join()}), ${u});
        ${o[r-1]} += 1;
        if(${c}) {
          ${p}
          result[1] = getChannel(getX(${l.join()}), ${u});
        }
      `}else{let p=`
        ${a} source = rc;
        ${a} lt = ${a}(lessThan(source, start));
        ${a} gte = ${a}(greaterThanEqual(source, end));
        ${a} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${h}) +
                gte * ((end - 1) * 2 - source + ${h});
        source -= start;
      `;d=`
        ${a} rc = outputLoc;
        ${p}
        result[0] = getChannel(getX(${l.join()}), ${u});
        ${o[r-1]} += 1;
        if(${c}) {
          ${p}
          result[1] = getChannel(getX(${l.join()}), ${u});
        }
        rc = outputLoc;
        ${o[r-2]} += 1;
        if(${o[r-2]} < ${this.outputShape[r-2]}) {
          ${p}
          result[2] = getChannel(getX(${l.join()}), ${u});
          ${o[r-1]} += 1;
          if(${c}) {
            ${p}
            result[3] = getChannel(getX(${l.join()}), ${u});
          }
        }
      `}this.userCode=`
      const ${a} start = ${a}(${s});
      const ${a} end = ${a}(${i});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${d}
        setOutput(result);
      }
    `}},U1e=({inputs:e,backend:t,attrs:n})=>{let{x:r}=e,{paddings:a,mode:s}=n,i=X().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new W1e(r.shape,a,s):new B1e(r.shape,a,s);return t.runWebGLProgram(i,[r],r.dtype)},V1e={kernelName:Yu,backendName:"webgl",kernelFunc:U1e},j1e=`if (b == 0.0) return NAN;
  return mod(a, b);`,G1e=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Dc+`
  return result;
`,H1e=Dn({opSnippet:j1e,packedOpSnippet:G1e}),q1e={kernelName:Ju,backendName:"webgl",kernelFunc:H1e},K1e=class{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}},X1e=`
if (a == b) {
  return 1.0;
};
return a / b;`,Z1e=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,GB=Dn({opSnippet:X1e,packedOpSnippet:Z1e,checkOutOfBounds:!0}),Y1e={kernelName:Tu,backendName:"webgl",kernelFunc:GB},rM="return a - b;",HB=Dn({opSnippet:rM,packedOpSnippet:rM,supportsComplex:!0,cpuKernelImpl:Uye}),J1e={kernelName:Sc,backendName:"webgl",kernelFunc:HB};function qB(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:s}=r,i=k.parseAxisParam([s],a.shape),o=jB({inputs:{x:a},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),l=E.expandShapeToKeepDim(o.shape,i),c=pe({inputs:{x:o},backend:n,attrs:{shape:l}}),u=HB({inputs:{a,b:c},backend:n}),h=WB({inputs:{x:u},backend:n}),d=Sv({inputs:{x:h},backend:n,attrs:{axis:i,keepDims:!1}}),p=pe({inputs:{x:d},backend:n,attrs:{shape:l}}),f=GB({inputs:{a:h,b:p},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),f}var Q1e={kernelName:wc,backendName:"webgl",kernelFunc:qB};function eke(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:i,normalized:o}=r,l=o?a:qB({inputs:{logits:a},backend:n,attrs:{dim:a.shape.length-1}}),c=l.shape[0],u=l.shape[1],h=new K1e(c,u,s),d=[[i]],p=n.runWebGLProgram(h,[l],"int32",d);return o||n.disposeIntermediateTensorInfo(l),p}var tke={kernelName:Hd,backendName:"webgl",kernelFunc:eke},nke=Fa+`
  return -x;
`,rke=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function ake(e){let{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){let s=n.texData.get(r.dataId),[i,o]=Sye(s.values,r.shape,r.dtype);return n.makeTensorInfo(o,r.dtype,i)}let a;return X().getBool("WEBGL_PACK_UNARY_OPERATIONS")?a=new Yi(r.shape,rke):a=new ws(r.shape,nke),n.runWebGLProgram(a,[r],r.dtype)}var ske={kernelName:qd,backendName:"webgl",kernelFunc:ake},ike=Fs.nonMaxSuppressionV3Impl;function oke(e){E.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r,c=n.readSync(a.dataId),u=n.readSync(s.dataId),{selectedIndices:h}=ike(c,u,i,o,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}var lke={kernelName:Xd,backendName:"webgl",kernelFunc:oke},uke=Fs.nonMaxSuppressionV4Impl;function cke(e){E.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:c}=r,u=n.readSync(a.dataId),h=n.readSync(s.dataId),{selectedIndices:d,validOutputs:p}=uke(u,h,i,o,l,c);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}var hke={kernelName:Zd,backendName:"webgl",kernelFunc:cke},dke=Fs.nonMaxSuppressionV5Impl;function pke(e){E.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:c}=r,u=n.readSync(a.dataId),h=n.readSync(s.dataId),d=i,p=o,f=l,m=c,{selectedIndices:y,selectedScores:g}=dke(u,h,d,p,f,m);return[n.makeTensorInfo([y.length],"int32",new Int32Array(y)),n.makeTensorInfo([g.length],"float32",new Float32Array(g))]}var fke={kernelName:Yd,backendName:"webgl",kernelFunc:pke},mke=class{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${n}),
                      float(index == coords.y)));
      }
    `}},gke=e=>{let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:s,depth:i,onValue:o,offValue:l}=r,c=k.sizeFromShape(a.shape),u=new mke(c,i,o,l),h=pe({inputs:{x:a},backend:n,attrs:{shape:[c]}}),d=n.runWebGLProgram(u,[h],s);n.disposeIntermediateTensorInfo(h);let p=[...a.shape,i],f=pe({inputs:{x:d},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(d),f},yke={kernelName:ec,backendName:"webgl",kernelFunc:gke};function Nx(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="complex64"){let a=Dg({inputs:{input:r},backend:n}),s=Nx({inputs:{x:a},backend:n}),i=Iv({inputs:{input:r},backend:n}),o=Nx({inputs:{x:i},backend:n}),l=Go({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return Og({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:n})}var xke={kernelName:gp,backendName:"webgl",kernelFunc:Nx};function KB(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){let a=Dg({inputs:{input:r},backend:n}),s=KB({inputs:{x:a},backend:n}),i=Iv({inputs:{input:r},backend:n}),o=Nx({inputs:{x:i},backend:n}),l=Go({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return Og({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:n})}var bke={kernelName:Jd,backendName:"webgl",kernelFunc:KB};function vke(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(t.length===1)return u2({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let s=t[0].shape,i=t[0].dtype;t.forEach(u=>{k.assertShapesMatch(s,u.shape,"All tensors passed to stack must have matching shapes"),k.assert(i===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],l=t.map(u=>{let h=u2({inputs:{input:u},backend:n,attrs:{dim:a}});return o.push(h),h}),c=FB({inputs:l,backend:n,attrs:{axis:a}});return o.forEach(u=>n.disposeIntermediateTensorInfo(u)),c}var wke={kernelName:Qd,backendName:"webgl",kernelFunc:vke},kke=class{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((l,c)=>l[0]+e[c]+l[1]);let r=e.length,a=vt(r),s=t.map(l=>l[0]).join(","),i=t.map((l,c)=>l[0]+e[c]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${s};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${a} start = ${a}(${s});
      ${a} end = ${a}(${i});

      void main() {
        ${a} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${a} coords = outC - start;
          setOutput(getX(${o}));
        }
      }
    `}},Ske=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((f,m)=>f[0]+e[m]+f[1]);let r=e.length,a=vt(r),s=t.map(f=>f[0]).join(","),i=t.map((f,m)=>f[0]+e[m]).join(","),o=Jn("rc",r),l=Jn("source",r),c=`${o[r-1]} < ${this.outputShape[r-1]}`,u=r===1?"source":`vec2(${l.slice(-2).join()})`,h=[`${a} rc = outputLoc;`,`${o[r-1]} += 1;
       if(${c}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${o[r-2]} += 1;
       if(${o[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${o[r-1]} += 1;
         if(${c}) {`],d=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",p="";for(let f=0,m=r===1?2:4;f<m;f++)p+=`
        ${h[f]}
        if (${d}) {
          result[${f}] = float(value);
        } else {
          ${a} source = rc - start;
          result[${f}] = getChannel(getX(${l.join()}), ${u});
        }
      `;p+=r===1?"} ":"}}",this.userCode=`
      const ${a} start = ${a}(${s});
      const ${a} end = ${a}(${i});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `}},XB=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,constantValue:i}=r;if(k.sizeFromShape(a.shape)===0){let c=s.map((u,h)=>u[0]+a.shape[h]+u[1]);return Og({backend:n,attrs:{shape:c,value:i,dtype:a.dtype}})}let o=X().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Ske(a.shape,s,i):new kke(a.shape,s,i),l=[[i]];return n.runWebGLProgram(o,[a],a.dtype,l)},Ike={kernelName:tc,backendName:"webgl",kernelFunc:XB},Nke=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,_ke=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Dc+`
  return result;
`,Cke=Dn({opSnippet:Nke,packedOpSnippet:_ke}),Tke={kernelName:nc,backendName:"webgl",kernelFunc:Cke};function Eke(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=[],c=k.parseAxisParam(s,a.shape),u=c,h=E.getAxesPermutation(u,o),d=a;h!=null&&(d=rr({inputs:{x:a},backend:n,attrs:{perm:h}}),u=E.getInnerMostAxes(u.length,o),l.push(d)),E.assertAxesAreInnerMostDims("prod",u,o);let p;if(n.shouldExecuteOnCPU([d])){let f=n.texData.get(d.dataId).values,{outVals:m,outShape:y,outDtype:g}=Nye(d.shape,d.dtype,f,u);p=n.makeTensorInfo(y,g,m)}else{let[f,m]=E.computeOutAndReduceShapes(d.shape,u),y=k.sizeFromShape(m),g=pe({inputs:{x:d},backend:n,attrs:{shape:[-1,y]}}),x=gb(a.dtype),b=Oc(g,x,"prod",n);p=pe({inputs:{x:b},backend:n,attrs:{shape:f}}),l.push(g),l.push(b)}if(i){l.push(p);let f=E.expandShapeToKeepDim(p.shape,c);p=pe({inputs:{x:p},backend:n,attrs:{shape:f}})}return l.forEach(f=>n.disposeIntermediateTensorInfo(f)),p}var Ake={kernelName:ac,backendName:"webgl",kernelFunc:Eke};function $ke(e){let{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:a,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=r,l=a.map(g=>n.readSync(g.dataId)),c=a.map(g=>g.shape),u=n.readSync(s.dataId),h=n.readSync(i.dataId),[d,p,f]=_ye(l,c,u,s.shape,s.dtype,h,i.shape,o),m=d.map(g=>n.makeTensorInfo([g.length],"int32",g)),y=n.makeTensorInfo(f,s.dtype,p);return m.concat([y])}var Mke={kernelName:hb,backendName:"webgl",kernelFunc:$ke};function Fke(e){let{inputs:t,backend:n}=e,{starts:r,limits:a,deltas:s}=t,i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[c,u]=Cye(i,r.shape,r.dtype,o,a.shape,l,s.shape),h=n.makeTensorInfo([c.length],"int32",c),d=n.makeTensorInfo([u.length],r.dtype,u);return[h,d]}var Rke={kernelName:db,backendName:"webgl",kernelFunc:Fke};function Dke(e){let{inputs:t,backend:n,attrs:r}=e,{shape:a,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,c=n.readSync(a.dataId),u=n.readSync(s.dataId),h=n.readSync(i.dataId),d=o.map(y=>n.readSync(y.dataId)),p=o.map(y=>y.shape),[f,m]=Tye(c,a.shape,u,s.shape,s.dtype,h,i.shape,d,p,l);return n.makeTensorInfo(f,s.dtype,m)}var Oke={kernelName:pb,backendName:"webgl",kernelFunc:Dke},ZB=e=>{let{backend:t,attrs:n}=e,{start:r,stop:a,step:s,dtype:i}=n,o=Eye(r,a,s,i);return t.makeTensorInfo([o.length],i,o)},zke={kernelName:qm,backendName:"webgl",kernelFunc:ZB},Pke="return 1.0 / x;",Lke=nt({opSnippet:Pke}),Bke={kernelName:sc,backendName:"webgl",kernelFunc:Lke},Wke=Fa+`
  return (x < 0.0) ? 0.0 : x;
`,Uke=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Vke=nt({opSnippet:Wke,packedOpSnippet:Uke}),jke={kernelName:ic,backendName:"webgl",kernelFunc:Vke},Gke=Fa+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Hke=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,qke=nt({opSnippet:Gke,packedOpSnippet:Hke}),Kke={kernelName:uc,backendName:"webgl",kernelFunc:qke},Xke=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let c=[r&&t>1?i-1:i,r&&n>1?o-1:o],u=[r&&t>1?t-1:t,r&&n>1?n-1:n],h;a?h="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":h="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/u[0]},
          ${c[1]/u[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${h};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}},Zke=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let c=[r&&t>1?i-1:i,r&&n>1?o-1:o],u=[r&&t>1?t-1:t,r&&n>1?n-1:n],h;a?h="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":h="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/u[0]},
          ${c[1]/u[1]},
          ${c[1]/u[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,
                                     ${o}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${h};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}};function Yke(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,c]=o,u=X().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Zke(a.shape,l,c,s,i):new Xke(a.shape,l,c,s,i);return n.runWebGLProgram(u,[a],"float32")}var Jke={kernelName:lc,backendName:"webgl",kernelFunc:Yke},Qke=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,r,a]=t,[,s,i]=e,o=[n&&s>1?r-1:r,n&&i>1?a-1:a],l=[n&&s>1?s-1:s,n&&i>1?i-1:i],c=o[0]/l[0],u=o[1]/l[1],h=1/c,d=1/u,p=Math.ceil(h)*2+2,f=Math.ceil(d)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${u});

        const float invHeightScale = float(${h});
        const float invWidthScale = float(${d});

        const int winHeight = int(${p});
        const int winWidth = int(${f});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${s}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${a-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function e2e(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r,o=new Qke(s.shape,a.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}var t2e={kernelName:np,backendName:"webgl",kernelFunc:e2e},n2e=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let c=[r&&t>1?i-1:i,r&&n>1?o-1:o],u=[r&&t>1?t-1:t,r&&n>1?n-1:n],h=r?"0.5":"0.0",d;a?d="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/u[0]},
          ${c[1]/u[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}},r2e=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let c=[r&&t>1?i-1:i,r&&n>1?o-1:o],u=[r&&t>1?t-1:t,r&&n>1?n-1:n],h=r?"0.5":"0.0",d;a?d="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/u[0]},
          ${c[1]/u[1]},
          ${c[1]/u[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,
                                     ${o}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}};function a2e(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,c]=o,u=X().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new r2e(a.shape,l,c,s,i):new n2e(a.shape,l,c,s,i);return n.runWebGLProgram(u,[a],a.dtype)}var s2e={kernelName:oc,backendName:"webgl",kernelFunc:a2e},i2e=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,r,a]=t,[,s,i]=e,o=[n&&s>1?r-1:r,n&&i>1?a-1:a],l=[n&&s>1?s-1:s,n&&i>1?i-1:i],c=o[0]/l[0],u=o[1]/l[1],h=1/c,d=1/u,p=Math.ceil(h)*2+2,f=Math.ceil(d)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${u});

        const float invHeightScale = float(${h});
        const float invWidthScale = float(${d});

        const int winHeight = int(${p});
        const int winWidth = int(${f});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${s}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float sourceFracRow =
              float(${o[0]}) *
                (float(dyR) / float(${l[0]}));

            float sourceFracCol =
                float(${o[1]}) *
                  (float(dyC) / float(${l[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${n} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${a}) - 1),
                ${n} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function o2e(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r,o=new i2e(s.shape,a.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}var l2e={kernelName:tp,backendName:"webgl",kernelFunc:o2e},u2e=class{constructor(e,t){this.variableNames=["x"];let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,n===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}let r=i=>t.indexOf(i)!==-1&&e[i]!==1?`${e[i]} - coords[${i}] - 1`:`coords[${i}]`,a=e.map((i,o)=>r(o)).join(","),s=vt(n);this.userCode=`
      void main() {
        ${s} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}},c2e=class{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;let r=Jn("rc",n),a=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,s=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,i=vt(n);n===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${a}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${i} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${o(r.slice())};
          if(${a}){
            result.g = ${l(r.slice())};
          }
          if(${s}) {
            result.b = ${c(r.slice())};
            if(${a}) {
              result.a = ${u(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function o(p){return h(p)}function l(p){return p[n-1]="("+p[n-1]+" + 1)",h(p)}function c(p){return p[n-2]="("+p[n-2]+" + 1)",h(p)}function u(p){return p[n-1]="("+p[n-1]+" + 1)",p[n-2]="("+p[n-2]+" + 1)",h(p)}function h(p){let f=e.map((g,x)=>d(x,p)),m=f.join(","),y=f.slice(-2).join(",");return`getChannel(getX(${m}), vec2(${y}))`}function d(p,f){return t.indexOf(p)!==-1&&e[p]!==1?`${e[p]} - ${f[p]} - 1`:`${f[p]}`}}};function h2e(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r,i=a.shape.length,o=k.parseAxisParam(s,a.shape);if(i===0)return Hr({inputs:{x:a},backend:n});let l=X().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new c2e(a.shape,o):new u2e(a.shape,o);return n.runWebGLProgram(l,[a],a.dtype)}var d2e={kernelName:cc,backendName:"webgl",kernelFunc:h2e},p2e=class{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let n=e[1],r=e[2];this.outputShape=e;let a="";typeof t=="number"?a=`float outputValue = ${t.toFixed(2)};`:a=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${a}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}},f2e={kernelName:yp,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,{radians:a,fillValue:s,center:i}=t,o=n,l=new p2e(r.shape,s),[c,u]=E.getImageCenter(i,r.shape[1],r.shape[2]),h=[[c,u,Math.sin(a),Math.cos(a)]];return o.runWebGLProgram(l,[r],r.dtype,h)}},m2e=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,g2e=nt({opSnippet:m2e}),y2e={kernelName:hc,backendName:"webgl",kernelFunc:g2e},x2e="return inversesqrt(x);",b2e=nt({opSnippet:x2e,cpuKernelImpl:Aye}),v2e={kernelName:dc,backendName:"webgl",kernelFunc:b2e},IC=class{constructor(e,t,n,r,a,s,i=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=s;let l=vt(a.length),c=vt(s.length),u="";n===1?u="i":n===2&&(u="i, j");let h=`getIndices(${u})`,d="";r===1?d="i":r===2&&(d="i, coords[1]");let p=`getUpdates(${d})`,f="";o&&(f="coords[0], coords[1]");let m=`getDefaultValue(${f})`,y=t>1?"strides[j]":"strides";this.userCode=`
        ${l} strides = ${l}(${a});

        void main() {
          ${c} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${h});
              flattenedIndex += index * ${y};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${p};
              found = true;
            }
          }
          setOutput(mix(${m}, sum, float(found)));
        }
      `}},w2e=class{constructor(e,t,n,r,a,s,i=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s;let l=vt(a.length),c=vt(s.length),u="";n===1?u="i":n===2&&(u="i, j");let h=`getIndices(${u})`,d="";r===1?d="i":r===2&&(d="i, coords[1]");let p=`getUpdates(${d})`,f="";o&&(f="coords[0], coords[1]");let m=`getDefaultValue(${f})`,y=t>1?"strides[j]":"strides",g=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${l} strides = ${l}(${a});

        void main() {
          ${c} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${h});
              flattenedIndex += index.xz * ${y};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${g};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${p};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${m}, sum, found));
        }
      `}};function k2e(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:s}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=E.calculateShapes(s,a,i),d=[h/c,c];if(h===0)return n.makeTensorInfo(i,a.dtype);let p=pe({inputs:{x:a},backend:n,attrs:{shape:[l,o]}}),f=pe({inputs:{x:s},backend:n,attrs:{shape:[l,c]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0])),y;X().getBool("WEBGL_PACK")?y=new w2e(l,o,p.shape.length,f.shape.length,u,d):y=new IC(l,o,p.shape.length,f.shape.length,u,d);let g=n.runWebGLProgram(y,[f,p,m],f.dtype),x=pe({inputs:{x:g},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(m),x}var S2e={kernelName:rp,backendName:"webgl",kernelFunc:k2e},I2e=class{constructor(e,t,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];let a="while (left < right) {",s=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,i=X().getNumber("WEBGL_VERSION")===2?a:s,o=r==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${i}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${o} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};function N2e(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:i}=r,o=new I2e(a.shape[0],a.shape[1],s.shape[1],i),l=[[a.shape[1]]];return n.runWebGLProgram(o,[a,s],"int32",l)}var _2e={kernelName:sp,backendName:"webgl",kernelFunc:N2e},C2e=class{constructor(e,t,n){this.variableNames=["c","a","b"],this.outputShape=t;let r,a;if(n>4)throw Error(`Where for rank ${n} is not yet supported`);if(n===1)a="resRC",r="resRC";else{let i=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],l=[];for(let c=0;c<t.length;c++)l.push(`${i[c]}`),c<e&&o.push(`${i[c]}`);r=o.join(),a=l.join()}let s=vt(n);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${a}));
        } else {
          setOutput(getB(${a}));
        }
      }
    `}};function T2e(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t,i=new C2e(r.shape.length,a.shape,a.shape.length);return n.runWebGLProgram(i,[r,a,s],ca(a.dtype,s.dtype))}var E2e={kernelName:ip,backendName:"webgl",kernelFunc:T2e},A2e=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${E.SELU_SCALEALPHA};
  float scale = ${E.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,$2e=nt({opSnippet:A2e}),M2e={kernelName:pc,backendName:"webgl",kernelFunc:$2e},F2e=Op+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,R2e=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,D2e=nt({opSnippet:F2e,packedOpSnippet:R2e,cpuKernelImpl:Mye}),O2e={kernelName:yc,backendName:"webgl",kernelFunc:D2e},z2e=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,P2e=nt({opSnippet:z2e}),L2e={kernelName:gc,backendName:"webgl",kernelFunc:P2e},B2e=Op+`
  return sin(x);
`,W2e=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Dc}
  return result;
`,U2e=nt({opSnippet:B2e,packedOpSnippet:W2e}),V2e={kernelName:fc,backendName:"webgl",kernelFunc:U2e},j2e=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,G2e=nt({opSnippet:j2e}),H2e={kernelName:mc,backendName:"webgl",kernelFunc:G2e},q2e=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,K2e=nt({opSnippet:q2e}),X2e={kernelName:xc,backendName:"webgl",kernelFunc:K2e},Z2e=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r;k.assert(a.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let o=s.reduce((g,x)=>g*x),l=[[0,0]];l.push(...i);for(let g=1+s.length;g<a.shape.length;++g)l.push([0,0]);let c=[],u=XB({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),h=E.getReshaped(u.shape,s,o,!1),d=E.getPermuted(h.length,s.length,!1),p=E.getReshapedPermuted(u.shape,s,o,!1),f=pe({inputs:{x:u},backend:n,attrs:{shape:h}}),m=rr({inputs:{x:f},backend:n,attrs:{perm:d}}),y=pe({inputs:{x:m},backend:n,attrs:{shape:p}});return c.push(u),c.push(f),c.push(m),c.forEach(g=>n.disposeIntermediateTensorInfo(g)),y},Y2e={kernelName:lp,backendName:"webgl",kernelFunc:Z2e};function J2e(e){let{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:s,defaultValue:i}=t;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${s.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(a.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${a.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let o=n.readSync(r.dataId),l=n.readSync(a.dataId),c=n.readSync(s.dataId),u=n.readSync(i.dataId)[0],[h,d,p,f,m]=Rye(o,r.shape,r.dtype,l,a.dtype,c,u);return[n.makeTensorInfo(d,r.dtype,h),n.makeTensorInfo([d[0]],a.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(y=>Number(y)))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}var Q2e={kernelName:Km,backendName:"webgl",kernelFunc:J2e};function eSe(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:s}=t;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(a.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${a.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(n.readSync(a.dataId)),o=n.readSync(r.dataId),l=Array.from(n.readSync(s.dataId)),[c,u,h]=Dye(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(u,r.dtype,c),n.makeTensorInfo([h.length],s.dtype,new Int32Array(h))]}var tSe={kernelName:cp,backendName:"webgl",kernelFunc:eSe};function nSe(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(a.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${a.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${s.shape}`);let i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[c,u]=xB(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(u,r.dtype,c)}var rSe={kernelName:Xm,backendName:"webgl",kernelFunc:nSe};function aSe(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(a.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${a.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${s.shape}`);let i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[c,u]=xB(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(u,r.dtype,c)}var sSe={kernelName:Zm,backendName:"webgl",kernelFunc:aSe};function iSe(e){let{inputs:t,backend:n,attrs:r}=e,{sparseIndices:a,sparseValues:s,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:d}=E.calculateShapes(s,a,o),p=!1;if(s.dtype==="string"){let g=n.bufferSync(a),x=n.bufferSync(s),b=k.decodeString(n.readSync(i.dataId)[0]),v=$ye(g,x,o,d,u,c,l,h,b,p);return n.makeTensorInfo(o,v.dtype,v.values)}let f=new IC(c,l,a.shape.length,s.shape.length,h,[d,1],p),m=n.runWebGLProgram(f,[s,a,i],s.dtype),y=pe({inputs:{x:m},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(m),y}var oSe={kernelName:hp,backendName:"webgl",kernelFunc:iSe};function lSe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=r,o=k.parseAxisParam(i,a.shape)[0],l=E.prepareSplitSize(a,s,o),c=a.shape.length,u=new Array(c).fill(0),h=a.shape.slice();return l.map(d=>{let p=[...h];p[o]=d;let f=zp({inputs:{x:a},backend:n,attrs:{begin:u,size:p}});return u[o]+=d,f})}var uSe={kernelName:up,backendName:"webgl",kernelFunc:lSe},aM="return sqrt(x);",cSe=nt({opSnippet:aM,packedOpSnippet:aM,cpuKernelImpl:Oye}),hSe={kernelName:bc,backendName:"webgl",kernelFunc:cSe},dSe="return x * x;",pSe=nt({opSnippet:dSe}),fSe={kernelName:Ym,backendName:"webgl",kernelFunc:pSe},sM="return (a - b) * (a - b);",mSe=Dn({opSnippet:sM,packedOpSnippet:sM}),gSe={kernelName:kc,backendName:"webgl",kernelFunc:mSe};function ySe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");let s=n.readSync(a.dataId),i=E.fromUint8ToStringArray(s),o=zye(i,"string",r);return n.makeTensorInfo(a.shape,"string",o)}var xSe={kernelName:Jm,backendName:"webgl",kernelFunc:ySe};function bSe({inputs:e,attrs:t,backend:n}){let{x:r}=e,a=Fa+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,s=new ws(r.shape,a);return n.runWebGLProgram(s,[r],r.dtype)}var vSe={kernelName:Po,backendName:"webgl",kernelFunc:bSe},wSe=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;let r=n.length,a=vt(n.length),s=vt(n.length),i="";if(r===1)i="coords * strides + begin";else{let o=0;i=n.map((l,c)=>(o++,n.length===1?`coords * strides[${c}] + begin[${c}]`:`coords[${o-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`
      ${a} begin = ${a}(${e});
      ${a} strides = ${a}(${t});

      void main() {
        ${s} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}};function kSe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,end:i,strides:o,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:d}=r,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:y,isSimpleSlice:g,begin:x,end:b,strides:v}=ln.sliceInfo(a.shape,s,i,o,l,c,u,h,d),w;if(m)w=pe({inputs:{x:a},backend:n,attrs:{shape:f}});else if(y||g){k.assert(a.shape.length>=1,()=>`Input must have rank at least 1, got: ${a.shape.length}`);let _=ln.computeOutShape(x,b,v),T=zp({inputs:{x:a},backend:n,attrs:{begin:x,size:_}});w=pe({inputs:{x:T},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(T)}else if(n.shouldExecuteOnCPU([a])){let _=n.readSync(a.dataId),T=Ve(a.shape,a.dtype,_),A=Pye(p,T,v,x);w=n.makeTensorInfo(f,a.dtype,A.values)}else{let _=new wSe(x,v,p);w=n.runWebGLProgram(_,[a],a.dtype)}let I=pe({inputs:{x:w},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(w),I}var SSe={kernelName:dp,backendName:"webgl",kernelFunc:kSe};function ISe(e){let{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:c}=r,{data:u,dataSplits:h}=t,d=n.readSync(u.dataId),p=n.readSync(h.dataId),[f,m]=Lye(d,p,a,s,i,o,l,c);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}var NSe={kernelName:Qm,backendName:"webgl",kernelFunc:ISe};function _Se(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:s,delimiter:i}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let o=n.readSync(s.dataId),l=n.readSync(i.dataId)[0],[c,u,h]=Bye(o,l,a),d=u.length;return[n.makeTensorInfo([d,2],"int32",c),n.makeTensorInfo([d],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(h))]}var CSe={kernelName:eg,backendName:"webgl",kernelFunc:_Se};function TSe(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");let i=n.readSync(s.dataId),o=Wye(i,a);return n.makeTensorInfo(s.shape,"int32",o)}var ESe={kernelName:tg,backendName:"webgl",kernelFunc:TSe},ASe="return tan(x);",$Se=nt({opSnippet:ASe}),MSe={kernelName:Ic,backendName:"webgl",kernelFunc:$Se},FSe=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,RSe=nt({opSnippet:FSe}),DSe={kernelName:Nc,backendName:"webgl",kernelFunc:RSe};function OSe(e){let{inputs:t,backend:n,attrs:r}=e,{tensor:a,indices:s,updates:i}=t,{sliceRank:o,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=E.calculateShapes(i,s,a.shape),d=[h/c,c];if(h===0)return n.makeTensorInfo(a.shape,s.dtype);let p=pe({inputs:{x:s},backend:n,attrs:{shape:[l,o]}}),f=pe({inputs:{x:i},backend:n,attrs:{shape:[l,c]}}),m=pe({inputs:{x:a},backend:n,attrs:{shape:d}}),y=new IC(l,o,p.shape.length,f.shape.length,u,d,!1,!0),g=n.runWebGLProgram(y,[f,p,m],m.dtype),x=pe({inputs:{x:g},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),x}var zSe={kernelName:ap,backendName:"webgl",kernelFunc:OSe},PSe=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[s]*t[s];this.outputShape=n,this.rank=n.length;let r=vt(this.rank),a=LSe(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${a}));
      }
    `}};function LSe(e){let t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${e[0]})`;let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let a=0;a<e.length;a++)r.push(`imod(${n[a]}, ${e[a]})`);return r.join()}function YB(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:s}=r;if(a.dtype==="string"||a.shape.length>5){let o=n.readSync(a.dataId),l=a.dtype==="string"?o.map(h=>k.decodeString(h)):o,c=Ve(a.shape,a.dtype,l),u=Vye(c,s);return n.makeTensorInfo(u.shape,u.dtype,u.values)}let i=new PSe(a.shape,s);return n.runWebGLProgram(i,[a],a.dtype)}var BSe={kernelName:zo,backendName:"webgl",kernelFunc:YB},WSe=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},USe=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};function al(e,t){t!==null&&e.disposeIntermediateTensorInfo(t)}function iM(e){let t=1;for(;t<e;)t*=2;return t}function VSe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:s,sorted:i}=r,o=X().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=X().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=a.shape,u=c[c.length-1];if(n.shouldExecuteOnCPU([a])||u<o||s>l){let A=n.readSync(a.dataId),[M,F]=jye(A,c,a.dtype,s,i);return[n.makeTensorInfo(M.shape,M.dtype,M.values),n.makeTensorInfo(F.shape,F.dtype,F.values)]}if(s===0)return c[c.length-1]=0,[n.makeTensorInfo(c,a.dtype,[]),n.makeTensorInfo(c,"int32",[])];if(u===1)return[a,Og({attrs:{shape:c,dtype:"int32",value:0},backend:n})];let h=n.texData.get(a.dataId),d=h!==null&&h.isPacked,p=d?n.unpackTensor(a):a,f=k.sizeFromShape(c)/u,m=pe({inputs:{x:p},attrs:{shape:[f,u]},backend:n});d&&al(n,p);let y=iM(s),g=iM(u),x=null,b=()=>x===null?[m,m]:[m,x],v=(A,M,F)=>{let C=b(),D=new WSe(F),L=[[u],[x===null?1:0],[Number.NEGATIVE_INFINITY],[A],[M]],O=x;x=n.runWebGLProgram(D,C,"int32",L),al(n,O)};for(let A=1;A<y;A*=2){let M=A*2;for(let F=A;F>=1;F/=2)v(M,F,[f,g])}for(let A=g;A>y;A/=2){let M=b(),F=new USe([f,A/2]),C=[[u],[x===null?1:0],[y]],D=x;x=n.runWebGLProgram(F,M,"int32",C),al(n,D);let L=y/2,O=L*2;for(let q=L;q>=1;q/=2)v(O,q,x.shape)}let w=x;x=zp({inputs:{x},backend:n,attrs:{begin:0,size:[f,s]}}),al(n,w);let I=VB({inputs:{x:m,indices:x},backend:n,attrs:{axis:1,batchDims:1}});al(n,m);let _=c.slice(0,-1);_.push(s),w=x,x=pe({inputs:{x},attrs:{shape:_},backend:n}),al(n,w);let T=I;return I=pe({inputs:{x:I},attrs:{shape:_},backend:n}),al(n,T),[I,x]}var jSe={kernelName:pp,backendName:"webgl",kernelFunc:VSe},GSe=class{constructor(e,t,n,r,a,s){this.variableNames=["Image","Transforms"],this.outputShape=s;let i=n==="nearest"?1:2,o;switch(r){case"constant":o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4;break;default:o=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${o} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${o} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${o} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${a});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${a});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${i} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};function HSe(e){let{inputs:t,backend:n,attrs:r}=e,{image:a,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:c}=r,[u,h,d,p]=a.shape,[f,m]=c??[h,d],y=[u,f,m,p],g=new GSe(h,d,i,o,l,y);return n.runWebGLProgram(g,[a,s],"float32")}var qSe={kernelName:fp,backendName:"webgl",kernelFunc:HSe};function KSe(e){let{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t;Ap(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let i=r.readSync(s.dataId),{outputValues:o,outputShape:l,indices:c}=Gye(i,a,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,o),r.makeTensorInfo([c.length],"int32",c)]}var XSe={kernelName:ng,backendName:"webgl",kernelFunc:KSe};function ZSe(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:s}=r;s<0&&(s+=a.shape.length);let i=a,o=i.shape.length,l=a.shape[s],c=new Array(o-1),u=0;for(let m=0;m<o;m++)m!==s&&(c[u++]=i.shape[m]);let h=[],d=new Array(o).fill(0),p=i.shape.slice();p[s]=1;let f=new Array(l);for(let m=0;m<f.length;m++){d[s]=m;let y=zp({inputs:{x:i},backend:n,attrs:{begin:d,size:p}}),g=pe({inputs:{x:y},backend:n,attrs:{shape:c}});f[m]=g,h.push(y)}return h.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}var YSe={kernelName:mp,backendName:"webgl",kernelFunc:ZSe},JSe=class{constructor(e,t){this.variableNames=["x","segmentIds"];let n=e.windowSize,r=e.batchSize,a=e.inSize,s=e.numSegments,i=s*Math.ceil(a/n);this.outputShape=[r,i];let o="0.0",l="sumValue",c=Math.floor(n/4)*4,u=n%4,h=`
        sumValue += dot(values, segFilter);
    `,d="";a%n>0&&(d=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return initializationValue;
        }
      `);let p="";a%n>0&&(p=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${o};

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${p}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${s})) * float(${n}));
        int currentSeg = int(mod(float(outIdx), float(${s})));

        float sumValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${h}
        }

        int inIdx = inOffset + ${c};
        if (${u===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${h}
        } else if (${u===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${h}
        } else if (${u===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${h}
        }
        setOutput(${l});
      }
    `}};function QSe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:s}=t,{numSegments:i}=r,o=a.shape.length,l=[],c=0,u=E.getAxesPermutation([c],o),h=a;u!=null&&(h=rr({inputs:{x:a},backend:n,attrs:{perm:u}}),l.push(h),c=E.getInnerMostAxes(1,o)[0]);let d=E.segment_util.computeOutShape(h.shape,c,i),p=k.sizeFromShape([h.shape[c]]),f=pe({inputs:{x:h},backend:n,attrs:{shape:[-1,p]}});l.push(f);let m=gb(a.dtype),y=(v,w,I,_,T)=>{let A=v.shape[0],M=v.shape[1],F=E.segment_util.segOpComputeOptimalWindowSize(M,T),C={windowSize:F,inSize:M,batchSize:A,numSegments:T},D=new JSe(C,w),L=n.compileAndRun(D,[v,I],_);if(l.push(L),L.shape[1]===T)return L;let O=ZB({backend:n,attrs:{start:0,stop:T,step:1,dtype:"float32"}}),q=YB({inputs:{x:O},backend:n,attrs:{reps:[M/F]}});return l.push(O),l.push(q),y(L,w,q,_,T)},g=y(f,"unsortedSegmentSum",s,m,i),x=pe({inputs:{x:g},backend:n,attrs:{shape:d}}),b=x;if(u!=null){l.push(x);let v=E.getUndoAxesPermutation(u);b=rr({inputs:{x:b},backend:n,attrs:{perm:v}})}return l.forEach(v=>n.disposeIntermediateTensorInfo(v)),b}var eIe={kernelName:rg,backendName:"webgl",kernelFunc:QSe},tIe=[P0e,B0e,V0e,H0e,K0e,Y0e,Q0e,txe,sxe,oxe,cxe,pxe,gxe,vxe,Sxe,Nxe,Cxe,$xe,Fxe,Dxe,Lxe,Hxe,Kxe,Jxe,ebe,ibe,lbe,dbe,w0e,mbe,vbe,Ibe,Abe,Fbe,Dbe,zbe,Lbe,Vbe,Hbe,Xbe,Ybe,Qbe,tve,ave,ive,cve,dve,mve,xve,vve,Ive,Tve,Mve,Dve,Pve,Lve,Wve,Vve,Gve,qve,Xve,Qve,nwe,swe,owe,cwe,pwe,ywe,wwe,v0e,Swe,xbe,_we,Ewe,Mwe,S0e,Owe,Bwe,Uwe,Hwe,Xwe,Qwe,n1e,i1e,c1e,p1e,m1e,b1e,w1e,S1e,C1e,E1e,$1e,F1e,D1e,L1e,V1e,q1e,tke,_0e,ske,lke,hke,fke,nbe,yke,bke,wke,Ike,Tke,N0e,Ake,Mke,Rke,Oke,zke,rbe,Y1e,Bke,jke,Kke,T0e,Jke,t2e,s2e,l2e,d2e,f2e,y2e,v2e,S2e,_2e,E2e,M2e,O2e,L2e,V2e,H2e,jxe,Q1e,X2e,Y2e,Q2e,tSe,rSe,sSe,oSe,uSe,hSe,fSe,gSe,xSe,vSe,SSe,NSe,CSe,ESe,J1e,D0e,MSe,DSe,zSe,BSe,jSe,qSe,O0e,XSe,YSe,eIe,xke];for(let e of tIe)ag(e);var at;(function(e){e[e.float32=0]="float32",e[e.int32=1]="int32",e[e.bool=2]="bool",e[e.string=3]="string",e[e.complex64=4]="complex64"})(at||(at={}));var Im;(function(e){e[e.linear=0]="linear",e[e.relu=1]="relu",e[e.relu6=2]="relu6",e[e.prelu=3]="prelu",e[e.leakyrelu=4]="leakyrelu",e[e.sigmoid=5]="sigmoid",e[e.elu=6]="elu"})(Im||(Im={}));var JB;function nIe(e){JB=e.wasm.cwrap(zl,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])}function rIe(e){let{inputs:t,backend:n,attrs:r}=e,{a,b:s,bias:i,preluActivationWeights:o}=t;if(a.dtype!=="float32"||s.dtype!=="float32")throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");let{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=r,d=n.dataIdMap.get(a.dataId).id,p=n.dataIdMap.get(s.dataId).id,f=0;if(i!=null){let T=n.dataIdMap.get(i.dataId);if(T.shape.length!==1)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${T.shape.length}.`);f=T.id}let m=o==null?0:n.dataIdMap.get(o.dataId).id,y=Im[u];if(y==null)throw new Error(`${u} activation not yet supported for FusedConv2D in the wasm backend.`);let g=l?a.shape[2]:a.shape[1],x=c?s.shape[1]:s.shape[2],b=xp.assertAndGetBroadcastShape(a.shape.slice(0,-2),s.shape.slice(0,-2)),v=n.makeOutput([...b,g,x],a.dtype),w=n.dataIdMap.get(v.dataId).id,I=new Uint8Array(new Int32Array(a.shape).buffer),_=new Uint8Array(new Int32Array(s.shape).buffer);return JB(d,I,a.shape.length,p,_,s.shape.length,l,c,y,f,m,h||0,w),v}var aIe={kernelName:zl,backendName:"wasm",setupFunc:nIe,kernelFunc:rIe};function et(e,t){let n;function r(s){n=s.wasm.cwrap(e,null,["number","number","number"])}function a(s){let{backend:i,inputs:{x:o}}=s,l=i.dataIdMap.get(o.dataId).id,c=i.makeOutput(o.shape,t||o.dtype),u=i.dataIdMap.get(c.dataId).id;return k.sizeFromShape(c.shape)===0||n(l,at[o.dtype],u),c}return{kernelName:e,backendName:"wasm",setupFunc:r,kernelFunc:a}}var sIe=et(gd),iIe=et(lu),oIe=et(uu);function tn(e,t,n){let r;function a(i){r=i.wasm.cwrap(e,null,["number","array","number","number","array","number","number","number"])}function s(i){let{backend:o,inputs:l}=i,{a:c,b:u}=l,h=o.dataIdMap.get(c.dataId).id,d=o.dataIdMap.get(u.dataId).id,p=n??c.dtype,f=E.assertAndGetBroadcastShape(c.shape,u.shape),m=o.makeOutput(f,p);if(k.sizeFromShape(f)===0)return m;let y=new Uint8Array(new Int32Array(c.shape).buffer),g=new Uint8Array(new Int32Array(u.shape).buffer),x=o.dataIdMap.get(m.dataId).id;return r(h,y,c.shape.length,d,g,u.shape.length,at[c.dtype],x),m}return{kernelName:e,backendName:"wasm",setupFunc:a,kernelFunc:s}}var lIe=tn(Do),QB;function uIe(e){QB=e.wasm.cwrap(cu,null,["array","number","number","number"])}function cIe(e){let{inputs:t,backend:n}=e,r=n.makeOutput(t[0].shape,t[0].dtype);if(k.sizeFromShape(r.shape)===0)return r;let a=t.map(o=>n.dataIdMap.get(o.dataId).id),s=new Uint8Array(new Int32Array(a).buffer),i=n.dataIdMap.get(r.dataId).id;return QB(s,a.length,at[r.dtype],i),r}var hIe={kernelName:cu,backendName:"wasm",setupFunc:uIe,kernelFunc:cIe};function Nv(e){let{inputs:{x:t},backend:n}=e;if(t.dtype==="string")return er(n.readSync(t.dataId),t.shape,t.dtype);let r=n.makeOutput(t.shape,t.dtype),a=n.typedArrayFromHeap(t);return n.typedArrayFromHeap(r).set(a),r}var dIe={kernelName:zu,backendName:"wasm",kernelFunc:Nv},eW;function pIe(e){eW=e.wasm.cwrap(ni,null,["number","array","number","number","number","array","number"])}function To(e){let{inputs:t,backend:n,attrs:r}=e,[a,s]=mIe(t.x.shape,r.perm),i=!0;for(let f=0;f<s.length;f++)s[f]!==f&&(i=!1);let o=fIe(t.x.shape,r.perm),l={dataId:t.x.dataId,shape:a,dtype:t.x.dtype};if(i){let f=Nv({inputs:t,backend:n});return f.shape=o,f}let c=n.makeOutput(o,l.dtype),u=n.dataIdMap.get(l.dataId).id,h=n.dataIdMap.get(c.dataId).id,d=new Uint8Array(new Int32Array(s).buffer),p=new Uint8Array(new Int32Array(l.shape).buffer);return eW(u,p,l.shape.length,at[l.dtype],h,d,s.length),c}function fIe(e,t){let n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];return n}function mIe(e,t){let n=[],r=[];for(let a=0;a<e.length;++a)e[a]!==1&&n.push(e[a]),e[t[a]]!==1&&r.push(t[a]);for(let a=0;a<r.length;++a){let s=-1;for(let i=0;i<r.length;++i)r[i]>=a&&(s===-1||r[s]>r[i])&&(s=i);r[s]=a}return[n,r]}var gIe={kernelName:ni,backendName:"wasm",kernelFunc:To,setupFunc:pIe};function Ho(e,t,n){let r=e.shape,a=e.shape.length,s=k.parseAxisParam(t,r),i=s,o=E.getAxesPermutation(i,a),l=null,c=!1;if(o!=null){let u=new Array(a);for(let d=0;d<u.length;d++)u[d]=r[o[d]];i=E.getInnerMostAxes(i.length,a),l=To({inputs:{x:e},attrs:{perm:o},backend:n});let h=n.dataIdMap.get(e.dataId).id;n.dataIdMap.get(l.dataId).id!==h&&(c=!0)}return{transposed:l,originalAxes:s,axes:i,inputWasTransposed:c}}var tW;function yIe(e){tW=e.wasm.cwrap(yd,null,["number, number, number"])}function xIe(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:c,axes:u,originalAxes:h,inputWasTransposed:d}=Ho(i,a,t);if(d){let x=t.dataIdMap.get(c.dataId).id;l=c,o=x}let p=l.shape.length;E.assertAxesAreInnerMostDims("all",u,p);let[f,m]=E.computeOutAndReduceShapes(l.shape,u),y=k.sizeFromShape(m),g=t.makeOutput(f,i.dtype);if(k.sizeFromShape(l.shape)!==0){let x=t.dataIdMap.get(g.dataId).id;tW(o,y,x)}if(d&&t.disposeData(c.dataId),s){let x=E.expandShapeToKeepDim(g.shape,h);g.shape=x}return g}var bIe={kernelName:yd,backendName:"wasm",setupFunc:yIe,kernelFunc:xIe},nW;function vIe(e){nW=e.wasm.cwrap(xd,null,["number, number, number"])}function wIe(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:c,axes:u,originalAxes:h,inputWasTransposed:d}=Ho(i,a,t);if(d){let x=t.dataIdMap.get(c.dataId).id;l=c,o=x}let p=l.shape.length;E.assertAxesAreInnerMostDims("any",u,p);let[f,m]=E.computeOutAndReduceShapes(l.shape,u),y=k.sizeFromShape(m),g=t.makeOutput(f,i.dtype);if(k.sizeFromShape(l.shape)!==0){let x=t.dataIdMap.get(g.dataId).id;nW(o,y,x)}if(d&&t.disposeData(c.dataId),s){let x=E.expandShapeToKeepDim(g.shape,h);g.shape=x}return g}var kIe={kernelName:xd,backendName:"wasm",setupFunc:vIe,kernelFunc:wIe};function rW(e){let t;function n(a){t=a.wasm.cwrap(e,null,["number","number","number","number","number"])}function r(a){let{backend:s,inputs:i,attrs:o}=a,{axis:l}=o,{x:c}=i,u=s.dataIdMap.get(c.dataId).id,h=u,d=c,{transposed:p,axes:f,inputWasTransposed:m}=Ho(c,l,s);if(m){let w=s.dataIdMap.get(p.dataId).id;w!==u&&(d=p,h=w)}let y=d.shape.slice(0,-1),g=s.makeOutput(y,"int32"),x=s.dataIdMap.get(g.dataId).id,b=k.sizeFromShape(g.shape),v=d.shape[f[0]];return t(h,at[d.dtype],b,v,x),m&&s.disposeData(p.dataId),g}return{kernelName:e,backendName:"wasm",setupFunc:n,kernelFunc:r}}var SIe=rW(bd),IIe=rW(vd),NIe=et(hu),_Ie=et(du),CIe=et(pu),TIe=tn(mu),EIe=et(fu),aW;function AIe(e){aW=e.wasm.cwrap(gu,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function $Ie(e){let{inputs:t,attrs:n,backend:r}=e,a=t.x,s=r.dataIdMap.get(a.dataId).id,{filterSize:i,strides:o,pad:l,dimRoundingMode:c}=n,u=E.computePool2DInfo(a.shape,i,o,1,l,c),h=u.filterHeight,d=u.filterWidth,p=u.padInfo.top,f=u.padInfo.right,m=u.padInfo.bottom,y=u.padInfo.left,g=u.strideHeight,x=u.strideWidth,b=u.inChannels;if(u.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${u.dataFormat}'. Please use 'channelsLast'.`);if(u.dilationWidth!==1||u.dilationHeight!==1)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${u.dilationHeight}, ${u.dilationWidth}].`);let v=r.makeOutput(u.outShape,"float32"),w=r.dataIdMap.get(v.dataId).id;return aW(s,a.shape[0],a.shape[1],a.shape[2],h,d,p,f,m,y,g,x,b,w),v}var MIe={kernelName:gu,backendName:"wasm",setupFunc:AIe,kernelFunc:$Ie},sW;function FIe(e){sW=e.wasm.cwrap("AvgPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function RIe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:c}=r,u=E.computePool3DInfo(a.shape,s,i,1,o,l,c),h=n.makeOutput(u.outShape,a.dtype);return sW(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(h.dataId).id,u.batchSize,u.inChannels,u.inDepth,u.inHeight,u.inWidth,u.outDepth,u.outHeight,u.outWidth,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.effectiveFilterDepth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),h}var DIe={kernelName:wd,backendName:"wasm",setupFunc:FIe,kernelFunc:RIe},iW;function OIe(e){iW=e.wasm.cwrap("AvgPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function zIe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:c}=r,u=E.computePool3DInfo(s.shape,i,o,1,l,c),h=n.makeOutput(s.shape,s.dtype);return iW(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(h.dataId).id,u.batchSize,u.inChannels,u.inDepth,u.inHeight,u.inWidth,u.outDepth,u.outHeight,u.outWidth,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.effectiveFilterDepth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left,u.filterDepth,u.filterHeight,u.filterWidth),h}var PIe={kernelName:Pm,backendName:"wasm",setupFunc:OIe,kernelFunc:zIe},oW;function LIe(e){oW=e.wasm.cwrap("AvgPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function BIe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l}=r,c=E.computePool2DInfo(s.shape,i,o,1,l),u=n.makeOutput(s.shape,s.dtype);return oW(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(u.dataId).id,c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.top,c.padInfo.left,c.filterHeight,c.filterWidth),u}var WIe={kernelName:zm,backendName:"wasm",setupFunc:LIe,kernelFunc:BIe};function br(e){let{inputs:t,attrs:n}=e,{x:r}=t,{shape:a}=n,s=k.sizeFromShape(r.shape),i=k.inferFromImplicitShape(a,s);return k.assert(s===k.sizeFromShape(i),()=>`new shape: ${i}, old shape: ${r.shape}. New shape and old shape must have the same number of elements.`),e.backend.incRef(r.dataId),{dataId:r.dataId,shape:i,dtype:r.dtype}}var UIe={kernelName:ep,backendName:"wasm",kernelFunc:br},lW;function VIe(e){lW=e.wasm.cwrap(yu,null,["number","array","number","number","array","number","number","number","number"])}function jIe(e){let{inputs:t,backend:n,attrs:r}=e,{a,b:s}=t,{transposeA:i,transposeB:o}=r;if(a.dtype!=="float32"||s.dtype!=="float32")throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");let l=a.shape.length,c=s.shape.length,u=i?a.shape[l-2]:a.shape[l-1],h=o?s.shape[c-1]:s.shape[c-2],d=i?a.shape[l-1]:a.shape[l-2],p=o?s.shape[c-2]:s.shape[c-1],f=a.shape.slice(0,-2),m=s.shape.slice(0,-2),y=k.sizeFromShape(f),g=k.sizeFromShape(m),x=xp.assertAndGetBroadcastShape(a.shape.slice(0,-2),s.shape.slice(0,-2)).concat([d,p]);k.assert(u===h,()=>`Error in matMul: inner shapes (${u}) and (${h}) of Tensors with shapes ${a.shape} and ${s.shape} and transposeA=${i} and transposeB=${o} must match.`);let b=i?[y,u,d]:[y,d,u],v=o?[g,p,h]:[g,h,p],w=br({inputs:{x:a},backend:n,attrs:{shape:b}}),I=br({inputs:{x:s},backend:n,attrs:{shape:v}}),_=n.dataIdMap.get(w.dataId).id,T=n.dataIdMap.get(I.dataId).id,A=i?w.shape[2]:w.shape[1],M=o?I.shape[1]:I.shape[2],F=Math.max(y,g),C=n.makeOutput([F,A,M],w.dtype),D=n.dataIdMap.get(C.dataId).id,L=new Uint8Array(new Int32Array(w.shape).buffer),O=new Uint8Array(new Int32Array(I.shape).buffer);return lW(_,L,w.shape.length,T,O,I.shape.length,i,o,D),n.disposeData(w.dataId),n.disposeData(I.dataId),C.shape=x,C}var GIe={kernelName:yu,backendName:"wasm",setupFunc:VIe,kernelFunc:jIe};function tu(e){let{inputs:{x:t},attrs:{begin:n,size:r},backend:a}=e,[s,i]=ln.parseSliceParams(t,n,r),o=ln.isSliceContinous(t.shape,s,i),l=a.readSync(t.dataId),c=a.makeOutput(i,t.dtype),u=k.computeStrides(t.shape),h=a.dataIdMap.get(c.dataId);if(o){let f=ln.computeFlatOffset(s,u);return t.dtype==="string"?h.stringBytes=l.slice(f,f+k.sizeFromShape(i)):a.typedArrayFromHeap(c).set(l.subarray(f,f+k.sizeFromShape(i))),c}if(t.dtype==="string"){let f=bx(l,s,i,t.shape,t.dtype);return h.stringBytes=f,c}let d=a.typedArrayFromHeap(c),p=t.shape.length;if(p===2)HIe(l,u[0],d,s,i);else if(p===3)qIe(l,u[0],u[1],d,s,i);else if(p===4)KIe(l,u[0],u[1],u[2],d,s,i);else{let f=bx(l,s,i,t.shape,t.dtype);d.set(f)}return c}function HIe(e,t,n,r,a){let s=0,i=r[0],o=r[1],l=i+a[0];for(let c=i;c<l;c++){let u=c*t+o;n.set(e.subarray(u,u+a[1]),s),s+=a[1]}}function qIe(e,t,n,r,a,s){let i=0,o=a[0],l=a[1],c=a[2],u=o+s[0],h=l+s[1];for(let d=o;d<u;d++)for(let p=l;p<h;p++){let f=d*t+p*n+c;r.set(e.subarray(f,f+s[2]),i),i+=s[2]}}function KIe(e,t,n,r,a,s,i){let o=0,l=s[0],c=s[1],u=s[2],h=l+i[0],d=c+i[1],p=u+i[2],f=s[3];for(let m=l;m<h;m++)for(let y=c;y<d;y++)for(let g=u;g<p;g++){let x=m*t+y*n+g*r+f;a.set(e.subarray(x,x+i[3]),o),o+=i[3]}}var XIe={kernelName:op,backendName:"wasm",kernelFunc:tu};function ZIe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r,o=s.reduce((g,x)=>g*x),l=E.getReshaped(a.shape,s,o),c=E.getPermuted(l.length,s.length),u=E.getReshapedPermuted(a.shape,s,o),h=E.getSliceBeginCoords(i,s.length),d=E.getSliceSize(u,i,s.length),p=br({inputs:{x:a},backend:n,attrs:{shape:l}}),f=To({inputs:{x:p},backend:n,attrs:{perm:c}}),m=br({inputs:{x:f},backend:n,attrs:{shape:u}}),y=tu({inputs:{x:m},backend:n,attrs:{begin:h,size:d}});return n.disposeData(p.dataId),n.disposeData(f.dataId),n.disposeData(m.dataId),y}var YIe={kernelName:kd,backendName:"wasm",kernelFunc:ZIe},uW;function JIe(e){uW=e.wasm.cwrap(Sd,null,["number","number","boolean","number","number","number"])}function QIe(e){let{backend:t,inputs:n,attrs:r}=e,{x:a,weights:s}=n,{size:i}=r,o=s.shape.reduce((h,d)=>h*d,1)!==0,l=a.shape.length===1?[i]:[a.shape[0],i],c=t.makeOutput(l,s.dtype);function u(h){return t.dataIdMap.get(h.dataId).id}return uW(u(a),i,o,u(s),at[s.dtype],u(c)),c}var eNe={kernelName:Sd,backendName:"wasm",setupFunc:JIe,kernelFunc:QIe},tNe=tn(Id);function nNe(e){let{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.typedArrayFromHeap(r),i=n.typedArrayFromHeap(a),o=E.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeOutput([o.length],"int32",void 0,new Int32Array(o))}var rNe={kernelName:Lm,backendName:"wasm",kernelFunc:nNe};function qo(e){let{inputs:{x:t},attrs:{dtype:n},backend:r}=e,a=r.makeOutput(t.shape,n),s=r.typedArrayFromHeap(t);return r.typedArrayFromHeap(a).set(s),a}var aNe={kernelName:xu,backendName:"wasm",kernelFunc:qo},sNe=et(bu),cW;function iNe(e){cW=e.wasm.cwrap(Oo,null,["number","number","number","number"])}function oNe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{clipValueMin:s,clipValueMax:i}=r,o=n.dataIdMap.get(a.dataId).id,l=n.makeOutput(a.shape,a.dtype),c=n.dataIdMap.get(l.dataId).id;return cW(o,s,i,c),l}var lNe={kernelName:Oo,backendName:"wasm",setupFunc:iNe,kernelFunc:oNe};function hW(e){let{inputs:t,backend:n}=e,r=k.parseAxisParam(e.attrs.axis,t[0].shape)[0],a=t.map(p=>p.shape);E.assertParamsConsistent(a,r);let s=E.computeOutShape(t.map(p=>p.shape),r),i=t.filter(p=>k.sizeFromShape(p.shape)>0);if(i.length===1)return Nv({inputs:{x:i[0]},backend:n});let o=n.makeOutput(s,t[0].dtype);if(k.sizeFromShape(s)===0)return o;if(i[0].dtype==="string"){let p=i.map(b=>{let v=[-1,k.sizeFromShape(b.shape.slice(r))];return br({inputs:{x:b},backend:n,attrs:{shape:v}})}),f=p.map(b=>({vals:n.readSync(b.dataId),shape:b.shape}));s=E.computeOutShape(p.map(b=>b.shape),1);let m=p[0].shape[0]===1,y=Z_(f,s,t[0].dtype,m),g=E.computeOutShape(i.map(b=>b.shape),r);o.shape=g;let x=n.dataIdMap.get(o.dataId);return x.stringBytes=E.fromStringArrayToUint8(y),p.forEach(b=>n.disposeData(b.dataId)),o}let l=k.sizeFromShape(i[0].shape.slice(0,r)),c=0,u=i.map(p=>{let f=k.sizeFromShape(p.shape.slice(r));return c+=f,f}),h=i.map(p=>n.typedArrayFromHeap(p)),d=n.typedArrayFromHeap(o);for(let p=0;p<l;p++){let f=p*c;for(let m=0;m<h.length;m++){let y=u[m],g=p*y,x=h[m].subarray(g,g+y);d.set(x,f),f+=y}}return o}var uNe={kernelName:Nd,backendName:"wasm",kernelFunc:hW},dW;function cNe(e){dW=e.wasm.cwrap(vu,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function hNe(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s}=t,i=r.dataIdMap.get(a.dataId).id,o=r.dataIdMap.get(s.dataId).id,{strides:l,dilations:c,pad:u,dimRoundingMode:h,dataFormat:d}=n,p=E.convertConv2DDataFormat(d),f=E.computeConv2DInfo(a.shape,s.shape,l,c,u,h,!1,p),m=f.filterHeight,y=f.filterWidth,g=f.padInfo.top,x=f.padInfo.right,b=f.padInfo.bottom,v=f.padInfo.left,w=f.dilationHeight,I=f.dilationWidth,_=f.strideHeight,T=f.strideWidth,A=f.inChannels,M=f.outChannels,F=f.padInfo.type==="SAME"?1:0;if(f.dataFormat!=="channelsLast")throw new Error(`wasm backend Conv2D does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);let C=r.makeOutput(f.outShape,"float32"),D=r.dataIdMap.get(C.dataId).id;return dW(i,a.shape[0],a.shape[1],a.shape[2],o,m,y,g,x,b,v,F,w,I,_,T,A,M,D),C}var dNe={kernelName:vu,backendName:"wasm",setupFunc:cNe,kernelFunc:hNe},pW;function pNe(e){pW=e.wasm.cwrap(wu,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function fNe(e){let{backend:t,inputs:n,attrs:r}=e,{dy:a,filter:s}=n,{strides:i,pad:o,dataFormat:l,dimRoundingMode:c,inputShape:u}=r,h=1,d=E.convertConv2DDataFormat(l),p=E.computeConv2DInfo(u,s.shape,i,h,o,c,!1,d),{batchSize:f,filterHeight:m,filterWidth:y,inChannels:g,inHeight:x,inWidth:b,outChannels:v,outHeight:w,outWidth:I,strideHeight:_,strideWidth:T}=p,A=m-1-p.padInfo.top,M=y-1-p.padInfo.left,F=p.dataFormat==="channelsLast",C=k.computeStrides(p.inShape),D=k.computeStrides(a.shape),[L,O,q]=k.computeStrides(s.shape),H=C[0],z=F?C[1]:C[2],K=F?C[2]:1,Z=F?1:C[1],J=D[0],Q=F?D[1]:D[2],ne=F?D[2]:1,oe=F?1:D[1],ue=t.makeOutput(p.inShape,"float32"),ve=t.dataIdMap.get(ue.dataId).id,we=t.dataIdMap.get(a.dataId).id,ge=t.dataIdMap.get(s.dataId).id;return pW(we,ge,f,m,y,x,b,g,w,I,v,_,T,A,M,L,O,q,H,z,K,Z,J,Q,ne,oe,ve),ue}var mNe={kernelName:wu,backendName:"wasm",setupFunc:pNe,kernelFunc:fNe},fW;function gNe(e){fW=e.wasm.cwrap(ku,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function yNe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r;if(a.dtype!=="float32")throw new Error(`Tensor x must have dtype float32, got ${a.dtype}`);if(s.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let c=E.computeConv3DInfo(a.shape,s.shape,i,l,o),u=n.makeOutput(c.outShape,a.dtype);return fW(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(u.dataId).id,c.batchSize,c.inDepth,c.inHeight,c.inWidth,c.inChannels,c.outDepth,c.outHeight,c.outWidth,c.outChannels,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.filterDepth,c.filterHeight,c.filterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),u}var xNe={kernelName:ku,backendName:"wasm",setupFunc:gNe,kernelFunc:yNe},mW;function bNe(e){mW=e.wasm.cwrap(_d,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function vNe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,filterShape:l}=r;if(a.dtype!=="float32")throw new Error(`Tensor dy must have dtype float32, got ${a.dtype}`);if(s.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let c=E.computeConv3DInfo(a.shape,l,i,1,o),u=n.makeOutput(c.filterShape,s.dtype);return mW(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(u.dataId).id,c.batchSize,c.inDepth,c.inHeight,c.inWidth,c.inChannels,c.outDepth,c.outHeight,c.outWidth,c.outChannels,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.filterDepth,c.filterHeight,c.filterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),u}var wNe={kernelName:_d,backendName:"wasm",setupFunc:bNe,kernelFunc:vNe},gW;function kNe(e){gW=e.wasm.cwrap(Cd,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function SNe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:i,strides:o,inputShape:l}=r;if(a.dtype!=="float32")throw new Error(`Tensor dy must have dtype float32, got ${a.dtype}`);if(s.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let c=E.computeConv3DInfo(l,s.shape,o,1,i),u=n.makeOutput(c.inShape,a.dtype);return gW(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(u.dataId).id,c.batchSize,c.inDepth,c.inHeight,c.inWidth,c.inChannels,c.outDepth,c.outHeight,c.outWidth,c.outChannels,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.filterDepth,c.filterHeight,c.filterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),u}var INe={kernelName:Cd,backendName:"wasm",setupFunc:kNe,kernelFunc:SNe},NNe=et(Su),_Ne=et(Iu),c2;(function(e){e[e.bilinear=0]="bilinear",e[e.nearest=1]="nearest"})(c2||(c2={}));var yW;function CNe(e){yW=e.wasm.cwrap(Ed,null,["number","number","number","number","array","number","number","number","number","number"])}function TNe(e){let{backend:t,inputs:n,attrs:r}=e,{method:a,extrapolationValue:s,cropSize:i}=r,{image:o,boxes:l,boxInd:c}=n,u=l.shape[0],[h,d]=i,p=[u,h,d,o.shape[3]],f=t.dataIdMap.get(o.dataId),m;o.dtype!=="float32"&&(m=qo({backend:t,inputs:{x:o},attrs:{dtype:"float32"}}),f=t.dataIdMap.get(m.dataId));let y=f.id,g=t.dataIdMap.get(l.dataId).id,x=t.dataIdMap.get(c.dataId).id,b=t.makeOutput(p,"float32"),v=t.dataIdMap.get(b.dataId).id,w=new Uint8Array(new Int32Array(o.shape).buffer);return yW(y,g,x,u,w,h,d,c2[a],s,v),m!=null&&t.disposeData(m.dataId),b}var ENe={kernelName:Ed,backendName:"wasm",setupFunc:CNe,kernelFunc:TNe},xW;function ANe(e){xW=e.wasm.cwrap(Td,null,["number","number","number","number","number","number"])}function $Ne(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r,l=a.shape.length;k.assert(a.dtype==="float32"||a.dtype==="int32",()=>`cumprod does not support ${a.dtype} tensors in the WASM backend`);let c=E.getAxesPermutation([s],l),u=a;c!==null&&(u=To({inputs:{x:a},attrs:{perm:c},backend:n}));let h=E.getInnerMostAxes(1,l)[0];E.assertAxesAreInnerMostDims("cumprod",[h],l);let d=n.makeOutput(u.shape,u.dtype),p=u.shape[h],f=n.dataIdMap.get(u.dataId).id,m=n.dataIdMap.get(d.dataId).id;xW(f,i?1:0,o?1:0,p,m,at[a.dtype]);let y=d;if(c!==null){let g=E.getUndoAxesPermutation(c);y=To({inputs:{x:d},attrs:{perm:g},backend:n}),n.disposeData(u.dataId),n.disposeData(d.dataId)}return y}var MNe={kernelName:Td,backendName:"wasm",setupFunc:ANe,kernelFunc:$Ne},bW;function FNe(e){bW=e.wasm.cwrap(Nu,null,["number","number","number","number","number","number"])}function RNe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r,l=a.shape.length;k.assert(a.dtype==="float32"||a.dtype==="int32",()=>`cumsum does not support ${a.dtype} tensors in the WASM backend`);let c=E.getAxesPermutation([s],l),u=a;c!==null&&(u=To({inputs:{x:a},attrs:{perm:c},backend:n}));let h=E.getInnerMostAxes(1,l)[0];E.assertAxesAreInnerMostDims("cumsum",[h],l);let d=n.makeOutput(u.shape,u.dtype),p=u.shape[h],f=n.dataIdMap.get(u.dataId).id,m=n.dataIdMap.get(d.dataId).id;bW(f,i?1:0,o?1:0,p,m,at[a.dtype]);let y=d;if(c!==null){let g=E.getUndoAxesPermutation(c);y=To({inputs:{x:d},attrs:{perm:g},backend:n}),n.disposeData(u.dataId),n.disposeData(d.dataId)}return y}var DNe={kernelName:Nu,backendName:"wasm",setupFunc:FNe,kernelFunc:RNe},vW;function ONe(e){vW=e.wasm.cwrap("DenseBincount",null,["number","array","number","number","boolean","number","number","boolean","number"])}function zNe(e){let{backend:t,inputs:n,attrs:r}=e,{x:a,weights:s}=n,{size:i,binaryOutput:o}=r,l=s.shape.reduce((d,p)=>d*p,1)!==0,c=a.shape.length===1?[i]:[a.shape[0],i],u=t.makeOutput(c,s.dtype);function h(d){return t.dataIdMap.get(d.dataId).id}return vW(h(a),new Uint8Array(new Int32Array(a.shape).buffer),a.shape.length,i,l,h(s),at[s.dtype],o,h(u)),u}var PNe={kernelName:Wm,backendName:"wasm",setupFunc:ONe,kernelFunc:zNe},wW;function LNe(e){wW=e.wasm.cwrap(Ad,null,["number","number","number","array","number","array","array","number","number"])}function BNe(e){let{backend:t,inputs:n,attrs:r}=e,{x:a}=n,{blockSize:s,dataFormat:i}=r,o=a.shape[0],l=i==="NHWC"?a.shape[1]:a.shape[2],c=i==="NHWC"?a.shape[2]:a.shape[3],u=i==="NHWC"?a.shape[3]:a.shape[1],h=l*s,d=c*s,p=u/(s*s),f=i==="NHWC"?[o,h,d,p]:[o,p,h,d],m=t.makeOutput(f,"float32"),y=t.dataIdMap.get(a.dataId).id,g=new Uint8Array(new Int32Array(k.computeStrides(a.shape)).buffer),x=new Uint8Array(new Int32Array(f).buffer),b=new Uint8Array(new Int32Array(k.computeStrides(f)).buffer),v=t.dataIdMap.get(m.dataId).id;return wW(y,s,i==="NHWC"?1:0,g,a.shape.length-1,x,b,f.length,v),m}var WNe={kernelName:Ad,backendName:"wasm",setupFunc:LNe,kernelFunc:BNe},kW;function UNe(e){kW=e.wasm.cwrap(_u,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function VNe(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s}=t,i=r.dataIdMap.get(a.dataId).id,o=r.dataIdMap.get(s.dataId).id,{strides:l,dilations:c,pad:u,dimRoundingMode:h}=n,d=c??[1,1],p=E.computeConv2DInfo(a.shape,s.shape,l,d,u,h,!0),f=p.filterHeight,m=p.filterWidth,y=p.padInfo.top,g=p.padInfo.right,x=p.padInfo.bottom,b=p.padInfo.left,v=p.dilationHeight,w=p.dilationWidth,I=p.strideHeight,_=p.strideWidth,T=p.inChannels,A=p.outChannels,M=p.padInfo.type==="SAME"?1:0;if(p.dataFormat!=="channelsLast")throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${p.dataFormat}'. Please use 'channelsLast'.`);let F=r.makeOutput(p.outShape,"float32"),C=r.dataIdMap.get(F.dataId).id;return kW(i,a.shape[0],a.shape[1],a.shape[2],o,f,m,y,g,x,b,M,v,w,I,_,T,A,C),F}var jNe={kernelName:_u,backendName:"wasm",setupFunc:UNe,kernelFunc:VNe},SW;function GNe(e){SW=e.wasm.cwrap("Diag",null,["number","number","number","number"])}function HNe(e){let{inputs:t,backend:n}=e,{x:r}=t,a=k.sizeFromShape(r.shape),s=n.makeOutput([...r.shape,...r.shape],r.dtype);return SW(n.dataIdMap.get(r.dataId).id,at[r.dtype],a,n.dataIdMap.get(s.dataId).id),s}var qNe={kernelName:Um,backendName:"wasm",setupFunc:GNe,kernelFunc:HNe},IW;function KNe(e){IW=e.wasm.cwrap(Cu,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function XNe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r;if(a.dtype!==s.dtype)throw new Error(`Dilation2D error: x must have the same dtype as filter. Got ${a.dtype} and ${s.dtype}`);let c=E.computeDilation2DInfo(a.shape,s.shape,i,o,"NHWC",l),u=n.makeOutput(c.outShape,a.dtype);return IW(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(u.dataId).id,at[a.dtype],c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.filterHeight,c.filterWidth,c.padInfo.top,c.padInfo.left),u}var ZNe={kernelName:Cu,backendName:"wasm",setupFunc:KNe,kernelFunc:XNe},NW;function YNe(e){NW=e.wasm.cwrap(Hh,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function JNe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,dy:i}=t,{strides:o,pad:l,dilations:c}=r;if(a.dtype!==s.dtype||a.dtype!==i.dtype)throw new Error(`Dilation2DBackpropFilter error: x must have the same dtype as filter and dy. Got ${a.dtype}, ${s.dtype}, and ${i.dtype}`);let u=E.computeDilation2DInfo(a.shape,s.shape,o,l,"NHWC",c),h=n.makeOutput(s.shape,s.dtype);return NW(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(h.dataId).id,at[a.dtype],u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.filterHeight,u.filterWidth,u.padInfo.top,u.padInfo.left),h}var QNe={kernelName:Hh,backendName:"wasm",setupFunc:YNe,kernelFunc:JNe},_W;function e_e(e){_W=e.wasm.cwrap(Gh,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function t_e(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,dy:i}=t,{strides:o,pad:l,dilations:c}=r;if(a.dtype!==s.dtype||a.dtype!==i.dtype)throw new Error(`Dilation2DBackpropInput error: x must have the same dtype as filter and dy. Got ${a.dtype}, ${s.dtype}, and ${i.dtype}`);let u=E.computeDilation2DInfo(a.shape,s.shape,o,l,"NHWC",c),h=n.makeOutput(a.shape,a.dtype);return _W(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(h.dataId).id,at[a.dtype],u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.filterHeight,u.filterWidth,u.padInfo.top,u.padInfo.left),h}var n_e={kernelName:Gh,backendName:"wasm",setupFunc:e_e,kernelFunc:t_e},r_e=et(Eu),CW;function a_e(e){CW=e.wasm.cwrap($d,null,["number","number","number"])}function s_e(e){let{inputs:t,backend:n}=e,{dy:r,y:a}=t,s=n.makeOutput(a.shape,"float32"),i=o=>n.dataIdMap.get(o.dataId).id;return CW(i(a),i(r),i(s)),s}var i_e={kernelName:$d,backendName:"wasm",setupFunc:a_e,kernelFunc:s_e},o_e=!1,l_e=tn(Md,o_e,"bool"),u_e=et(Au),c_e=et($u,"float32");function h2(e){let{inputs:t,attrs:n,backend:r}=e,{input:a}=t,{dim:s}=n,i=a.shape.length,o=a.shape.slice(),l=s;return s<0&&(k.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),o.splice(l,0,1),br({inputs:{x:a},backend:r,attrs:{shape:o}})}var h_e={kernelName:Fd,backendName:"wasm",kernelFunc:h2},d_e=et(Mu,"float32");function TW(e){let{attrs:{shape:t,value:n},backend:r}=e,{attrs:{dtype:a}}=e;a=a||k.inferDtype(n);let s=r.makeOutput(t,a);return r.typedArrayFromHeap(s).fill(n),s}var p_e={kernelName:Vm,backendName:"wasm",kernelFunc:TW},EW;function f_e(e){EW=e.wasm.cwrap(Rd,null,["number","number","number","number","number","number"])}function m_e(e){let{inputs:t,backend:n}=e,{image:r}=t,a=n.makeOutput(r.shape,r.dtype),s=n.dataIdMap.get(r.dataId).id,i=n.dataIdMap.get(a.dataId).id,[o,l,c,u]=r.shape;return EW(s,o,l,c,u,i),a}var g_e={kernelName:Rd,backendName:"wasm",kernelFunc:m_e,setupFunc:f_e},y_e=et(Fu),x_e=tn(Ru),AW;function b_e(e){AW=e.wasm.cwrap(Du,null,["number","number","number","number","number","number","number"])}function v_e(e){let{backend:t,inputs:n,attrs:r}=e,{varianceEpsilon:a}=r,{x:s,mean:i,variance:o,offset:l,scale:c}=n,u=t.dataIdMap.get(s.dataId).id,h=t.dataIdMap.get(i.dataId).id,d=t.dataIdMap.get(o.dataId).id,p=l!=null?t.dataIdMap.get(l.dataId).id:0,f=c!=null?t.dataIdMap.get(c.dataId).id:0,m=t.makeOutput(s.shape,s.dtype);if(k.sizeFromShape(s.shape)===0)return m;let y=t.dataIdMap.get(m.dataId).id;return AW(u,h,d,p,f,a,y),m}var w_e={kernelName:Du,backendName:"wasm",setupFunc:b_e,kernelFunc:v_e},$W;function k_e(e){$W=e.wasm.cwrap(Pl,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function S_e(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:c,dilations:u,dataFormat:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=n,m=E.computeConv2DInfo(a.shape,s.shape,l,u,c,d),y=Im[p];if(y==null)throw new Error(`${p} activation not yet supported for FusedConv2D in the wasm backend.`);let g=r.dataIdMap.get(a.dataId).id,x=r.dataIdMap.get(s.dataId).id,b=m.outChannels,v=0;if(i!=null){let ne=r.dataIdMap.get(i.dataId);if(ne.shape.length!==1)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${ne.shape.length}.`);if(ne.shape[0]!==b)throw new Error(`FusedConv2D bias shape (${ne.shape}) does not match the number of output channels (${b})`);v=ne.id}let w=m.filterHeight,I=m.filterWidth,_=m.padInfo.top,T=m.padInfo.right,A=m.padInfo.bottom,M=m.padInfo.left,F=m.dilationHeight,C=m.dilationWidth,D=m.strideHeight,L=m.strideWidth,O=m.inChannels,q=m.padInfo.type==="SAME"?1:0,H=m.batchSize,z=m.inHeight,K=m.inWidth;if(h!=="NHWC")throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${h}'. Please use 'NHWC'.`);let Z=r.makeOutput(m.outShape,"float32"),J=r.dataIdMap.get(Z.dataId).id,Q=o==null?0:r.dataIdMap.get(o.dataId).id;return $W(g,H,z,K,x,w,I,v,_,T,A,M,q,F,C,D,L,O,b,y,Q,f||0,J),Z}var I_e={kernelName:Pl,backendName:"wasm",setupFunc:k_e,kernelFunc:S_e},MW;function N_e(e){MW=e.wasm.cwrap(Ll,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function __e(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:c,dilations:u,dataFormat:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=n,m=E.computeConv2DInfo(a.shape,s.shape,l,u,c,d,!0),y=Im[p];if(y==null)throw new Error(`${p} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);let g=r.dataIdMap.get(a.dataId).id,x=r.dataIdMap.get(s.dataId).id,b=m.outChannels,v=0;if(i!=null){let ne=r.dataIdMap.get(i.dataId);if(ne.shape.length!==1)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${ne.shape.length}.`);if(ne.shape[0]!==b)throw new Error(`FusedDepthwiseConv2D bias shape (${ne.shape}) does not match the number of output channels (${b})`);v=ne.id}let w=m.filterHeight,I=m.filterWidth,_=m.padInfo.top,T=m.padInfo.right,A=m.padInfo.bottom,M=m.padInfo.left,F=m.dilationHeight,C=m.dilationWidth,D=m.strideHeight,L=m.strideWidth,O=m.inChannels,q=m.padInfo.type==="SAME"?1:0,H=m.batchSize,z=m.inHeight,K=m.inWidth;if(h!=="NHWC")throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${h}'. Please use 'NHWC'.`);let Z=r.makeOutput(m.outShape,"float32"),J=r.dataIdMap.get(Z.dataId).id,Q=o==null?0:r.dataIdMap.get(o.dataId).id;return MW(g,H,z,K,x,w,I,v,_,T,A,M,q,F,C,D,L,O,b,y,Q,f||0,J),Z}var C_e={kernelName:Ll,backendName:"wasm",setupFunc:N_e,kernelFunc:__e},FW;function T_e(e){FW=e.wasm.cwrap(Od,null,["number","number","number","number","number","number","array","number"])}function E_e(e){let{backend:t,inputs:n}=e,{params:r,indices:a}=n,[s,i,o,l]=lN.prepareAndValidate(r,a),c=t.makeOutput(s,r.dtype);if(i===0)return c;let u=a.shape,h=u[u.length-1],d=t.dataIdMap.get(r.dataId).id,p=t.dataIdMap.get(a.dataId).id,f=new Uint8Array(new Int32Array(l).buffer),m=t.dataIdMap.get(c.dataId).id;return FW(d,at[r.dtype],p,i,h,o,f,m),c}var A_e={kernelName:Od,backendName:"wasm",setupFunc:T_e,kernelFunc:E_e},RW;function $_e(e){RW=e.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])}function M_e(e){let{backend:t,inputs:n,attrs:r}=e,{x:a,indices:s}=n,{axis:i,batchDims:o}=r,l=k.parseAxisParam(i,a.shape)[0],c=t.readSync(s.dataId),u=a.shape[l];for(let _=0;_<c.length;++_){let T=c[_];k.assert(T<=u-1&&T>=0,()=>`GatherV2: the index value ${T} is not in [0, ${u-1}]`)}let h=E.segment_util.collectGatherOpShapeInfo(a,s,l,o),d=br({inputs:{x:a},attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]},backend:t}),p=k.sizeFromShape(s.shape),f=br({inputs:{x:s},attrs:{shape:[h.batchSize,p/h.batchSize]},backend:t}),m=[h.batchSize,h.outerSize,p/h.batchSize,h.sliceSize],y=t.makeOutput(m,a.dtype);if(k.sizeFromShape(a.shape)===0)return y;let g=d.shape.length-1,x=t.dataIdMap.get(d.dataId).id,b=t.dataIdMap.get(f.dataId).id,v=t.dataIdMap.get(y.dataId).id,w=new Uint8Array(new Int32Array(k.computeStrides(d.shape)).buffer),I=new Uint8Array(new Int32Array(k.computeStrides(m)).buffer);return RW(x,at[a.dtype],w,g,b,h.batchSize,I,v),t.disposeData(d.dataId),t.disposeData(f.dataId),y.shape=h.outputShape,y}var F_e={kernelName:Dd,backendName:"wasm",setupFunc:$_e,kernelFunc:M_e},R_e=!1,D_e=tn(zd,R_e,"bool"),O_e=!1,z_e=tn(Ou,O_e,"bool"),P_e=et(Pu,"bool"),L_e=et(Lu,"bool"),B_e=et(Bu,"bool"),DW;function W_e(e){DW=e.wasm.cwrap(Wu,null,["number","number","number","number"])}function U_e(e){let{inputs:{x:t},attrs:{alpha:n},backend:r}=e,a=r.dataIdMap.get(t.dataId).id,s=r.makeOutput(t.shape,"float32");if(k.sizeFromShape(t.shape)!==0){let i=r.dataIdMap.get(s.dataId).id;DW(a,at[t.dtype],n,i)}return s}var V_e={kernelName:Wu,backendName:"wasm",setupFunc:W_e,kernelFunc:U_e},j_e=!1,G_e=tn(Pd,j_e,"bool"),H_e=!1,q_e=tn(Ld,H_e,"bool"),OW;function K_e(e){OW=e.wasm.cwrap(Bd,null,["number","number","number","number"])}function X_e(e){let{attrs:t,backend:n}=e,{start:r,stop:a,num:s}=t,i=Math.floor(s),o=n.makeOutput([i],"float32");return OW(n.dataIdMap.get(o.dataId).id,r,a,i),o}var Z_e={kernelName:Bd,backendName:"wasm",setupFunc:K_e,kernelFunc:X_e},Y_e=et(Uu),J_e=et(Vu),Q_e=!1,eCe=tn(Wd,Q_e,"bool"),tCe=et(Ud),nCe=!1,rCe=tn(Vd,nCe,"bool"),aCe=!1,sCe=tn(DD,aCe,"bool"),zW;function iCe(e){zW=e.wasm.cwrap(ju,null,["number","number","number","number","number","number","number"])}function oCe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=r;if(a.dtype!=="float32")throw new Error("LRN error: x must have dtype float32");let c=n.makeOutput(a.shape,a.dtype);return zW(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(c.dataId).id,a.shape[3],s,i,o,l),c}var lCe={kernelName:ju,backendName:"wasm",setupFunc:iCe,kernelFunc:oCe},PW;function uCe(e){PW=e.wasm.cwrap(jd,null,["number","number","number","number","number","number","number","number","number"])}function cCe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:c,beta:u}=r;if(a.dtype!=="float32"||s.dtype!=="float32"||i.dtype!=="float32")throw new Error("LRNGrad error: x, y, and dy must have dtype float32");let h=n.makeOutput(a.shape,a.dtype);return PW(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(h.dataId).id,i.shape[3],o,l,c,u),h}var hCe={kernelName:jd,backendName:"wasm",setupFunc:uCe,kernelFunc:cCe},LW;function dCe(e){LW=e.wasm.cwrap(Gu,null,["number","number","number","number"])}function pCe(e){let{backend:t,inputs:n,attrs:r}=e,{reductionIndices:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:c,axes:u,originalAxes:h,inputWasTransposed:d}=Ho(i,a,t);if(d){let x=t.dataIdMap.get(c.dataId).id;l=c,o=x}let p=l.shape.length;E.assertAxesAreInnerMostDims("max",u,p);let[f,m]=E.computeOutAndReduceShapes(l.shape,u),y=k.sizeFromShape(m),g=t.makeOutput(f,i.dtype);if(k.sizeFromShape(l.shape)!==0){let x=t.dataIdMap.get(g.dataId).id;LW(o,at[i.dtype],y,x)}if(d&&t.disposeData(c.dataId),s){let x=E.expandShapeToKeepDim(g.shape,h);g.shape=x}return g}var fCe={kernelName:Gu,backendName:"wasm",setupFunc:dCe,kernelFunc:pCe},mCe=tn(Hu),BW;function gCe(e){BW=e.wasm.cwrap(qu,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function yCe(e){let{inputs:t,attrs:n,backend:r}=e,a=t.x,s=r.dataIdMap.get(a.dataId).id;k.assert(a.dtype==="float32",()=>`Error in MaxPool: only float32 input is supported. Got ${a.dtype}.`);let{filterSize:i,strides:o,pad:l,dimRoundingMode:c}=n,u=E.computePool2DInfo(a.shape,i,o,1,l,c),h=u.filterHeight,d=u.filterWidth,p=u.padInfo.top,f=u.padInfo.right,m=u.padInfo.bottom,y=u.padInfo.left,g=u.dilationHeight,x=u.dilationWidth,b=u.strideHeight,v=u.strideWidth,w=u.inChannels,I=u.outChannels;if(u.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${u.dataFormat}'. Please use 'channelsLast'.`);let _=r.makeOutput(u.outShape,"float32"),T=r.dataIdMap.get(_.dataId).id;return BW(s,a.shape[0],a.shape[1],a.shape[2],h,d,p,f,m,y,g,x,b,v,w,I,T),_}var xCe={kernelName:qu,backendName:"wasm",setupFunc:gCe,kernelFunc:yCe},WW;function bCe(e){WW=e.wasm.cwrap("MaxPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function vCe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:c}=r,u=E.computePool3DInfo(a.shape,s,i,1,o,l,c),h=n.makeOutput(u.outShape,a.dtype);return WW(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(h.dataId).id,u.batchSize,u.inChannels,u.inDepth,u.inHeight,u.inWidth,u.outDepth,u.outHeight,u.outWidth,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.effectiveFilterDepth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),h}var wCe={kernelName:Gd,backendName:"wasm",setupFunc:bCe,kernelFunc:vCe},UW;function kCe(e){UW=e.wasm.cwrap("MaxPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function SCe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:c}=r,u=E.computePool3DInfo(s.shape,i,o,1,l,c),h=n.makeOutput(s.shape,s.dtype);return UW(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(h.dataId).id,u.batchSize,u.inChannels,u.inDepth,u.inHeight,u.inWidth,u.outDepth,u.outHeight,u.outWidth,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.effectiveFilterDepth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),h}var ICe={kernelName:Gm,backendName:"wasm",setupFunc:kCe,kernelFunc:SCe},VW;function NCe(e){VW=e.wasm.cwrap("MaxPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function _Ce(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:c}=r,u=E.computePool2DInfo(s.shape,i,o,1,l,c),h=n.makeOutput(s.shape,s.dtype);return VW(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(h.dataId).id,u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.top,u.padInfo.left),h}var CCe={kernelName:jm,backendName:"wasm",setupFunc:NCe,kernelFunc:_Ce},jW;function TCe(e){jW=e.wasm.cwrap("MaxPoolWithArgmax",null,["number","number","number","number","boolean","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function ECe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,includeBatchInIndex:l}=r;k.assert(a.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.shape.length}.`);let c=[1,1];k.assert(E.eitherStridesOrDilationsAreOne(i,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);let u=E.computePool2DInfo(a.shape,s,i,[1,1],o),h=n.makeOutput(u.outShape,a.dtype),d=n.makeOutput(u.outShape,"int32");return jW(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(h.dataId).id,n.dataIdMap.get(d.dataId).id,at[a.dtype],l,u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.top,u.padInfo.left),[h,d]}var ACe={kernelName:Hm,backendName:"wasm",setupFunc:TCe,kernelFunc:ECe},GW;function $Ce(e){GW=e.wasm.cwrap(Ku,null,["number, number, number"])}function MCe(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,c=i,{transposed:u,axes:h,originalAxes:d,inputWasTransposed:p}=Ho(i,a,t),f=h;if(p){let v=t.dataIdMap.get(u.dataId).id;v!==o&&(c=u,l=v,f=E.getInnerMostAxes(f.length,c.shape.length))}E.assertAxesAreInnerMostDims("mean",f,c.shape.length);let[m,y]=E.computeOutAndReduceShapes(c.shape,f),g=k.sizeFromShape(y),x=c;c.dtype!=="float32"&&(x=qo({backend:t,inputs:{x:c},attrs:{dtype:"float32"}}),l=t.dataIdMap.get(x.dataId).id);let b=t.makeOutput(m,"float32");if(k.sizeFromShape(c.shape)!==0){let v=t.dataIdMap.get(b.dataId).id;GW(l,g,v)}if(p&&t.disposeData(u.dataId),s){let v=E.expandShapeToKeepDim(b.shape,d);b.shape=v}return c.dtype!=="float32"&&t.disposeData(x.dataId),b}var FCe={kernelName:Ku,backendName:"wasm",setupFunc:$Ce,kernelFunc:MCe},HW;function RCe(e){HW=e.wasm.cwrap(Xu,null,["number","number","number","number"])}function DCe(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,c=i,{transposed:u,axes:h,originalAxes:d,inputWasTransposed:p}=Ho(i,a,t);if(p){let b=t.dataIdMap.get(u.dataId).id;b!==o&&(c=u,l=b)}let f=c.shape.length;E.assertAxesAreInnerMostDims("min",h,f);let[m,y]=E.computeOutAndReduceShapes(c.shape,h),g=k.sizeFromShape(y),x=t.makeOutput(m,c.dtype);if(k.sizeFromShape(c.shape)!==0){let b=t.dataIdMap.get(x.dataId).id;HW(l,at[i.dtype],g,b)}if(p&&t.disposeData(u.dataId),s){let b=E.expandShapeToKeepDim(x.shape,d);x.shape=b}return x}var OCe={kernelName:Xu,backendName:"wasm",setupFunc:RCe,kernelFunc:DCe},zCe=tn(Zu),d2;(function(e){e[e.reflect=0]="reflect",e[e.symmetric=1]="symmetric"})(d2||(d2={}));var qW;function PCe(e){qW=e.wasm.cwrap(Yu,null,["number","array","number","number","array","array","number","number"])}function LCe(e){let{inputs:{x:t},backend:n,attrs:{paddings:r,mode:a}}=e,s=r.map((f,m)=>f[0]+t.shape[m]+f[1]),i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(s,t.dtype),l=n.dataIdMap.get(o.dataId).id,c=new Uint8Array(new Int32Array(t.shape).buffer),u=r.map(f=>f[0]),h=r.map(f=>f[1]),d=new Uint8Array(new Int32Array(u).buffer),p=new Uint8Array(new Int32Array(h).buffer);return qW(i,c,t.shape.length,at[t.dtype],d,p,d2[a],l),o}var BCe={kernelName:Yu,backendName:"wasm",kernelFunc:LCe,setupFunc:PCe},KW;function WCe(e){KW=e.wasm.cwrap(wc,null,["number","number","number","number"])}function XW(e){let{backend:t,inputs:{logits:n},attrs:{dim:r}}=e,a=t.dataIdMap.get(n.dataId).id,s=t.makeOutput(n.shape,n.dtype),i=t.dataIdMap.get(s.dataId).id,o=n.shape[r],l=k.sizeFromShape(n.shape)/o;return k.sizeFromShape(s.shape)===0||KW(a,i,o,l),s}var UCe={kernelName:wc,backendName:"wasm",setupFunc:WCe,kernelFunc:XW},ZW;function VCe(e){ZW=e.wasm.cwrap(Hd,null,["number","number","number","number","number","number"])}function jCe(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:i,normalized:o}=r;if(a.dtype!=="float32")throw new Error(`Tensor logits must have dtype float32, got ${a.dtype}`);let l=o?a:XW({inputs:{logits:a},backend:n,attrs:{dim:a.shape.length-1}}),[c,u]=l.shape,h=n.makeOutput([c,s],"int32");return ZW(n.dataIdMap.get(l.dataId).id,c,u,s,i,n.dataIdMap.get(h.dataId).id),o||n.disposeData(l.dataId),h}var GCe={kernelName:Hd,backendName:"wasm",setupFunc:VCe,kernelFunc:jCe},HCe=tn(Ju),qCe=tn(Qu),KCe=et(qd);function NC(e,t){let n=new Int32Array(e.wasm.HEAPU8.buffer,t,4),r=n[0],a=n[1],s=n[2],i=n[3];return e.wasm._free(t),{pSelectedIndices:r,selectedSize:a,pSelectedScores:s,pValidOutputs:i}}var YW;function XCe(e){YW=e.wasm.cwrap(Xd,"number",["number","number","number","number","number"])}function ZCe(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:s,scoreThreshold:i}=r,{boxes:o,scores:l}=n,c=t.dataIdMap.get(o.dataId).id,u=t.dataIdMap.get(l.dataId).id,h=YW(c,u,s,a,i),{pSelectedIndices:d,selectedSize:p,pSelectedScores:f,pValidOutputs:m}=NC(t,h);return t.wasm._free(f),t.wasm._free(m),t.makeOutput([p],"int32",d)}var YCe={kernelName:Xd,backendName:"wasm",setupFunc:XCe,kernelFunc:ZCe},JW;function JCe(e){JW=e.wasm.cwrap(Zd,"number",["number","number","number","number","number","bool"])}function QCe(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:s,scoreThreshold:i,padToMaxOutputSize:o}=r,{boxes:l,scores:c}=n,u=t.dataIdMap.get(l.dataId).id,h=t.dataIdMap.get(c.dataId).id,d=JW(u,h,s,a,i,o),{pSelectedIndices:p,selectedSize:f,pSelectedScores:m,pValidOutputs:y}=NC(t,d);t.wasm._free(m);let g=t.makeOutput([f],"int32",p),x=t.makeOutput([],"int32",y);return[g,x]}var eTe={kernelName:Zd,backendName:"wasm",setupFunc:JCe,kernelFunc:QCe},QW;function tTe(e){QW=e.wasm.cwrap(Yd,"number",["number","number","number","number","number","number"])}function nTe(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:s,scoreThreshold:i,softNmsSigma:o}=r,{boxes:l,scores:c}=n,u=t.dataIdMap.get(l.dataId).id,h=t.dataIdMap.get(c.dataId).id,d=QW(u,h,s,a,i,o),{pSelectedIndices:p,selectedSize:f,pSelectedScores:m,pValidOutputs:y}=NC(t,d);t.wasm._free(y);let g=t.makeOutput([f],"int32",p),x=t.makeOutput([f],"float32",m);return[g,x]}var rTe={kernelName:Yd,backendName:"wasm",setupFunc:tTe,kernelFunc:nTe},aTe=!1,sTe=tn(Kd,aTe,"bool"),eU;function iTe(e){eU=e.wasm.cwrap(ec,null,["number","number","number","number","number"])}function oTe(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:s,depth:i,onValue:o,offValue:l}=r,c=n.makeOutput([...a.shape,i],s),u=n.dataIdMap.get(c.dataId).id,h=n.dataIdMap.get(a.dataId).id;return eU(h,i,o,l,u),c}var lTe={kernelName:ec,backendName:"wasm",setupFunc:iTe,kernelFunc:oTe};function uTe(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(1),r}var cTe={kernelName:Jd,backendName:"wasm",kernelFunc:uTe};function hTe(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(t.length===1)return h2({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let s=t[0].shape,i=t[0].dtype;t.forEach(u=>{k.assertShapesMatch(s,u.shape,"All tensors passed to stack must have matching shapes"),k.assert(i===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],l=t.map(u=>{let h=h2({inputs:{input:u},backend:n,attrs:{dim:a}});return o.push(h),h}),c=hW({inputs:l,backend:n,attrs:{axis:a}});return o.forEach(u=>n.disposeData(u.dataId)),c}var dTe={kernelName:Qd,backendName:"wasm",kernelFunc:hTe},tU;function pTe(e){tU=e.wasm.cwrap(tc,null,["number","array","number","number","array","array","number","number"])}function fTe(e){let{inputs:{x:t},backend:n,attrs:{paddings:r,constantValue:a}}=e,s=r.map((f,m)=>f[0]+t.shape[m]+f[1]);if(k.sizeFromShape(t.shape)===0)return TW({backend:n,attrs:{shape:s,value:a,dtype:t.dtype}});let i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(s,t.dtype),l=n.dataIdMap.get(o.dataId).id,c=new Uint8Array(new Int32Array(t.shape).buffer),u=r.map(f=>f[0]),h=r.map(f=>f[1]),d=new Uint8Array(new Int32Array(u).buffer),p=new Uint8Array(new Int32Array(h).buffer);return tU(i,c,t.shape.length,at[t.dtype],d,p,a,l),o}var nU={kernelName:tc,backendName:"wasm",kernelFunc:fTe,setupFunc:pTe},mTe=tn(nc),rU;function gTe(e){rU=e.wasm.cwrap(rc,null,["number","number","number"])}function yTe(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t,s=n.dataIdMap.get(r.dataId).id,i=n.dataIdMap.get(a.dataId).id,o=s,l=r,c=l;l.dtype!=="float32"&&(c=qo({backend:n,inputs:{x:r},attrs:{dtype:"float32"}}),o=n.dataIdMap.get(c.dataId).id);let u=n.makeOutput(r.shape,"float32"),h=n.dataIdMap.get(u.dataId).id;return rU(o,i,h),l.dtype!=="float32"&&n.disposeData(c.dataId),u}var xTe={kernelName:rc,backendName:"wasm",setupFunc:gTe,kernelFunc:yTe},aU;function bTe(e){aU=e.wasm.cwrap(ac,null,["number","number","number","number"])}function vTe(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,c=i,{transposed:u,axes:h,originalAxes:d,inputWasTransposed:p}=Ho(i,a,t),f=h;if(p){let b=t.dataIdMap.get(u.dataId).id;b!==o&&(c=u,l=b,f=E.getInnerMostAxes(f.length,c.shape.length))}E.assertAxesAreInnerMostDims("prod",f,c.shape.length);let[m,y]=E.computeOutAndReduceShapes(c.shape,f),g=k.sizeFromShape(y),x=t.makeOutput(m,c.dtype);if(k.sizeFromShape(c.shape)!==0){let b=t.dataIdMap.get(x.dataId).id;aU(l,g,at[x.dtype],b)}if(p&&t.disposeData(u.dataId),s){let b=E.expandShapeToKeepDim(x.shape,d);x.shape=b}return x}var wTe={kernelName:ac,backendName:"wasm",setupFunc:bTe,kernelFunc:vTe},kTe=e=>{let{backend:t,attrs:n}=e,{start:r,stop:a,step:s,dtype:i}=n,o=Q_(r,a,s,i),l=t.makeOutput([o.length],i);return t.typedArrayFromHeap(l).set(o),l},STe={kernelName:qm,backendName:"wasm",kernelFunc:kTe},ITe=tn(Tu),NTe=et(sc),_Te=et(ic),CTe=et(uc),sU;function TTe(e){sU=e.wasm.cwrap(lc,null,["number","number","number","number","number","number","number","number","number","number"])}function ETe(e){let{backend:t,inputs:n,attrs:r}=e,{images:a}=n,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,c]=o,[u,h,d,p]=a.shape,f=[u,l,c,p],m=t.dataIdMap.get(a.dataId),y;m.dtype!=="float32"&&(y=qo({backend:t,inputs:{x:a},attrs:{dtype:"float32"}}),m=t.dataIdMap.get(y.dataId));let g=m.id,x=t.makeOutput(f,"float32");if(k.sizeFromShape(a.shape)===0)return x;let b=t.dataIdMap.get(x.dataId).id;return sU(g,u,h,d,p,l,c,s?1:0,i?1:0,b),y!=null&&t.disposeData(y.dataId),x}var ATe={kernelName:lc,backendName:"wasm",setupFunc:TTe,kernelFunc:ETe},iU;function $Te(e){iU=e.wasm.cwrap(np,null,["number","number","number","array","array","boolean"])}function MTe(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r,o=n.makeOutput(a.shape,"float32"),l=n.dataIdMap.get(a.dataId),c;return l.dtype!=="float32"&&(c=qo({backend:n,inputs:{x:a},attrs:{dtype:"float32"}}),l=n.dataIdMap.get(c.dataId)),iU(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(o.dataId).id,new Uint8Array(new Int32Array(a.shape).buffer),new Uint8Array(new Int32Array(s.shape).buffer),i),c!=null&&n.disposeData(c.dataId),o}var FTe={kernelName:np,backendName:"wasm",setupFunc:$Te,kernelFunc:MTe},oU;function RTe(e){oU=e.wasm.cwrap(oc,null,["number","number","number","number","number","number","number","number","number","number"])}function DTe(e){let{backend:t,inputs:n,attrs:r}=e,{images:a}=n,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,c]=o,[u,h,d,p]=a.shape,f=[u,l,c,p],m=t.makeOutput(f,"float32");if(k.sizeFromShape(a.shape)===0)return m;let y=t.dataIdMap.get(a.dataId),g;y.dtype!=="float32"&&(g=qo({backend:t,inputs:{x:a},attrs:{dtype:"float32"}}),y=t.dataIdMap.get(g.dataId));let x=y.id,b=t.dataIdMap.get(m.dataId).id;return oU(x,u,h,d,p,l,c,s?1:0,i?1:0,b),g!=null&&t.disposeData(g.dataId),m}var OTe={kernelName:oc,backendName:"wasm",setupFunc:RTe,kernelFunc:DTe},lU;function zTe(e){lU=e.wasm.cwrap(tp,null,["number","number","number","array","array","boolean"])}function PTe(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r,o=n.makeOutput(a.shape,"float32"),l=n.dataIdMap.get(a.dataId),c;return l.dtype!=="float32"&&(c=qo({backend:n,inputs:{x:a},attrs:{dtype:"float32"}}),l=n.dataIdMap.get(c.dataId)),lU(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(o.dataId).id,new Uint8Array(new Int32Array(a.shape).buffer),new Uint8Array(new Int32Array(s.shape).buffer),i),c!=null&&n.disposeData(c.dataId),o}var LTe={kernelName:tp,backendName:"wasm",setupFunc:zTe,kernelFunc:PTe},uU;function BTe(e){uU=e.wasm.cwrap(cc,null,["number","array","number","array","number","number"])}function WTe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r,i=k.parseAxisParam(s,a.shape);if(a.shape.length===0)return Nv({inputs:{x:a},backend:n});let o=n.makeOutput(a.shape,a.dtype),l=n.dataIdMap.get(a.dataId).id,c=n.dataIdMap.get(o.dataId).id,u=new Uint8Array(new Int32Array(i).buffer),h=new Uint8Array(new Int32Array(a.shape).buffer);uU(l,u,i.length,h,a.shape.length,c);let d=br({inputs:{x:o},attrs:{shape:a.shape},backend:n});return n.disposeData(o.dataId),d}var UTe={kernelName:cc,backendName:"wasm",kernelFunc:WTe,setupFunc:BTe},cU;function VTe(e){cU=e.wasm.cwrap(yp,null,["number","number","number","number","number","number","number","number","array","number","number"])}function jTe(e){let{inputs:t,backend:n,attrs:r}=e,{image:a}=t,{radians:s,fillValue:i,center:o}=r,l=n.makeOutput(a.shape,a.dtype),c=n.dataIdMap.get(a.dataId).id,u=n.dataIdMap.get(l.dataId).id,[h,d,p,f]=a.shape,[m,y]=E.getImageCenter(o,d,p),g=i===0,x=255,b=typeof i=="number"?[i,i,i,g?0:x]:[...i,x],v=new Uint8Array(new Int32Array(b).buffer);return cU(c,h,d,p,f,s,m,y,v,b.length,u),l}var GTe={kernelName:yp,backendName:"wasm",kernelFunc:jTe,setupFunc:VTe},HTe=et(hc),qTe=et(dc),hU;function KTe(e){hU=e.wasm.cwrap(rp,null,["number","number","number","number","number","number","array","number","number"])}function XTe(e){let{backend:t,inputs:n,attrs:r}=e,{indices:a,updates:s}=n,{shape:i}=r,o=t.makeOutput(i,s.dtype);if(k.sizeFromShape(i)===0)return o;let{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:d}=Wb.calculateShapes(s,a,i),p=t.dataIdMap.get(a.dataId).id,f=t.dataIdMap.get(s.dataId).id,m=new Uint8Array(new Int32Array(h).buffer),y=t.dataIdMap.get(o.dataId).id;return hU(p,f,at[s.dtype],l,c,u,m,d,y),o}var ZTe={kernelName:rp,backendName:"wasm",setupFunc:KTe,kernelFunc:XTe},dU;function YTe(e){dU=e.wasm.cwrap(sp,null,["number","number","number","number","number","number","bool","number"])}function JTe(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:i}=r;if(a.dtype!==s.dtype)throw new Error(`SearchSorted error: sorted_sequence must have the same dtype as values. Got ${a.dtype} and ${s.dtype}`);let o=n.makeOutput(s.shape,"int32");function l(c){return n.dataIdMap.get(c.dataId).id}return dU(l(a),l(s),a.shape[0],a.shape[1],s.shape[1],at[a.dtype],i==="left",l(o)),o}var QTe={kernelName:sp,backendName:"wasm",setupFunc:YTe,kernelFunc:JTe},pU;function eEe(e){pU=e.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}function tEe(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t,i=n.dataIdMap.get(r.dataId).id,o=n.dataIdMap.get(a.dataId).id,l=n.dataIdMap.get(s.dataId).id,c=n.makeOutput(a.shape,a.dtype),u=n.dataIdMap.get(c.dataId).id,h=r.shape.length,d=a.shape.length,p=h===0||h>1||d===1?1:k.sizeFromShape(a.shape.slice(1));return pU(i,o,l,p,u),c}var nEe={kernelName:ip,backendName:"wasm",kernelFunc:tEe,setupFunc:eEe},rEe=et(pc),fU;function aEe(e){fU=e.wasm.cwrap(yc,null,["number","number"])}function sEe(e){let{backend:t,inputs:{x:n}}=e,r=t.dataIdMap.get(n.dataId).id,a=t.makeOutput(n.shape,n.dtype),s=t.dataIdMap.get(a.dataId).id;return k.sizeFromShape(a.shape)===0||fU(r,s),a}var iEe={kernelName:"Sigmoid",backendName:"wasm",setupFunc:aEe,kernelFunc:sEe},oEe=et(gc),lEe=et(fc),uEe=et(mc),cEe=et(xc);function hEe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r,o=k.sizeFromShape(s),l=[[0,0]];l.push(...i);for(let y=1+s.length;y<a.shape.length;++y)l.push([0,0]);let c=nU.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),u=E.getReshaped(c.shape,s,o,!1),h=E.getPermuted(u.length,s.length,!1),d=E.getReshapedPermuted(c.shape,s,o,!1),p=br({inputs:{x:c},backend:n,attrs:{shape:u}}),f=To({inputs:{x:p},backend:n,attrs:{perm:h}}),m=br({inputs:{x:f},backend:n,attrs:{shape:d}});return n.disposeData(c.dataId),n.disposeData(p.dataId),n.disposeData(f.dataId),m}var dEe={kernelName:lp,backendName:"wasm",kernelFunc:hEe},mU;function pEe(e){mU=e.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])}function fEe(e){let{backend:t,inputs:n}=e,{indices:r,values:a,denseShape:s,defaultValue:i}=n,o=r.shape[0],l=r.shape[1],c=t.readSync(s.dataId)[0],u=[o+c,l],h=t.dataIdMap.get(r.dataId).id,d=t.dataIdMap.get(a.dataId).id,p=t.dataIdMap.get(i.dataId).id,f=t.makeOutput(u,r.dtype),m=t.dataIdMap.get(f.dataId).id,y=t.makeOutput(u.slice(0,1),a.dtype),g=t.dataIdMap.get(y.dataId).id,x=t.makeOutput([c],"bool"),b=t.dataIdMap.get(x.dataId).id,v=t.makeOutput([o],r.dtype),w=t.dataIdMap.get(v.dataId).id,I=t.makeOutput([4],"int32"),_=t.dataIdMap.get(I.dataId).id,T=mU(h,d,at[a.dtype],o,c,l,p,m,g,b,w,_),A=t.readSync(I.dataId),M;switch(A[0]){case 1:{M=E.getSparseFillEmptyRowsIndicesDenseShapeMismatch(A[1]);break}case 2:{M=E.getSparseFillEmptyRowsNegativeIndexErrorMessage(A[1],A[2]);break}case 3:M=E.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(A[1],A[2],A[3]);break;default:M=""}if(t.disposeData(I.dataId),M)throw t.disposeData(f.dataId),t.disposeData(y.dataId),t.disposeData(x.dataId),t.disposeData(v.dataId),new Error(M);let F=f,C=y;return T!==u[0]&&(F=tu({inputs:{x:f},attrs:{begin:0,size:[T,l]},backend:t}),C=tu({inputs:{x:y},attrs:{begin:0,size:T},backend:t}),t.disposeData(f.dataId),t.disposeData(y.dataId)),[F,C,x,v]}var mEe={kernelName:Km,backendName:"wasm",setupFunc:pEe,kernelFunc:fEe},gU;function gEe(e){gU=e.wasm.cwrap(cp,null,["number","number","number","number","number","number","number"])}function yEe(e){let{backend:t,inputs:n}=e,{inputIndices:r,inputShape:a,newShape:s}=n;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(a.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${a.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=t.dataIdMap.get(r.dataId).id,o=t.dataIdMap.get(a.dataId).id,l=t.dataIdMap.get(s.dataId).id,c=r.shape[0],u=k.sizeFromShape(s.shape),h=t.makeOutput([c,u],r.dtype),d=t.dataIdMap.get(h.dataId).id,p=t.makeOutput([u],s.dtype),f=t.dataIdMap.get(p.dataId).id,m=t.makeOutput([3],"int32"),y=t.dataIdMap.get(m.dataId).id;gU(i,o,l,c,d,f,y);let g=t.readSync(m.dataId),x;switch(g[0]){case 0:{x=E.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(g[1],g[2]);break}case 1:{x=E.getSparseReshapeNegativeOutputDimErrorMessage(g[1],g[2]);break}case 2:x=E.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{let b=Array.from(t.readSync(a.dataId)),v=Array.from(t.readSync(p.dataId));x=E.getSparseReshapeInputOutputMultipleErrorMessage(b,v);break}case 4:{let b=Array.from(t.readSync(a.dataId)),v=Array.from(t.readSync(p.dataId));x=E.getSparseReshapeInputOutputMismatchErrorMessage(b,v);break}default:x=""}if(t.disposeData(m.dataId),x)throw t.disposeData(h.dataId),t.disposeData(p.dataId),new Error(x);return[h,p]}var xEe={kernelName:cp,backendName:"wasm",setupFunc:gEe,kernelFunc:yEe},yU;function xU(e){yU=e.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function bU(e,t){let{backend:n,inputs:r}=e,{data:a,indices:s,segmentIds:i}=r,o=s.shape[0],l=n.readSync(i.dataId,o-1,o)[0],c=o>0?l+1:0;if(c<0)throw new Error(E.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let u=a.shape.slice();u[0]=c;let h=n.dataIdMap.get(a.dataId).id,d=n.dataIdMap.get(s.dataId).id,p=n.dataIdMap.get(i.dataId).id,f=n.makeOutput(u,a.dtype),m=n.dataIdMap.get(f.dataId).id,y=n.makeOutput([4],"int32"),g=n.dataIdMap.get(y.dataId).id;yU(h,at[a.dtype],a.shape[0],d,p,m,g,t,0);let x=n.readSync(y.dataId),b;switch(x[0]){case 0:{b=E.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break}case 1:{b=E.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break}case 2:b=E.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(x[1],x[2]);break;case 3:b=E.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(x[1],x[2],x[3]);break;default:b=""}if(n.disposeData(y.dataId),b)throw n.disposeData(f.dataId),new Error(b);return f}function bEe(e){return bU(e,!0)}var vEe={kernelName:Xm,backendName:"wasm",setupFunc:xU,kernelFunc:bEe};function wEe(e){return bU(e,!1)}var kEe={kernelName:Zm,backendName:"wasm",setupFunc:xU,kernelFunc:wEe},vU;function SEe(e){vU=e.wasm.cwrap(hp,null,["number","number","number","number","number","number","number","number","array","number","number"])}function IEe(e){let{backend:t,inputs:n,attrs:r}=e,{sparseIndices:a,sparseValues:s,defaultValue:i}=n,{outputShape:o}=r,l=t.makeOutput(o,i.dtype);if(k.sizeFromShape(o)===0)return l;let{sliceRank:c,numUpdates:u,sliceSize:h,strides:d,outputSize:p}=E.calculateShapes(s,a,o),f=t.dataIdMap.get(a.dataId).id,m=t.dataIdMap.get(s.dataId).id,y=t.dataIdMap.get(i.dataId).id,g=new Uint8Array(new Int32Array(d).buffer),x=t.dataIdMap.get(l.dataId).id;return vU(f,m,s.shape.length,y,at[i.dtype],c,u,h,g,p,x),l}var NEe={kernelName:hp,backendName:"wasm",setupFunc:SEe,kernelFunc:IEe};function _Ee(e){let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=n,o=k.parseAxisParam(i,a.shape)[0],l=E.prepareSplitSize(a,s,o),c=new Array(a.shape.length).fill(0),u=a.shape.slice();return l.map(h=>{let d=[...u];d[o]=h;let p=tu({inputs:{x:a},attrs:{begin:c,size:d},backend:r});return c[o]+=h,p})}var CEe={kernelName:up,backendName:"wasm",kernelFunc:_Ee},TEe=et(bc),EEe=et(Ym),AEe=tn(kc),wU;function $Ee(e){wU=e.wasm.cwrap(Po,null,["number","number","number","number"])}function MEe(e){let{backend:t,inputs:n,attrs:r}=e,{alpha:a}=r,{x:s}=n,i=t.dataIdMap.get(s.dataId).id,o=t.makeOutput(s.shape,s.dtype),l=t.dataIdMap.get(o.dataId).id;return wU(i,a,at[s.dtype],l),o}var FEe={kernelName:Po,backendName:"wasm",setupFunc:$Ee,kernelFunc:MEe},kU;function REe(e){kU=e.wasm.cwrap(dp,null,["number","array","number","array","array","array","array","array","number","number"])}function DEe(e){let{backend:t,inputs:n,attrs:r}=e,{x:a}=n,{begin:s,end:i,strides:o,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:d}=r,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:y,isSimpleSlice:g,begin:x,end:b,strides:v}=ln.sliceInfo(a.shape,s,i,o,l,c,u,h,d),w;if(m)w=br({inputs:{x:a},backend:t,attrs:{shape:f}});else if(y||g){k.assert(a.shape.length>=1,()=>`Input must have rank at least 1, got: ${a.shape.length}`);let I=ln.computeOutShape(x,b,v),_=tu({inputs:{x:a},backend:t,attrs:{begin:x,size:I}});w=br({inputs:{x:_},backend:t,attrs:{shape:f}}),t.disposeData(_.dataId)}else{let I=t.makeOutput(p,"float32"),_=t.dataIdMap.get(a.dataId).id,T=new Uint8Array(new Int32Array(k.computeStrides(a.shape)).buffer),A=new Uint8Array(new Int32Array(x).buffer),M=new Uint8Array(new Int32Array(b).buffer),F=new Uint8Array(new Int32Array(v).buffer),C=new Uint8Array(new Int32Array(p).buffer),D=new Uint8Array(new Int32Array(k.computeStrides(p)).buffer),L=t.dataIdMap.get(I.dataId).id;kU(_,T,a.shape.length,A,M,F,C,D,p.length,L),w=br({inputs:{x:I},backend:t,attrs:{shape:f}}),t.disposeData(I.dataId)}return w}var OEe={kernelName:dp,backendName:"wasm",setupFunc:REe,kernelFunc:DEe};function zEe(e){let{backend:t,inputs:n,attrs:r}=e,{data:a,dataSplits:s}=n,{separator:i,nGramWidths:o,leftPad:l,rightPad:c,padWidth:u,preserveShortSequences:h}=r,d=t.readSync(a.dataId),p=t.readSync(s.dataId),[f,m]=tC(d,p,i,o,l,c,u,h),y=t.makeOutput([f.length],"string"),g=t.dataIdMap.get(y.dataId);g.stringBytes=f;let x=t.makeOutput(s.shape,"int32");return t.typedArrayFromHeap(x).set(m),[y,x]}var PEe={kernelName:Qm,backendName:"wasm",kernelFunc:zEe};function LEe(e){let{backend:t,inputs:n,attrs:r}=e,{input:a,delimiter:s}=n,{skipEmpty:i}=r,o=t.readSync(a.dataId),l=t.readSync(s.dataId),[c,u,h]=nC(o,l[0],i),d=u.length,p=t.makeOutput([d,2],"int32");t.typedArrayFromHeap(p).set(c);let f=t.makeOutput([d],"string"),m=t.dataIdMap.get(f.dataId);m.stringBytes=u;let y=t.makeOutput([2],"int32");return t.typedArrayFromHeap(y).set(h),[p,f,y]}var BEe={kernelName:eg,backendName:"wasm",kernelFunc:LEe};function WEe(e){let{backend:t,inputs:n,attrs:r}=e,{input:a}=n,{numBuckets:s}=r,i=t.readSync(a.dataId),o=rC(i,s),l=t.makeOutput(a.shape,"int32");return t.typedArrayFromHeap(l).set(o),l}var UEe={kernelName:tg,backendName:"wasm",kernelFunc:WEe},VEe=tn(Sc),SU;function jEe(e){SU=e.wasm.cwrap(vc,null,["number","number","number","number"])}function GEe(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,c=i,{transposed:u,axes:h,originalAxes:d,inputWasTransposed:p}=Ho(i,a,t),f=h;if(p){let b=t.dataIdMap.get(u.dataId).id;b!==o&&(c=u,l=b,f=E.getInnerMostAxes(f.length,c.shape.length))}E.assertAxesAreInnerMostDims("sum",f,c.shape.length);let[m,y]=E.computeOutAndReduceShapes(c.shape,f),g=k.sizeFromShape(y),x=t.makeOutput(m,c.dtype);if(k.sizeFromShape(c.shape)!==0){let b=t.dataIdMap.get(x.dataId).id;SU(l,g,at[x.dtype],b)}if(p&&t.disposeData(u.dataId),s){let b=E.expandShapeToKeepDim(x.shape,d);x.shape=b}return x}var HEe={kernelName:vc,backendName:"wasm",setupFunc:jEe,kernelFunc:GEe},qEe=et(Ic),KEe=et(Nc),IU;function XEe(e){IU=e.wasm.cwrap(ap,null,["number","number","number","number","number","number","array","number","number","number"])}function ZEe(e){let{backend:t,inputs:n,attrs:r}=e,{tensor:a,indices:s,updates:i}=n,o=t.makeOutput(a.shape,a.dtype);if(k.sizeFromShape(a.shape)===0)return o;let{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:d}=Wb.calculateShapes(i,s,a.shape),p=t.dataIdMap.get(s.dataId).id,f=t.dataIdMap.get(i.dataId).id,m=t.dataIdMap.get(a.dataId).id,y=new Uint8Array(new Int32Array(h).buffer),g=t.dataIdMap.get(o.dataId).id;return IU(p,f,at[i.dtype],l,c,u,y,d,g,m),o}var YEe={kernelName:ap,backendName:"wasm",setupFunc:XEe,kernelFunc:ZEe},NU;function JEe(e){NU=e.wasm.cwrap(zo,null,["number","array","number","array","number","number"])}function QEe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,s=n.dataIdMap.get(a.dataId).id,{reps:i}=r,o=new Array(a.shape.length);for(let d=0;d<o.length;d++)o[d]=a.shape[d]*i[d];let l=new Uint8Array(new Int32Array(a.shape).buffer),c=new Uint8Array(new Int32Array(o).buffer),u=n.makeOutput(o,a.dtype),h=n.dataIdMap.get(u.dataId).id;return NU(s,l,a.shape.length,c,o.length,at[u.dtype],h),u}var eAe={kernelName:zo,backendName:"wasm",setupFunc:JEe,kernelFunc:QEe},_U;function tAe(e){_U=e.wasm.cwrap(pp,null,["number","array","number","number","number","bool","number","number"])}var nAe=({inputs:e,backend:t,attrs:n})=>{let{x:r}=e,{k:a,sorted:s}=n,i=t.dataIdMap.get(r.dataId).id,o=new Uint8Array(new Int32Array(r.shape).buffer),l=r.shape.slice();l[l.length-1]=a;let c=t.makeOutput(l,r.dtype),u=t.dataIdMap.get(c.dataId).id,h=t.makeOutput(l,"int32"),d=t.dataIdMap.get(h.dataId).id;return _U(i,o,r.shape.length,at[r.dtype],a,s,u,d),[c,h]},rAe={kernelName:pp,backendName:"wasm",setupFunc:tAe,kernelFunc:nAe},CU;function aAe(e){CU=e.wasm.cwrap(fp,null,["number","number","bool","number","number","number","number","number","number","array","number","array","number","number","number","number","number"])}function sAe(e){let{backend:t,inputs:n,attrs:r}=e,{image:a,transforms:s}=n,{interpolation:i,fillMode:o,fillValue:l,outputShape:c}=r,[u,h,d,p]=a.shape,[f,m]=c??[h,d],y=[u,f,m,p],g=new Uint8Array(new Int32Array(k.computeStrides(a.shape)).buffer),x=new Uint8Array(new Int32Array(k.computeStrides(y)).buffer),b=t.makeOutput(y,a.dtype),v=t.dataIdMap.get(b.dataId).id,w=t.dataIdMap.get(a.dataId).id,I=t.dataIdMap.get(s.dataId).id,_=i==="nearest"?1:2,T;switch(o){case"constant":T=1;break;case"reflect":T=2;break;case"wrap":T=3;break;case"nearest":T=4;break;default:T=1;break}return CU(w,I,s.shape[0]>1,u,f,m,p,d,h,g,a.shape.length-1,x,y.length-1,_,T,l,v),b}var iAe={kernelName:fp,backendName:"wasm",setupFunc:aAe,kernelFunc:sAe};function oAe(e){let{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t,{outputValues:i,outputShape:o,indices:l}=sC(r.readSync(s.dataId),a,s.shape,s.dtype);return[r.makeOutput(o,s.dtype,void 0,i),r.makeOutput([l.length],"int32",void 0,l)]}var lAe={kernelName:ng,backendName:"wasm",kernelFunc:oAe};function uAe(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:s}=r;s<0&&(s+=a.shape.length);let i=a.shape[s],o=a.shape.length,l=new Array(o-1),c=0;for(let p=0;p<o;p++)p!==s&&(l[c++]=a.shape[p]);let u=new Array(i),h=new Array(o).fill(0),d=a.shape.slice();d[s]=1;for(let p=0;p<u.length;p++)h[s]=p,u[p]=tu({inputs:{x:a},attrs:{begin:h,size:d},backend:n});return u.map(({dataId:p,dtype:f})=>({dataId:p,dtype:f,shape:l}))}var cAe={kernelName:mp,backendName:"wasm",kernelFunc:uAe};function hAe(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(0),r}var dAe={kernelName:gp,backendName:"wasm",kernelFunc:hAe},pAe=[aIe,sIe,iIe,oIe,lIe,hIe,bIe,kIe,SIe,IIe,NIe,_Ie,CIe,TIe,EIe,MIe,WIe,DIe,PIe,GIe,YIe,eNe,tNe,rNe,aNe,sNe,lNe,uNe,dNe,mNe,xNe,wNe,INe,NNe,_Ne,ENe,MNe,DNe,PNe,WNe,jNe,qNe,ZNe,QNe,n_e,r_e,i_e,l_e,u_e,c_e,h_e,d_e,p_e,g_e,y_e,x_e,w_e,I_e,C_e,A_e,F_e,D_e,z_e,dIe,P_e,L_e,B_e,V_e,G_e,q_e,Z_e,J_e,Y_e,eCe,tCe,rCe,sCe,lCe,hCe,fCe,mCe,xCe,wCe,ICe,CCe,ACe,FCe,OCe,zCe,BCe,GCe,HCe,qCe,KCe,YCe,eTe,rTe,sTe,lTe,cTe,dTe,nU,mTe,xTe,wTe,STe,ITe,NTe,_Te,CTe,UIe,ATe,FTe,OTe,LTe,UTe,GTe,HTe,qTe,ZTe,QTe,nEe,rEe,iEe,oEe,lEe,uEe,XIe,UCe,cEe,dEe,mEe,xEe,vEe,kEe,NEe,CEe,TEe,EEe,AEe,FEe,OEe,PEe,BEe,UEe,VEe,HEe,qEe,KEe,YEe,eAe,rAe,iAe,gIe,lAe,cAe,dAe];for(let e of pAe)ag(e);var p2=X();p2.registerFlag("WASM_HAS_SIMD_SUPPORT",async()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))}catch{return!1}});p2.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",async()=>{if(p2.get("IS_NODE"))return!1;try{return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}});var oM=Ro(Kq()),fAe=Ro(Xq()),lM=Ro(Zq()),uM=oM.default||oM,mAe=lM.default||lM,TU=class extends Dm{constructor(e){super(),this.wasm=e,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(EU),f2=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new Qx(this,wa())}write(e,t,n){let r={id:this.dataIdNextNumber++};return this.move(r,e,t,n,1),r}numDataIds(){return this.dataIdMap.numDataIds()}async time(e){let t=k.now();return e(),{kernelMs:k.now()-t}}move(e,t,n,r,a){let s=this.dataIdNextNumber++;if(r==="string"){let c=t;this.dataIdMap.set(e,{id:s,stringBytes:c,shape:n,dtype:r,memoryOffset:null,refCount:a});return}let i=k.sizeFromShape(n),o=i*k.bytesPerElement(r),l=this.wasm._malloc(o)>>>0;this.dataIdMap.set(e,{id:s,memoryOffset:l,shape:n,dtype:r,refCount:a}),this.wasm.tfjs.registerTensor(s,i,l),t!=null&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,o),l)}async read(e){return this.readSync(e)}readSync(e,t,n){let{memoryOffset:r,dtype:a,shape:s,stringBytes:i}=this.dataIdMap.get(e);if(a==="string")return(t==null||t===0)&&(n==null||n>=i.length)?i:i.slice(t,n);t=t||0,n=n||k.sizeFromShape(s);let o=k.bytesPerElement(a),l=this.wasm.HEAPU8.slice(r+t*o,r+n*o);return xAe(l.buffer,a)}disposeData(e,t=!1){if(this.dataIdMap.has(e)){let n=this.dataIdMap.get(e);if(n.refCount--,!t&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(e)}return!0}refCount(e){return this.dataIdMap.has(e)?this.dataIdMap.get(e).refCount:0}incRef(e){let t=this.dataIdMap.get(e);t!=null&&t.refCount++}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,t,n,r){let a;if(n==null)a=this.write(r??null,e,t);else{let s=this.dataIdNextNumber++;a={id:s},this.dataIdMap.set(a,{id:s,memoryOffset:n,shape:e,dtype:t,refCount:1});let i=k.sizeFromShape(e);this.wasm.tfjs.registerTensor(s,i,n)}return{dataId:a,shape:e,dtype:t}}typedArrayFromHeap({shape:e,dtype:t,dataId:n}){let r=this.wasm.HEAPU8.buffer,{memoryOffset:a}=this.dataIdMap.get(n),s=k.sizeFromShape(e);switch(t){case"float32":return new Float32Array(r,a,s);case"int32":return new Int32Array(r,a,s);case"bool":return new Uint8Array(r,a,s);default:throw new Error(`Unknown dtype ${t}`)}}};function gAe(e){return(t,n)=>(k.fetch(e,{credentials:"same-origin"}).then(r=>{r.ok||t.env.a(`failed to load wasm binary file at '${e}'`),r.arrayBuffer().then(a=>{WebAssembly.instantiate(a,t).then(s=>{n(s.instance,s.module)})})}),{})}function cM(e,t,n){if(_x!=null)return _x;let r="tfjs-backend-wasm.wasm";return e&&t?r="tfjs-backend-wasm-threaded-simd.wasm":e&&(r="tfjs-backend-wasm-simd.wasm"),zf!=null&&zf[r]!=null?zf[r]:n+r}async function yAe(){let[e,t]=await Promise.all([X().getAsync("WASM_HAS_SIMD_SUPPORT"),X().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise((n,r)=>{let a={};a.locateFile=(o,l)=>{if(o.endsWith(".worker.js")){let c=fAe.wasmWorkerContents.replace(/\n/g,"\\n"),u=new Blob([c],{type:"application/javascript"});return URL.createObjectURL(u)}return o.endsWith(".wasm")?cM(e,t,Sf??l):l+o},_C&&(a.instantiateWasm=gAe(cM(e,t,Sf??"")));let s=!1;a.onAbort=()=>{s||Pf||(Pf=!0,r({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"}))};let i;t&&e&&_x==null?(a.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+uM.toString()],{type:"text/javascript"}),i=uM(a)):i=mAe(a),i.then(o=>{s=!0,Pf=!1;let l=null;o.tfjs={init:o.cwrap("init",null,[]),initWithThreadsCount:o.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:o.cwrap("get_threads_count","number",[]),registerTensor:o.cwrap("register_tensor",null,["number","number","number"]),disposeData:o.cwrap("dispose_data",l,["number"]),dispose:o.cwrap("dispose",l,[])},n({wasm:o})}).catch(r)})}function xAe(e,t){switch(t){case"float32":return new Float32Array(e);case"int32":return new Int32Array(e);case"bool":return new Uint8Array(e);default:throw new Error(`Unknown dtype ${t}`)}}var bAe=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"],_x=null,Sf=null,zf={},Pf=!1,_C=!1;function vAe(e,t=!1){if(ZD("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),Pf)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");_x=e,_C=t}function wAe(e,t=!1){if(Pf)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if(typeof e=="string")Sf=e;else{zf=e;let n=bAe.filter(r=>zf[r]==null);if(n.length>0)throw new Error(`There were no entries found for the following binaries: ${n.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}_C=t}var EU=-1,f2=-1;function kAe(e){EU=e}function SAe(){if(f2===-1)throw new Error("WASM backend not initialized.");return f2}var IAe="4.22.0",NAe=2;yb("wasm",async()=>{let{wasm:e}=await yAe();return new TU(e)},NAe);var hM="4.22.0",_Ae="4.22.0",CAe="4.22.0",TAe="4.22.0",EAe="4.22.0",AAe={tfjs:hM,"tfjs-core":hM,"tfjs-converter":_Ae,"tfjs-backend-cpu":CAe,"tfjs-backend-webgl":TAe,"tfjs-backend-wasm":EAe},$Ae={};RS($Ae,{AnchorPosition:()=>GU,DrawBox:()=>KU,DrawBoxOptions:()=>qU,DrawFaceLandmarks:()=>hV,DrawFaceLandmarksOptions:()=>cV,DrawTextField:()=>FC,DrawTextFieldOptions:()=>MC,drawContour:()=>zi,drawDetections:()=>jAe,drawFaceExpressions:()=>r$e,drawFaceLandmarks:()=>s$e});function zi(e,t,n=!1){if(e.beginPath(),t.slice(1).forEach(({x:r,y:a},s)=>{let i=t[s];e.moveTo(i.x,i.y),e.lineTo(r,a)}),n){let r=t[t.length-1],a=t[0];if(!r||!a)return;e.moveTo(r.x,r.y),e.lineTo(a.x,a.y)}e.stroke()}var MAe={};RS(MAe,{computeReshapedDimensions:()=>FU,getCenterPoint:()=>TC,isDimensions:()=>g2,isEven:()=>m2,isFloat:()=>MU,isTensor:()=>Pp,isTensor1D:()=>FAe,isTensor2D:()=>$U,isTensor3D:()=>zg,isTensor4D:()=>ai,isValidNumber:()=>$l,isValidProbablitiy:()=>RAe,range:()=>od,round:()=>CC});var Dh=class AU{constructor(t,n){if(!$l(t)||!$l(n))throw new Error(`Dimensions.constructor - expected width and height to be valid numbers, instead have ${JSON.stringify({width:t,height:n})}`);this._width=t,this._height=n}get width(){return this._width}get height(){return this._height}reverse(){return new AU(1/this.width,1/this.height)}};function Pp(e,t){return e instanceof ze&&e.shape.length===t}function FAe(e){return Pp(e,1)}function $U(e){return Pp(e,2)}function zg(e){return Pp(e,3)}function ai(e){return Pp(e,4)}function MU(e){return e%1!==0}function m2(e){return e%2===0}function CC(e,t=2){let n=10**t;return Math.floor(e*n)/n}function g2(e){return e&&e.width&&e.height}function FU({width:e,height:t},n){let r=n/Math.max(t,e);return new Dh(Math.round(e*r),Math.round(t*r))}function TC(e){return e.reduce((t,n)=>t.add(n),new mt(0,0)).div(new mt(e.length,e.length))}function od(e,t,n){return Array(e).fill(0).map((r,a)=>t+a*n)}function $l(e){return!!e&&e!==1/0&&e!==-1/0&&!Number.isNaN(e)||e===0}function RAe(e){return $l(e)&&e>=0&&e<=1}var mt=class cl{constructor(t,n){this._x=t,this._y=n}get x(){return this._x}get y(){return this._y}add(t){return new cl(this.x+t.x,this.y+t.y)}sub(t){return new cl(this.x-t.x,this.y-t.y)}mul(t){return new cl(this.x*t.x,this.y*t.y)}div(t){return new cl(this.x/t.x,this.y/t.y)}abs(){return new cl(Math.abs(this.x),Math.abs(this.y))}magnitude(){return Math.sqrt(this.x**2+this.y**2)}floor(){return new cl(Math.floor(this.x),Math.floor(this.y))}},nu=class Ua{static isRect(t){return!!t&&[t.x,t.y,t.width,t.height].every($l)}static assertIsValidBox(t,n,r=!1){if(!Ua.isRect(t))throw new Error(`${n} - invalid box: ${JSON.stringify(t)}, expected object with properties x, y, width, height`);if(!r&&(t.width<0||t.height<0))throw new Error(`${n} - width (${t.width}) and height (${t.height}) must be positive numbers`)}constructor(t,n=!0){let r=t||{},a=[r.left,r.top,r.right,r.bottom].every($l),s=[r.x,r.y,r.width,r.height].every($l);if(!s&&!a)throw new Error(`Box.constructor - expected box to be IBoundingBox | IRect, instead have ${JSON.stringify(r)}`);let[i,o,l,c]=s?[r.x,r.y,r.width,r.height]:[r.left,r.top,r.right-r.left,r.bottom-r.top];Ua.assertIsValidBox({x:i,y:o,width:l,height:c},"Box.constructor",n),this._x=i,this._y=o,this._width=l,this._height=c}get x(){return this._x}get y(){return this._y}get width(){return this._width}get height(){return this._height}get left(){return this.x}get top(){return this.y}get right(){return this.x+this.width}get bottom(){return this.y+this.height}get area(){return this.width*this.height}get topLeft(){return new mt(this.left,this.top)}get topRight(){return new mt(this.right,this.top)}get bottomLeft(){return new mt(this.left,this.bottom)}get bottomRight(){return new mt(this.right,this.bottom)}round(){let[t,n,r,a]=[this.x,this.y,this.width,this.height].map(s=>Math.round(s));return new Ua({x:t,y:n,width:r,height:a})}floor(){let[t,n,r,a]=[this.x,this.y,this.width,this.height].map(s=>Math.floor(s));return new Ua({x:t,y:n,width:r,height:a})}toSquare(){let{x:t,y:n,width:r,height:a}=this,s=Math.abs(r-a);return r<a&&(t-=s/2,r+=s),a<r&&(n-=s/2,a+=s),new Ua({x:t,y:n,width:r,height:a})}rescale(t){let n=g2(t)?t.width:t,r=g2(t)?t.height:t;return new Ua({x:this.x*n,y:this.y*r,width:this.width*n,height:this.height*r})}pad(t,n){let[r,a,s,i]=[this.x-t/2,this.y-n/2,this.width+t,this.height+n];return new Ua({x:r,y:a,width:s,height:i})}clipAtImageBorders(t,n){let{x:r,y:a,right:s,bottom:i}=this,o=Math.max(r,0),l=Math.max(a,0),c=s-o,u=i-l,h=Math.min(c,t-o),d=Math.min(u,n-l);return new Ua({x:o,y:l,width:h,height:d}).floor()}shift(t,n){let{width:r,height:a}=this,s=this.x+t,i=this.y+n;return new Ua({x:s,y:i,width:r,height:a})}padAtBorders(t,n){let r=this.width+1,a=this.height+1,s=1,i=1,o=r,l=a,c=this.left,u=this.top,h=this.right,d=this.bottom;return h>n&&(o=-h+n+r,h=n),d>t&&(l=-d+t+a,d=t),c<1&&(l=2-c,c=1),u<1&&(l=2-u,u=1),{dy:i,edy:l,dx:s,edx:o,y:u,ey:d,x:c,ex:h,w:r,h:a}}calibrate(t){return new Ua({left:this.left+t.left*this.width,top:this.top+t.top*this.height,right:this.right+t.right*this.width,bottom:this.bottom+t.bottom*this.height}).toSquare().round()}},RU=class extends nu{constructor(e,t,n,r,a=!1){super({left:e,top:t,right:n,bottom:r},a)}},DU=class OU{constructor(t,n,r,a,s){this._imageDims=new Dh(s.width,s.height),this._score=t,this._classScore=n,this._className=r,this._box=new nu(a).rescale(this._imageDims)}get score(){return this._score}get classScore(){return this._classScore}get className(){return this._className}get box(){return this._box}get imageDims(){return this._imageDims}get imageWidth(){return this.imageDims.width}get imageHeight(){return this.imageDims.height}get relativeBox(){return new nu(this._box).rescale(this.imageDims.reverse())}forSize(t,n){return new OU(this.score,this.classScore,this.className,this.relativeBox,{width:t,height:n})}},as=class zU extends DU{constructor(t,n,r){super(t,t,"",n,r)}forSize(t,n){let{score:r,relativeBox:a,imageDims:s}=super.forSize(t,n);return new zU(r,a,s)}};function DAe(e,t,n=!0){let r=Math.max(0,Math.min(e.right,t.right)-Math.max(e.left,t.left)),a=Math.max(0,Math.min(e.bottom,t.bottom)-Math.max(e.top,t.top)),s=r*a;return n?s/(e.area+t.area-s):s/Math.min(e.area,t.area)}function OAe(e){let t=e.map(o=>o.x),n=e.map(o=>o.y),r=t.reduce((o,l)=>l<o?l:o,1/0),a=n.reduce((o,l)=>l<o?l:o,1/0),s=t.reduce((o,l)=>o<l?l:o,0),i=n.reduce((o,l)=>o<l?l:o,0);return new RU(r,a,s,i)}function zAe(e,t,n,r=!0){let a=t.map((i,o)=>({score:i,boxIndex:o})).sort((i,o)=>i.score-o.score).map(i=>i.boxIndex),s=[];for(;a.length>0;){let i=a.pop();s.push(i);let o=a,l=[];for(let c=0;c<o.length;c++){let u=o[c],h=e[i],d=e[u];l.push(DAe(h,d,r))}a=a.filter((c,u)=>l[u]<=n)}return s}function Pg(e,t){return j(()=>{let[n,r,a]=t,s=Wr([...e.shape.slice(0,3),1],n,"float32"),i=Wr([...e.shape.slice(0,3),1],r,"float32"),o=Wr([...e.shape.slice(0,3),1],a,"float32"),l=xt([s,i,o],3);return me(e,l)})}function PAe(e,t=!1){return j(()=>{let[n,r]=e.shape.slice(1);if(n===r)return e;let a=Math.abs(n-r),s=Math.round(a*(t?.5:1)),i=n>r?2:1,o=h=>{let d=e.shape.slice();return d[i]=h,Wr(d,0,"float32")},l=o(s),c=a-l.shape[i],u=[t&&c?o(c):null,e,l].filter(h=>!!h).map(h=>le(h,"float32"));return xt(u,i)})}function r1(e){return 1/(1+Math.exp(-e))}var PU=class extends nu{constructor(e,t,n,r,a=!1){super({x:e,y:t,width:n,height:r},a)}},LAe=.5,BAe=.43,WAe=.45,Cx=class{constructor(e,t,n=new mt(0,0)){let{width:r,height:a}=t;this._imgDims=new Dh(r,a),this._shift=n,this._positions=e.map(s=>s.mul(new mt(r,a)).add(n))}get shift(){return new mt(this._shift.x,this._shift.y)}get imageWidth(){return this._imgDims.width}get imageHeight(){return this._imgDims.height}get positions(){return this._positions}get relativePositions(){return this._positions.map(e=>e.sub(this._shift).div(new mt(this.imageWidth,this.imageHeight)))}forSize(e,t){return new this.constructor(this.relativePositions,{width:e,height:t})}shiftBy(e,t){return new this.constructor(this.relativePositions,this._imgDims,new mt(e,t))}shiftByPoint(e){return this.shiftBy(e.x,e.y)}align(e,t={}){if(e){let a=e instanceof as?e.box.floor():new nu(e);return this.shiftBy(a.x,a.y).align(null,t)}let{useDlibAlignment:n,minBoxPadding:r}={useDlibAlignment:!1,minBoxPadding:.2,...t};return n?this.alignDlib():this.alignMinBbox(r)}alignDlib(){let e=this.getRefPointsForAlignment(),[t,n,r]=e,a=u=>r.sub(u).magnitude(),s=(a(t)+a(n))/2,i=Math.floor(s/WAe),o=TC(e),l=Math.floor(Math.max(0,o.x-LAe*i)),c=Math.floor(Math.max(0,o.y-BAe*i));return new PU(l,c,Math.min(i,this.imageWidth+l),Math.min(i,this.imageHeight+c))}alignMinBbox(e){let t=OAe(this.positions);return t.pad(t.width*e,t.height*e)}getRefPointsForAlignment(){throw new Error("getRefPointsForAlignment not implemented by base class")}},LU=class extends Cx{getJawOutline(){return this.positions.slice(0,17)}getLeftEyeBrow(){return this.positions.slice(17,22)}getRightEyeBrow(){return this.positions.slice(22,27)}getNose(){return this.positions.slice(27,36)}getLeftEye(){return this.positions.slice(36,42)}getRightEye(){return this.positions.slice(42,48)}getMouth(){return this.positions.slice(48,68)}getRefPointsForAlignment(){return[this.getLeftEye(),this.getRightEye(),this.getMouth()].map(TC)}};function Tx(e){return e.detection instanceof as}function BU(e,t){return{...e,detection:t}}function WU(){let e=window.fetch;if(!e)throw new Error("fetch - missing fetch implementation for browser environment");return{Canvas:HTMLCanvasElement,CanvasRenderingContext2D,Image:HTMLImageElement,ImageData,Video:HTMLVideoElement,createCanvasElement:()=>document.createElement("canvas"),createImageElement:()=>document.createElement("img"),createVideoElement:()=>document.createElement("video"),fetch:e,readFile:()=>{throw new Error("readFile - filesystem not available for browser environment")}}}function EC(){return typeof global=="object"&&typeof process<"u"&&process.versions!=null&&process.versions.node!=null}function UU(e){let t="";if(!e&&EC())try{e=Cq("fs")}catch(n){t=n.toString()}return{readFile:e?n=>new Promise((r,a)=>{e.readFile(n,(s,i)=>s?a(s):r(i))}):()=>{throw new Error(`readFile - failed to require fs in nodejs environment with error: ${t}`)}}}function VU(){let e=global.Canvas||global.HTMLCanvasElement,t=global.Image||global.HTMLImageElement,n=global.Video||global.HTMLVideoElement,r=()=>{if(e)return new e;throw new Error("createCanvasElement - missing Canvas implementation for nodejs environment")},a=()=>{if(t)return new t;throw new Error("createImageElement - missing Image implementation for nodejs environment")},s=()=>{if(n)return new n;throw new Error("createVideoElement - missing Video implementation for nodejs environment")},i=global.fetch,o=UU();return{Canvas:e||class{},CanvasRenderingContext2D:global.CanvasRenderingContext2D||class{},Image:t||class{},ImageData:global.ImageData||class{},Video:global.HTMLVideoElement||class{},createCanvasElement:r,createImageElement:a,createVideoElement:s,fetch:i,...o}}function jU(){return typeof window=="object"&&typeof document<"u"&&typeof HTMLImageElement<"u"&&typeof HTMLCanvasElement<"u"&&typeof HTMLVideoElement<"u"&&typeof ImageData<"u"&&typeof CanvasRenderingContext2D<"u"}var dn;function UAe(){if(!dn)throw new Error("getEnv - environment is not defined, check isNodejs() and isBrowser()");return dn}function y2(e){dn=e}function AC(){return jU()?y2(WU()):EC()?y2(VU()):null}function VAe(e){if(dn||AC(),!dn)throw new Error("monkeyPatch - environment is not defined, check isNodejs() and isBrowser()");let{Canvas:t=dn.Canvas,Image:n=dn.Image}=e;dn.Canvas=t,dn.Image=n,dn.createCanvasElement=e.createCanvasElement||(()=>new t),dn.createImageElement=e.createImageElement||(()=>new n),dn.ImageData=e.ImageData||dn.ImageData,dn.Video=e.Video||dn.Video,dn.fetch=e.fetch||dn.fetch,dn.readFile=e.readFile||dn.readFile}var Sr={getEnv:UAe,setEnv:y2,initialize:AC,createBrowserEnv:WU,createFileSystem:UU,createNodejsEnv:VU,monkeyPatch:VAe,isBrowser:jU,isNodejs:EC};AC();function $C(e){return!Sr.isNodejs()&&typeof e=="string"?document.getElementById(e):e}function Eo(e){let{Canvas:t,CanvasRenderingContext2D:n}=Sr.getEnv();if(e instanceof n)return e;let r=$C(e);if(!(r instanceof t))throw new Error("resolveContext2d - expected canvas to be of instance of Canvas");let a=r.getContext("2d",{willReadFrequently:!0});if(!a)throw new Error("resolveContext2d - canvas 2d context is null");return a}var GU=(e=>(e.TOP_LEFT="TOP_LEFT",e.TOP_RIGHT="TOP_RIGHT",e.BOTTOM_LEFT="BOTTOM_LEFT",e.BOTTOM_RIGHT="BOTTOM_RIGHT",e))(GU||{}),MC=class{constructor(e={}){let{anchorPosition:t,backgroundColor:n,fontColor:r,fontSize:a,fontStyle:s,padding:i}=e;this.anchorPosition=t||"TOP_LEFT",this.backgroundColor=n||"rgba(0, 0, 0, 0.5)",this.fontColor=r||"rgba(255, 255, 255, 1)",this.fontSize=a||14,this.fontStyle=s||"Georgia",this.padding=i||4}},FC=class HU{constructor(t,n,r={}){this.text=typeof t=="string"?[t]:t instanceof HU?t.text:t,this.anchor=n,this.options=new MC(r)}measureWidth(t){let{padding:n}=this.options;return this.text.map(r=>t.measureText(r).width).reduce((r,a)=>r<a?a:r,0)+2*n}measureHeight(){let{fontSize:t,padding:n}=this.options;return this.text.length*t+2*n}getUpperLeft(t,n){let{anchorPosition:r}=this.options,a=r==="BOTTOM_RIGHT"||r==="TOP_RIGHT",s=r==="BOTTOM_LEFT"||r==="BOTTOM_RIGHT",i=this.measureWidth(t),o=this.measureHeight(),l=a?this.anchor.x-i:this.anchor.x,c=s?this.anchor.y-o:this.anchor.y;if(n){let{width:u,height:h}=n,d=Math.max(Math.min(l,u-i),0),p=Math.max(Math.min(c,h-o),0);return{x:d,y:p}}return{x:l,y:c}}draw(t){let n=$C(t),r=Eo(n),{backgroundColor:a,fontColor:s,fontSize:i,fontStyle:o,padding:l}=this.options;r.font=`${i}px ${o}`;let c=this.measureWidth(r),u=this.measureHeight();r.fillStyle=a;let h=this.getUpperLeft(r,n);r.fillRect(h.x,h.y,c,u),r.fillStyle=s,this.text.forEach((d,p)=>{let f=l+h.x,m=l+h.y+(p+1)*i;r.fillText(d,f,m)})}},qU=class{constructor(e={}){let{boxColor:t,lineWidth:n,label:r,drawLabelOptions:a}=e;this.boxColor=t||"rgba(0, 0, 255, 1)",this.lineWidth=n||2,this.label=r;let s={anchorPosition:"BOTTOM_LEFT",backgroundColor:this.boxColor};this.drawLabelOptions=new MC({...s,...a})}},KU=class{constructor(e,t={}){this.box=new nu(e),this.options=new qU(t)}draw(e){let t=Eo(e),{boxColor:n,lineWidth:r}=this.options,{x:a,y:s,width:i,height:o}=this.box;t.strokeStyle=n,t.lineWidth=r,t.strokeRect(a,s,i,o);let{label:l}=this.options;l&&new FC([l],{x:a-r/2,y:s},this.options.drawLabelOptions).draw(e)}};function jAe(e,t){(Array.isArray(t)?t:[t]).forEach(n=>{let r=n instanceof as?n.score:Tx(n)?n.detection.score:void 0,a=n instanceof as?n.box:Tx(n)?n.detection.box:new nu(n),s=r?`${CC(r)}`:void 0;new KU(a,{label:s}).draw(e)})}function XU(e){let{Image:t,Video:n}=Sr.getEnv();return e instanceof t&&e.complete||e instanceof n&&e.readyState>=3}function GAe(e){return new Promise((t,n)=>{if(e instanceof Sr.getEnv().Canvas||XU(e)){t(null);return}function r(s){s.currentTarget&&(s.currentTarget.removeEventListener("load",a),s.currentTarget.removeEventListener("error",r),n(s))}function a(s){s.currentTarget&&(s.currentTarget.removeEventListener("load",a),s.currentTarget.removeEventListener("error",r),t(s))}e.addEventListener("load",a),e.addEventListener("error",r)})}function ZU(e){let{Image:t,Video:n}=Sr.getEnv();return e instanceof t?new Dh(e.naturalWidth,e.naturalHeight):e instanceof n?new Dh(e.videoWidth,e.videoHeight):new Dh(e.width,e.height)}function Ex({width:e,height:t}){let{createCanvasElement:n}=Sr.getEnv(),r=n();return r.width=e,r.height=t,r}function YU(e,t){let{ImageData:n}=Sr.getEnv();if(!(e instanceof n)&&!XU(e))throw new Error("createCanvasFromMedia - media has not finished loading yet");let{width:r,height:a}=ZU(e),s=Ex({width:r,height:a});return e instanceof n?Eo(s).putImageData(e,0,0):Eo(s).drawImage(e,0,0,r,a),s}async function HAe(e,t){let n=t||Sr.getEnv().createCanvasElement(),[r,a,s]=e.shape.slice(ai(e)?1:0),i=j(()=>e.as3D(r,a,s).toInt());return await Sg.toPixels(i,n),i.dispose(),n}function dM(e){let{Image:t,Canvas:n,Video:r}=Sr.getEnv();return e instanceof t||e instanceof n||e instanceof r}function qAe(e,t,n=!1){let{Image:r,Canvas:a}=Sr.getEnv();if(!(e instanceof r||e instanceof a))throw new Error("imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement");if(t<=0)return Ex({width:1,height:1});let s=ZU(e),i=t/Math.max(s.height,s.width),o=i*s.width,l=i*s.height,c=Ex({width:t,height:t}),u=e instanceof a?e:YU(e),h=Math.abs(o-l)/2,d=n&&o<l?h:0,p=n&&l<o?h:0;return u.width>0&&u.height>0&&Eo(c).drawImage(u,d,p,o,l),c}var Ax=class{constructor(e,t=!1){if(this._imageTensors=[],this._canvases=[],this._treatAsBatchInput=!1,this._inputDimensions=[],this._inputSize=0,!Array.isArray(e))throw new Error(`NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have ${e}`);this._treatAsBatchInput=t,this._batchSize=e.length,e.forEach((n,r)=>{if(zg(n)){this._imageTensors[r]=n,this._inputDimensions[r]=n.shape;return}if(ai(n)){let s=n.shape[0];if(s!==1)throw new Error(`NetInput - tf.Tensor4D with batchSize ${s} passed, but not supported in input array`);this._imageTensors[r]=n,this._inputDimensions[r]=n.shape.slice(1);return}let a=n instanceof Sr.getEnv().Canvas?n:YU(n);this._canvases[r]=a,this._inputDimensions[r]=[a.height,a.width,3]})}get imageTensors(){return this._imageTensors}get canvases(){return this._canvases}get isBatchInput(){return this.batchSize>1||this._treatAsBatchInput}get batchSize(){return this._batchSize}get inputDimensions(){return this._inputDimensions}get inputSize(){return this._inputSize}get reshapedInputDimensions(){return od(this.batchSize,0,1).map((e,t)=>this.getReshapedInputDimensions(t))}getInput(e){return this.canvases[e]||this.imageTensors[e]}getInputDimensions(e){return this._inputDimensions[e]}getInputHeight(e){return this._inputDimensions[e][0]}getInputWidth(e){return this._inputDimensions[e][1]}getReshapedInputDimensions(e){if(typeof this.inputSize!="number")throw new Error("getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet");let t=this.getInputWidth(e),n=this.getInputHeight(e);return FU({width:t,height:n},this.inputSize)}toBatchTensor(e,t=!0){return this._inputSize=e,j(()=>{let n=od(this.batchSize,0,1).map(r=>{let a=this.getInput(r);if(a instanceof ze){let s=ai(a)?a:yn(a);return s=PAe(s,t),(s.shape[1]!==e||s.shape[2]!==e)&&(s=ra.resizeBilinear(s,[e,e],!1,!1)),s.as3D(e,e,3)}if(a instanceof Sr.getEnv().Canvas)return Sg.fromPixels(qAe(a,e,t));throw new Error(`toBatchTensor - at batchIdx ${r}, expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have ${a}`)});return Jt(n.map(r=>le(r,"float32"))).as4D(this.batchSize,e,e,3)})}};async function ar(e){if(e instanceof Ax)return e;let t=Array.isArray(e)?e:[e];if(!t.length)throw new Error("toNetInput - empty array passed as input");let n=a=>Array.isArray(e)?` at input index ${a}:`:"",r=t.map($C);return r.forEach((a,s)=>{if(!dM(a)&&!zg(a)&&!ai(a))throw typeof t[s]=="string"?new Error(`toNetInput -${n(s)} string passed, but could not resolve HTMLElement for element id ${t[s]}`):new Error(`toNetInput -${n(s)} expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id`);if(ai(a)){let i=a.shape[0];if(i!==1)throw new Error(`toNetInput -${n(s)} tf.Tensor4D with batchSize ${i} passed, but not supported in input array`)}}),await Promise.all(r.map(a=>dM(a)&&GAe(a))),new Ax(r,Array.isArray(e))}async function RC(e,t){let{Canvas:n}=Sr.getEnv(),r=e;if(!(e instanceof n)){let s=await ar(e);if(s.batchSize>1)throw new Error("extractFaces - batchSize > 1 not supported");let i=s.getInput(0);r=i instanceof n?i:await HAe(i)}let a=Eo(r);return t.map(s=>s instanceof as?s.forSize(r.width,r.height).box.floor():s).map(s=>s.clipAtImageBorders(r.width,r.height)).map(({x:s,y:i,width:o,height:l})=>{let c=Ex({width:o,height:l});return o>0&&l>0&&Eo(c).putImageData(a.getImageData(s,i,o,l),0,0),c})}async function DC(e,t){if(!zg(e)&&!ai(e))throw new Error("extractFaceTensors - expected image tensor to be 3D or 4D");if(ai(e)&&e.shape[0]>1)throw new Error("extractFaceTensors - batchSize > 1 not supported");return j(()=>{let[n,r,a]=e.shape.slice(ai(e)?1:0);return t.map(s=>s instanceof as?s.forSize(r,n).box:s).map(s=>s.clipAtImageBorders(r,n)).filter(s=>s.width>0&&s.height>0).map(({x:s,y:i,width:o,height:l})=>Ip(e.as3D(n,r,a),[i,s,0],[l,o,a]))})}async function KAe(e,t){let{fetch:n}=Sr.getEnv(),r=await n(e,t);if(!(r.status<400))throw new Error(`failed to fetch: (${r.status}) ${r.statusText}, from url: ${r.url}`);return r}async function XAe(e){return(await KAe(e)).json()}function JU(e,t){let n=`${t}-weights_manifest.json`;if(!e)return{modelBaseUri:"",manifestUri:n};if(e==="/")return{modelBaseUri:"/",manifestUri:`/${n}`};let r=e.startsWith("http://")?"http://":e.startsWith("https://")?"https://":"";e=e.replace(r,"");let a=e.split("/").filter(o=>o),s=e.endsWith(".json")?a[a.length-1]:n,i=r+(e.endsWith(".json")?a.slice(0,a.length-1):a).join("/");return i=e.startsWith("/")?`/${i}`:i,{modelBaseUri:i,manifestUri:i==="/"?`/${s}`:`${i}/${s}`}}async function ZAe(e,t){let{manifestUri:n,modelBaseUri:r}=JU(e,t),a=await XAe(n);return Mn.loadWeights(a,r)}var Ko=class{constructor(e){this._params=void 0,this._paramMappings=[],this._name=e}get params(){return this._params}get paramMappings(){return this._paramMappings}get isLoaded(){return!!this.params}getParamFromPath(e){let{obj:t,objProp:n}=this.traversePropertyPath(e);return t[n]}reassignParamFromPath(e,t){let{obj:n,objProp:r}=this.traversePropertyPath(e);n[r].dispose(),n[r]=t}getParamList(){return this._paramMappings.map(({paramPath:e})=>({path:e,tensor:this.getParamFromPath(e)}))}getTrainableParams(){return this.getParamList().filter(e=>e.tensor instanceof Bl)}getFrozenParams(){return this.getParamList().filter(e=>!(e.tensor instanceof Bl))}variable(){this.getFrozenParams().forEach(({path:e,tensor:t})=>{this.reassignParamFromPath(e,t.variable())})}freeze(){this.getTrainableParams().forEach(({path:e,tensor:t})=>{let n=er(t.dataSync());t.dispose(),this.reassignParamFromPath(e,n)})}dispose(e=!0){this.getParamList().forEach(t=>{if(e&&t.tensor.isDisposed)throw new Error(`param tensor has already been disposed for path ${t.path}`);t.tensor.dispose()}),this._params=void 0}serializeParams(){return new Float32Array(this.getParamList().map(({tensor:e})=>Array.from(e.dataSync())).reduce((e,t)=>e.concat(t)))}async load(e){if(e instanceof Float32Array){this.extractWeights(e);return}await this.loadFromUri(e)}async loadFromUri(e){if(e&&typeof e!="string")throw new Error(`${this._name}.loadFromUri - expected model uri`);let t=await ZAe(e,this.getDefaultModelName());this.loadFromWeightMap(t)}async loadFromDisk(e){if(e&&typeof e!="string")throw new Error(`${this._name}.loadFromDisk - expected model file path`);let{readFile:t}=Sr.getEnv(),{manifestUri:n,modelBaseUri:r}=JU(e,this.getDefaultModelName()),a=l=>Promise.all(l.map(c=>t(c).then(u=>typeof u=="string"?Buffer.from(u):u.buffer))),s=Mn.weightsLoaderFactory(a),i=JSON.parse((await t(n)).toString()),o=await s(i,r);this.loadFromWeightMap(o)}loadFromWeightMap(e){let{paramMappings:t,params:n}=this.extractParamsFromWeightMap(e);this._paramMappings=t,this._params=n}extractWeights(e){let{paramMappings:t,params:n}=this.extractParams(e);this._paramMappings=t,this._params=n}traversePropertyPath(e){if(!this.params)throw new Error("traversePropertyPath - model has no loaded params");let t=e.split("/").reduce((a,s)=>{if(!a.nextObj.hasOwnProperty(s))throw new Error(`traversePropertyPath - object does not have property ${s}, for path ${e}`);return{obj:a.nextObj,objProp:s,nextObj:a.nextObj[s]}},{nextObj:this.params}),{obj:n,objProp:r}=t;if(!n||!r||!(n[r]instanceof ze))throw new Error(`traversePropertyPath - parameter is not a tensor, for path ${e}`);return{obj:n,objProp:r}}};function ia(e,t,n){return j(()=>{let r=Sp(e,t.depthwise_filter,t.pointwise_filter,n,"same");return r=te(r,t.bias),r})}function a1(e,t,n=!1){return j(()=>{let r=ht(n?te(nr(e,t.conv0.filters,[2,2],"same"),t.conv0.bias):ia(e,t.conv0,[2,2])),a=ia(r,t.conv1,[1,1]),s=ht(te(r,a)),i=ia(s,t.conv2,[1,1]);return ht(te(r,te(a,i)))})}function Yy(e,t,n=!1,r=!0){return j(()=>{let a=ht(n?te(nr(e,t.conv0.filters,r?[2,2]:[1,1],"same"),t.conv0.bias):ia(e,t.conv0,r?[2,2]:[1,1])),s=ia(a,t.conv1,[1,1]),i=ht(te(a,s)),o=ia(i,t.conv2,[1,1]),l=ht(te(a,te(s,o))),c=ia(l,t.conv3,[1,1]);return ht(te(a,te(s,te(o,c))))})}function Lf(e,t,n="same",r=!1){return j(()=>{let a=te(nr(e,t.filters,[1,1],n),t.bias);return r?ht(a):a})}function Xo(e,t){Object.keys(e).forEach(n=>{t.some(r=>r.originalPath===n)||e[n].dispose()})}function OC(e,t){return(n,r,a,s)=>{let i=ko(e(n*r*a*a),[a,a,n,r]),o=ut(e(r));return t.push({paramPath:`${s}/filters`},{paramPath:`${s}/bias`}),{filters:i,bias:o}}}function QU(e,t){return(n,r,a)=>{let s=Ns(e(n*r),[n,r]),i=ut(e(r));return t.push({paramPath:`${a}/weights`},{paramPath:`${a}/bias`}),{weights:s,bias:i}}}var eV=class{constructor(e,t,n){this.depthwise_filter=e,this.pointwise_filter=t,this.bias=n}};function zC(e,t){return(n,r,a)=>{let s=ko(e(9*n),[3,3,n,1]),i=ko(e(n*r),[1,1,n,r]),o=ut(e(r));return t.push({paramPath:`${a}/depthwise_filter`},{paramPath:`${a}/pointwise_filter`},{paramPath:`${a}/bias`}),new eV(s,i,o)}}function PC(e){return t=>{let n=e(`${t}/depthwise_filter`,4),r=e(`${t}/pointwise_filter`,4),a=e(`${t}/bias`,1);return new eV(n,r,a)}}function zc(e,t){return(n,r,a)=>{let s=e[n];if(!Pp(s,r))throw new Error(`expected weightMap[${n}] to be a Tensor${r}D, instead have ${s}`);return t.push({originalPath:n,paramPath:a||n}),s}}function Zo(e){let t=e;function n(a){let s=t.slice(0,a);return t=t.slice(a),s}function r(){return t}return{extractWeights:n,getRemainingWeights:r}}function tV(e,t){let n=OC(e,t),r=zC(e,t);function a(i,o,l,c=!1){let u=c?n(i,o,3,`${l}/conv0`):r(i,o,`${l}/conv0`),h=r(o,o,`${l}/conv1`),d=r(o,o,`${l}/conv2`);return{conv0:u,conv1:h,conv2:d}}function s(i,o,l,c=!1){let{conv0:u,conv1:h,conv2:d}=a(i,o,l,c),p=r(o,o,`${l}/conv3`);return{conv0:u,conv1:h,conv2:d,conv3:p}}return{extractDenseBlock3Params:a,extractDenseBlock4Params:s}}function YAe(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Zo(e),{extractDenseBlock4Params:a}=tV(n,t),s=a(3,32,"dense0",!0),i=a(32,64,"dense1"),o=a(64,128,"dense2"),l=a(128,256,"dense3");if(r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{dense0:s,dense1:i,dense2:o,dense3:l}}}function nV(e){return t=>{let n=e(`${t}/filters`,4),r=e(`${t}/bias`,1);return{filters:n,bias:r}}}function rV(e,t){let n=zc(e,t),r=nV(n),a=PC(n);function s(o,l=!1){let c=l?r(`${o}/conv0`):a(`${o}/conv0`),u=a(`${o}/conv1`),h=a(`${o}/conv2`);return{conv0:c,conv1:u,conv2:h}}function i(o,l=!1){let c=l?r(`${o}/conv0`):a(`${o}/conv0`),u=a(`${o}/conv1`),h=a(`${o}/conv2`),d=a(`${o}/conv3`);return{conv0:c,conv1:u,conv2:h,conv3:d}}return{extractDenseBlock3Params:s,extractDenseBlock4Params:i}}function JAe(e){let t=[],{extractDenseBlock4Params:n}=rV(e,t),r={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2"),dense3:n("dense3")};return Xo(e,t),{params:r,paramMappings:t}}var aV=class extends Ko{constructor(){super("FaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceFeatureExtractor - load model before inference");return j(()=>{let n=le(e.toBatchTensor(112,!0),"float32"),r=Pg(n,[122.782,117.001,104.298]).div(255),a=Yy(r,t.dense0,!0);return a=Yy(a,t.dense1),a=Yy(a,t.dense2),a=Yy(a,t.dense3),a=mi(a,[7,7],[2,2],"valid"),a})}async forward(e){return this.forwardInput(await ar(e))}getDefaultModelName(){return"face_feature_extractor_model"}extractParamsFromWeightMap(e){return JAe(e)}extractParams(e){return YAe(e)}};function x2(e,t){return j(()=>te(We(e,t.weights),t.bias))}function QAe(e,t,n){let r=[],{extractWeights:a,getRemainingWeights:s}=Zo(e),i=QU(a,r)(t,n,"fc");if(s().length!==0)throw new Error(`weights remaing after extract: ${s().length}`);return{paramMappings:r,params:{fc:i}}}function e$e(e){let t=[],n=zc(e,t);function r(s){let i=n(`${s}/weights`,2),o=n(`${s}/bias`,1);return{weights:i,bias:o}}let a={fc:r("fc")};return Xo(e,t),{params:a,paramMappings:t}}function sV(e){let t={},n={};return Object.keys(e).forEach(r=>{let a=r.startsWith("fc")?n:t;a[r]=e[r]}),{featureExtractorMap:t,classifierMap:n}}var iV=class extends Ko{constructor(e,t){super(e),this._faceFeatureExtractor=t}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return j(()=>{let n=e instanceof Ax?this.faceFeatureExtractor.forwardInput(e):e;return x2(n.as2D(n.shape[0],-1),t.fc)})}dispose(e=!0){this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return QAe(e,this.getClassifierChannelsIn(),this.getClassifierChannelsOut())}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=sV(e);return this.faceFeatureExtractor.loadFromWeightMap(t),e$e(n)}extractParams(e){let t=this.getClassifierChannelsIn(),n=this.getClassifierChannelsOut(),r=n*t+n,a=e.slice(0,e.length-r),s=e.slice(e.length-r);return this.faceFeatureExtractor.extractWeights(a),this.extractClassifierParams(s)}},pM=["neutral","happy","sad","angry","fearful","disgusted","surprised"],LC=class{constructor(e){if(this.neutral=0,this.happy=0,this.sad=0,this.angry=0,this.fearful=0,this.disgusted=0,this.surprised=0,e.length!==7)throw new Error(`FaceExpressions.constructor - expected probabilities.length to be 7, have: ${e.length}`);pM.forEach((t,n)=>{this[t]=e[n]})}asSortedArray(){return pM.map(e=>({expression:e,probability:this[e]})).sort((e,t)=>t.probability-e.probability)}},t$e=class extends iV{constructor(e=new aV){super("FaceExpressionNet",e)}forwardInput(e){return j(()=>Uo(this.runNet(e)))}async forward(e){return this.forwardInput(await ar(e))}async predictExpressions(e){let t=await ar(e),n=await this.forwardInput(t),r=await Promise.all(Vt(n).map(async s=>{let i=s.dataSync();return s.dispose(),i}));n.dispose();let a=r.map(s=>new LC(s));return t.isBatchInput?a:a[0]}getDefaultModelName(){return"face_expression_model"}getClassifierChannelsIn(){return 256}getClassifierChannelsOut(){return 7}};function n$e(e){return e.expressions instanceof LC}function oV(e,t){return{...e,expressions:t}}function r$e(e,t,n=.1,r){(Array.isArray(t)?t:[t]).forEach(a=>{let s=a instanceof LC?a:n$e(a)?a.expressions:void 0;if(!s)throw new Error("drawFaceExpressions - expected faceExpressions to be FaceExpressions | WithFaceExpressions<{}> or array thereof");let i=s.asSortedArray().filter(l=>l.probability>n),o=Tx(a)?a.detection.box.bottomLeft:r||new mt(0,0);new FC(i.map(l=>`${l.expression} (${CC(l.probability)})`),o).draw(e)})}function lV(e){return Tx(e)&&e.landmarks instanceof Cx&&e.unshiftedLandmarks instanceof Cx&&e.alignedRect instanceof as}function a$e(e){let t=l=>l*180/Math.PI,n=(l,c)=>Math.sqrt((l.x-c.x)**2+(l.y-c.y)**2),r={roll:void 0,pitch:void 0,yaw:void 0},a=(l,c,u)=>{let h=Math.floor(l.x-c.x),d=Math.floor(c.x-u.x);return h-d},s=(l,c)=>{let u=Math.hypot(c.x-l.x,c.y-l.y),h=c.y-l.y,d=Math.asin(h/u),p=t(d),f=Math.floor(90-p),m=c.x-l.x<0?-1:1;return f*m},i=(l,c,u)=>{let h=n(l,u),d=new mt((l.x+u.x)/2,(l.y+u.y)/2),p=n(c,d),f=Math.atan(p/h),m=Math.floor(t(f)),y=d.y-c.y<0?-1:1;return m*y};if(!e||!e.positions||e.positions.length!==68)return r;let o=e.positions;return r.roll=s(o[27],o[66]),r.pitch=i(o[14],o[30],o[2]),r.yaw=a(o[14],o[33],o[2]),r}function uV(e,t){let{box:n}=e.detection,r=t.shiftBy(n.x,n.y),a=r.align(),{imageDims:s}=e.detection,i=new as(e.detection.score,a.rescale(s.reverse()),s),o=a$e(t);return{...e,landmarks:r,unshiftedLandmarks:t,alignedRect:i,angle:o}}var cV=class{constructor(e={}){let{drawLines:t=!0,drawPoints:n=!0,lineWidth:r,lineColor:a,pointSize:s,pointColor:i}=e;this.drawLines=t,this.drawPoints=n,this.lineWidth=r||1,this.pointSize=s||2,this.lineColor=a||"rgba(0, 255, 255, 1)",this.pointColor=i||"rgba(255, 0, 255, 1)"}},hV=class{constructor(e,t={}){this.faceLandmarks=e,this.options=new cV(t)}draw(e){let t=Eo(e),{drawLines:n,drawPoints:r,lineWidth:a,lineColor:s,pointSize:i,pointColor:o}=this.options;if(n&&this.faceLandmarks instanceof LU&&(t.strokeStyle=s,t.lineWidth=a,zi(t,this.faceLandmarks.getJawOutline()),zi(t,this.faceLandmarks.getLeftEyeBrow()),zi(t,this.faceLandmarks.getRightEyeBrow()),zi(t,this.faceLandmarks.getNose()),zi(t,this.faceLandmarks.getLeftEye(),!0),zi(t,this.faceLandmarks.getRightEye(),!0),zi(t,this.faceLandmarks.getMouth(),!0)),r){t.strokeStyle=o,t.fillStyle=o;let l=c=>{t.beginPath(),t.arc(c.x,c.y,i,0,2*Math.PI),t.fill()};this.faceLandmarks.positions.forEach(l)}}};function s$e(e,t){(Array.isArray(t)?t:[t]).forEach(n=>{let r=n instanceof Cx?n:lV(n)?n.landmarks:void 0;if(!r)throw new Error("drawFaceLandmarks - expected faceExpressions to be FaceLandmarks | WithFaceLandmarks<WithFaceDetection<{}>> or array thereof");new hV(r).draw(e)})}function i$e(e,t){let n=OC(e,t),r=zC(e,t);function a(i,o,l){let c=r(i,o,`${l}/separable_conv0`),u=r(o,o,`${l}/separable_conv1`),h=n(i,o,1,`${l}/expansion_conv`);return{separable_conv0:c,separable_conv1:u,expansion_conv:h}}function s(i,o){let l=r(i,i,`${o}/separable_conv0`),c=r(i,i,`${o}/separable_conv1`),u=r(i,i,`${o}/separable_conv2`);return{separable_conv0:l,separable_conv1:c,separable_conv2:u}}return{extractConvParams:n,extractSeparableConvParams:r,extractReductionBlockParams:a,extractMainBlockParams:s}}function o$e(e,t){let n=[],{extractWeights:r,getRemainingWeights:a}=Zo(e),{extractConvParams:s,extractSeparableConvParams:i,extractReductionBlockParams:o,extractMainBlockParams:l}=i$e(r,n),c=s(3,32,3,"entry_flow/conv_in"),u=o(32,64,"entry_flow/reduction_block_0"),h=o(64,128,"entry_flow/reduction_block_1"),d={conv_in:c,reduction_block_0:u,reduction_block_1:h},p={};od(t,0,1).forEach(g=>{p[`main_block_${g}`]=l(128,`middle_flow/main_block_${g}`)});let f=o(128,256,"exit_flow/reduction_block"),m=i(256,512,"exit_flow/separable_conv"),y={reduction_block:f,separable_conv:m};if(a().length!==0)throw new Error(`weights remaing after extract: ${a().length}`);return{paramMappings:n,params:{entry_flow:d,middle_flow:p,exit_flow:y}}}function l$e(e,t){let n=zc(e,t),r=nV(n),a=PC(n);function s(o){let l=a(`${o}/separable_conv0`),c=a(`${o}/separable_conv1`),u=r(`${o}/expansion_conv`);return{separable_conv0:l,separable_conv1:c,expansion_conv:u}}function i(o){let l=a(`${o}/separable_conv0`),c=a(`${o}/separable_conv1`),u=a(`${o}/separable_conv2`);return{separable_conv0:l,separable_conv1:c,separable_conv2:u}}return{extractConvParams:r,extractSeparableConvParams:a,extractReductionBlockParams:s,extractMainBlockParams:i}}function u$e(e,t){let n=[],{extractConvParams:r,extractSeparableConvParams:a,extractReductionBlockParams:s,extractMainBlockParams:i}=l$e(e,n),o=r("entry_flow/conv_in"),l=s("entry_flow/reduction_block_0"),c=s("entry_flow/reduction_block_1"),u={conv_in:o,reduction_block_0:l,reduction_block_1:c},h={};od(t,0,1).forEach(m=>{h[`main_block_${m}`]=i(`middle_flow/main_block_${m}`)});let d=s("exit_flow/reduction_block"),p=a("exit_flow/separable_conv"),f={reduction_block:d,separable_conv:p};return Xo(e,n),{params:{entry_flow:u,middle_flow:h,exit_flow:f},paramMappings:n}}function dV(e,t,n){return te(nr(e,t.filters,n,"same"),t.bias)}function s1(e,t,n=!0){let r=n?ht(e):e;return r=ia(r,t.separable_conv0,[1,1]),r=ia(ht(r),t.separable_conv1,[1,1]),r=pn(r,[3,3],[2,2],"same"),r=te(r,dV(e,t.expansion_conv,[2,2])),r}function c$e(e,t){let n=ia(ht(e),t.separable_conv0,[1,1]);return n=ia(ht(n),t.separable_conv1,[1,1]),n=ia(ht(n),t.separable_conv2,[1,1]),n=te(n,e),n}var h$e=class extends Ko{constructor(e){super("TinyXception"),this._numMainBlocks=e}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyXception - load model before inference");return j(()=>{let n=le(e.toBatchTensor(112,!0),"float32"),r=Pg(n,[122.782,117.001,104.298]).div(255),a=ht(dV(r,t.entry_flow.conv_in,[2,2]));return a=s1(a,t.entry_flow.reduction_block_0,!1),a=s1(a,t.entry_flow.reduction_block_1),od(this._numMainBlocks,0,1).forEach(s=>{a=c$e(a,t.middle_flow[`main_block_${s}`])}),a=s1(a,t.exit_flow.reduction_block),a=ht(ia(a,t.exit_flow.separable_conv,[1,1])),a})}async forward(e){return this.forwardInput(await ar(e))}getDefaultModelName(){return"tiny_xception_model"}extractParamsFromWeightMap(e){return u$e(e,this._numMainBlocks)}extractParams(e){return o$e(e,this._numMainBlocks)}};function d$e(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Zo(e),a=QU(n,t),s=a(512,1,"fc/age"),i=a(512,2,"fc/gender");if(r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{fc:{age:s,gender:i}}}}function p$e(e){let t=[],n=zc(e,t);function r(s){let i=n(`${s}/weights`,2),o=n(`${s}/bias`,1);return{weights:i,bias:o}}let a={fc:{age:r("fc/age"),gender:r("fc/gender")}};return Xo(e,t),{params:a,paramMappings:t}}var f$e=(e=>(e.FEMALE="female",e.MALE="male",e))(f$e||{}),m$e=class extends Ko{constructor(e=new h$e(2)){super("AgeGenderNet"),this._faceFeatureExtractor=e}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return j(()=>{let n=e instanceof Ax?this.faceFeatureExtractor.forwardInput(e):e,r=mi(n,[7,7],[2,2],"valid").as2D(n.shape[0],-1),a=x2(r,t.fc.age).as1D(),s=x2(r,t.fc.gender);return{age:a,gender:s}})}forwardInput(e){return j(()=>{let{age:t,gender:n}=this.runNet(e);return{age:t,gender:Uo(n)}})}async forward(e){return this.forwardInput(await ar(e))}async predictAgeAndGender(e){let t=await ar(e),n=await this.forwardInput(t),r=Vt(n.age),a=Vt(n.gender),s=r.map((o,l)=>({ageTensor:o,genderTensor:a[l]})),i=await Promise.all(s.map(async({ageTensor:o,genderTensor:l})=>{let c=o.dataSync()[0],u=l.dataSync()[0],h=u>.5,d=h?"male":"female",p=h?u:1-u;return o.dispose(),l.dispose(),{age:c,gender:d,genderProbability:p}}));return n.age.dispose(),n.gender.dispose(),t.isBatchInput?i:i[0]}getDefaultModelName(){return"age_gender_model"}dispose(e=!0){this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return d$e(e)}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=sV(e);return this.faceFeatureExtractor.loadFromWeightMap(t),p$e(n)}extractParams(e){let t=e.slice(0,e.length-1539),n=e.slice(e.length-1539);return this.faceFeatureExtractor.extractWeights(t),this.extractClassifierParams(n)}},pV=class extends iV{postProcess(e,t,n){let r=n.map(({width:s,height:i})=>{let o=t/Math.max(i,s);return{width:s*o,height:i*o}}),a=r.length;return j(()=>{let s=(c,u)=>Jt([Wr([68],c,"float32"),Wr([68],u,"float32")],1).as2D(1,136).as1D(),i=(c,u)=>{let{width:h,height:d}=r[c];return u(h,d)?Math.abs(h-d)/2:0},o=c=>i(c,(u,h)=>u<h),l=c=>i(c,(u,h)=>h<u);return e.mul(Wr([a,136],t,"float32")).sub(Jt(Array.from(Array(a),(c,u)=>s(o(u),l(u))))).div(Jt(Array.from(Array(a),(c,u)=>s(r[u].width,r[u].height))))})}forwardInput(e){return j(()=>{let t=this.runNet(e);return this.postProcess(t,e.inputSize,e.inputDimensions.map(([n,r])=>({height:n,width:r})))})}async forward(e){return this.forwardInput(await ar(e))}async detectLandmarks(e){let t=await ar(e),n=j(()=>Vt(this.forwardInput(t))),r=await Promise.all(n.map(async(a,s)=>{let i=Array.from(a.dataSync()),o=i.filter((c,u)=>m2(u)),l=i.filter((c,u)=>!m2(u));return new LU(Array(68).fill(0).map((c,u)=>new mt(o[u],l[u])),{height:t.getInputHeight(s),width:t.getInputWidth(s)})}));return n.forEach(a=>a.dispose()),t.isBatchInput?r:r[0]}getClassifierChannelsOut(){return 136}},g$e=class extends pV{constructor(e=new aV){super("FaceLandmark68Net",e)}getDefaultModelName(){return"face_landmark_68_model"}getClassifierChannelsIn(){return 256}};function y$e(e){let t=[],{extractDenseBlock3Params:n}=rV(e,t),r={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2")};return Xo(e,t),{params:r,paramMappings:t}}function x$e(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Zo(e),{extractDenseBlock3Params:a}=tV(n,t),s=a(3,32,"dense0",!0),i=a(32,64,"dense1"),o=a(64,128,"dense2");if(r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{dense0:s,dense1:i,dense2:o}}}var b$e=class extends Ko{constructor(){super("TinyFaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyFaceFeatureExtractor - load model before inference");return j(()=>{let n=le(e.toBatchTensor(112,!0),"float32"),r=Pg(n,[122.782,117.001,104.298]).div(255),a=a1(r,t.dense0,!0);return a=a1(a,t.dense1),a=a1(a,t.dense2),a=mi(a,[14,14],[2,2],"valid"),a})}async forward(e){return this.forwardInput(await ar(e))}getDefaultModelName(){return"face_feature_extractor_tiny_model"}extractParamsFromWeightMap(e){return y$e(e)}extractParams(e){return x$e(e)}},v$e=class extends pV{constructor(e=new b$e){super("FaceLandmark68TinyNet",e)}getDefaultModelName(){return"face_landmark_68_tiny_model"}getClassifierChannelsIn(){return 128}};function w$e(e,t){return te(U(e,t.weights),t.biases)}function BC(e,t,n,r,a="same"){let{filters:s,bias:i}=t.conv,o=nr(e,s,n,a);return o=te(o,i),o=w$e(o,t.scale),r?ht(o):o}function k$e(e,t){return BC(e,t,[1,1],!0)}function fV(e,t){return BC(e,t,[1,1],!1)}function mV(e,t){return BC(e,t,[2,2],!0,"valid")}function S$e(e,t){function n(o,l,c){let u=e(o),h=u.length/(l*c*c);if(MU(h))throw new Error(`depth has to be an integer: ${h}, weights.length: ${u.length}, numFilters: ${l}, filterSize: ${c}`);return j(()=>Ue(ko(u,[l,h,c,c]),[2,3,1,0]))}function r(o,l,c,u){let h=n(o,l,c),d=ut(e(l));return t.push({paramPath:`${u}/filters`},{paramPath:`${u}/bias`}),{filters:h,bias:d}}function a(o,l){let c=ut(e(o)),u=ut(e(o));return t.push({paramPath:`${l}/weights`},{paramPath:`${l}/biases`}),{weights:c,biases:u}}function s(o,l,c,u){let h=r(o,l,c,`${u}/conv`),d=a(l,`${u}/scale`);return{conv:h,scale:d}}function i(o,l,c,u,h=!1){let d=s((h?.5:1)*o,l,c,`${u}/conv1`),p=s(o,l,c,`${u}/conv2`);return{conv1:d,conv2:p}}return{extractConvLayerParams:s,extractResidualLayerParams:i}}function I$e(e){let{extractWeights:t,getRemainingWeights:n}=Zo(e),r=[],{extractConvLayerParams:a,extractResidualLayerParams:s}=S$e(t,r),i=a(4704,32,7,"conv32_down"),o=s(9216,32,3,"conv32_1"),l=s(9216,32,3,"conv32_2"),c=s(9216,32,3,"conv32_3"),u=s(36864,64,3,"conv64_down",!0),h=s(36864,64,3,"conv64_1"),d=s(36864,64,3,"conv64_2"),p=s(36864,64,3,"conv64_3"),f=s(147456,128,3,"conv128_down",!0),m=s(147456,128,3,"conv128_1"),y=s(147456,128,3,"conv128_2"),g=s(589824,256,3,"conv256_down",!0),x=s(589824,256,3,"conv256_1"),b=s(589824,256,3,"conv256_2"),v=s(589824,256,3,"conv256_down_out"),w=j(()=>Ue(Ns(t(256*128),[128,256]),[1,0]));if(r.push({paramPath:"fc"}),n().length!==0)throw new Error(`weights remaing after extract: ${n().length}`);return{params:{conv32_down:i,conv32_1:o,conv32_2:l,conv32_3:c,conv64_down:u,conv64_1:h,conv64_2:d,conv64_3:p,conv128_down:f,conv128_1:m,conv128_2:y,conv256_down:g,conv256_1:x,conv256_2:b,conv256_down_out:v,fc:w},paramMappings:r}}function N$e(e,t){let n=zc(e,t);function r(i){let o=n(`${i}/scale/weights`,1),l=n(`${i}/scale/biases`,1);return{weights:o,biases:l}}function a(i){let o=n(`${i}/conv/filters`,4),l=n(`${i}/conv/bias`,1),c=r(i);return{conv:{filters:o,bias:l},scale:c}}function s(i){return{conv1:a(`${i}/conv1`),conv2:a(`${i}/conv2`)}}return{extractConvLayerParams:a,extractResidualLayerParams:s}}function _$e(e){let t=[],{extractConvLayerParams:n,extractResidualLayerParams:r}=N$e(e,t),a=n("conv32_down"),s=r("conv32_1"),i=r("conv32_2"),o=r("conv32_3"),l=r("conv64_down"),c=r("conv64_1"),u=r("conv64_2"),h=r("conv64_3"),d=r("conv128_down"),p=r("conv128_1"),f=r("conv128_2"),m=r("conv256_down"),y=r("conv256_1"),g=r("conv256_2"),x=r("conv256_down_out"),{fc:b}=e;if(t.push({originalPath:"fc",paramPath:"fc"}),!$U(b))throw new Error(`expected weightMap[fc] to be a Tensor2D, instead have ${b}`);let v={conv32_down:a,conv32_1:s,conv32_2:i,conv32_3:o,conv64_down:l,conv64_1:c,conv64_2:u,conv64_3:h,conv128_down:d,conv128_1:p,conv128_2:f,conv256_down:m,conv256_1:y,conv256_2:g,conv256_down_out:x,fc:b};return Xo(e,t),{params:v,paramMappings:t}}function us(e,t){let n=k$e(e,t.conv1);return n=fV(n,t.conv2),n=te(n,e),n=ht(n),n}function Jy(e,t){let n=mV(e,t.conv1);n=fV(n,t.conv2);let r=mi(e,2,2,"valid"),a=Ot(r.shape),s=r.shape[3]!==n.shape[3];if(r.shape[1]!==n.shape[1]||r.shape[2]!==n.shape[2]){let i=[...n.shape];i[1]=1;let o=Ot(i);n=xt([n,o],1);let l=[...n.shape];l[2]=1;let c=Ot(l);n=xt([n,c],2)}return r=s?xt([r,a],3):r,n=te(r,n),n=ht(n),n}var C$e=class extends Ko{constructor(){super("FaceRecognitionNet")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceRecognitionNet - load model before inference");return j(()=>{let n=le(e.toBatchTensor(150,!0),"float32"),r=Pg(n,[122.782,117.001,104.298]).div(255),a=mV(r,t.conv32_down);a=pn(a,3,2,"valid"),a=us(a,t.conv32_1),a=us(a,t.conv32_2),a=us(a,t.conv32_3),a=Jy(a,t.conv64_down),a=us(a,t.conv64_1),a=us(a,t.conv64_2),a=us(a,t.conv64_3),a=Jy(a,t.conv128_down),a=us(a,t.conv128_1),a=us(a,t.conv128_2),a=Jy(a,t.conv256_down),a=us(a,t.conv256_1),a=us(a,t.conv256_2),a=Jy(a,t.conv256_down_out);let s=a.mean([1,2]);return We(s,t.fc)})}async forward(e){return this.forwardInput(await ar(e))}async computeFaceDescriptor(e){var t;if((t=e==null?void 0:e.shape)!=null&&t.some(s=>s<=0))return new Float32Array(128);let n=await ar(e),r=j(()=>Vt(this.forwardInput(n))),a=await Promise.all(r.map(s=>s.data()));return r.forEach(s=>s.dispose()),n.isBatchInput?a:a[0]}getDefaultModelName(){return"face_recognition_model"}extractParamsFromWeightMap(e){return _$e(e)}extractParams(e){return I$e(e)}};function gV(e,t){return{...e,descriptor:t}}function yV(e,t){return{...e,age:t}}function xV(e,t,n){return{...e,gender:t,genderProbability:n}}function T$e(e,t){function n(l,c){let u=ko(e(9*l),[3,3,l,1]),h=ut(e(l)),d=ut(e(l)),p=ut(e(l)),f=ut(e(l));return t.push({paramPath:`${c}/filters`},{paramPath:`${c}/batch_norm_scale`},{paramPath:`${c}/batch_norm_offset`},{paramPath:`${c}/batch_norm_mean`},{paramPath:`${c}/batch_norm_variance`}),{filters:u,batch_norm_scale:h,batch_norm_offset:d,batch_norm_mean:p,batch_norm_variance:f}}function r(l,c,u,h,d){let p=ko(e(l*c*u*u),[u,u,l,c]),f=ut(e(c));return t.push({paramPath:`${h}/filters`},{paramPath:`${h}/${d?"batch_norm_offset":"bias"}`}),{filters:p,bias:f}}function a(l,c,u,h){let{filters:d,bias:p}=r(l,c,u,h,!0);return{filters:d,batch_norm_offset:p}}function s(l,c,u){let h=n(l,`${u}/depthwise_conv`),d=a(l,c,1,`${u}/pointwise_conv`);return{depthwise_conv:h,pointwise_conv:d}}function i(){let l=a(3,32,3,"mobilenetv1/conv_0"),c=s(32,64,"mobilenetv1/conv_1"),u=s(64,128,"mobilenetv1/conv_2"),h=s(128,128,"mobilenetv1/conv_3"),d=s(128,256,"mobilenetv1/conv_4"),p=s(256,256,"mobilenetv1/conv_5"),f=s(256,512,"mobilenetv1/conv_6"),m=s(512,512,"mobilenetv1/conv_7"),y=s(512,512,"mobilenetv1/conv_8"),g=s(512,512,"mobilenetv1/conv_9"),x=s(512,512,"mobilenetv1/conv_10"),b=s(512,512,"mobilenetv1/conv_11"),v=s(512,1024,"mobilenetv1/conv_12"),w=s(1024,1024,"mobilenetv1/conv_13");return{conv_0:l,conv_1:c,conv_2:u,conv_3:h,conv_4:d,conv_5:p,conv_6:f,conv_7:m,conv_8:y,conv_9:g,conv_10:x,conv_11:b,conv_12:v,conv_13:w}}function o(){let l=a(1024,256,1,"prediction_layer/conv_0"),c=a(256,512,3,"prediction_layer/conv_1"),u=a(512,128,1,"prediction_layer/conv_2"),h=a(128,256,3,"prediction_layer/conv_3"),d=a(256,128,1,"prediction_layer/conv_4"),p=a(128,256,3,"prediction_layer/conv_5"),f=a(256,64,1,"prediction_layer/conv_6"),m=a(64,128,3,"prediction_layer/conv_7"),y=r(512,12,1,"prediction_layer/box_predictor_0/box_encoding_predictor"),g=r(512,9,1,"prediction_layer/box_predictor_0/class_predictor"),x=r(1024,24,1,"prediction_layer/box_predictor_1/box_encoding_predictor"),b=r(1024,18,1,"prediction_layer/box_predictor_1/class_predictor"),v=r(512,24,1,"prediction_layer/box_predictor_2/box_encoding_predictor"),w=r(512,18,1,"prediction_layer/box_predictor_2/class_predictor"),I=r(256,24,1,"prediction_layer/box_predictor_3/box_encoding_predictor"),_=r(256,18,1,"prediction_layer/box_predictor_3/class_predictor"),T=r(256,24,1,"prediction_layer/box_predictor_4/box_encoding_predictor"),A=r(256,18,1,"prediction_layer/box_predictor_4/class_predictor"),M=r(128,24,1,"prediction_layer/box_predictor_5/box_encoding_predictor"),F=r(128,18,1,"prediction_layer/box_predictor_5/class_predictor");return{conv_0:l,conv_1:c,conv_2:u,conv_3:h,conv_4:d,conv_5:p,conv_6:f,conv_7:m,box_predictor_0:{box_encoding_predictor:y,class_predictor:g},box_predictor_1:{box_encoding_predictor:x,class_predictor:b},box_predictor_2:{box_encoding_predictor:v,class_predictor:w},box_predictor_3:{box_encoding_predictor:I,class_predictor:_},box_predictor_4:{box_encoding_predictor:T,class_predictor:A},box_predictor_5:{box_encoding_predictor:M,class_predictor:F}}}return{extractMobilenetV1Params:i,extractPredictionLayerParams:o}}function E$e(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Zo(e),{extractMobilenetV1Params:a,extractPredictionLayerParams:s}=T$e(n,t),i=a(),o=s(),l={extra_dim:Bb(n(5118*4),[1,5118,4])};if(t.push({paramPath:"output_layer/extra_dim"}),r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{params:{mobilenetv1:i,prediction_layer:o,output_layer:l},paramMappings:t}}function A$e(e,t){let n=zc(e,t);function r(c,u,h){let d=n(`${c}/Conv2d_${u}_pointwise/weights`,4,`${h}/filters`),p=n(`${c}/Conv2d_${u}_pointwise/convolution_bn_offset`,1,`${h}/batch_norm_offset`);return{filters:d,batch_norm_offset:p}}function a(c){let u=`mobilenetv1/conv_${c}`,h=`MobilenetV1/Conv2d_${c}_depthwise`,d=`${u}/depthwise_conv`,p=`${u}/pointwise_conv`,f=n(`${h}/depthwise_weights`,4,`${d}/filters`),m=n(`${h}/BatchNorm/gamma`,1,`${d}/batch_norm_scale`),y=n(`${h}/BatchNorm/beta`,1,`${d}/batch_norm_offset`),g=n(`${h}/BatchNorm/moving_mean`,1,`${d}/batch_norm_mean`),x=n(`${h}/BatchNorm/moving_variance`,1,`${d}/batch_norm_variance`);return{depthwise_conv:{filters:f,batch_norm_scale:m,batch_norm_offset:y,batch_norm_mean:g,batch_norm_variance:x},pointwise_conv:r("MobilenetV1",c,p)}}function s(){return{conv_0:r("MobilenetV1",0,"mobilenetv1/conv_0"),conv_1:a(1),conv_2:a(2),conv_3:a(3),conv_4:a(4),conv_5:a(5),conv_6:a(6),conv_7:a(7),conv_8:a(8),conv_9:a(9),conv_10:a(10),conv_11:a(11),conv_12:a(12),conv_13:a(13)}}function i(c,u){let h=n(`${c}/weights`,4,`${u}/filters`),d=n(`${c}/biases`,1,`${u}/bias`);return{filters:h,bias:d}}function o(c){let u=i(`Prediction/BoxPredictor_${c}/BoxEncodingPredictor`,`prediction_layer/box_predictor_${c}/box_encoding_predictor`),h=i(`Prediction/BoxPredictor_${c}/ClassPredictor`,`prediction_layer/box_predictor_${c}/class_predictor`);return{box_encoding_predictor:u,class_predictor:h}}function l(){return{conv_0:r("Prediction",0,"prediction_layer/conv_0"),conv_1:r("Prediction",1,"prediction_layer/conv_1"),conv_2:r("Prediction",2,"prediction_layer/conv_2"),conv_3:r("Prediction",3,"prediction_layer/conv_3"),conv_4:r("Prediction",4,"prediction_layer/conv_4"),conv_5:r("Prediction",5,"prediction_layer/conv_5"),conv_6:r("Prediction",6,"prediction_layer/conv_6"),conv_7:r("Prediction",7,"prediction_layer/conv_7"),box_predictor_0:o(0),box_predictor_1:o(1),box_predictor_2:o(2),box_predictor_3:o(3),box_predictor_4:o(4),box_predictor_5:o(5)}}return{extractMobilenetV1Params:s,extractPredictionLayerParams:l}}function $$e(e){let t=[],{extractMobilenetV1Params:n,extractPredictionLayerParams:r}=A$e(e,t),a=e["Output/extra_dim"];if(t.push({originalPath:"Output/extra_dim",paramPath:"output_layer/extra_dim"}),!zg(a))throw new Error(`expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have ${a}`);let s={mobilenetv1:n(),prediction_layer:r(),output_layer:{extra_dim:a}};return Xo(e,t),{params:s,paramMappings:t}}function ps(e,t,n){return j(()=>{let r=nr(e,t.filters,n,"same");return r=te(r,t.batch_norm_offset),Ln(r,0,6)})}var M$e=.0010000000474974513;function F$e(e,t,n){return j(()=>{let r=Cc(e,t.filters,n,"same");return r=_c(r,t.batch_norm_mean,t.batch_norm_variance,t.batch_norm_offset,t.batch_norm_scale,M$e),Ln(r,0,6)})}function R$e(e){return[2,4,6,12].some(t=>t===e)?[2,2]:[1,1]}function D$e(e,t){return j(()=>{let n,r=ps(e,t.conv_0,[2,2]);if([t.conv_1,t.conv_2,t.conv_3,t.conv_4,t.conv_5,t.conv_6,t.conv_7,t.conv_8,t.conv_9,t.conv_10,t.conv_11,t.conv_12,t.conv_13].forEach((a,s)=>{let i=s+1,o=R$e(i);r=F$e(r,a.depthwise_conv,o),r=ps(r,a.pointwise_conv,[1,1]),i===11&&(n=r)}),n===null)throw new Error("mobileNetV1 - output of conv layer 11 is null");return{out:r,conv11:n}})}function O$e(e,t,n){let r=e.arraySync(),a=Math.min(r[t][0],r[t][2]),s=Math.min(r[t][1],r[t][3]),i=Math.max(r[t][0],r[t][2]),o=Math.max(r[t][1],r[t][3]),l=Math.min(r[n][0],r[n][2]),c=Math.min(r[n][1],r[n][3]),u=Math.max(r[n][0],r[n][2]),h=Math.max(r[n][1],r[n][3]),d=(i-a)*(o-s),p=(u-l)*(h-c);if(d<=0||p<=0)return 0;let f=Math.max(a,l),m=Math.max(s,c),y=Math.min(i,u),g=Math.min(o,h),x=Math.max(y-f,0)*Math.max(g-m,0);return x/(d+p-x)}function z$e(e,t,n,r,a){let s=e.shape[0],i=Math.min(n,s),o=t.map((u,h)=>({score:u,boxIndex:h})).filter(u=>u.score>a).sort((u,h)=>h.score-u.score),l=u=>u<=r?1:0,c=[];return o.forEach(u=>{if(c.length>=i)return;let h=u.score;for(let d=c.length-1;d>=0;--d){let p=O$e(e,u.boxIndex,c[d]);if(p!==0&&(u.score*=l(p),u.score<=a))break}h===u.score&&c.push(u.boxIndex)}),c}function P$e(e){let t=Vt(Ue(e,[1,0])),n=[me(t[2],t[0]),me(t[3],t[1])],r=[te(t[0],xe(n[0],2)),te(t[1],xe(n[1],2))];return{sizes:n,centers:r}}function L$e(e,t){let{sizes:n,centers:r}=P$e(e),a=Vt(Ue(t,[1,0])),s=xe(U(Bn(xe(a[2],5)),n[0]),2),i=te(U(xe(a[0],10),n[0]),r[0]),o=xe(U(Bn(xe(a[3],5)),n[1]),2),l=te(U(xe(a[1],10),n[1]),r[1]);return Ue(Jt([me(i,s),me(l,o),te(i,s),te(l,o)]),[1,0])}function B$e(e,t,n){return j(()=>{let r=e.shape[0],a=L$e(V(Or(n.extra_dim,[r,1,1]),[-1,4]),V(e,[-1,4]));a=V(a,[r,a.shape[0]/r,4]);let s=Ca(Ke(t,[0,0,1],[-1,-1,-1])),i=Ke(s,[0,0,0],[-1,-1,1]);i=V(i,[r,i.shape[1]]);let o=Vt(a),l=Vt(i);return{boxes:o,scores:l}})}function ah(e,t){return j(()=>{let n=e.shape[0],r=V(Lf(e,t.box_encoding_predictor),[n,-1,1,4]),a=V(Lf(e,t.class_predictor),[n,-1,3]);return{boxPredictionEncoding:r,classPrediction:a}})}function W$e(e,t,n){return j(()=>{let r=ps(e,n.conv_0,[1,1]),a=ps(r,n.conv_1,[2,2]),s=ps(a,n.conv_2,[1,1]),i=ps(s,n.conv_3,[2,2]),o=ps(i,n.conv_4,[1,1]),l=ps(o,n.conv_5,[2,2]),c=ps(l,n.conv_6,[1,1]),u=ps(c,n.conv_7,[2,2]),h=ah(t,n.box_predictor_0),d=ah(e,n.box_predictor_1),p=ah(a,n.box_predictor_2),f=ah(i,n.box_predictor_3),m=ah(l,n.box_predictor_4),y=ah(u,n.box_predictor_5),g=xt([h.boxPredictionEncoding,d.boxPredictionEncoding,p.boxPredictionEncoding,f.boxPredictionEncoding,m.boxPredictionEncoding,y.boxPredictionEncoding],1),x=xt([h.classPrediction,d.classPrediction,p.classPrediction,f.classPrediction,m.classPrediction,y.classPrediction],1);return{boxPredictions:g,classPredictions:x}})}var _v=class{constructor({minConfidence:e,maxResults:t}={}){if(this._name="SsdMobilenetv1Options",this._minConfidence=e||.5,this._maxResults=t||100,typeof this._minConfidence!="number"||this._minConfidence<=0||this._minConfidence>=1)throw new Error(`${this._name} - expected minConfidence to be a number between 0 and 1`);if(typeof this._maxResults!="number")throw new Error(`${this._name} - expected maxResults to be a number`)}get minConfidence(){return this._minConfidence}get maxResults(){return this._maxResults}},U$e=class extends Ko{constructor(){super("SsdMobilenetv1")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("SsdMobilenetv1 - load model before inference");return j(()=>{let n=le(e.toBatchTensor(512,!1),"float32"),r=me(xe(n,127.5),1),a=D$e(r,t.mobilenetv1),{boxPredictions:s,classPredictions:i}=W$e(a.out,a.conv11,t.prediction_layer);return B$e(s,i,t.output_layer)})}async forward(e){return this.forwardInput(await ar(e))}async locateFaces(e,t={}){let{maxResults:n,minConfidence:r}=new _v(t),a=await ar(e),{boxes:s,scores:i}=this.forwardInput(a),o=s[0],l=i[0];for(let g=1;g<s.length;g++)s[g].dispose(),i[g].dispose();let c=Array.from(l.dataSync()),u=z$e(o,c,n,.5,r),h=a.getReshapedInputDimensions(0),d=a.inputSize,p=d/h.width,f=d/h.height,m=o.arraySync(),y=u.map(g=>{let[x,b]=[Math.max(0,m[g][0]),Math.min(1,m[g][2])].map(I=>I*f),[v,w]=[Math.max(0,m[g][1]),Math.min(1,m[g][3])].map(I=>I*p);return new as(c[g],new PU(v,x,w-v,b-x),{height:a.getInputHeight(0),width:a.getInputWidth(0)})});return o.dispose(),l.dispose(),y}getDefaultModelName(){return"ssd_mobilenetv1_model"}extractParamsFromWeightMap(e){return $$e(e)}extractParams(e){return E$e(e)}},V$e=.4,j$e=[new mt(.738768,.874946),new mt(2.42204,2.65704),new mt(4.30971,7.04493),new mt(10.246,4.59428),new mt(12.6868,11.8741)],G$e=[new mt(1.603231,2.094468),new mt(6.041143,7.080126),new mt(2.882459,3.518061),new mt(4.266906,5.178857),new mt(9.041765,10.66308)],H$e=[117.001,114.697,97.404],q$e="tiny_yolov2_model",K$e="tiny_yolov2_separable_conv_model",Qy=e=>typeof e=="number";function X$e(e){if(!e)throw new Error(`invalid config: ${e}`);if(typeof e.withSeparableConvs!="boolean")throw new Error(`config.withSeparableConvs has to be a boolean, have: ${e.withSeparableConvs}`);if(!Qy(e.iouThreshold)||e.iouThreshold<0||e.iouThreshold>1)throw new Error(`config.iouThreshold has to be a number between [0, 1], have: ${e.iouThreshold}`);if(!Array.isArray(e.classes)||!e.classes.length||!e.classes.every(t=>typeof t=="string"))throw new Error(`config.classes has to be an array class names: string[], have: ${JSON.stringify(e.classes)}`);if(!Array.isArray(e.anchors)||!e.anchors.length||!e.anchors.map(t=>t||{}).every(t=>Qy(t.x)&&Qy(t.y)))throw new Error(`config.anchors has to be an array of { x: number, y: number }, have: ${JSON.stringify(e.anchors)}`);if(e.meanRgb&&(!Array.isArray(e.meanRgb)||e.meanRgb.length!==3||!e.meanRgb.every(Qy)))throw new Error(`config.meanRgb has to be an array of shape [number, number, number], have: ${JSON.stringify(e.meanRgb)}`)}function WC(e){return j(()=>{let t=U(e,_e(.10000000149011612));return te(ht(me(e,t)),t)})}function Mi(e,t){return j(()=>{let n=ss(e,[[0,0],[1,1],[1,1],[0,0]]);return n=nr(n,t.conv.filters,[1,1],"valid"),n=me(n,t.bn.sub),n=U(n,t.bn.truediv),n=te(n,t.conv.bias),WC(n)})}function Fi(e,t){return j(()=>{let n=ss(e,[[0,0],[1,1],[1,1],[0,0]]);return n=Sp(n,t.depthwise_filter,t.pointwise_filter,[1,1],"valid"),n=te(n,t.bias),WC(n)})}function Z$e(e,t){let n=OC(e,t);function r(i,o){let l=ut(e(i)),c=ut(e(i));return t.push({paramPath:`${o}/sub`},{paramPath:`${o}/truediv`}),{sub:l,truediv:c}}function a(i,o,l){let c=n(i,o,3,`${l}/conv`),u=r(o,`${l}/bn`);return{conv:c,bn:u}}let s=zC(e,t);return{extractConvParams:n,extractConvWithBatchNormParams:a,extractSeparableConvParams:s}}function Y$e(e,t,n,r){let{extractWeights:a,getRemainingWeights:s}=Zo(e),i=[],{extractConvParams:o,extractConvWithBatchNormParams:l,extractSeparableConvParams:c}=Z$e(a,i),u;if(t.withSeparableConvs){let[h,d,p,f,m,y,g,x,b]=r,v=t.isFirstLayerConv2d?o(h,d,3,"conv0"):c(h,d,"conv0"),w=c(d,p,"conv1"),I=c(p,f,"conv2"),_=c(f,m,"conv3"),T=c(m,y,"conv4"),A=c(y,g,"conv5"),M=x?c(g,x,"conv6"):void 0,F=b?c(x,b,"conv7"):void 0,C=o(b||x||g,5*n,1,"conv8");u={conv0:v,conv1:w,conv2:I,conv3:_,conv4:T,conv5:A,conv6:M,conv7:F,conv8:C}}else{let[h,d,p,f,m,y,g,x,b]=r,v=l(h,d,"conv0"),w=l(d,p,"conv1"),I=l(p,f,"conv2"),_=l(f,m,"conv3"),T=l(m,y,"conv4"),A=l(y,g,"conv5"),M=l(g,x,"conv6"),F=l(x,b,"conv7"),C=o(b,5*n,1,"conv8");u={conv0:v,conv1:w,conv2:I,conv3:_,conv4:T,conv5:A,conv6:M,conv7:F,conv8:C}}if(s().length!==0)throw new Error(`weights remaing after extract: ${s().length}`);return{params:u,paramMappings:i}}function J$e(e,t){let n=zc(e,t);function r(o){let l=n(`${o}/sub`,1),c=n(`${o}/truediv`,1);return{sub:l,truediv:c}}function a(o){let l=n(`${o}/filters`,4),c=n(`${o}/bias`,1);return{filters:l,bias:c}}function s(o){let l=a(`${o}/conv`),c=r(`${o}/bn`);return{conv:l,bn:c}}let i=PC(n);return{extractConvParams:a,extractConvWithBatchNormParams:s,extractSeparableConvParams:i}}function Q$e(e,t){let n=[],{extractConvParams:r,extractConvWithBatchNormParams:a,extractSeparableConvParams:s}=J$e(e,n),i;if(t.withSeparableConvs){let o=t.filterSizes&&t.filterSizes.length||9;i={conv0:t.isFirstLayerConv2d?r("conv0"):s("conv0"),conv1:s("conv1"),conv2:s("conv2"),conv3:s("conv3"),conv4:s("conv4"),conv5:s("conv5"),conv6:o>7?s("conv6"):void 0,conv7:o>8?s("conv7"):void 0,conv8:r("conv8")}}else i={conv0:a("conv0"),conv1:a("conv1"),conv2:a("conv2"),conv3:a("conv3"),conv4:a("conv4"),conv5:a("conv5"),conv6:a("conv6"),conv7:a("conv7"),conv8:r("conv8")};return Xo(e,n),{params:i,paramMappings:n}}var UC=class{constructor({inputSize:e,scoreThreshold:t}={}){if(this._name="TinyYolov2Options",this._inputSize=e||416,this._scoreThreshold=t||.5,typeof this._inputSize!="number"||this._inputSize%32!==0)throw new Error(`${this._name} - expected inputSize to be a number divisible by 32`);if(typeof this._scoreThreshold!="number"||this._scoreThreshold<=0||this._scoreThreshold>=1)throw new Error(`${this._name} - expected scoreThreshold to be a number between 0 and 1`)}get inputSize(){return this._inputSize}get scoreThreshold(){return this._scoreThreshold}},bV=class vV extends Ko{constructor(t){super("TinyYolov2"),X$e(t),this._config=t}get config(){return this._config}get withClassScores(){return this.config.withClassScores||this.config.classes.length>1}get boxEncodingSize(){return 5+(this.withClassScores?this.config.classes.length:0)}runTinyYolov2(t,n){let r=Mi(t,n.conv0);return r=pn(r,[2,2],[2,2],"same"),r=Mi(r,n.conv1),r=pn(r,[2,2],[2,2],"same"),r=Mi(r,n.conv2),r=pn(r,[2,2],[2,2],"same"),r=Mi(r,n.conv3),r=pn(r,[2,2],[2,2],"same"),r=Mi(r,n.conv4),r=pn(r,[2,2],[2,2],"same"),r=Mi(r,n.conv5),r=pn(r,[2,2],[1,1],"same"),r=Mi(r,n.conv6),r=Mi(r,n.conv7),Lf(r,n.conv8,"valid",!1)}runMobilenet(t,n){let r=this.config.isFirstLayerConv2d?WC(Lf(t,n.conv0,"valid",!1)):Fi(t,n.conv0);return r=pn(r,[2,2],[2,2],"same"),r=Fi(r,n.conv1),r=pn(r,[2,2],[2,2],"same"),r=Fi(r,n.conv2),r=pn(r,[2,2],[2,2],"same"),r=Fi(r,n.conv3),r=pn(r,[2,2],[2,2],"same"),r=Fi(r,n.conv4),r=pn(r,[2,2],[2,2],"same"),r=Fi(r,n.conv5),r=pn(r,[2,2],[1,1],"same"),r=n.conv6?Fi(r,n.conv6):r,r=n.conv7?Fi(r,n.conv7):r,Lf(r,n.conv8,"valid",!1)}forwardInput(t,n){let{params:r}=this;if(!r)throw new Error("TinyYolov2 - load model before inference");return j(()=>{let a=le(t.toBatchTensor(n,!1),"float32");return a=this.config.meanRgb?Pg(a,this.config.meanRgb):a,a=a.div(255),this.config.withSeparableConvs?this.runMobilenet(a,r):this.runTinyYolov2(a,r)})}async forward(t,n){return this.forwardInput(await ar(t),n)}async detect(t,n={}){let{inputSize:r,scoreThreshold:a}=new UC(n),s=await ar(t),i=await this.forwardInput(s,r),o=j(()=>Vt(i)[0].expandDims()),l={width:s.getInputWidth(0),height:s.getInputHeight(0)},c=await this.extractBoxes(o,s.getReshapedInputDimensions(0),a);i.dispose(),o.dispose();let u=c.map(f=>f.box),h=c.map(f=>f.score),d=c.map(f=>f.classScore),p=c.map(f=>this.config.classes[f.label]);return zAe(u.map(f=>f.rescale(r)),h,this.config.iouThreshold,!0).map(f=>new DU(h[f],d[f],p[f],u[f],l))}getDefaultModelName(){return""}extractParamsFromWeightMap(t){return Q$e(t,this.config)}extractParams(t){let n=this.config.filterSizes||vV.DEFAULT_FILTER_SIZES,r=n?n.length:void 0;if(r!==7&&r!==8&&r!==9)throw new Error(`TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found ${r} filterSizes in config`);return Y$e(t,this.config,this.boxEncodingSize,n)}async extractBoxes(t,n,r){let{width:a,height:s}=n,i=Math.max(a,s),o=i/a,l=i/s,c=t.shape[1],u=this.config.anchors.length,[h,d,p]=j(()=>{let g=t.reshape([c,c,u,this.boxEncodingSize]),x=g.slice([0,0,0,0],[c,c,u,4]),b=g.slice([0,0,0,4],[c,c,u,1]),v=this.withClassScores?Uo(g.slice([0,0,0,5],[c,c,u,this.config.classes.length]),3):_e(0);return[x,b,v]}),f=[],m=await d.array(),y=await h.array();for(let g=0;g<c;g++)for(let x=0;x<c;x++)for(let b=0;b<u;b++){let v=r1(m[g][x][b][0]);if(!r||v>r){let w=(x+r1(y[g][x][b][0]))/c*o,I=(g+r1(y[g][x][b][1]))/c*l,_=Math.exp(y[g][x][b][2])*this.config.anchors[b].x/c*o,T=Math.exp(y[g][x][b][3])*this.config.anchors[b].y/c*l,A=w-_/2,M=I-T/2,F={row:g,col:x,anchor:b},{classScore:C,label:D}=this.withClassScores?await this.extractPredictedClass(p,F):{classScore:1,label:0};f.push({box:new RU(A,M,A+_,M+T),score:v,classScore:v*C,label:D,...F})}}return h.dispose(),d.dispose(),p.dispose(),f}async extractPredictedClass(t,n){let{row:r,col:a,anchor:s}=n,i=await t.array();return Array(this.config.classes.length).fill(0).map((o,l)=>i[r][a][s][l]).map((o,l)=>({classScore:o,label:l})).reduce((o,l)=>o.classScore>l.classScore?o:l)}};bV.DEFAULT_FILTER_SIZES=[3,16,32,64,128,256,512,1024,1024];var wV=bV,eMe=class extends wV{constructor(e=!0){let t={withSeparableConvs:e,iouThreshold:V$e,classes:["face"],...e?{anchors:G$e,meanRgb:H$e}:{anchors:j$e,withClassScores:!0}};super(t)}get withSeparableConvs(){return this.config.withSeparableConvs}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map(n=>new as(n.score,n.relativeBox,{width:n.imageWidth,height:n.imageHeight}))}getDefaultModelName(){return this.withSeparableConvs?K$e:q$e}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}},S0=class extends UC{constructor(){super(...arguments),this._name="TinyFaceDetectorOptions"}},Lg=class{async then(e){return e(await this.run())}async run(){throw new Error("ComposableTask - run is not implemented")}};async function Cv(e,t,n,r,a=({alignedRect:s})=>s){let s=e.map(l=>lV(l)?a(l):l.detection),i=r||(t instanceof ze?await DC(t,s):await RC(t,s)),o=await n(i);return i.forEach(l=>l instanceof ze&&l.dispose()),o}async function VC(e,t,n,r,a){return Cv([e],t,async s=>n(s[0]),r,a)}var tMe=.4,nMe=[new mt(1.603231,2.094468),new mt(6.041143,7.080126),new mt(2.882459,3.518061),new mt(4.266906,5.178857),new mt(9.041765,10.66308)],rMe=[117.001,114.697,97.404],aMe=class extends wV{constructor(){let e={withSeparableConvs:!0,iouThreshold:tMe,classes:["face"],anchors:nMe,meanRgb:rMe,isFirstLayerConv2d:!0,filterSizes:[3,16,32,64,128,256,512]};super(e)}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map(n=>new as(n.score,n.relativeBox,{width:n.imageWidth,height:n.imageHeight}))}getDefaultModelName(){return"tiny_face_detector_model"}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}},Ur={ssdMobilenetv1:new U$e,tinyFaceDetector:new aMe,tinyYolov2:new eMe,faceLandmark68Net:new g$e,faceLandmark68TinyNet:new v$e,faceRecognitionNet:new C$e,faceExpressionNet:new t$e,ageGenderNet:new m$e},kV=class extends Lg{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},jC=class extends kV{async run(){let e=await this.parentTask,t=await Cv(e,this.input,async n=>Promise.all(n.map(r=>Ur.faceExpressionNet.predictExpressions(r))),this.extractedFaces);return e.map((n,r)=>oV(n,t[r]))}withAgeAndGender(){return new KC(this,this.input)}},GC=class extends kV{async run(){let e=await this.parentTask;if(!e)return;let t=await VC(e,this.input,n=>Ur.faceExpressionNet.predictExpressions(n),this.extractedFaces);return oV(e,t)}withAgeAndGender(){return new XC(this,this.input)}},HC=class extends jC{withAgeAndGender(){return new ZC(this,this.input)}withFaceDescriptors(){return new JC(this,this.input)}},qC=class extends GC{withAgeAndGender(){return new YC(this,this.input)}withFaceDescriptor(){return new QC(this,this.input)}},SV=class extends Lg{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},KC=class extends SV{async run(){let e=await this.parentTask,t=await Cv(e,this.input,async n=>Promise.all(n.map(r=>Ur.ageGenderNet.predictAgeAndGender(r))),this.extractedFaces);return e.map((n,r)=>{let{age:a,gender:s,genderProbability:i}=t[r];return yV(xV(n,s,i),a)})}withFaceExpressions(){return new jC(this,this.input)}},XC=class extends SV{async run(){let e=await this.parentTask;if(!e)return;let{age:t,gender:n,genderProbability:r}=await VC(e,this.input,a=>Ur.ageGenderNet.predictAgeAndGender(a),this.extractedFaces);return yV(xV(e,n,r),t)}withFaceExpressions(){return new GC(this,this.input)}},ZC=class extends KC{withFaceExpressions(){return new HC(this,this.input)}withFaceDescriptors(){return new JC(this,this.input)}},YC=class extends XC{withFaceExpressions(){return new qC(this,this.input)}withFaceDescriptor(){return new QC(this,this.input)}},IV=class extends Lg{constructor(e,t){super(),this.parentTask=e,this.input=t}},JC=class extends IV{async run(){let e=await this.parentTask;return(await Cv(e,this.input,t=>Promise.all(t.map(n=>Ur.faceRecognitionNet.computeFaceDescriptor(n))),null,t=>t.landmarks.align(null,{useDlibAlignment:!0}))).map((t,n)=>gV(e[n],t))}withFaceExpressions(){return new HC(this,this.input)}withAgeAndGender(){return new ZC(this,this.input)}},QC=class extends IV{async run(){let e=await this.parentTask;if(!e)return;let t=await VC(e,this.input,n=>Ur.faceRecognitionNet.computeFaceDescriptor(n),null,n=>n.landmarks.align(null,{useDlibAlignment:!0}));return gV(e,t)}withFaceExpressions(){return new qC(this,this.input)}withAgeAndGender(){return new YC(this,this.input)}},NV=class extends Lg{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.useTinyLandmarkNet=n}get landmarkNet(){return this.useTinyLandmarkNet?Ur.faceLandmark68TinyNet:Ur.faceLandmark68Net}},sMe=class extends NV{async run(){let e=await this.parentTask,t=e.map(a=>a.detection),n=this.input instanceof ze?await DC(this.input,t):await RC(this.input,t),r=await Promise.all(n.map(a=>this.landmarkNet.detectLandmarks(a)));return n.forEach(a=>a instanceof ze&&a.dispose()),e.filter((a,s)=>r[s]).map((a,s)=>uV(a,r[s]))}withFaceExpressions(){return new HC(this,this.input)}withAgeAndGender(){return new ZC(this,this.input)}withFaceDescriptors(){return new JC(this,this.input)}},iMe=class extends NV{async run(){let e=await this.parentTask;if(!e)return;let{detection:t}=e,n=this.input instanceof ze?await DC(this.input,[t]):await RC(this.input,[t]),r=await this.landmarkNet.detectLandmarks(n[0]);return n.forEach(a=>a instanceof ze&&a.dispose()),uV(e,r)}withFaceExpressions(){return new qC(this,this.input)}withAgeAndGender(){return new YC(this,this.input)}withFaceDescriptor(){return new QC(this,this.input)}},_V=class extends Lg{constructor(e,t=new _v){super(),this.input=e,this.options=t}},oMe=class extends _V{async run(){let{input:e,options:t}=this,n;if(t instanceof S0)n=Ur.tinyFaceDetector.locateFaces(e,t);else if(t instanceof _v)n=Ur.ssdMobilenetv1.locateFaces(e,t);else if(t instanceof UC)n=Ur.tinyYolov2.locateFaces(e,t);else throw new Error("detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | TinyYolov2Options");return n}runAndExtendWithFaceDetections(){return new Promise((e,t)=>{this.run().then(n=>e(n.map(r=>BU({},r)))).catch(n=>t(n))})}withFaceLandmarks(e=!1){return new sMe(this.runAndExtendWithFaceDetections(),this.input,e)}withFaceExpressions(){return new jC(this.runAndExtendWithFaceDetections(),this.input)}withAgeAndGender(){return new KC(this.runAndExtendWithFaceDetections(),this.input)}},lMe=class extends _V{async run(){let e=await new oMe(this.input,this.options),t=e[0];return e.forEach(n=>{n.score>t.score&&(t=n)}),t}runAndExtendWithFaceDetection(){return new Promise(async e=>{let t=await this.run();e(t?BU({},t):void 0)})}withFaceLandmarks(e=!1){return new iMe(this.runAndExtendWithFaceDetection(),this.input,e)}withFaceExpressions(){return new GC(this.runAndExtendWithFaceDetection(),this.input)}withAgeAndGender(){return new XC(this.runAndExtendWithFaceDetection(),this.input)}};function i1(e,t=new _v){return new lMe(e,t)}async function uMe(e,t){console.log("Creating GLB from texture...");const n=new fD({map:e,side:_S,roughness:.5,metalness:.1});e.flipY=!1,e.colorSpace=fr,e.needsUpdate=!0;const r=t,a=1;let s;const i=window.lastFaceLandmarks;if(i&&Array.isArray(i)){console.log("Creating 3D face mesh from",i.length,"landmarks");const g=[],x=[],b=[];for(const v of i){const w=Math.sqrt(Math.pow(v.x/e.image.width-.5,2)+Math.pow(v.y/e.image.height-.5,2)),I=.2*Math.exp(-w*5)+v.z;g.push((v.x/e.image.width-.5)*r,-(v.y/e.image.height-.5)*a,I),b.push(v.x/e.image.width,1-v.y/e.image.height)}for(let v=0;v<16;v++)x.push(v,v+1,36);x.push(36,37,41),x.push(37,38,41),x.push(38,39,41),x.push(39,40,41),x.push(42,43,47),x.push(43,44,47),x.push(44,45,47),x.push(45,46,47),x.push(27,28,29),x.push(28,29,30),x.push(29,30,31),x.push(30,31,32),x.push(31,32,33),x.push(31,33,34),x.push(33,34,35);for(let v=48;v<59;v++)x.push(v,v+1,66);x.push(59,48,66);for(let v=60;v<67;v++)x.push(v,v+1,66);x.push(67,60,66),s=new Rm,s.setAttribute("position",new Ah(g,3)),s.setAttribute("uv",new Ah(b,2)),s.setIndex(x)}else console.warn("No face landmarks available, falling back to simple plane geometry"),s=new Yx(r,a);s.computeVertexNormals();const o=new dD(s,n);o.name="CapturedFace",o.rotation.y=Math.PI,o.castShadow=!0,o.receiveShadow=!0;const l=s.getAttribute("position"),c=s.getAttribute("normal"),u=l.array,h=c.array,d=new Map;for(let g=0;g<l.count;g++){const x=[Math.round(u[g*3]*1e3)/1e3,Math.round(u[g*3+1]*1e3)/1e3,Math.round(u[g*3+2]*1e3)/1e3].join(","),b=d.get(x)||[];b.push(g),d.set(x,b)}d.forEach(g=>{if(g.length>1){const x=new ie;g.forEach(b=>{x.add(new ie(h[b*3],h[b*3+1],h[b*3+2]))}),x.divideScalar(g.length).normalize(),g.forEach(b=>{h[b*3]=x.x,h[b*3+1]=x.y,h[b*3+2]=x.z})}}),c.needsUpdate=!0;const p=new J0,f=new xD(16777215,.3);p.add(f);const m=new yD(16777215,1);m.position.set(0,0,1),m.target.position.set(0,0,0),p.add(m.target),p.add(m),p.add(o);const y=new z8(45,r/a,.1,1e3);return y.position.z=2,p.add(y),new Promise((g,x)=>{new im().parse(p,v=>{const w=new Blob([v],{type:"model/gltf-binary"}),I=URL.createObjectURL(w);g(I)},v=>{console.error("Error exporting GLB:",v),x(v)},{binary:!0,includeCustomExtensions:!0,onlyVisible:!0})})}const yl=class yl{constructor(){Ra(this,"videoElement",null);Ra(this,"analysisCanvas");Ra(this,"analysisContext");Ra(this,"debugCanvas",null);Ra(this,"debugContext",null);Ra(this,"isAnalyzing",!1);Ra(this,"lastAnalysis",null);Ra(this,"onFrameAnalyzed",null);Ra(this,"modelsLoaded",!1);this.analysisCanvas=document.createElement("canvas");const t=this.analysisCanvas.getContext("2d");if(!t)throw new Error("Failed to get 2D context");this.analysisContext=t}static getInstance(){return yl.instance||(yl.instance=new yl),yl.instance}async loadFaceDetectionModels(){if(this.modelsLoaded){console.log("Models already loaded, skipping");return}console.log("Starting face detection model loading...");try{try{if(console.log("Attempting to reset TensorFlow engine..."),Ri&&typeof Ri.engine=="function"){const i=Ri.engine();i&&typeof i.reset=="function"&&(i.reset(),console.log("TensorFlow engine reset successful"))}Ri&&"setBackend"in Ri&&typeof Ri.setBackend=="function"&&(await Ri.setBackend("webgl"),console.log("Set TensorFlow backend to WebGL"))}catch(i){console.warn("Could not reset TensorFlow engine:",i)}const t=["https://cdn.jsdelivr.net/npm/@vladmandic/face-api@1.7.15/model","https://unpkg.com/@vladmandic/face-api@1.7.15/model","https://vladmandic.github.io/face-api/model","/models","/TexWeb/models"],n=i=>{console.log(i),window&&typeof window.updateModelLoadingStatus=="function"&&window.updateModelLoadingStatus(i)},r=async(i,o,l,c=2e4)=>new Promise((u,h)=>{const d=setTimeout(()=>{console.error(`Timeout: Loading ${o} from ${l} timed out after ${c/1e3} seconds`),h(new Error(`Loading ${o} from ${l} timed out after ${c/1e3} seconds`))},c);try{console.log(`Starting to load ${o} from ${l}...`),n(`Loading ${o} from ${l}...`),i.loadFromUri(l).then(()=>{console.log(`SUCCESS: ${o} loaded successfully from ${l}`),n(`${o} loaded successfully from ${l}`),clearTimeout(d),u()}).catch(p=>{console.error(`ERROR: Failed to load ${o} from ${l}:`,p),clearTimeout(d),h(p)})}catch(p){console.error(`EXCEPTION: Error loading ${o} from ${l}:`,p),clearTimeout(d),h(p)}});let a=null;for(const i of t){console.log(`Attempting to load models from: ${i}`);try{await r(Ur.tinyFaceDetector,"TinyFaceDetector",i),await r(Ur.faceLandmark68Net,"FaceLandmark68",i),await r(Ur.faceRecognitionNet,"FaceRecognition",i),console.log(`All face detection models loaded successfully from ${i}`),this.modelsLoaded=!0;return}catch(o){console.warn(`Failed to load models from ${i}:`,o),a=o}}console.error("Failed to load models from all paths:",a);const s=a instanceof Error?a.message:String(a);throw new Error(`Failed to load face detection models from all paths: ${s||"Unknown error"}`)}catch(t){throw console.error("Error during model loading:",t),new Error("Failed to load face detection models. Please ensure model files are correctly installed.")}}async initializeCamera(t){this.videoElement=t,await this.loadFaceDetectionModels();try{const n=await navigator.mediaDevices.getUserMedia({video:{facingMode:"user",width:{ideal:1280},height:{ideal:720}}});this.videoElement.srcObject=n,await new Promise(r=>{this.videoElement&&(this.videoElement.onloadedmetadata=()=>{this.videoElement&&(this.videoElement.play(),this.analysisCanvas.width=this.videoElement.videoWidth,this.analysisCanvas.height=this.videoElement.videoHeight,this.debugCanvas&&(this.debugCanvas.width=this.videoElement.videoWidth,this.debugCanvas.height=this.videoElement.videoHeight)),r()})})}catch(n){throw console.error("Error initializing camera:",n),n}}setDebugCanvas(t){if(this.debugCanvas=t,t){const n=t.getContext("2d");if(!n)throw new Error("Failed to get debug canvas 2D context");this.debugContext=n,this.videoElement&&(t.width=this.videoElement.videoWidth,t.height=this.videoElement.videoHeight)}else this.debugContext=null}startAnalysis(t){this.isAnalyzing||(this.isAnalyzing=!0,this.onFrameAnalyzed=t||null,requestAnimationFrame(()=>this.analyze()))}stopAnalysis(){this.isAnalyzing=!1,this.onFrameAnalyzed=null}validateFacePosition(t){if(!t||!this.analysisCanvas)return!1;const{box:n}=t,r=this.analysisCanvas.width,a=this.analysisCanvas.height,s={min:r*.25,max:r*.75},i={min:a*.25,max:a*.75},o={x:n.x+n.width/2,y:n.y+n.height/2},l=a*.2,c=n.height>=l,u=o.x>=s.min&&o.x<=s.max&&o.y>=i.min&&o.y<=i.max;return c||console.log(`Face too small: ${n.height.toFixed(0)}px, minimum required: ${l.toFixed(0)}px`),u||console.log(`Face not centered: position (${o.x.toFixed(0)}, ${o.y.toFixed(0)}), 
        valid X range: ${s.min.toFixed(0)}-${s.max.toFixed(0)}, 
        valid Y range: ${i.min.toFixed(0)}-${i.max.toFixed(0)}`),c&&u}async detectFace(t){try{console.log("Starting face detection process...");try{console.log("Attempting face detection with TinyFaceDetector...");const r=new S0({inputSize:416,scoreThreshold:.5});console.log("Detector options:",JSON.stringify(r));const a=await i1(t,r).withFaceLandmarks().withFaceDescriptor();if(console.log("Detection result:",a?"Found face":"No face found"),a){console.log("Face landmarks found:",a.landmarks.positions.length);const s=a==null?void 0:a.detection;if(s){console.log("Face detected with score:",s.score,"at position:",JSON.stringify(s.box));const i=this.validateFacePosition(s);return console.log("Face position valid:",i),i?s:(console.log("Face detected but position is invalid"),null)}}}catch(r){console.warn("Face landmark detection failed:",r)}console.log("Falling back to basic face detection...");const n=await i1(t,new S0({inputSize:320,scoreThreshold:.4}));return n?(console.log("Face detected with basic detection"),this.validateFacePosition(n)?n:(console.log("Face detected but position is invalid"),null)):(console.log("No face detected"),null)}catch(n){return console.error("Error in face detection pipeline:",n),null}}async analyze(){if(!(!this.isAnalyzing||!this.videoElement)){try{this.analysisContext.drawImage(this.videoElement,0,0,this.analysisCanvas.width,this.analysisCanvas.height);const t=await this.detectFace(this.analysisCanvas),n=!!t,r=this.analysisContext.getImageData(0,0,this.analysisCanvas.width,this.analysisCanvas.height),a=await this.getFaceLandmarks(this.analysisCanvas);a&&(window.lastFaceLandmarks=a),this.lastAnalysis={imageData:r,aspectRatio:this.analysisCanvas.width/this.analysisCanvas.height,hasValidPose:n,faceDetection:t??void 0,faceLandmarks:a??void 0},this.drawDebugView(),this.onFrameAnalyzed&&this.onFrameAnalyzed(n)}catch(t){console.error("Error in analysis:",t)}requestAnimationFrame(()=>this.analyze())}}drawDebugView(){if(!(!this.debugContext||!this.lastAnalysis))if(this.debugContext.clearRect(0,0,this.debugCanvas.width,this.debugCanvas.height),this.debugContext.drawImage(this.analysisCanvas,0,0),this.lastAnalysis.faceDetection){const{box:t}=this.lastAnalysis.faceDetection;this.debugContext.strokeStyle="#00ff00",this.debugContext.lineWidth=2,this.debugContext.strokeRect(t.x,t.y,t.width,t.height),this.debugContext.fillStyle="#00ff00",this.debugContext.font="20px Arial",this.debugContext.fillText("Face Detected",10,30)}else this.debugContext.fillStyle="#ff0000",this.debugContext.font="20px Arial",this.debugContext.fillText("No Face Detected",10,30)}async captureAndCreateGLB(){if(!this.lastAnalysis||!this.lastAnalysis.hasValidPose)return console.warn("No valid pose detected for capture"),null;try{console.log("Starting GLB creation...");const t=await new Promise(a=>{this.analysisCanvas.toBlob(s=>a(s),"image/jpeg",.95)});console.log("Created image blob:",t.size,"bytes");const n=URL.createObjectURL(t);let r=null;try{r=await this.createTextureFromUrl(n),console.log("Texture created successfully");const a=await uMe(r,this.lastAnalysis.aspectRatio);return console.log("GLB processing complete"),a}finally{URL.revokeObjectURL(n),r&&r.dispose()}}catch(t){throw console.error("Error creating GLB from camera:",t),t}}async createTextureFromUrl(t){return new Promise((n,r)=>{const a=new mD;a.setCrossOrigin("anonymous");const s=setTimeout(()=>{r(new Error("Texture loading timed out after 10 seconds"))},1e4);a.load(t,i=>{clearTimeout(s),i.colorSpace=fr,"encoding"in i&&(i.encoding=void 0),i.needsUpdate=!0,i.generateMipmaps=!0,i.minFilter=CS,i.magFilter=Xx,i.wrapS=kl,i.wrapT=kl,console.log("Texture loaded successfully with dimensions:",i.image.width,"x",i.image.height),n(i)},i=>{console.log(`Texture loading: ${Math.round(i.loaded/i.total*100)}%`)},i=>{clearTimeout(s),console.error("Error loading texture:",i),r(i)})})}async getFaceLandmarks(t){try{const n=await i1(t,new S0).withFaceLandmarks();return n?n.landmarks.positions.map(s=>{const i=this.estimateDepthFromLandmark(s,n.landmarks);return{x:s.x,y:s.y,z:i}}):null}catch(n){return console.error("Error getting face landmarks:",n),null}}estimateDepthFromLandmark(t,n){const a=n.getNose()[3],s=t.x-a.x,i=t.y-a.y,o=Math.sqrt(s*s+i*i),l=.2,c=100;return l*Math.exp(-(o*o)/(2*c*c))}cleanup(){var t;this.stopAnalysis(),(t=this.videoElement)!=null&&t.srcObject&&this.videoElement.srcObject.getTracks().forEach(r=>r.stop()),this.videoElement=null,this.debugCanvas=null,this.debugContext=null,this.lastAnalysis=null}};Ra(yl,"instance");let b2=yl;function cMe({isOpen:e,onClose:t,onCapture:n}){const r=ee.useRef(null),a=ee.useRef(null),s=ee.useRef(null),[i,o]=ee.useState(!1),[l,c]=ee.useState(null),[u,h]=ee.useState(!1),[d,p]=ee.useState(!1),[f,m]=ee.useState("Loading face detection models..."),[y,g]=ee.useState("models");ee.useEffect(()=>{if(e&&r.current&&a.current)return(async()=>{p(!0),c(null),g("models");try{console.log("Initializing camera..."),s.current=b2.getInstance(),window.updateModelLoadingStatus=v=>{console.log("Model loading status:",v),m(v)},s.current.setDebugCanvas(a.current);try{g("models"),m("Loading face detection models..."),await s.current.initializeCamera(r.current),console.log("Camera initialized, starting analysis..."),g("camera"),m("Camera initialized, starting face detection..."),s.current.startAnalysis(v=>{o(v),v&&y!=="ready"&&g("ready")}),console.log("Analysis started")}catch(v){console.error("Failed to initialize face models:",v),c(`Failed to load face detection models: ${(v==null?void 0:v.message)||"Unknown error"}. 
              Try reloading the page or using a different browser.`),g("error"),setTimeout(t,5e3);return}}catch(v){console.error("Failed to initialize camera:",v),c((v==null?void 0:v.message)||"Failed to access camera. Please ensure camera permissions are granted."),g("error"),setTimeout(t,5e3)}finally{p(!1)}})(),()=>{window.updateModelLoadingStatus=void 0,s.current&&(s.current.cleanup(),s.current=null)}},[e,t]);const x=async()=>{if(!(!s.current||!i)){c(null),h(!0);try{console.log("Starting capture process...");const b=await s.current.captureAndCreateGLB();if(b)console.log("Capture successful, GLB URL length:",b.length),n(b),t();else throw new Error("Failed to create GLB - no URL returned")}catch(b){console.error("Capture failed:",b),c("Failed to process image. Please try again.")}finally{h(!1)}}};return e?N.jsxs("div",{className:"fixed inset-0 z-50 flex items-center justify-center bg-black/70 backdrop-blur-sm",children:["      ",N.jsxs("div",{className:"relative w-full max-w-2xl bg-white rounded-lg shadow-xl overflow-hidden",children:[N.jsxs("div",{className:"relative aspect-video",children:[(u||d)&&N.jsx("div",{className:"absolute inset-0 bg-black/50 flex items-center justify-center z-10",children:N.jsxs("div",{className:"text-white text-center p-4 max-w-md",children:[N.jsx("div",{className:"animate-spin rounded-full h-12 w-12 border-4 border-white border-t-transparent mx-auto mb-3"}),u?N.jsx("p",{className:"text-lg font-medium",children:"Processing capture..."}):N.jsxs(N.Fragment,{children:[N.jsx("p",{className:"text-lg font-medium mb-2",children:y==="models"?"Loading face detection models...":y==="camera"?"Initializing camera...":"Starting face detection..."}),N.jsx("p",{className:"text-sm opacity-80",children:f}),y==="models"&&N.jsx("p",{className:"text-xs mt-4 opacity-70",children:"This may take a moment on first load. If it takes too long, try refreshing the page."})]})]})}),N.jsx("video",{ref:r,autoPlay:!0,playsInline:!0,muted:!0,className:"hidden"}),N.jsx("canvas",{ref:a,className:"absolute inset-0 w-full h-full object-cover"}),!d&&!u&&N.jsx("div",{className:"absolute inset-0 flex items-center justify-center pointer-events-none",children:N.jsx("div",{className:`w-1/2 h-1/2 border-2 rounded-lg ${i?"border-green-500":"border-yellow-500"} transition-colors`,children:N.jsx("div",{className:"absolute inset-0 flex items-center justify-center",children:N.jsx("p",{className:"text-lg font-medium text-white text-center bg-black/50 px-4 py-2 rounded-lg",children:i?"Perfect! Click capture.":"Position your face in the frame"})})})}),N.jsx("button",{onClick:t,className:"absolute top-4 right-4 p-2 bg-white/90 rounded-full hover:bg-white transition-colors",children:N.jsx(Vh,{className:"w-6 h-6"})})]}),"        ",l&&N.jsx("div",{className:"p-4 bg-red-50 border-t border-red-100",children:N.jsxs("div",{className:"flex items-start",children:[N.jsx(uH,{className:"w-5 h-5 text-red-500 mt-0.5 mr-2 flex-shrink-0"}),N.jsxs("div",{children:[N.jsx("h4",{className:"text-red-700 font-medium mb-1",children:"Error"}),N.jsx("p",{className:"text-red-600 text-sm whitespace-pre-line",children:l}),l.includes("models")&&N.jsxs("div",{className:"mt-2 text-xs text-red-500",children:[N.jsx("p",{children:"Possible solutions:"}),N.jsxs("ul",{className:"list-disc pl-4 mt-1 space-y-1",children:[N.jsx("li",{children:"Try refreshing the page"}),N.jsx("li",{children:"Try using a different browser (Chrome or Edge recommended)"}),N.jsx("li",{children:"Check your internet connection"}),N.jsx("li",{children:"Temporarily disable any content blockers"})]})]}),l.includes("camera")&&N.jsxs("div",{className:"mt-2 text-xs text-red-500",children:[N.jsx("p",{children:"Possible solutions:"}),N.jsxs("ul",{className:"list-disc pl-4 mt-1 space-y-1",children:[N.jsx("li",{children:"Make sure your camera is connected and working"}),N.jsx("li",{children:"Allow camera permissions in your browser"}),N.jsx("li",{children:"Close other apps that might be using your camera"})]})]})]})]})}),N.jsx("div",{className:"p-4 bg-gray-50 border-t border-gray-100",children:N.jsxs("button",{onClick:x,disabled:!i||u||d,className:`
              w-full py-3 px-4 rounded-lg flex items-center justify-center space-x-2
              ${i&&!u&&!d?"bg-rose-600 hover:bg-rose-700 text-white":"bg-gray-100 text-gray-400 cursor-not-allowed"}
              transition-colors
            `,children:[N.jsx(XR,{className:"w-5 h-5"}),N.jsx("span",{children:d?"Initializing...":u?"Processing...":"Capture"})]})})]})]}):null}function hMe({onImageSelected:e}){const t=ee.useRef(null),n=ee.useRef(null),r=ee.useRef(null),[a,s]=ee.useState(!1),[i,o]=ee.useState(!1),l=ee.useCallback(async h=>{var p;const d=(p=h.target.files)==null?void 0:p[0];if(d&&Bw.isValidImageFile(d)){o(!0);try{const f=await Bw.convertImageToTexture(d);f&&e(f)}finally{o(!1)}}},[e]),c=ee.useCallback(async()=>{try{const h=await navigator.mediaDevices.getUserMedia({video:!0});r.current=h,s(!0)}catch(h){console.error("Error accessing camera:",h)}},[]),u=ee.useCallback(async()=>{if(n.current){o(!0);try{const h=document.createElement("canvas");h.width=n.current.videoWidth,h.height=n.current.videoHeight;const d=h.getContext("2d");if(d){d.drawImage(n.current,0,0);const p=await new Promise(f=>h.toBlob(f,"image/jpeg"));if(p){const f=new File([p],"photo.jpg",{type:"image/jpeg"}),m=await Bw.convertImageToTexture(f);m&&e(m)}}}finally{r.current&&(r.current.getTracks().forEach(h=>h.stop()),r.current=null),o(!1),s(!1)}}},[e]);return N.jsxs(N.Fragment,{children:["      ",N.jsxs("div",{className:"absolute top-4 right-4 z-20 flex items-center gap-2",children:[N.jsx("input",{ref:t,type:"file",accept:"image/*",onChange:l,className:"hidden"}),i&&N.jsxs("div",{className:"px-3 py-1 bg-white/90 rounded-full text-sm text-gray-700 shadow-lg backdrop-blur-sm flex items-center gap-2",children:[N.jsx(VE,{className:"w-4 h-4 animate-spin"}),"Processing image..."]}),N.jsx("button",{onClick:()=>{var h;return(h=t.current)==null?void 0:h.click()},className:"p-2 bg-white rounded-full shadow-lg hover:bg-gray-50 transition-colors disabled:opacity-50 disabled:cursor-not-allowed",title:"Upload image",disabled:i,children:i?N.jsx(VE,{className:"w-5 h-5 text-gray-700 animate-spin"}):N.jsx(CH,{className:"w-5 h-5 text-gray-700"})}),N.jsx("button",{onClick:c,className:"p-2 bg-white rounded-full shadow-lg hover:bg-gray-50 transition-colors disabled:opacity-50 disabled:cursor-not-allowed",title:"Take photo",disabled:i,children:N.jsx(XR,{className:"w-5 h-5 text-gray-700"})})]}),N.jsx(cMe,{isOpen:a,onClose:()=>{r.current&&(r.current.getTracks().forEach(h=>h.stop()),r.current=null),s(!1)},onCapture:u,isLoading:i}),N.jsx("video",{ref:n,className:"hidden",autoPlay:!0,playsInline:!0})]})}const dMe={itemType:"T-shirt",color:"#000000",standardSize:"M",measurements:IS.M,zoom:1};function fM(){const[e,t]=ee.useState(dMe),[n,r]=ee.useState(!1),[a,s]=ee.useState(null),i=hd(),o=$m();ee.useEffect(()=>{o.pathname.includes("/design/")&&i("/design",{replace:!0})},[o.pathname,i]);const l=h=>{if(console.log("Settings changed:",h),h.itemType==="Full Body"){const d=h.standardSize;t({...h,measurements:{...h.measurements,height:IS[d].height}})}else t(h)},c=()=>{requestAnimationFrame(()=>{r(h=>!h)})},u=(h,d)=>{t(p=>({...p,measurements:{...p.measurements,[h]:d}}))};return N.jsxs("div",{className:"design-container",children:[N.jsx(VH,{settings:e,isPanelOpen:n,onPanelToggle:c,onSettingsChange:l,onMeasurementChange:u}),N.jsx("div",{className:"design-preview",children:N.jsx("div",{className:"model-container relative",children:N.jsx("div",{className:"absolute top-4 right-4 z-10",children:N.jsx(hMe,{onImageSelected:s})})})})]})}const pMe=()=>{const{loginWithRedirect:e,logout:t,user:n,isAuthenticated:r,isLoading:a}=KR();return hd(),a?N.jsx("div",{className:"min-h-screen flex items-center justify-center",children:N.jsx("div",{className:"animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-rose-600"})}):r?N.jsx("div",{className:"min-h-screen flex items-center justify-center bg-gray-50",children:N.jsxs("div",{className:"z-10 max-w-md w-full space-y-8 p-8 bg-white rounded-xl shadow-2xl",children:[N.jsxs("div",{className:"text-center",children:[N.jsx("img",{src:n==null?void 0:n.picture,alt:n==null?void 0:n.name,className:"mx-auto h-24 w-24 rounded-full"}),N.jsxs("h2",{className:"mt-6 text-3xl font-extrabold text-gray-900",children:["Welcome, ",n==null?void 0:n.name,"!"]}),N.jsx("p",{className:"mt-2 text-sm text-gray-600",children:n==null?void 0:n.email})]}),N.jsx("div",{className:"mt-8",children:N.jsx("button",{onClick:()=>t({logoutParams:{returnTo:window.location.origin}}),className:"w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-rose-600 hover:bg-rose-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-rose-500 transition-colors duration-200",children:"Sign Out"})})]})}):N.jsxs("div",{className:"min-h-screen flex items-center justify-center bg-gray-50",children:[N.jsx("div",{className:"absolute inset-0 bg-cover bg-center opacity-30",style:{backgroundImage:'url("https://images.unsplash.com/photo-1528578950694-9f79b45a3397?auto=format&fit=crop&q=80")'}}),N.jsxs("div",{className:"z-10 max-w-md w-full space-y-8 p-8 bg-white rounded-xl shadow-2xl",children:[N.jsxs("div",{children:[N.jsx("h2",{className:"mt-6 text-center text-3xl font-extrabold text-gray-900",children:"Welcome to TexWeb"}),N.jsx("p",{className:"mt-2 text-center text-sm text-gray-600",children:"Please sign in to continue"})]}),N.jsx("div",{className:"mt-8",children:N.jsx("button",{onClick:()=>e(),className:"w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-rose-600 hover:bg-rose-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-rose-500 transition-colors duration-200",children:"Sign In / Sign Up with Auth0"})})]})]})},CV=ee.createContext(void 0),fMe=({children:e})=>{const[t,n]=ee.useState([]),r=o=>{s(o.id)||n(l=>[...l,{...o,createdAt:new Date}])},a=o=>{n(l=>l.filter(c=>c.id!==o))},s=o=>t.some(l=>l.id===o),i=()=>{n([])};return N.jsx(CV.Provider,{value:{wishlistItems:t,addToWishlist:r,removeFromWishlist:a,isInWishlist:s,clearWishlist:i},children:e})},mMe=()=>{const e=ee.useContext(CV);if(e===void 0)throw new Error("useWishlist must be used within a WishlistProvider");return e},gMe=()=>N.jsx("div",{className:"max-w-7xl mx-auto",children:N.jsx("div",{className:"bg-white rounded-lg shadow min-h-[calc(100vh-4rem)]",children:N.jsx(yG,{})})}),yMe=()=>{const e=[{id:"ORD-2025-001",date:"2025-06-20",status:"delivered",total:149.99,items:2},{id:"ORD-2025-002",date:"2025-06-18",status:"shipped",total:89.99,items:1}],t=n=>({pending:"bg-yellow-100 text-yellow-800",processing:"bg-blue-100 text-blue-800",shipped:"bg-purple-100 text-purple-800",delivered:"bg-green-100 text-green-800"})[n];return N.jsx("div",{className:"max-w-7xl mx-auto px-4 py-8",children:N.jsxs("div",{className:"bg-white rounded-lg shadow",children:[N.jsxs("div",{className:"border-b border-gray-200 px-6 py-4",children:[N.jsxs("div",{className:"flex items-center space-x-3",children:[N.jsx(ak,{className:"h-6 w-6 text-rose-600"}),N.jsx("h1",{className:"text-2xl font-semibold text-gray-900",children:"My Orders"})]}),N.jsxs("div",{className:"mt-4 flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4",children:[N.jsxs("div",{className:"relative flex-1 max-w-md",children:[N.jsx("input",{type:"text",placeholder:"Search orders...",className:"w-full pl-10 pr-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-rose-500 focus:border-transparent"}),N.jsx(kH,{className:"absolute left-3 top-1/2 transform -translate-y-1/2 h-5 w-5 text-gray-400"})]}),N.jsxs("button",{className:"inline-flex items-center px-4 py-2 border border-gray-300 rounded-lg text-sm font-medium text-gray-700 hover:bg-gray-50",children:[N.jsx(gH,{className:"h-4 w-4 mr-2"}),"Filter"]})]})]}),N.jsx("div",{className:"divide-y divide-gray-200",children:e.length===0?N.jsxs("div",{className:"text-center py-12",children:[N.jsx(ak,{className:"h-16 w-16 text-gray-400 mx-auto mb-4"}),N.jsx("h3",{className:"text-lg font-medium text-gray-900",children:"No orders yet"}),N.jsx("p",{className:"mt-1 text-gray-500",children:"When you place an order, it will appear here"}),N.jsx("div",{className:"mt-6",children:N.jsx("a",{href:"/",className:"inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-rose-600 hover:bg-rose-700",children:"Start Shopping"})})]}):e.map(n=>N.jsx("div",{className:"p-6 hover:bg-gray-50 transition-colors duration-150 cursor-pointer",children:N.jsx("div",{className:"flex items-center justify-between",children:N.jsxs("div",{className:"flex-1",children:[N.jsxs("div",{className:"flex items-center justify-between",children:[N.jsx("h3",{className:"text-lg font-medium text-gray-900",children:n.id}),N.jsx(fH,{className:"h-5 w-5 text-gray-400"})]}),N.jsxs("div",{className:"mt-2 flex items-center justify-between",children:[N.jsxs("div",{className:"flex items-center space-x-4",children:[N.jsx("span",{className:"text-sm text-gray-500",children:new Date(n.date).toLocaleDateString()}),N.jsx("span",{className:`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${t(n.status)}`,children:n.status.charAt(0).toUpperCase()+n.status.slice(1)})]}),N.jsxs("div",{className:"text-right",children:[N.jsxs("p",{className:"text-sm font-medium text-gray-900",children:["$",n.total.toFixed(2)]}),N.jsxs("p",{className:"text-sm text-gray-500",children:[n.items," ",n.items===1?"item":"items"]})]})]})]})})},n.id))})]})})},xMe=()=>{const[e,t]=ee.useState(!1),[n,r]=ee.useState(null),[a,s]=ee.useState({type:"home",name:"",address:"",city:"",state:"",pincode:"",phone:"",isDefault:!1,latitude:void 0,longitude:void 0}),[i,o]=ee.useState([{id:"1",type:"home",name:"John Doe",address:"123 Main Street",city:"New York",state:"NY",pincode:"10001",phone:"123-456-7890",isDefault:!0,latitude:40.7128,longitude:-74.006}]),l=g=>{switch(g){case"home":return N.jsx(yH,{className:"h-5 w-5"});case"office":return N.jsx(dH,{className:"h-5 w-5"});default:return N.jsx(pH,{className:"h-5 w-5"})}},c=g=>{o(i.filter(x=>x.id!==g))},u=g=>{o(i.map(x=>({...x,isDefault:x.id===g})))},h=(g,x)=>{s(b=>({...b,latitude:g,longitude:x}))},d=g=>{const x=g.replace(/\D/g,"");return!!(x.length===10&&/^[6-9]/.test(x)||x.length===11&&/^0[6-9]/.test(x)||x.length===12&&x.startsWith("91")&&/^91[6-9]/.test(x)||x.length===13&&x.startsWith("091"))},p=()=>{if(!navigator.geolocation){alert("Geolocation is not supported by this browser.");return}navigator.geolocation.getCurrentPosition(async g=>{var v,w,I,_,T,A,M,F,C,D;const{latitude:x,longitude:b}=g.coords;try{const L=await fetch(`https://api.bigdatacloud.net/data/reverse-geocode-client?latitude=${x}&longitude=${b}&localityLanguage=en`);let O=null;if(L.ok&&(O=await L.json(),console.log("BigDataCloud data received:",O),console.log("Available fields:",Object.keys(O||{}))),!O||!O.locality&&!O.city&&!O.postcode&&!O.principalSubdivision){console.log("Trying OpenStreetMap Nominatim as backup...");const q=await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${x}&lon=${b}&zoom=18&addressdetails=1`);if(q.ok){const H=await q.json();console.log("Nominatim data received:",H),H.address&&(O={...O,city:H.address.city||H.address.town||H.address.village||H.address.municipality,locality:H.address.suburb||H.address.neighbourhood||H.address.hamlet,postcode:H.address.postcode,principalSubdivision:H.address.state||H.address.province,countrySecondarySubdivision:H.address.state_district||H.address.county,town:H.address.town,village:H.address.village,municipality:H.address.municipality,district:H.address.district,state:H.address.state,province:H.address.province,region:H.address.region},console.log("Merged data with Nominatim:",O))}}if(O&&(O.locality||O.city||O.postcode||O.principalSubdivision)){let q="";q=[O.city,O.locality,(I=(w=(v=O.localityInfo)==null?void 0:v.administrative)==null?void 0:w[2])==null?void 0:I.name,(A=(T=(_=O.localityInfo)==null?void 0:_.administrative)==null?void 0:T[1])==null?void 0:A.name,O.principalSubdivisionCode,O.countrySubdivision,O.town,O.village,O.municipality,O.district].find(Q=>Q&&typeof Q=="string"&&Q.length>2&&Q.length<50&&!/^\d+$/.test(Q)&&!/^\d{5,6}$/.test(Q))||"";let z="";const K=[O.postcode,O.postalCode,O.zipcode,O.zip,O.postal_code,O.postalCodeNumber,O.postCode,O.zipCode,O.postalcode,O.pin,O.pincode];(M=O.localityInfo)!=null&&M.administrative&&O.localityInfo.administrative.forEach(Q=>{Q.name&&/^\d{5,6}$/.test(Q.name)&&K.push(Q.name)}),z=K.find(Q=>Q&&Q.toString().length>=5&&/^\d{5,6}$/.test(Q.toString()))||"";let Z="";if(Z=[O.principalSubdivision,O.countrySecondarySubdivision,(D=(C=(F=O.localityInfo)==null?void 0:F.administrative)==null?void 0:C[0])==null?void 0:D.name,O.principalSubdivisionCode,O.state,O.province,O.region,O.adminLevel1].find(Q=>Q&&typeof Q=="string"&&Q.length>2&&Q.length<50&&!/^\d+$/.test(Q)&&!/^\d{5,6}$/.test(Q))||"",!z&&q&&Z){console.log("PIN code not found in geocoding data, trying additional strategies...");try{const Q=await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${x}&lon=${b}&zoom=16&addressdetails=1&extratags=1`);if(Q.ok){const ne=await Q.json();console.log("Detailed Nominatim data for PIN code:",ne),ne.address&&ne.address.postcode&&(z=ne.address.postcode,console.log("Found PIN code from detailed Nominatim:",z))}}catch(Q){console.error("Detailed Nominatim fallback failed:",Q)}if(!z)try{const Q=await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q+", "+Z+", India")}&addressdetails=1&limit=1`);if(Q.ok){const ne=await Q.json();console.log("Nominatim search data for PIN code:",ne),ne.length>0&&ne[0].address&&ne[0].address.postcode&&(z=ne[0].address.postcode,console.log("Found PIN code from Nominatim search:",z))}}catch(Q){console.error("Nominatim search fallback failed:",Q)}}s(Q=>({...Q,latitude:x,longitude:b,city:q||Q.city||"",state:Z||Q.state||"",pincode:z||Q.pincode||""})),console.log("Updated address data:",{coordinates:{latitude:x,longitude:b},city:q,state:Z,pincode:z})}else h(x,b)}catch(L){console.error("Geocoding error:",L),h(x,b)}},g=>{let x="Unable to retrieve your location.";switch(g.code){case g.PERMISSION_DENIED:x="Location access denied by user. Please enable location permissions in your browser settings.";break;case g.POSITION_UNAVAILABLE:x="Location information is unavailable.";break;case g.TIMEOUT:x="Location request timed out.";break}alert(x)},{enableHighAccuracy:!0,timeout:2e4,maximumAge:6e4})},f=()=>{t(!0),n||setTimeout(p,500)},m=()=>{t(!1),r(null),s({type:"home",name:"",address:"",city:"",state:"",pincode:"",phone:"",isDefault:!1,latitude:void 0,longitude:void 0})},y=g=>{if(g.preventDefault(),!d(a.phone||"")){alert("Please enter a valid 10-digit Indian mobile number starting with 6, 7, 8, or 9.");return}const x={...a,id:n?n.id:Math.random().toString(36).substr(2,9)};n?o(i.map(b=>b.id===n.id?{...x,isDefault:n.isDefault||x.isDefault}:x.isDefault?{...b,isDefault:!1}:b)):x.isDefault?o(i.map(b=>({...b,isDefault:!1})).concat(x)):(i.length===0&&(x.isDefault=!0),o([...i,x])),m()};return N.jsxs("div",{className:"flex flex-col min-h-[calc(100vh-4rem)] bg-white",children:[N.jsx("header",{className:"sticky top-0 z-10 bg-white border-b border-gray-200",children:N.jsx("div",{className:"px-4 sm:px-6 py-4",children:N.jsxs("div",{className:"flex items-center justify-between",children:[N.jsxs("div",{className:"flex items-center space-x-3",children:[N.jsx(p0,{className:"h-5 w-5 sm:h-6 sm:w-6 text-rose-600"}),N.jsx("h1",{className:"text-lg sm:text-xl font-semibold text-gray-900",children:"Saved Addresses"})]}),N.jsxs("button",{onClick:f,className:"inline-flex items-center px-3 sm:px-4 py-2 border border-transparent text-sm font-medium rounded-lg shadow-sm text-white bg-rose-600 hover:bg-rose-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-rose-500",children:[N.jsx(ZR,{className:"h-4 w-4 sm:h-5 sm:w-5 mr-1 sm:mr-2"}),N.jsx("span",{className:"hidden sm:inline",children:"Add New"}),N.jsx("span",{className:"sm:hidden",children:"Add"})]})]})})}),N.jsx("div",{className:"flex-1 overflow-y-auto",children:N.jsx("div",{className:"px-4 sm:px-6 py-4 sm:py-6",children:i.length===0?N.jsxs("div",{className:"text-center py-12",children:[N.jsx(p0,{className:"h-16 w-16 text-gray-400 mx-auto mb-4"}),N.jsx("h3",{className:"text-lg font-medium text-gray-900",children:"No addresses saved"}),N.jsx("p",{className:"mt-1 text-sm sm:text-base text-gray-500",children:"Add a new address to save it for future purchases"})]}):N.jsx("div",{className:"grid gap-3 sm:gap-4 md:gap-6 md:grid-cols-2",children:i.map(g=>N.jsxs("div",{className:"relative bg-white sm:bg-gray-50 rounded-lg p-3 sm:p-4 border border-gray-200 hover:border-gray-300 transition-colors shadow-sm hover:shadow",children:[g.isDefault&&N.jsx("div",{className:"absolute right-0 top-0 p-3",children:N.jsx("span",{className:"px-2 py-1 bg-rose-100 text-rose-700 text-xs font-medium rounded-full",children:"Default"})}),N.jsxs("div",{className:"flex items-start space-x-3",children:[N.jsx("div",{className:"mt-1 text-gray-500 flex-shrink-0",children:l(g.type)}),N.jsxs("div",{className:"flex-1 min-w-0",children:[N.jsx("h3",{className:"text-base font-medium text-gray-900 truncate pr-16",children:g.name}),N.jsx("p",{className:"mt-1 text-sm text-gray-600 break-words",children:g.address}),N.jsxs("p",{className:"text-sm text-gray-600",children:[g.city,", ",g.state," ",g.pincode]}),N.jsxs("p",{className:"mt-2 text-sm text-gray-600",children:["Phone: ",g.phone]}),g.latitude&&g.longitude&&N.jsx("div",{className:"mt-2",children:N.jsxs("p",{className:"text-xs text-gray-500",children:["📍 Latitude: ",g.latitude.toFixed(6),", Longitude: ",g.longitude.toFixed(6)]})}),N.jsxs("div",{className:"mt-3 pt-3 border-t border-gray-100 flex flex-wrap items-center gap-3 sm:gap-4",children:[N.jsxs("button",{onClick:()=>{r(g),s(g),t(!0)},className:"inline-flex items-center px-2 py-1 text-sm text-gray-600 hover:text-gray-900 rounded-md hover:bg-gray-100",children:[N.jsx(NH,{className:"h-4 w-4 mr-1"}),"Edit"]}),!g.isDefault&&N.jsxs(N.Fragment,{children:[N.jsxs("button",{onClick:()=>c(g.id),className:"inline-flex items-center px-2 py-1 text-sm text-red-600 hover:text-red-700 rounded-md hover:bg-red-50",children:[N.jsx(_H,{className:"h-4 w-4 mr-1"}),"Delete"]}),N.jsxs("button",{onClick:()=>u(g.id),className:"inline-flex items-center px-2 py-1 text-sm text-rose-600 hover:text-rose-700 rounded-md hover:bg-rose-50",children:[N.jsx(p0,{className:"h-4 w-4 mr-1"}),"Set as Default"]})]})]})]})]})]},g.id))})})}),(e||n)&&N.jsx("div",{className:"fixed inset-0 z-50 overflow-hidden",children:N.jsxs("div",{className:"flex min-h-screen items-center justify-center px-4 pt-4 pb-20 text-center sm:block sm:p-0",children:[N.jsx("div",{className:"fixed inset-0 bg-black bg-opacity-40 transition-opacity","aria-hidden":"true",onClick:m}),N.jsx("span",{className:"hidden sm:inline-block sm:h-screen sm:align-middle","aria-hidden":"true",children:"​"}),N.jsx("div",{className:"relative inline-block w-full transform overflow-hidden rounded-t-xl bg-white text-left align-bottom shadow-xl transition-all sm:my-8 sm:w-full sm:max-w-lg sm:rounded-xl sm:align-middle",children:N.jsx("div",{className:"bg-white",children:N.jsxs("div",{className:"px-4 pt-5 pb-4 sm:p-6 sm:pb-4",children:[N.jsxs("div",{className:"flex items-center justify-between mb-5",children:[N.jsx("h3",{className:"text-xl font-semibold text-gray-900",children:n?"Edit Address":"Add New Address"}),N.jsxs("button",{onClick:m,className:"rounded-md text-gray-400 hover:text-gray-500 focus:outline-none focus:ring-2 focus:ring-rose-500",children:[N.jsx("span",{className:"sr-only",children:"Close"}),N.jsx(Vh,{className:"h-6 w-6"})]})]}),N.jsxs("form",{onSubmit:y,className:"mt-3",children:[N.jsxs("div",{children:[N.jsx("label",{className:"block text-sm font-medium text-gray-700",children:"Full Name"}),N.jsx("input",{type:"text",value:a.name||"",onChange:g=>s({...a,name:g.target.value}),className:"mt-1 block w-full border-gray-300 rounded-lg shadow-sm focus:ring-rose-500 focus:border-rose-500 text-base",placeholder:"Enter your full name",required:!0})]}),N.jsxs("div",{children:[N.jsx("label",{className:"block text-sm font-medium text-gray-700",children:"Phone Number"}),N.jsx("input",{type:"tel",value:a.phone||"",onChange:g=>{const x=g.target.value.replace(/\D/g,"").slice(0,13);s({...a,phone:x})},className:"mt-1 block w-full border-gray-300 rounded-lg shadow-sm focus:ring-rose-500 focus:border-rose-500 text-base",placeholder:"Enter 10-digit mobile number",pattern:"[0-9]{10,13}",title:"Please enter a valid 10-digit mobile number",required:!0}),N.jsx("p",{className:"mt-1 text-xs text-gray-500",children:"Enter a valid 10-digit Indian mobile number (6-9 followed by 9 digits)"})]}),N.jsxs("div",{children:[N.jsx("label",{className:"block text-sm font-medium text-gray-700",children:"Address Type"}),N.jsxs("select",{value:a.type||"home",onChange:g=>s({...a,type:g.target.value}),className:"mt-1 block w-full border-gray-300 rounded-lg shadow-sm focus:ring-rose-500 focus:border-rose-500 text-base",required:!0,children:[N.jsx("option",{value:"home",children:"Home"}),N.jsx("option",{value:"office",children:"Office"}),N.jsx("option",{value:"other",children:"Other"})]})]}),N.jsxs("div",{children:[N.jsx("label",{className:"block text-sm font-medium text-gray-700",children:"Street Address"}),N.jsx("input",{type:"text",value:a.address||"",onChange:g=>s({...a,address:g.target.value}),className:"mt-1 block w-full border-gray-300 rounded-lg shadow-sm focus:ring-rose-500 focus:border-rose-500 text-base",placeholder:"Enter your complete street address",required:!0})]}),N.jsxs("div",{className:"grid grid-cols-1 sm:grid-cols-2 gap-4",children:[N.jsxs("div",{children:[N.jsx("label",{className:"block text-sm font-medium text-gray-700",children:"City"}),N.jsx("input",{type:"text",value:a.city||"",onChange:g=>s({...a,city:g.target.value}),className:"mt-1 block w-full border-gray-300 rounded-lg shadow-sm focus:ring-rose-500 focus:border-rose-500 text-base",placeholder:"Enter city",required:!0})]}),N.jsxs("div",{children:[N.jsx("label",{className:"block text-sm font-medium text-gray-700",children:"State"}),N.jsx("input",{type:"text",value:a.state||"",onChange:g=>s({...a,state:g.target.value}),className:"mt-1 block w-full border-gray-300 rounded-lg shadow-sm focus:ring-rose-500 focus:border-rose-500 text-base",placeholder:"Enter state",required:!0})]})]}),N.jsxs("div",{children:[N.jsx("label",{className:"block text-sm font-medium text-gray-700",children:"PIN Code"}),N.jsx("input",{type:"text",value:a.pincode||"",onChange:g=>s({...a,pincode:g.target.value}),className:"mt-1 block w-full border-gray-300 rounded-lg shadow-sm focus:ring-rose-500 focus:border-rose-500 text-base",placeholder:"Enter PIN code",pattern:"[0-9]{6}",title:"Please enter a 6-digit PIN code",required:!0}),N.jsx("p",{className:"mt-1 text-xs text-gray-500",children:"Please enter a 6-digit PIN code"})]}),!(n!=null&&n.isDefault)&&N.jsxs("div",{className:"flex items-center pt-2",children:[N.jsx("input",{type:"checkbox",id:"isDefault",checked:a.isDefault||!1,onChange:g=>s({...a,isDefault:g.target.checked}),className:"h-5 w-5 text-rose-600 focus:ring-rose-500 border-gray-300 rounded"}),N.jsx("label",{htmlFor:"isDefault",className:"ml-2 block text-base text-gray-900",children:"Set as default address"})]}),N.jsx("div",{className:"mt-6 sm:mt-8 border-t border-gray-200 pt-4",children:N.jsxs("div",{className:"flex flex-col-reverse sm:flex-row sm:space-x-3",children:[N.jsx("button",{type:"button",onClick:m,className:"mt-3 sm:mt-0 w-full sm:w-1/2 inline-flex justify-center px-4 py-2.5 border border-gray-300 shadow-sm text-base font-medium rounded-lg text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-rose-500",children:"Cancel"}),N.jsx("button",{type:"submit",className:"w-full sm:w-1/2 inline-flex justify-center px-4 py-2.5 border border-transparent text-base font-medium rounded-lg text-white bg-rose-600 hover:bg-rose-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-rose-500",children:n?"Save Changes":"Add Address"})]})})]})]})})})]})})]})},bMe=()=>{const{wishlistItems:e,removeFromWishlist:t,clearWishlist:n}=mMe(),{addItem:r}=Mm(),a=hd(),[s,i]=ee.useState(!1),o=c=>{r({id:c.id,name:c.name,price:c.price,image:c.image}),t(c.id)},l=c=>{c&&a(`/design/${c}`)};return N.jsxs("div",{className:"flex flex-col min-h-full bg-white",children:[N.jsx("header",{className:"sticky top-0 z-20 bg-white border-b border-gray-200",children:N.jsx("div",{className:"px-4 sm:px-6 py-4",children:N.jsxs("div",{className:"flex items-center justify-between",children:[N.jsxs("div",{className:"flex items-center space-x-2",children:[N.jsx(Z0,{className:"h-5 w-5 text-rose-600"}),N.jsx("h1",{className:"text-lg font-semibold text-gray-900",children:"My Wishlist"})]}),e.length>0&&N.jsxs("button",{onClick:()=>i(!0),className:"inline-flex items-center px-3 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-rose-500 focus:ring-offset-2",children:[N.jsx(dw,{className:"h-4 w-4 mr-1.5"}),N.jsx("span",{className:"hidden sm:inline",children:"Clear Wishlist"}),N.jsx("span",{className:"sm:hidden",children:"Clear"})]})]})})}),N.jsx("div",{className:"flex-1 overflow-y-auto",children:N.jsx("div",{className:"px-4 sm:px-6 py-4 sm:py-6",children:e.length===0?N.jsxs("div",{className:"text-center py-12",children:[N.jsx(Z0,{className:"h-16 w-16 text-gray-400 mx-auto mb-4"}),N.jsx("h3",{className:"text-lg font-medium text-gray-900",children:"Your wishlist is empty"}),N.jsx("p",{className:"mt-1 text-sm sm:text-base text-gray-500",children:"Start adding items you love to your wishlist"})]}):N.jsx("div",{className:"grid gap-4 sm:gap-6 md:grid-cols-2 lg:grid-cols-3",children:e.map(c=>N.jsxs("div",{className:"relative bg-white sm:bg-gray-50 rounded-lg border border-gray-200 hover:border-gray-300 transition-colors shadow-sm hover:shadow overflow-hidden",children:[N.jsx("div",{className:"aspect-w-4 aspect-h-3 bg-gray-200 cursor-pointer",onClick:()=>l(c.designId),children:N.jsx("img",{src:c.image,alt:c.name,className:"object-cover w-full h-full"})}),N.jsxs("div",{className:"p-4",children:[N.jsx("h3",{className:"font-medium text-gray-900 truncate",children:c.name}),N.jsxs("p",{className:"mt-1 text-sm text-gray-700",children:["₹",c.price.toFixed(2)]}),N.jsxs("div",{className:"mt-4 flex items-center gap-3",children:[N.jsxs("button",{onClick:()=>o(c),className:"flex-1 inline-flex items-center justify-center px-4 py-2 border border-transparent text-sm font-medium rounded-lg text-white bg-rose-600 hover:bg-rose-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-rose-500",children:[N.jsx(SS,{className:"h-4 w-4 mr-1.5"}),"Add to Cart"]}),N.jsx("button",{onClick:()=>t(c.id),className:"inline-flex items-center p-2 border border-gray-300 rounded-lg text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-rose-500",children:N.jsx(dw,{className:"h-4 w-4"})})]})]})]},c.id))})})}),s&&N.jsx("div",{className:"fixed inset-0 z-50 overflow-y-auto",children:N.jsxs("div",{className:"flex min-h-screen items-end justify-center px-4 pt-4 pb-20 text-center sm:block sm:p-0",children:[N.jsx("div",{className:"fixed inset-0 bg-black bg-opacity-40 transition-opacity","aria-hidden":"true",onClick:()=>i(!1)}),N.jsx("span",{className:"hidden sm:inline-block sm:h-screen sm:align-middle","aria-hidden":"true",children:"​"}),N.jsxs("div",{className:"relative inline-block transform overflow-hidden rounded-lg bg-white text-left align-bottom shadow-xl transition-all sm:my-8 sm:w-full sm:max-w-lg sm:align-middle",children:[N.jsx("div",{className:"bg-white px-4 pt-5 pb-4 sm:p-6 sm:pb-4",children:N.jsxs("div",{className:"sm:flex sm:items-start",children:[N.jsx("div",{className:"mx-auto flex h-12 w-12 flex-shrink-0 items-center justify-center rounded-full bg-red-100 sm:mx-0 sm:h-10 sm:w-10",children:N.jsx(dw,{className:"h-6 w-6 text-red-600"})}),N.jsxs("div",{className:"mt-3 text-center sm:mt-0 sm:ml-4 sm:text-left",children:[N.jsx("h3",{className:"text-lg font-medium text-gray-900",children:"Clear Wishlist"}),N.jsx("div",{className:"mt-2",children:N.jsx("p",{className:"text-sm text-gray-500",children:"Are you sure you want to clear your wishlist? This action cannot be undone."})})]})]})}),N.jsxs("div",{className:"bg-gray-50 px-4 py-3 sm:flex sm:flex-row-reverse sm:px-6",children:[N.jsx("button",{type:"button",onClick:()=>{n(),i(!1)},className:"inline-flex w-full justify-center rounded-lg bg-red-600 px-4 py-2 text-base font-medium text-white shadow-sm hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 sm:ml-3 sm:w-auto sm:text-sm",children:"Clear Wishlist"}),N.jsx("button",{type:"button",onClick:()=>i(!1),className:"mt-3 inline-flex w-full justify-center rounded-lg border border-gray-300 bg-white px-4 py-2 text-base font-medium text-gray-700 shadow-sm hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-rose-500 focus:ring-offset-2 sm:mt-0 sm:w-auto sm:text-sm",children:"Cancel"})]})]})]})})]})},vMe="dev-arrows.au.auth0.com",wMe="wyCAzyDQa7umHNaXCColuKkLtx0pkX0G",kMe={audience:"https://dev-arrows.au.auth0.com/api/v2/"},SMe={v7_startTransition:!0,v7_relativeSplatPath:!0};function IMe(){const[e]=ee.useTransition();return N.jsx(_G,{future:SMe,children:N.jsx(iH,{domain:vMe,clientId:wMe,authorizationParams:{redirect_uri:AH(),audience:kMe.audience},cacheLocation:"localstorage",onRedirectCallback:t=>{window.location.href=(t==null?void 0:t.returnTo)||window.location.pathname},children:N.jsx(EH,{children:N.jsx(MH,{children:N.jsx(fMe,{children:N.jsxs("div",{className:"min-h-screen bg-white",children:[N.jsx(RH,{}),e&&N.jsx("div",{className:"fixed top-0 left-0 w-full h-1",children:N.jsx("div",{className:"h-full bg-rose-600 animate-[loading_1s_ease-in-out_infinite]",style:{width:"25%"}})})," ",N.jsxs(bG,{children:[N.jsx(va,{path:"/",element:N.jsx(PH,{})}),N.jsx(va,{path:"/about",element:N.jsx(zH,{})}),N.jsx(va,{path:"/design/*",element:N.jsx(fM,{})})," ",N.jsx(va,{path:"/auth",element:N.jsx(pMe,{})}),N.jsx(va,{path:"/orders",element:N.jsx(yMe,{})}),N.jsxs(va,{path:"/profile",element:N.jsx(gMe,{}),children:[N.jsx(va,{path:"my-designs",element:N.jsx(fM,{})}),"                  ",N.jsx(va,{path:"wishlist",element:N.jsx(bMe,{})}),N.jsx(va,{path:"payments",element:N.jsx("div",{children:"Payments Coming Soon"})}),N.jsx(va,{path:"addresses",element:N.jsx(xMe,{})}),N.jsx(va,{path:"settings",element:N.jsx("div",{children:"Settings Coming Soon"})})]})]}),N.jsx(OH,{}),N.jsx(DH,{})," "]})})})})})})}TR(document.getElementById("root")).render(N.jsx(ee.StrictMode,{children:N.jsx(IMe,{})}));
